{
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  final AtomicBoolean connectorIsReady=new AtomicBoolean(false);
  myDebugProcessDispatcher.addListener(new DebugProcessAdapter(){
    @Override public void connectorIsReady(){
      connectorIsReady.set(true);
      semaphore.up();
      myDebugProcessDispatcher.removeListener(this);
    }
  }
);
  DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().reloadBreakpoints();
  getManagerThread().schedule(new DebuggerCommandImpl(){
    @Override protected void action(){
      VirtualMachine vm=null;
      try {
        final long time=System.currentTimeMillis();
        while (System.currentTimeMillis() - time < LOCAL_START_TIMEOUT) {
          try {
            vm=createVirtualMachineInt();
            break;
          }
 catch (          final ExecutionException e) {
            if (pollConnection && !myConnection.isServerMode() && e.getCause() instanceof IOException) {
synchronized (this) {
                try {
                  wait(500);
                }
 catch (                InterruptedException ignored) {
                  break;
                }
              }
            }
 else {
              fail();
              DebuggerInvocationUtil.swingInvokeLater(myProject,new Runnable(){
                @Override public void run(){
                  if (myExecutionResult != null || !connectorIsReady.get()) {
                    ExecutionUtil.handleExecutionError(myProject,ToolWindowId.DEBUG,sessionName,e);
                  }
                }
              }
);
              break;
            }
          }
        }
      }
  finally {
        semaphore.up();
      }
      if (vm != null) {
        final VirtualMachine vm1=vm;
        afterProcessStarted(new Runnable(){
          @Override public void run(){
            getManagerThread().schedule(new DebuggerCommandImpl(){
              @Override protected void action() throws Exception {
                commitVM(vm1);
              }
            }
);
          }
        }
);
      }
    }
    @Override protected void commandCancelled(){
      try {
        super.commandCancelled();
      }
  finally {
        semaphore.up();
      }
    }
  }
);
  semaphore.waitFor();
}
