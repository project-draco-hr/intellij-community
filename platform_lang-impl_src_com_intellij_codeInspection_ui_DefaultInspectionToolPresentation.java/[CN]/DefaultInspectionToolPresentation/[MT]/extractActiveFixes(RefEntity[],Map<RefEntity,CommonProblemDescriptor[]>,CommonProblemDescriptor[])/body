{
  final Set<CommonProblemDescriptor> allowedDescriptorSet=allowedDescriptors == null ? null : ContainerUtil.newHashSet(allowedDescriptors);
  Map<String,LocalQuickFixWrapper> result=new com.intellij.util.containers.HashMap<>();
  boolean isFirst=true;
  for (  RefEntity refElement : refElements) {
    final CommonProblemDescriptor[] descriptors=descriptorMap.get(refElement);
    if (descriptors == null)     continue;
    for (    CommonProblemDescriptor d : descriptors) {
      if (allowedDescriptorSet != null && !allowedDescriptorSet.contains(d)) {
        continue;
      }
      QuickFix[] fixes=d.getFixes();
      if (fixes != null) {
        if (isFirst) {
          for (          QuickFix fix : fixes) {
            if (fix == null)             continue;
            LocalQuickFixWrapper quickFixWrapper=new LocalQuickFixWrapper(fix,myToolWrapper);
            result.put(fix.getFamilyName(),quickFixWrapper);
          }
          isFirst=false;
        }
 else {
          for (          String familyName : new ArrayList<>(result.keySet())) {
            boolean isFound=false;
            for (            QuickFix fix : fixes) {
              if (fix == null)               continue;
              if (familyName.equals(fix.getFamilyName())) {
                isFound=true;
                final LocalQuickFixWrapper quickFixAction=result.get(fix.getFamilyName());
                LOG.assertTrue(getFixClass(fix).equals(getFixClass(quickFixAction.getFix())),"QuickFix-es with the same getFamilyName() should be the same class instances. " + "Please assign reported exception for the fix \"" + fix.getClass().getName() + "\" developer");
                try {
                  quickFixAction.setText(StringUtil.escapeMnemonics(fix.getFamilyName()));
                }
 catch (                AbstractMethodError e) {
                  quickFixAction.setText("Name is not available");
                }
                break;
              }
            }
            if (!isFound) {
              result.remove(familyName);
              if (result.isEmpty()) {
                return QuickFixAction.EMPTY;
              }
            }
          }
        }
      }
    }
  }
  return result.values().isEmpty() ? null : result.values().toArray(new QuickFixAction[result.size()]);
}
