{
  final MarkupModel markupModel=myDocument.getMarkupModel(myProject);
  final List<RangeHighlighter> highlighters=new ArrayList<RangeHighlighter>();
  final ProjectData data=suite.getCoverageData(CoverageDataManager.getInstance(myProject));
  if (data == null) {
    coverageDataNotFound(suite);
    return;
  }
  final TIntIntHashMap oldToNewLineMapping=getOldToNewLineMapping(suite.getLastCoverageTimeStamp());
  if (oldToNewLineMapping == null) {
    showEditorWarningMessage(CodeInsightBundle.message("coverage.data.outdated"));
    return;
  }
  final Module module=ModuleUtil.findModuleForPsiElement(myFile);
  if (module == null)   return;
  final VirtualFile outputpath=CompilerModuleExtension.getInstance(module).getCompilerOutputPath();
  final VirtualFile testOutputpath=CompilerModuleExtension.getInstance(module).getCompilerOutputPathForTests();
  if (outputpath == null || (suite.isTrackTestFolders() && testOutputpath == null)) {
    if (Messages.showOkCancelDialog("Project class files are out of date. Would you like to recompile? The refusal to do it will result in incomplete coverage information","Project is out of date",Messages.getWarningIcon()) == DialogWrapper.OK_EXIT_CODE) {
      final CompilerManager compilerManager=CompilerManager.getInstance(myProject);
      compilerManager.make(compilerManager.createProjectCompileScope(myProject),new CompileStatusNotification(){
        public void finished(        final boolean aborted,        final int errors,        final int warnings,        final CompileContext compileContext){
          if (aborted || errors != 0)           return;
          ApplicationManager.getApplication().invokeLater(new Runnable(){
            public void run(){
              CoverageDataManager.getInstance(myProject).chooseSuite(suite);
            }
          }
);
        }
      }
);
    }
    return;
  }
  final String packageFQName=((PsiClassOwner)myFile).getPackageName();
  final String packageVmName=packageFQName.replace('.','/');
  final List<VirtualFile> children=new ArrayList<VirtualFile>();
  final VirtualFile vDir=packageVmName.length() > 0 ? outputpath.findFileByRelativePath(packageVmName) : outputpath;
  if (vDir != null) {
    Collections.addAll(children,vDir.getChildren());
  }
  if (suite.isTrackTestFolders()) {
    final VirtualFile testDir=packageVmName.length() > 0 ? testOutputpath.findFileByRelativePath(packageVmName) : testOutputpath;
    if (testDir != null) {
      Collections.addAll(children,testDir.getChildren());
    }
  }
  final Set<VirtualFile> classFiles=new HashSet<VirtualFile>();
  for (  PsiClass psiClass : ((PsiClassOwner)myFile).getClasses()) {
    final String className=psiClass.getName();
    for (    VirtualFile child : children) {
      if (child.getFileType().equals(StdFileTypes.CLASS)) {
        final String childName=child.getNameWithoutExtension();
        if (childName.equals(className) || childName.startsWith(className) && childName.charAt(className.length()) == '$') {
          classFiles.add(child);
        }
      }
    }
  }
  final boolean subCoverageActive=((CoverageDataManagerImpl)CoverageDataManager.getInstance(myProject)).isSubCoverageActive();
  final boolean coverageByTestApplicable=suite.isCoverageByTestApplicable() && !(subCoverageActive && suite.isCoverageByTestEnabled());
  final TreeMap<Integer,LineData> executableLines=new TreeMap<Integer,LineData>();
  final TreeMap<Integer,ClassData> classLines=new TreeMap<Integer,ClassData>();
  for (  VirtualFile classFile : classFiles) {
    final String qualifiedName=packageFQName + "." + classFile.getNameWithoutExtension();
    final ClassData classData=data.getClassData(qualifiedName);
    if (classData != null) {
      final Object[] lines=classData.getLines();
      for (      Object lineData : lines) {
        final int line=((LineData)lineData).getLineNumber() - 1;
        if (oldToNewLineMapping.contains(line)) {
          final int lineNumberInCurrent=oldToNewLineMapping.get(line);
          LOG.assertTrue(lineNumberInCurrent < myDocument.getLineCount());
          executableLines.put(line,(LineData)lineData);
          classLines.put(line,classData);
          final RangeHighlighter highlighter=createRangeHighlighter(suite.getLastCoverageTimeStamp(),markupModel,coverageByTestApplicable,executableLines,classData,line,lineNumberInCurrent);
          highlighters.add(highlighter);
        }
      }
    }
 else     if (!subCoverageActive && (suite.isClassFiltered(qualifiedName) || suite.isPackageFiltered(packageFQName))) {
      collectNonCoveredClassInfo(classFile,highlighters,markupModel,executableLines,coverageByTestApplicable);
    }
  }
  final DocumentListener documentListener=new DocumentAdapter(){
    @Override public void documentChanged(    final DocumentEvent e){
      myNewToOldLines=null;
      myOldToNewLines=null;
      final TIntIntHashMap newToOldLineMapping=getNewToOldLineMapping(suite.getLastCoverageTimeStamp());
      if (newToOldLineMapping != null) {
        List<RangeHighlighter> rangeHighlighters=myFile.getUserData(COVERAGE_HIGHLIGHTERS);
        if (rangeHighlighters == null)         rangeHighlighters=new ArrayList<RangeHighlighter>();
        int offset=e.getOffset();
        final int lineNumber=myDocument.getLineNumber(offset);
        final int lastLineNumber=myDocument.getLineNumber(offset + e.getNewLength());
        final TextRange changeRange=new TextRange(myDocument.getLineStartOffset(lineNumber),myDocument.getLineEndOffset(lastLineNumber));
        for (Iterator<RangeHighlighter> it=rangeHighlighters.iterator(); it.hasNext(); ) {
          final RangeHighlighter highlighter=it.next();
          if (!highlighter.isValid() || new TextRange(highlighter.getStartOffset(),highlighter.getEndOffset()).intersects(changeRange)) {
            myDocument.getMarkupModel(myProject).removeHighlighter(highlighter);
            it.remove();
          }
        }
        for (int line=lineNumber; line <= lastLineNumber; line++) {
          final LineData lineData=executableLines.get(newToOldLineMapping.get(line));
          if (lineData != null) {
            rangeHighlighters.add(createRangeHighlighter(suite.getLastCoverageTimeStamp(),markupModel,coverageByTestApplicable,executableLines,classLines.get(line),line,line));
          }
        }
        myFile.putUserData(COVERAGE_HIGHLIGHTERS,rangeHighlighters.size() > 0 ? rangeHighlighters : null);
      }
    }
  }
;
  myDocument.addDocumentListener(documentListener);
  myFile.putUserData(COVERAGE_DOCUMENT_LISTENER,documentListener);
  if (highlighters.size() > 0) {
    myFile.putUserData(COVERAGE_HIGHLIGHTERS,highlighters);
  }
}
