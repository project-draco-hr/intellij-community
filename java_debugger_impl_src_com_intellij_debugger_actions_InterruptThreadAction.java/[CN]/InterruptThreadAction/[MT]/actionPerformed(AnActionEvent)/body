{
  final DebuggerTreeNodeImpl[] nodes=getSelectedNodes(e.getDataContext());
  if (nodes == null) {
    return;
  }
  final List<ThreadReferenceProxyImpl> threadsToInterrupt=new ArrayList<ThreadReferenceProxyImpl>();
  for (  final DebuggerTreeNodeImpl debuggerTreeNode : nodes) {
    final NodeDescriptorImpl descriptor=debuggerTreeNode.getDescriptor();
    if (descriptor instanceof ThreadDescriptorImpl) {
      threadsToInterrupt.add(((ThreadDescriptorImpl)descriptor).getThreadReference());
    }
  }
  if (!threadsToInterrupt.isEmpty()) {
    final DebuggerContextImpl debuggerContext=getDebuggerContext(e.getDataContext());
    final DebugProcessImpl debugProcess=debuggerContext.getDebugProcess();
    if (debugProcess != null) {
      debugProcess.getManagerThread().schedule(new DebuggerCommandImpl(){
        protected void action() throws Exception {
          boolean unsupported=false;
          for (          ThreadReferenceProxyImpl thread : threadsToInterrupt) {
            try {
              thread.getThreadReference().interrupt();
            }
 catch (            UnsupportedOperationException ignored) {
              unsupported=true;
            }
          }
          if (unsupported) {
            final Project project=debugProcess.getProject();
            SwingUtilities.invokeLater(new Runnable(){
              public void run(){
                if (!project.isDisposed()) {
                  XDebugSessionImpl.NOTIFICATION_GROUP.createNotification("Thread operation 'interrupt' is not supported by VM",MessageType.INFO).notify(project);
                }
              }
            }
);
          }
        }
      }
);
    }
  }
}
