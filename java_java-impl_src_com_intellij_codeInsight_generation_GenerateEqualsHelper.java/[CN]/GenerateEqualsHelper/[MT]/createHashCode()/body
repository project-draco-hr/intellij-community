{
  @NonNls StringBuilder buffer=new StringBuilder();
  final HashMap<String,Object> contextMap=new HashMap<String,Object>();
  contextMap.put("superHasHashCode",mySuperHasHashCode);
  final String methodText=GenerationUtil.velocityGenerateCode(myClass,Arrays.asList(myHashCodeFields),myNonNullSet,new HashMap<String,String>(),contextMap,EqualsHashCodeTemplatesManager.getInstance().getDefaultHashcodeTemplate().getTemplate(),0,false,myUseAccessors);
  buffer.append(methodText);
  PsiMethod hashCode;
  try {
    hashCode=myFactory.createMethodFromText(buffer.toString(),null);
  }
 catch (  IncorrectOperationException e) {
    return null;
  }
  final PsiMethod superHashCode=MethodSignatureUtil.findMethodBySignature(myClass,getHashCodeSignature(),true);
  if (superHashCode != null) {
    OverrideImplementUtil.annotateOnOverrideImplement(hashCode,myClass,superHashCode);
  }
  hashCode=(PsiMethod)myJavaCodeStyleManager.shortenClassReferences(hashCode);
  return (PsiMethod)myCodeStyleManager.reformat(hashCode);
}
