{
  final int fileCount=scope.getFileCount();
  final ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
  final List<LocalInspectionToolWrapper> lTools=new ArrayList<LocalInspectionToolWrapper>();
  final LinkedHashMap<PsiFile,List<HighlightInfo>> results=new LinkedHashMap<PsiFile,List<HighlightInfo>>();
  final SearchScope searchScope=scope.toSearchScope();
  final TextRange range;
  if (searchScope instanceof LocalSearchScope) {
    final PsiElement[] elements=((LocalSearchScope)searchScope).getScope();
    range=elements.length == 1 ? elements[0].getTextRange() : null;
  }
 else {
    range=null;
  }
  scope.accept(new PsiElementVisitor(){
    private int myCount=0;
    @Override public void visitFile(    PsiFile file){
      if (progressIndicator != null) {
        progressIndicator.setFraction(((double)++myCount) / fileCount);
      }
      if (isBinary(file))       return;
      for (      final Tools tools : profile.getAllEnabledInspectionTools(project)) {
        if (tools.getTool().getTool() instanceof CleanupLocalInspectionTool) {
          final InspectionToolWrapper tool=tools.getEnabledTool(file);
          if (tool instanceof LocalInspectionToolWrapper) {
            lTools.add((LocalInspectionToolWrapper)tool);
            tool.initialize(GlobalInspectionContextImpl.this);
          }
        }
      }
      if (!lTools.isEmpty()) {
        final LocalInspectionsPass pass=new LocalInspectionsPass(file,PsiDocumentManager.getInstance(project).getDocument(file),range != null ? range.getStartOffset() : 0,range != null ? range.getEndOffset() : file.getTextLength(),LocalInspectionsPass.EMPTY_PRIORITY_RANGE,true,HighlightInfoProcessor.getEmpty());
        Runnable runnable=new Runnable(){
          @Override public void run(){
            pass.doInspectInBatch(GlobalInspectionContextImpl.this,InspectionManager.getInstance(project),lTools);
          }
        }
;
        ApplicationManager.getApplication().runReadAction(runnable);
        final List<HighlightInfo> infos=pass.getInfos();
        if (searchScope instanceof LocalSearchScope) {
          for (Iterator<HighlightInfo> iterator=infos.iterator(); iterator.hasNext(); ) {
            final HighlightInfo info=iterator.next();
            final TextRange infoRange=new TextRange(info.getStartOffset(),info.getEndOffset());
            if (!((LocalSearchScope)searchScope).containsRange(file,infoRange)) {
              iterator.remove();
            }
          }
        }
        if (!infos.isEmpty()) {
          results.put(file,infos);
        }
      }
    }
  }
);
  if (results.isEmpty()) {
    UIUtil.invokeLaterIfNeeded(new Runnable(){
      @Override public void run(){
        if (commandName != null) {
          NOTIFICATION_GROUP.createNotification(InspectionsBundle.message("inspection.no.problems.message"),MessageType.INFO).notify(getProject());
        }
        if (postRunnable != null) {
          postRunnable.run();
        }
      }
    }
);
    return;
  }
  Runnable runnable=new Runnable(){
    @Override public void run(){
      if (!FileModificationService.getInstance().preparePsiElementsForWrite(results.keySet()))       return;
      final SequentialModalProgressTask progressTask=new SequentialModalProgressTask(project,"Code Cleanup",true);
      progressTask.setMinIterationTime(200);
      progressTask.setTask(new SequentialCleanupTask(project,results,progressTask));
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        @Override public void run(){
          if (commandName != null) {
            CommandProcessor.getInstance().markCurrentCommandAsGlobal(project);
          }
          ApplicationManager.getApplication().runWriteAction(new Runnable(){
            @Override public void run(){
              ProgressManager.getInstance().run(progressTask);
            }
          }
);
          if (postRunnable != null) {
            ApplicationManager.getApplication().invokeLater(postRunnable);
          }
        }
      }
,commandName,null);
    }
  }
;
  if (ApplicationManager.getApplication().isDispatchThread()) {
    runnable.run();
  }
 else {
    ApplicationManager.getApplication().invokeLater(runnable);
  }
}
