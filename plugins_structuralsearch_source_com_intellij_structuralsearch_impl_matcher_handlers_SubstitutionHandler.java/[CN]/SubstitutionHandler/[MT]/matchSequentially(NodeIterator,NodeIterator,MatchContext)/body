{
  final int previousMatchedOccurs=matchedOccurs;
  try {
    MatchingHandler handler=context.getPattern().getHandler(nodes.current());
    matchedOccurs=0;
    while (nodes2.hasNext() && matchedOccurs < minOccurs) {
      if (handler.match(nodes.current(),nodes2.current(),context)) {
        ++matchedOccurs;
      }
 else {
        break;
      }
      nodes2.advance();
    }
    if (matchedOccurs != minOccurs) {
      removeLastResults(matchedOccurs,context);
      nodes2.rewind(matchedOccurs);
      return false;
    }
    if (greedy) {
      while (nodes2.hasNext() && matchedOccurs < maxOccurs) {
        if (handler.match(nodes.current(),nodes2.current(),context)) {
          ++matchedOccurs;
        }
 else {
          break;
        }
        nodes2.advance();
      }
      nodes.advance();
      if (nodes.hasNext()) {
        final MatchingHandler nextHandler=context.getPattern().getHandler(nodes.current());
        while (matchedOccurs >= minOccurs) {
          if (nextHandler.matchSequentially(nodes,nodes2,context)) {
            totalMatchedOccurs=matchedOccurs;
            return true;
          }
          if (matchedOccurs > 0) {
            nodes2.rewind();
            removeLastResults(1,context);
          }
          --matchedOccurs;
        }
        if (matchedOccurs > 0) {
          removeLastResults(matchedOccurs,context);
        }
        nodes.rewind();
        return false;
      }
 else {
        if (handler.isMatchSequentiallySucceeded(nodes2)) {
          return checkSameOccurencesConstraint();
        }
        removeLastResults(matchedOccurs,context);
        return false;
      }
    }
 else {
      nodes.advance();
      if (nodes.hasNext()) {
        final MatchingHandler nextHandler=context.getPattern().getHandler(nodes.current());
        while (nodes2.hasNext() && matchedOccurs <= maxOccurs) {
          if (nextHandler.matchSequentially(nodes,nodes2,context)) {
            return checkSameOccurencesConstraint();
          }
 else           if (handler.match(nodes.current(),nodes2.current(),context)) {
            matchedOccurs++;
          }
 else {
            nodes.rewind();
            removeLastResults(matchedOccurs,context);
            return false;
          }
          nodes2.advance();
        }
        nodes.rewind();
        removeLastResults(matchedOccurs,context);
        return false;
      }
 else {
        return checkSameOccurencesConstraint();
      }
    }
  }
  finally {
    matchedOccurs=previousMatchedOccurs;
  }
}
