{
  final boolean isField=member instanceof FieldRepr;
  final Util self=new Util();
  if (member.isPublic()) {
    debug("Public access, switching to a non-incremental mode");
    return false;
  }
  final THashSet<File> toRecompile=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
  if (member.isProtected()) {
    debug("Protected access, softening non-incremental decision: adding all relevant subclasses for a recompilation");
    debug("Root class: ",owner);
    final TIntHashSet propagated=self.propagateFieldAccess(isField ? member.name : myEmptyName,owner);
    propagated.forEach(new TIntProcedure(){
      @Override public boolean execute(      int className){
        final Collection<File> fileNames=myClassToSourceFile.get(className);
        if (fileNames != null) {
          for (          File fileName : fileNames) {
            debug("Adding ",fileName);
          }
          toRecompile.addAll(fileNames);
        }
        return true;
      }
    }
);
  }
  final String packageName=ClassRepr.getPackageName(myContext.getValue(isField ? owner : member.name));
  debug("Softening non-incremental decision: adding all package classes for a recompilation");
  debug("Package name: ",packageName);
  myClassToSourceFile.forEachEntry(new TIntObjectProcedure<Collection<File>>(){
    @Override public boolean execute(    int className,    Collection<File> fileNames){
      if (ClassRepr.getPackageName(myContext.getValue(className)).equals(packageName)) {
        for (        File fileName : fileNames) {
          if (filter == null || filter.accept(fileName)) {
            debug("Adding: ",fileName);
            toRecompile.add(fileName);
          }
        }
      }
      return true;
    }
  }
);
  toRecompile.removeAll(currentlyCompiled);
  for (Iterator<File> it=toRecompile.iterator(); it.hasNext(); ) {
    final File file=it.next();
    if (!file.exists()) {
      it.remove();
    }
  }
  affectedFiles.addAll(toRecompile);
  return true;
}
