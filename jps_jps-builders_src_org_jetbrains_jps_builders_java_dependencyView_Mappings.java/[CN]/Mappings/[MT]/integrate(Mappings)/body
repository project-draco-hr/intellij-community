{
synchronized (myLock) {
    try {
      assert(delta.isDifferentiated());
      final Collection<String> removed=delta.myRemovedFiles;
      delta.runPostPasses();
      final IntIntMultiMaplet dependenciesTrashBin=new IntIntTransientMultiMaplet();
      if (removed != null) {
        for (        final String file : removed) {
          final File deletedFile=new File(file);
          final Set<ClassRepr> fileClasses=(Set<ClassRepr>)mySourceFileToClasses.get(deletedFile);
          if (fileClasses != null) {
            for (            final ClassRepr aClass : fileClasses) {
              cleanupRemovedClass(delta,aClass,deletedFile,aClass.getUsages(),dependenciesTrashBin);
            }
            mySourceFileToClasses.remove(deletedFile);
          }
        }
      }
      if (!delta.isRebuild()) {
        for (        final Pair<ClassRepr,File> pair : delta.getDeletedClasses()) {
          final ClassRepr deletedClass=pair.first;
          cleanupRemovedClass(delta,deletedClass,pair.second,deletedClass.getUsages(),dependenciesTrashBin);
        }
        for (        ClassRepr repr : delta.getAddedClasses()) {
          if (!repr.isAnonymous() && !repr.isLocal()) {
            myShortClassNameIndex.put(myContext.get(repr.getShortName()),repr.name);
          }
        }
        final TIntHashSet superClasses=new TIntHashSet();
        final IntIntTransientMultiMaplet addedSuperClasses=delta.getAddedSuperClasses();
        final IntIntTransientMultiMaplet removedSuperClasses=delta.getRemovedSuperClasses();
        addAllKeys(superClasses,addedSuperClasses);
        addAllKeys(superClasses,removedSuperClasses);
        superClasses.forEach(new TIntProcedure(){
          @Override public boolean execute(          final int superClass){
            final TIntHashSet added=addedSuperClasses.get(superClass);
            TIntHashSet removed=removedSuperClasses.get(superClass);
            final TIntHashSet old=myClassToSubclasses.get(superClass);
            if (old == null) {
              if (added != null && !added.isEmpty()) {
                myClassToSubclasses.replace(superClass,added);
              }
            }
 else {
              boolean changed=false;
              final int[] addedAsArray=added != null && !added.isEmpty() ? added.toArray() : null;
              if (removed != null && !removed.isEmpty()) {
                if (addedAsArray != null) {
                  removed=(TIntHashSet)removed.clone();
                  removed.removeAll(addedAsArray);
                }
                if (!removed.isEmpty()) {
                  changed=old.removeAll(removed.toArray());
                }
              }
              if (addedAsArray != null) {
                changed|=old.addAll(addedAsArray);
              }
              if (changed) {
                myClassToSubclasses.replace(superClass,old);
              }
            }
            return true;
          }
        }
);
        delta.getChangedClasses().forEach(new TIntProcedure(){
          @Override public boolean execute(          final int className){
            final Collection<File> sourceFiles=delta.myClassToSourceFile.get(className);
            myClassToSourceFile.replace(className,sourceFiles);
            cleanupBackDependency(className,null,dependenciesTrashBin);
            return true;
          }
        }
);
        delta.getChangedFiles().forEach(new TObjectProcedure<File>(){
          @Override public boolean execute(          final File fileName){
            final Collection<ClassRepr> classes=delta.mySourceFileToClasses.get(fileName);
            mySourceFileToClasses.replace(fileName,classes);
            return true;
          }
        }
);
        final THashSet<File> unchangedSources=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
        delta.mySourceFileToClasses.forEachEntry(new TObjectObjectProcedure<File,Collection<ClassRepr>>(){
          @Override public boolean execute(          File source,          Collection<ClassRepr> b){
            unchangedSources.add(source);
            return true;
          }
        }
);
        unchangedSources.removeAll(delta.getChangedFiles());
        if (!unchangedSources.isEmpty()) {
          unchangedSources.forEach(new TObjectProcedure<File>(){
            @Override public boolean execute(            File file){
              final Collection<ClassRepr> updatedClasses=delta.mySourceFileToClasses.get(file);
              if (updatedClasses != null && !updatedClasses.isEmpty()) {
                final List<ClassRepr> classesToAdd=new ArrayList<ClassRepr>();
                classesToAdd.addAll(updatedClasses);
                Collection<ClassRepr> currentClasses=mySourceFileToClasses.get(file);
                if (currentClasses != null) {
                  final TIntHashSet updatedClassNames=new TIntHashSet();
                  for (                  ClassRepr aClass : updatedClasses) {
                    updatedClassNames.add(aClass.name);
                  }
                  for (                  ClassRepr aClass : currentClasses) {
                    if (!updatedClassNames.contains(aClass.name)) {
                      classesToAdd.add(aClass);
                    }
                  }
                }
                mySourceFileToClasses.replace(file,classesToAdd);
              }
              return true;
            }
          }
);
        }
      }
 else {
        myClassToSubclasses.putAll(delta.myClassToSubclasses);
        myClassToSourceFile.replaceAll(delta.myClassToSourceFile);
        mySourceFileToClasses.replaceAll(delta.mySourceFileToClasses);
        delta.mySourceFileToClasses.forEachEntry(new TObjectObjectProcedure<File,Collection<ClassRepr>>(){
          public boolean execute(          File src,          Collection<ClassRepr> classes){
            for (            ClassRepr repr : classes) {
              if (!repr.isAnonymous() && !repr.isLocal()) {
                myShortClassNameIndex.put(myContext.get(repr.getShortName()),repr.name);
              }
            }
            return true;
          }
        }
);
      }
      final TIntHashSet affectedClasses=new TIntHashSet();
      addAllKeys(affectedClasses,dependenciesTrashBin);
      addAllKeys(affectedClasses,delta.myClassToClassDependency);
      affectedClasses.forEach(new TIntProcedure(){
        @Override public boolean execute(        int aClass){
          final TIntHashSet now=delta.myClassToClassDependency.get(aClass);
          final TIntHashSet toRemove=dependenciesTrashBin.get(aClass);
          final boolean hasDataToAdd=now != null && !now.isEmpty();
          if (toRemove != null && !toRemove.isEmpty()) {
            final TIntHashSet current=myClassToClassDependency.get(aClass);
            if (current != null && !current.isEmpty()) {
              final TIntHashSet before=new TIntHashSet();
              addAll(before,current);
              final boolean removed=current.removeAll(toRemove.toArray());
              final boolean added=hasDataToAdd && current.addAll(now.toArray());
              if ((removed && !added) || (!removed && added) || !before.equals(current)) {
                myClassToClassDependency.replace(aClass,current);
              }
            }
 else {
              if (hasDataToAdd) {
                myClassToClassDependency.put(aClass,now);
              }
            }
          }
 else {
            if (hasDataToAdd) {
              myClassToClassDependency.put(aClass,now);
            }
          }
          return true;
        }
      }
);
    }
  finally {
      delta.close();
    }
  }
}
