{
  debug("Checking dependent classes:");
  state.myDependants.forEach(new TIntProcedure(){
    @Override public boolean execute(    final int depClass){
      final Collection<File> depFiles=myClassToSourceFile.get(depClass);
      if (depFiles != null) {
        for (        File depFile : depFiles) {
          processDependentFile(depClass,depFile);
        }
      }
      return true;
    }
    private void processDependentFile(    int depClass,    @NotNull File depFile){
      if (myAffectedFiles.contains(depFile) || myCompiledFiles.contains(depFile)) {
        return;
      }
      debug("Dependent class: ",depClass);
      final ClassRepr classRepr=getReprByName(depFile,depClass);
      if (classRepr == null) {
        return;
      }
      final Set<UsageRepr.Usage> depUsages=classRepr.getUsages();
      if (depUsages == null || depUsages.isEmpty()) {
        return;
      }
      for (      UsageRepr.Usage usage : depUsages) {
        if (usage instanceof UsageRepr.AnnotationUsage) {
          for (          final UsageRepr.AnnotationUsage query : state.myAnnotationQuery) {
            if (query.satisfies(usage)) {
              debug("Added file due to annotation query");
              myAffectedFiles.add(depFile);
              return;
            }
          }
        }
 else         if (state.myAffectedUsages.contains(usage)) {
          final Util.UsageConstraint constraint=state.myUsageConstraints.get(usage);
          if (constraint == null) {
            debug("Added file with no constraints");
            myAffectedFiles.add(depFile);
            return;
          }
          if (constraint.checkResidence(depClass)) {
            debug("Added file with satisfied constraint");
            myAffectedFiles.add(depFile);
            return;
          }
        }
      }
    }
  }
);
}
