{
  final Collection<MethodRepr> removed=diff.methods().removed();
  if (removed.isEmpty()) {
    return;
  }
  debug("Processing removed methods:");
  for (  final MethodRepr m : removed) {
    debug("Method ",m.name);
    final Collection<Pair<MethodRepr,ClassRepr>> overridenMethods=myFuture.findOverriddenMethods(m,it);
    final TIntHashSet propagated=myFuture.propagateMethodAccess(m,it.name);
    if (overridenMethods.size() == 0) {
      debug("No overridden methods found, affecting method usages");
      myFuture.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
    }
 else {
      boolean clear=true;
      loop:       for (      final Pair<MethodRepr,ClassRepr> overriden : overridenMethods) {
        final MethodRepr mm=overriden.first;
        if (mm == MOCK_METHOD || !mm.myType.equals(m.myType) || !isEmpty(mm.signature) || !isEmpty(m.signature) || m.isMoreAccessibleThan(mm)) {
          clear=false;
          break loop;
        }
      }
      if (!clear) {
        debug("No clearly overridden methods found, affecting method usages");
        myFuture.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
      }
    }
    final Collection<Pair<MethodRepr,ClassRepr>> overridingMethods=new HashSet<Pair<MethodRepr,ClassRepr>>();
    myFuture.addOverridingMethods(m,it,MethodRepr.equalByJavaRules(m),overridingMethods,null);
    for (    final Pair<MethodRepr,ClassRepr> p : overridingMethods) {
      final Collection<File> fNames=myClassToSourceFile.get(p.second.name);
      if (fNames != null) {
        myAffectedFiles.addAll(fNames);
        for (        File fName : fNames) {
          debug("Affecting file by overriding: ",fName);
        }
      }
    }
    if (!m.isAbstract()) {
      propagated.forEach(new TIntProcedure(){
        @Override public boolean execute(        int p){
          if (p != it.name) {
            final ClassRepr s=myFuture.reprByName(p);
            if (s != null) {
              final Collection<Pair<MethodRepr,ClassRepr>> overridenInS=myFuture.findOverriddenMethods(m,s);
              overridenInS.addAll(overridenMethods);
              boolean allAbstract=true;
              boolean visited=false;
              for (              final Pair<MethodRepr,ClassRepr> pp : overridenInS) {
                final ClassRepr cc=pp.second;
                if (cc == MOCK_CLASS) {
                  visited=true;
                  continue;
                }
                if (cc.name == it.name) {
                  continue;
                }
                visited=true;
                allAbstract=pp.first.isAbstract() || cc.isInterface();
                if (!allAbstract) {
                  break;
                }
              }
              if (allAbstract && visited) {
                final Collection<File> sources=myClassToSourceFile.get(p);
                if (sources != null && !myCompiledFiles.containsAll(sources)) {
                  myAffectedFiles.addAll(sources);
                  debug("Removed method is not abstract & overrides some abstract method which is not then over-overridden in subclass ",p);
                  for (                  File source : sources) {
                    debug("Affecting subclass source file ",source);
                  }
                }
              }
            }
          }
          return true;
        }
      }
);
    }
  }
  debug("End of removed methods processing");
}
