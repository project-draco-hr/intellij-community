{
  AtomicBoolean hasNext=new AtomicBoolean();
  try {
    ForkJoinPool.managedBlock(new ForkJoinPool.ManagedBlocker(){
      @Override public boolean block() throws InterruptedException {
        currentlyProcessingClasses.waitFor();
        return isReleasable();
      }
      @Override public boolean isReleasable(){
synchronized (lock) {
          boolean producedSomething=subClassIterator.hasNext();
          hasNext.set(producedSomething);
          return producedSomething || !candidatesToFindSubclassesIterator.hasNext() || classesBeingProcessed.isEmpty();
        }
      }
    }
);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return hasNext.get();
}
