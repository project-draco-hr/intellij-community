{
  if (myDefinition.isInterface() && !myDefinition.isTrait())   return Collections.emptyList();
  GrImplementsClause clause=myDefinition.getImplementsClause();
  if (clause == null)   return Collections.emptyList();
  PsiClassType[] types=clause.getReferencedTypes();
  List<PsiClassType.ClassResolveResult> traits=getSuperTraitsByCorrectOrder(types);
  if (traits.isEmpty())   return Collections.emptyList();
  Set<MethodSignature> existingSignatures=ContainerUtil.newHashSet(ContainerUtil.map(codeMethods,new Function<PsiMethod,MethodSignature>(){
    @Override public MethodSignature fun(    PsiMethod method){
      return method.getSignature(PsiSubstitutor.EMPTY);
    }
  }
));
  List<PsiMethod> result=ContainerUtil.newArrayList();
  for (  PsiClassType.ClassResolveResult resolveResult : traits) {
    PsiClass trait=resolveResult.getElement();
    LOG.assertTrue(trait != null);
    List<CandidateInfo> concreteTraitMethods=new TraitProcessor<PsiMethod>(trait,resolveResult.getSubstitutor()){
      protected void processTrait(      @NotNull PsiClass trait,      @NotNull PsiSubstitutor substitutor){
        if (trait instanceof GrTypeDefinition) {
          for (          GrMethod method : ((GrTypeDefinition)trait).getCodeMethods()) {
            if (!method.getModifierList().hasExplicitModifier(PsiModifier.ABSTRACT)) {
              addCandidate(method,substitutor);
            }
          }
          for (          GrField field : ((GrTypeDefinition)trait).getCodeFields()) {
            if (!field.isProperty())             continue;
            for (            GrAccessorMethod method : field.getGetters()) {
              addCandidate(method,substitutor);
            }
            GrAccessorMethod setter=field.getSetter();
            if (setter != null) {
              addCandidate(setter,substitutor);
            }
          }
        }
 else         if (trait instanceof ClsClassImpl) {
          for (          PsiMethod method : trait.getMethods()) {
            if (AnnotationUtil.isAnnotated(method,IMPLEMENTED_FQN,false)) {
              addCandidate(method,substitutor);
            }
          }
          final JavaPsiFacade psiFacade=JavaPsiFacade.getInstance(trait.getProject());
          final String helperFQN=trait.getQualifiedName();
          final PsiClass traitHelper=psiFacade.findClass(helperFQN + "$Trait$Helper",trait.getResolveScope());
          if (traitHelper != null) {
            final PsiType classType=TypesUtil.createJavaLangClassType(psiFacade.getElementFactory().createType(trait),trait.getProject(),trait.getResolveScope());
            for (            PsiMethod method : traitHelper.getMethods()) {
              if (!method.hasModifierProperty(PsiModifier.STATIC))               continue;
              final PsiParameter[] parameters=method.getParameterList().getParameters();
              if (parameters.length <= 0)               continue;
              final PsiParameter self=parameters[0];
              if (self.getType().equals(classType)) {
                addCandidate(GrGdkMethodImpl.createGdkMethod(method,true,"via @Trait"),substitutor);
              }
            }
          }
        }
      }
    }
.getResult();
    for (    CandidateInfo candidateInfo : concreteTraitMethods) {
      List<GrMethod> methodsToAdd=getExpandingMethods(candidateInfo);
      for (      GrMethod impl : methodsToAdd) {
        if (existingSignatures.add(impl.getSignature(PsiSubstitutor.EMPTY))) {
          result.add(impl);
        }
      }
    }
  }
  return result;
}
