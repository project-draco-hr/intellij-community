{
  if (clazz.isInterface() && !clazz.isTrait())   return;
  GrImplementsClause clause=clazz.getImplementsClause();
  if (clause == null)   return;
  PsiClassType[] types=clause.getReferencedTypes();
  List<PsiClassType.ClassResolveResult> traits=getSuperTraitsByCorrectOrder(types);
  if (traits.isEmpty())   return;
  PsiMethod[] codeMethods=clazz.getCodeMethods();
  Set<MethodSignature> existingSignatures=ContainerUtil.newHashSet(ContainerUtil.map(codeMethods,new Function<PsiMethod,MethodSignature>(){
    @Override public MethodSignature fun(    PsiMethod method){
      return method.getSignature(PsiSubstitutor.EMPTY);
    }
  }
));
  for (  PsiClassType.ClassResolveResult resolveResult : traits) {
    GrTypeDefinition trait=(GrTypeDefinition)resolveResult.getElement();
    LOG.assertTrue(trait != null);
    List<CandidateInfo> concreteTraitMethods=new TraitProcessor<PsiMethod>(trait,resolveResult.getSubstitutor()){
      protected void processTrait(      @NotNull GrTypeDefinition trait,      @NotNull PsiSubstitutor substitutor){
        for (        GrMethod method : trait.getCodeMethods()) {
          if (!method.getModifierList().hasExplicitModifier(PsiModifier.ABSTRACT)) {
            addCandidate(method,substitutor);
          }
        }
        for (        GrField field : trait.getCodeFields()) {
          if (!field.isProperty())           continue;
          for (          GrAccessorMethod method : field.getGetters()) {
            addCandidate(method,substitutor);
          }
          GrAccessorMethod setter=field.getSetter();
          if (setter != null) {
            addCandidate(setter,substitutor);
          }
        }
      }
    }
.getResult();
    for (    CandidateInfo candidateInfo : concreteTraitMethods) {
      List<GrMethod> methodsToAdd=getExpandingMethods(clazz,candidateInfo);
      for (      GrMethod impl : methodsToAdd) {
        if (existingSignatures.add(impl.getSignature(PsiSubstitutor.EMPTY))) {
          collector.add(impl);
        }
      }
    }
  }
}
