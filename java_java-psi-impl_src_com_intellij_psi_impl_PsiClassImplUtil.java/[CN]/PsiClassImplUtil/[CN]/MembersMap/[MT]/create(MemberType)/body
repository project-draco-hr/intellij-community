{
  final Map<String,List<PsiMember>> map=ContainerUtil.newTroveMap();
  final List<PsiMember> allMembers=ContainerUtil.newArrayList();
  map.put(ALL,allMembers);
  ElementClassFilter filter=key == MemberType.CLASS ? ElementClassFilter.CLASS : key == MemberType.METHOD ? ElementClassFilter.METHOD : ElementClassFilter.FIELD;
  final ElementClassHint classHint=new ElementClassHint(){
    @Override public boolean shouldProcess(    DeclarationKind kind){
      return key == MemberType.CLASS && kind == DeclarationKind.CLASS || key == MemberType.FIELD && (kind == DeclarationKind.FIELD || kind == DeclarationKind.ENUM_CONST) || key == MemberType.METHOD && kind == DeclarationKind.METHOD;
    }
  }
;
  FilterScopeProcessor<MethodCandidateInfo> processor=new FilterScopeProcessor<MethodCandidateInfo>(filter){
    @Override protected void add(    @NotNull PsiElement element,    @NotNull PsiSubstitutor substitutor){
      if (key == MemberType.CLASS && element instanceof PsiClass || key == MemberType.METHOD && element instanceof PsiMethod || key == MemberType.FIELD && element instanceof PsiField) {
        allMembers.add((PsiMember)element);
        String currentName=((PsiMember)element).getName();
        List<PsiMember> listByName=map.get(currentName);
        if (listByName == null) {
          listByName=ContainerUtil.newArrayList();
          map.put(currentName,listByName);
        }
        listByName.add((PsiMember)element);
      }
    }
    @Override public <K>K getHint(    @NotNull Key<K> hintKey){
      return ElementClassHint.KEY == hintKey ? (K)classHint : super.getHint(hintKey);
    }
  }
;
  processDeclarationsInClassNotCached(myPsiClass,processor,ResolveState.initial(),null,null,myPsiClass,false,PsiUtil.getLanguageLevel(myPsiClass),myResolveScope);
  Map<String,PsiMember[]> result=ContainerUtil.newTroveMap();
  for (  Entry<String,List<PsiMember>> entry : map.entrySet()) {
    result.put(entry.getKey(),entry.getValue().toArray(PsiMember.EMPTY_ARRAY));
  }
  return result;
}
