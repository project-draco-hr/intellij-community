{
  String path=myProject != null ? TestDiscoveryExtension.baseTestDiscoveryPathForProject(myProject) : "out";
  final File methodQNameToTestNameFile=new File(path + File.separator + "methodQNameToTestName.data");
  final File testNameToUsedClassesAndMethodMapFile=new File(path + File.separator + "testToCalledMethodNames");
  try {
    myMethodQNameToTestNames=IOUtil.openCleanOrResetBroken(new ThrowableComputable<PersistentHashMap<Pair<String,String>,Collection<String>>,IOException>(){
      @Override public PersistentHashMap<Pair<String,String>,Collection<String>> compute() throws IOException {
        return new PersistentHashMap<Pair<String,String>,Collection<String>>(methodQNameToTestNameFile,new StringPairKeyDescriptor(),new DataExternalizer<Collection<String>>(){
          public void save(          @NotNull DataOutput dataOutput,          Collection<String> strings) throws IOException {
            for (            String string : strings)             IOUtil.writeUTF(dataOutput,string);
          }
          public Collection<String> read(          @NotNull DataInput dataInput) throws IOException {
            Set<String> result=new THashSet<String>();
            while (((InputStream)dataInput).available() > 0) {
              String string=IOUtil.readUTF(dataInput);
              if (REMOVED_MARKER.equals(string)) {
                string=IOUtil.readUTF(dataInput);
                result.remove(string);
              }
 else {
                result.add(string);
              }
            }
            return result;
          }
        }
);
      }
    }
,methodQNameToTestNameFile);
    myTestNameToUsedClassesAndMethodMap=IOUtil.openCleanOrResetBroken(new ThrowableComputable<PersistentHashMap<String,Map<String,List<String>>>,IOException>(){
      @Override public PersistentHashMap<String,Map<String,List<String>>> compute() throws IOException {
        return new PersistentHashMap<String,Map<String,List<String>>>(testNameToUsedClassesAndMethodMapFile,EnumeratorStringDescriptor.INSTANCE,new DataExternalizer<Map<String,List<String>>>(){
          public void save(          @NotNull DataOutput dataOutput,          Map<String,List<String>> classAndMethodsMap) throws IOException {
            BufferExposingByteArrayOutputStream out=new BufferExposingByteArrayOutputStream();
            Deflater deflater=new Deflater(1);
            DataOutputStream dataOutputStream=new DataOutputStream(new BufferedOutputStream(new DeflaterOutputStream(out,deflater)));
            DataInputOutputUtil.writeINT(dataOutputStream,classAndMethodsMap.size());
            for (            Map.Entry<String,List<String>> e : classAndMethodsMap.entrySet()) {
              IOUtil.writeUTF(dataOutputStream,e.getKey());
              DataInputOutputUtil.writeINT(dataOutputStream,e.getValue().size());
              for (              String methodName : e.getValue())               IOUtil.writeUTF(dataOutputStream,methodName);
            }
            dataOutputStream.close();
            deflater.end();
            dataOutput.write(out.getInternalBuffer(),0,out.size());
          }
          public Map<String,List<String>> read(          @NotNull DataInput dataInput) throws IOException {
            byte[] buf;
            dataInput.readFully(buf=new byte[((InputStream)dataInput).available()]);
            DataInputStream dataInputStream=new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(buf)));
            int numberOfClasses=DataInputOutputUtil.readINT(dataInputStream);
            THashMap<String,List<String>> result=new THashMap<String,List<String>>(numberOfClasses);
            while (numberOfClasses-- > 0) {
              String className=IOUtil.readUTF(dataInputStream);
              int numberOfMethods=DataInputOutputUtil.readINT(dataInputStream);
              ArrayList<String> methods=new ArrayList<String>(numberOfMethods);
              while (numberOfMethods-- > 0)               methods.add(IOUtil.readUTF(dataInputStream));
              result.put(className,methods);
            }
            dataInputStream.close();
            return result;
          }
        }
);
      }
    }
,testNameToUsedClassesAndMethodMapFile);
    myFlushingFuture=FlushingDaemon.everyFiveSeconds(new Runnable(){
      @Override public void run(){
synchronized (ourLock) {
          if (myDisposed) {
            myFlushingFuture.cancel(false);
            return;
          }
          if (myMethodQNameToTestNames.isDirty()) {
            myMethodQNameToTestNames.force();
          }
          if (myTestNameToUsedClassesAndMethodMap.isDirty()) {
            myTestNameToUsedClassesAndMethodMap.force();
          }
        }
      }
    }
);
  }
 catch (  IOException ex) {
    throw new RuntimeException(ex);
  }
}
