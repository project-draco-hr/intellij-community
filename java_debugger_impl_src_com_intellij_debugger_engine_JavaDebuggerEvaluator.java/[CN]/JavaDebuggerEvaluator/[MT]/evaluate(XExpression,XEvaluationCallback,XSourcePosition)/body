{
  final Project project=myDebugProcess.getProject();
  final WatchItemDescriptor descriptor=new WatchItemDescriptor(project,TextWithImportsImpl.fromXExpression(expression));
  if (Registry.is("debugger.compiling.evaluator")) {
    try {
      PsiElement element=myDebugProcess.getDebuggerContext().getContextElement();
      PsiFile psiFile=element.getContainingFile();
      PsiCodeFragment fragment=descriptor.createCodeFragment(element);
      ExtractLightMethodObjectHandler.ExtractedData data=ExtractLightMethodObjectHandler.extractLightMethodObject(project,psiFile,fragment,CompilingEvaluator.getGeneratedClassName());
      descriptor.putUserData(CompilingEvaluator.COMPILING_EVALUATOR_DATA,data);
    }
 catch (    Exception e) {
      LOG.info(e);
    }
  }
  myDebugProcess.getManagerThread().schedule(new DebuggerContextCommandImpl(myDebugProcess.getDebuggerContext()){
    @Override public Priority getPriority(){
      return Priority.NORMAL;
    }
    @Override public void threadAction(){
      EvaluationContextImpl evalContext=myStackFrame.getFrameDebuggerContext().createEvaluationContext();
      if (evalContext == null) {
        callback.errorOccurred("Context is not available");
        return;
      }
      descriptor.setContext(evalContext);
      @SuppressWarnings("ThrowableResultOfMethodCallIgnored") EvaluateException exception=descriptor.getEvaluateException();
      if (exception != null) {
        callback.errorOccurred(exception.getMessage());
        return;
      }
      JavaDebugProcess process=myDebugProcess.getXdebugProcess();
      if (process == null) {
        callback.errorOccurred("No debug process");
        return;
      }
      callback.evaluated(JavaValue.create(null,descriptor,evalContext,process.getNodeManager(),true));
    }
  }
);
}
