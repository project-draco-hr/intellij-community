{
  if (!isRepositoryReady(root)) {
    return LogDataImpl.empty();
  }
  GitRepository repository=ObjectUtils.assertNotNull(myRepositoryManager.getRepositoryForRoot(root));
  int commitCount=requirements.getCommitCount() * 2;
  String[] params=new String[]{"HEAD","--branches","--remotes","--max-count=" + commitCount};
  boolean refresh=requirements instanceof VcsLogProviderRequirementsEx && ((VcsLogProviderRequirementsEx)requirements).isRefresh();
  DetailedLogData data=GitHistoryUtils.loadMetadata(myProject,root,refresh,params);
  Set<VcsRef> safeRefs=data.getRefs();
  Set<VcsRef> allRefs=new OpenTHashSet<VcsRef>(safeRefs,REF_ONLY_NAME_STRATEGY);
  addNewElements(allRefs,readBranches(repository));
  Collection<VcsCommitMetadata> allDetails;
  if (!refresh) {
    allDetails=data.getCommits();
  }
 else {
    VcsLogProviderRequirementsEx rex=(VcsLogProviderRequirementsEx)requirements;
    Set<String> currentTags=readCurrentTagNames(root);
    addOldStillExistingTags(allRefs,currentTags,rex.getPreviousRefs());
    allDetails=ContainerUtil.newHashSet(data.getCommits());
    Set<String> previousTags=new HashSet<String>(ContainerUtil.mapNotNull(rex.getPreviousRefs(),GET_TAG_NAME));
    Set<String> safeTags=new HashSet<String>(ContainerUtil.mapNotNull(safeRefs,GET_TAG_NAME));
    Set<String> newUnmatchedTags=remove(currentTags,previousTags,safeTags);
    if (!newUnmatchedTags.isEmpty()) {
      DetailedLogData commitsFromTags=loadSomeCommitsOnTaggedBranches(root,commitCount,newUnmatchedTags);
      addNewElements(allDetails,commitsFromTags.getCommits());
      addNewElements(allRefs,commitsFromTags.getRefs());
    }
  }
  List<VcsCommitMetadata> sortedCommits=VcsLogSorter.sortByDateTopoOrder(allDetails);
  sortedCommits=sortedCommits.subList(0,Math.min(sortedCommits.size(),requirements.getCommitCount()));
  return new LogDataImpl(allRefs,sortedCommits);
}
