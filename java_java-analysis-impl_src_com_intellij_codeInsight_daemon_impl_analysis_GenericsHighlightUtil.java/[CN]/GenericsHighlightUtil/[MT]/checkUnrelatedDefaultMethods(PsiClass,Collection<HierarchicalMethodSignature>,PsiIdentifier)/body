{
  for (  HierarchicalMethodSignature methodSignature : signaturesWithSupers) {
    final PsiMethod method=methodSignature.getMethod();
    final boolean isAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
    if (method.hasModifierProperty(PsiModifier.DEFAULT) || isAbstract) {
      final PsiClass containingClass=method.getContainingClass();
      List<HierarchicalMethodSignature> superSignatures=methodSignature.getSuperSignatures();
      if (!superSignatures.isEmpty()) {
        for (        HierarchicalMethodSignature signature : superSignatures) {
          final PsiMethod superMethod=signature.getMethod();
          final PsiClass superContainingClass=superMethod.getContainingClass();
          if (containingClass != null && superContainingClass != null && !InheritanceUtil.isInheritorOrSelf(containingClass,superContainingClass,true)) {
            final boolean isDefault=superMethod.hasModifierProperty(PsiModifier.DEFAULT);
            if (!aClass.hasModifierProperty(PsiModifier.ABSTRACT) && !isDefault && !isAbstract) {
              final String message=JavaErrorMessages.message(aClass instanceof PsiEnumConstantInitializer ? "enum.constant.should.implement.method" : "class.must.be.abstract",HighlightUtil.formatClass(superContainingClass),JavaHighlightUtil.formatMethod(superMethod),HighlightUtil.formatClass(superContainingClass,false));
              final HighlightInfo info=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(message).create();
              QuickFixAction.registerQuickFixAction(info,QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));
              return info;
            }
            if (isDefault || !isAbstract && superMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
              final String message=isDefault ? " inherits unrelated defaults for " : " inherits abstract and default for ";
              final String inheritUnrelatedDefaultsMessage=HighlightUtil.formatClass(aClass) + message + JavaHighlightUtil.formatMethod(method)+ " from types "+ HighlightUtil.formatClass(containingClass)+ " and "+ HighlightUtil.formatClass(superContainingClass);
              final HighlightInfo info=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(inheritUnrelatedDefaultsMessage).create();
              QuickFixAction.registerQuickFixAction(info,QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));
              return info;
            }
          }
        }
      }
    }
  }
  return null;
}
