{
  ClassWrapper wrapper=node.getWrapper();
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper methodWrapper=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  boolean hideMethod=false;
  int start_index_method=buffer.length();
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    boolean isInterface=cl.hasModifier(CodeConstants.ACC_INTERFACE);
    boolean isAnnotation=cl.hasModifier(CodeConstants.ACC_ANNOTATION);
    boolean isEnum=cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
    boolean isDeprecated=mt.getAttributes().containsKey("Deprecated");
    boolean clinit=false, init=false, dinit=false;
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    int flags=mt.getAccessFlags();
    if ((flags & CodeConstants.ACC_NATIVE) != 0) {
      flags&=~CodeConstants.ACC_STRICT;
    }
    if (CodeConstants.CLINIT_NAME.equals(mt.getName())) {
      flags&=CodeConstants.ACC_STATIC;
    }
    if (isDeprecated) {
      appendDeprecation(buffer,indent);
    }
    if (interceptor != null) {
      String oldName=interceptor.getOldName(cl.qualifiedName + " " + mt.getName()+ " "+ mt.getDescriptor());
      appendRenameComment(buffer,oldName,MType.METHOD,indent);
    }
    boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey("Synthetic");
    boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
    if (isSynthetic) {
      appendComment(buffer,"synthetic method",indent);
    }
    if (isBridge) {
      appendComment(buffer,"bridge method",indent);
    }
    appendAnnotations(buffer,mt,indent);
    buffer.appendIndent(indent);
    appendModifiers(buffer,flags,METHOD_ALLOWED,isInterface,METHOD_EXCLUDED);
    if (isInterface && mt.containsCode()) {
      buffer.append("default ");
    }
    String name=mt.getName();
    if (CodeConstants.INIT_NAME.equals(name)) {
      if (node.type == ClassNode.CLASS_ANONYMOUS) {
        name="";
        dinit=true;
      }
 else {
        name=node.simpleName;
        init=true;
      }
    }
 else     if (CodeConstants.CLINIT_NAME.equals(name)) {
      name="";
      clinit=true;
    }
    GenericMethodDescriptor descriptor=null;
    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
      StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttributes().getWithKey("Signature");
      if (attr != null) {
        descriptor=GenericMain.parseMethodSignature(attr.getSignature());
        if (descriptor != null) {
          int actualParams=md.params.length;
          List<VarVersionPair> sigFields=methodWrapper.signatureFields;
          if (sigFields != null) {
            actualParams=0;
            for (            VarVersionPair field : methodWrapper.signatureFields) {
              if (field == null) {
                actualParams++;
              }
            }
          }
 else           if (isEnum && init)           actualParams-=2;
          if (actualParams != descriptor.params.size()) {
            String message="Inconsistent generic signature in method " + mt.getName() + " "+ mt.getDescriptor()+ " in "+ cl.qualifiedName;
            DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
            descriptor=null;
          }
        }
      }
    }
    boolean throwsExceptions=false;
    int paramCount=0;
    if (!clinit && !dinit) {
      boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
      if (descriptor != null && !descriptor.fparameters.isEmpty()) {
        appendTypeParameters(buffer,descriptor.fparameters,descriptor.fbounds);
        buffer.append(' ');
      }
      if (!init) {
        if (descriptor != null) {
          buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
        }
 else {
          buffer.append(ExprProcessor.getCastTypeName(md.ret));
        }
        buffer.append(' ');
      }
      buffer.append(toValidJavaIdentifier(name));
      buffer.append('(');
      List<VarVersionPair> signFields=methodWrapper.signatureFields;
      int lastVisibleParameterIndex=-1;
      for (int i=0; i < md.params.length; i++) {
        if (signFields == null || signFields.get(i) == null) {
          lastVisibleParameterIndex=i;
        }
      }
      boolean firstParameter=true;
      int index=isEnum && init ? 3 : thisVar ? 1 : 0;
      boolean hasDescriptor=descriptor != null;
      int start=isEnum && init && !hasDescriptor ? 2 : 0;
      int params=hasDescriptor ? descriptor.params.size() : md.params.length;
      for (int i=start; i < params; i++) {
        if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {
          if (!firstParameter) {
            buffer.append(", ");
          }
          appendParameterAnnotations(buffer,mt,paramCount);
          if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index,0)) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {
            buffer.append("final ");
          }
          if (descriptor != null) {
            GenericType parameterType=descriptor.params.get(i);
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=GenericMain.getGenericCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append("...");
            }
          }
 else {
            VarType parameterType=md.params[i];
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=ExprProcessor.getCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append("...");
            }
          }
          buffer.append(' ');
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPair(index,0));
          buffer.append(parameterName == null ? "param" + index : parameterName);
          firstParameter=false;
          paramCount++;
        }
        index+=md.params[i].stackSize;
      }
      buffer.append(')');
      StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttributes().getWithKey("Exceptions");
      if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
        throwsExceptions=true;
        buffer.append(" throws ");
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          if (i > 0) {
            buffer.append(", ");
          }
          if (descriptor != null && !descriptor.exceptions.isEmpty()) {
            GenericType type=descriptor.exceptions.get(i);
            buffer.append(GenericMain.getGenericCastTypeName(type));
          }
 else {
            VarType type=new VarType(attr.getExcClassname(i,cl.getPool()),true);
            buffer.append(ExprProcessor.getCastTypeName(type));
          }
        }
      }
    }
    tracer.incrementCurrentSourceLine(buffer.countLines(start_index_method));
    if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
      if (isAnnotation) {
        StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttributes().getWithKey("AnnotationDefault");
        if (attr != null) {
          buffer.append(" default ");
          buffer.append(attr.getDefaultValue().toJava(0,new BytecodeMappingTracer()));
        }
      }
      buffer.append(';');
      buffer.appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
 else {
      if (!clinit && !dinit) {
        buffer.append(' ');
      }
      buffer.append('{').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
      RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null && !methodWrapper.decompiledWithErrors) {
        try {
          TextBuffer code=root.toJava(indent + 1,tracer);
          hideMethod=(clinit || dinit || hideConstructor(wrapper,init,throwsExceptions,paramCount)) && code.length() == 0;
          buffer.append(code);
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " "+ mt.getDescriptor()+ " couldn't be written.",ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
      if (methodWrapper.decompiledWithErrors) {
        buffer.appendIndent(indent + 1);
        buffer.append("// $FF: Couldn't be decompiled");
        buffer.appendLineSeparator();
        tracer.incrementCurrentSourceLine();
      }
      if (root != null) {
        tracer.addMapping(root.getDummyExit().bytecode);
      }
      buffer.appendIndent(indent).append('}').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
  return !hideMethod;
}
