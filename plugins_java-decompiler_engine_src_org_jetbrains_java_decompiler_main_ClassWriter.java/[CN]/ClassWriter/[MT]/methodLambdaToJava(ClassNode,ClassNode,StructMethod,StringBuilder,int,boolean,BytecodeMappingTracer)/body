{
  ClassWrapper classWrapper=classNode.wrapper;
  MethodWrapper methodWrapper=classWrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    String method_name=lambdaNode.lambda_information.method_name;
    MethodDescriptor md_content=MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.content_method_descriptor);
    MethodDescriptor md_lambda=MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.method_descriptor);
    if (!codeOnly) {
      InterpreterUtil.appendIndent(buffer,indent);
      buffer.append("public ");
      buffer.append(method_name);
      buffer.append("(");
      boolean firstParameter=true;
      int index=lambdaNode.lambda_information.is_content_method_static ? 0 : 1;
      int start_index=md_content.params.length - md_lambda.params.length;
      for (int i=0; i < md_content.params.length; i++) {
        if (i >= start_index) {
          if (!firstParameter) {
            buffer.append(", ");
          }
          String typeName=ExprProcessor.getCastTypeName(md_content.params[i].copy());
          if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
            typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
          }
          buffer.append(typeName);
          buffer.append(" ");
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPaar(index,0));
          buffer.append(parameterName == null ? "param" + index : parameterName);
          firstParameter=false;
        }
        index+=md_content.params[i].stack_size;
      }
      buffer.append(") {");
      buffer.append(DecompilerContext.getNewLineSeparator());
      indent+=1;
    }
    if (!methodWrapper.decompiledWithErrors) {
      RootStatement root=classWrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null) {
        try {
          buffer.append(root.toJava(indent,tracer));
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " "+ mt.getDescriptor()+ " couldn't be written.",ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
    }
    if (methodWrapper.decompiledWithErrors) {
      InterpreterUtil.appendIndent(buffer,indent);
      buffer.append("// $FF: Couldn't be decompiled");
      buffer.append(DecompilerContext.getNewLineSeparator());
    }
    if (!codeOnly) {
      indent-=1;
      InterpreterUtil.appendIndent(buffer,indent);
      buffer.append('}');
      buffer.append(DecompilerContext.getNewLineSeparator());
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
}
