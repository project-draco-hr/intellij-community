{
  if (myEditor.getCaretModel().supportsMultipleCarets()) {
    boolean virtualSpaceIsEnabled=myEditor.getSettings().isVirtualSpace();
    int startLine=Math.max(Math.min(blockStart.line,myEditor.getDocument().getLineCount() - 1),0);
    int endLine=Math.max(Math.min(blockEnd.line,myEditor.getDocument().getLineCount() - 1),0);
    int step=endLine < startLine ? -1 : 1;
    int count=1 + Math.abs(endLine - startLine);
    List<LogicalPosition> positions=new LinkedList<LogicalPosition>();
    List<TextRange> selections=new LinkedList<TextRange>();
    boolean hasSelection=false;
    for (int line=startLine, i=0; i < count; i++, line+=step) {
      int startColumn=blockStart.column;
      int endColumn=blockEnd.column;
      LogicalPosition startPos=new LogicalPosition(line,virtualSpaceIsEnabled ? startColumn : truncateColumnToLineWidth(line,startColumn));
      LogicalPosition endPos=new LogicalPosition(line,virtualSpaceIsEnabled ? endColumn : truncateColumnToLineWidth(line,endColumn));
      int startOffset=myEditor.logicalPositionToOffset(startPos);
      int endOffset=myEditor.logicalPositionToOffset(endPos);
      positions.add(endPos);
      selections.add(new TextRange(Math.min(startOffset,endOffset),Math.max(startOffset,endOffset)));
      hasSelection|=(startOffset != endOffset);
    }
    if (hasSelection) {
      Iterator<LogicalPosition> positionIterator=positions.iterator();
      Iterator<TextRange> selectionIterator=selections.iterator();
      while (selectionIterator.hasNext()) {
        TextRange selection=selectionIterator.next();
        positionIterator.next();
        if (selection.isEmpty()) {
          selectionIterator.remove();
          positionIterator.remove();
        }
      }
    }
    myEditor.getCaretModel().setCarets(positions,selections);
  }
 else {
    removeSelection();
    int oldStartLine=0;
    int oldEndLine=0;
    if (hasBlockSelection()) {
      oldStartLine=myBlockStart.line;
      oldEndLine=myBlockEnd.line;
      if (oldStartLine > oldEndLine) {
        int t=oldStartLine;
        oldStartLine=oldEndLine;
        oldEndLine=t;
      }
    }
    int newStartLine=blockStart.line;
    int newEndLine=blockEnd.line;
    if (newStartLine > newEndLine) {
      int t=newStartLine;
      newStartLine=newEndLine;
      newEndLine=t;
    }
    myEditor.repaintLines(Math.min(oldStartLine,newStartLine),Math.max(newEndLine,oldEndLine));
    final int[] oldStarts=getBlockSelectionStarts();
    final int[] oldEnds=getBlockSelectionEnds();
    myBlockStart=blockStart;
    myBlockEnd=blockEnd;
    recalculateBlockOffsets();
    final int[] newStarts=getBlockSelectionStarts();
    final int[] newEnds=getBlockSelectionEnds();
    broadcastSelectionEvent(new SelectionEvent(myEditor,oldStarts,oldEnds,newStarts,newEnds));
  }
}
