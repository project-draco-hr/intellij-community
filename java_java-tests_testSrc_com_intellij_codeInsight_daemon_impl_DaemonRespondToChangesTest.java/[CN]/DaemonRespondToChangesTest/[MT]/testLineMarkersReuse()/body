{
  configureByFile(BASE_PATH + "LineMarkerChange.java");
  List<HighlightInfo> errors=highlightErrors();
  assertEmpty(errors);
  List<LineMarkerInfo> lineMarkers=DaemonCodeAnalyzerImpl.getLineMarkers(myEditor.getDocument(),getProject());
  assertSize(5,lineMarkers);
  type('X');
  final Collection<String> changed=new ArrayList<>();
  MarkupModelEx modelEx=(MarkupModelEx)DocumentMarkupModel.forDocument(getDocument(getFile()),getProject(),true);
  modelEx.addMarkupModelListener(getTestRootDisposable(),new MarkupModelListener(){
    @Override public void afterAdded(    @NotNull RangeHighlighterEx highlighter){
      changed(highlighter,ExceptionUtil.getThrowableText(new Throwable("after added")));
    }
    @Override public void beforeRemoved(    @NotNull RangeHighlighterEx highlighter){
      changed(highlighter,ExceptionUtil.getThrowableText(new Throwable("before removed")));
    }
    @Override public void attributesChanged(    @NotNull RangeHighlighterEx highlighter,    boolean renderersChanged){
      changed(highlighter,ExceptionUtil.getThrowableText(new Throwable("changed")));
    }
    private void changed(    @NotNull RangeHighlighterEx highlighter,    String reason){
      String text=highlighter.getDocument().getText().substring(highlighter.getStartOffset(),highlighter.getEndOffset());
      if (text.equals("X"))       return;
      changed.add(highlighter + ": \n" + reason);
    }
  }
);
  PsiDocumentManager.getInstance(getProject()).commitAllDocuments();
  CodeInsightTestFixtureImpl.instantiateAndRun(myFile,myEditor,new int[]{Pass.UPDATE_ALL,Pass.LOCAL_INSPECTIONS},false);
  assertEmpty(changed);
  List<LineMarkerInfo> lineMarkersAfter=DaemonCodeAnalyzerImpl.getLineMarkers(myEditor.getDocument(),getProject());
  assertEquals(lineMarkersAfter.size(),lineMarkers.size());
}
