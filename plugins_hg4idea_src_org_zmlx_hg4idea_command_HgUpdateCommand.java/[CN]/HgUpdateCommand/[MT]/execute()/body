{
  List<String> arguments=new LinkedList<String>();
  if (clean) {
    arguments.add("--clean");
  }
  if (!StringUtil.isEmptyOrSpaces(revision)) {
    arguments.add("--rev");
    arguments.add(revision);
  }
 else   if (!StringUtil.isEmptyOrSpaces(branch)) {
    arguments.add(branch);
  }
  final HgCommandExecutor executor=new HgCommandExecutor(project);
  executor.setShowOutput(true);
  HgCommandResult result=executor.executeInCurrentThread(repo,"update",arguments,new HgDeleteModifyPromptHandler());
  if (detectLocalChangeConflict(result)) {
    final AtomicInteger exitCode=new AtomicInteger();
    UIUtil.invokeAndWaitIfNeeded(new Runnable(){
      @Override public void run(){
        exitCode.set(Messages.showOkCancelDialog(project,"Your uncommitted changes couldn't be merged into the requested changeset.\n" + "Would you like to perform Force Update and discard them?","Update Conflict","&Force Update","&Cancel",Messages.getWarningIcon()));
      }
    }
);
    if (exitCode.get() == Messages.YES) {
      arguments.add("-C");
      result=executor.executeInCurrentThread(repo,"update",arguments,new HgDeleteModifyPromptHandler());
    }
  }
  project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project,null);
  VfsUtil.markDirtyAndRefresh(true,true,false,repo);
  return result;
}
