{
  long primaryId=in.readInt();
  int sign=primaryId > 0 ? 1 : -1;
  primaryId=Math.abs(primaryId);
  int secondaryId=DataInputOutputUtil.readINT(in);
  long equationId=sign * (primaryId * BytecodeAnalysisConverter.SHIFT + secondaryId);
  boolean isFinal=in.readBoolean();
  if (isFinal) {
    int ordinal=DataInputOutputUtil.readINT(in);
    Value value=Value.values()[ordinal];
    return new IdEquation(equationId,new IdFinal(value));
  }
 else {
    int sumLength=DataInputOutputUtil.readINT(in);
    IntIdComponent[] components=new IntIdComponent[sumLength];
    for (int i=0; i < sumLength; i++) {
      int ordinal=DataInputOutputUtil.readINT(in);
      Value value=Value.values()[ordinal];
      int componentSize=DataInputOutputUtil.readINT(in);
      long[] ids=new long[componentSize];
      for (int j=0; j < componentSize; j++) {
        primaryId=in.readInt();
        sign=primaryId > 0 ? 1 : -1;
        primaryId=Math.abs(primaryId);
        secondaryId=DataInputOutputUtil.readINT(in);
        long id=sign * (primaryId * BytecodeAnalysisConverter.SHIFT + secondaryId);
        ids[j]=id;
      }
      components[i]=new IntIdComponent(value,ids);
    }
    return new IdEquation(equationId,new IdPending(components));
  }
}
