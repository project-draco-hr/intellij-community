{
  boolean stable=in.readBoolean();
  int size=DataInputOutputUtil.readINT(in);
  ArrayList<DirectionResultPair> results=new ArrayList<DirectionResultPair>(size);
  for (int k=0; k < size; k++) {
    int directionKey=DataInputOutputUtil.readINT(in);
    Direction direction=BytecodeAnalysisConverter.extractDirection(directionKey);
    if (direction == Direction.Pure) {
      Set<HEffectQuantum> effects=new HashSet<HEffectQuantum>();
      int effectsSize=DataInputOutputUtil.readINT(in);
      for (int i=0; i < effectsSize; i++) {
        int effectMask=DataInputOutputUtil.readINT(in);
        if (effectMask == -1) {
          effects.add(HEffectQuantum.TopEffectQuantum);
        }
 else         if (effectMask == -2) {
          effects.add(HEffectQuantum.ThisChangeQuantum);
        }
 else         if (effectMask == -3) {
          byte[] bytes=new byte[BytecodeAnalysisConverter.HASH_SIZE];
          in.readFully(bytes);
          int rawDirKey=DataInputOutputUtil.readINT(in);
          boolean isStable=in.readBoolean();
          HKey key=new HKey(bytes,Math.abs(rawDirKey),isStable,false);
          boolean isStatic=in.readBoolean();
          int dataLength=DataInputOutputUtil.readINT(in);
          DataValue[] data=new DataValue[dataLength];
          for (int di=0; di < dataLength; di++) {
            int dataI=DataInputOutputUtil.readINT(in);
            if (dataI == -1) {
              data[di]=DataValue.ThisDataValue;
            }
 else             if (dataI == -2) {
              data[di]=DataValue.LocalDataValue;
            }
 else             if (dataI == -3) {
              data[di]=DataValue.OwnedDataValue;
            }
 else             if (dataI == -4) {
              data[di]=DataValue.UnknownDataValue1;
            }
 else             if (dataI == -5) {
              data[di]=DataValue.UnknownDataValue2;
            }
 else {
              data[di]=new DataValue.ParameterDataValue(dataI);
            }
          }
          effects.add(new HEffectQuantum.CallQuantum(key,data,isStatic));
        }
 else {
          effects.add(new HEffectQuantum.ParamChangeQuantum(effectMask));
        }
      }
      results.add(new DirectionResultPair(directionKey,new HEffects(effects)));
    }
 else {
      boolean isFinal=in.readBoolean();
      if (isFinal) {
        int ordinal=DataInputOutputUtil.readINT(in);
        Value value=Value.values()[ordinal];
        results.add(new DirectionResultPair(directionKey,new HFinal(value)));
      }
 else {
        int sumLength=DataInputOutputUtil.readINT(in);
        HComponent[] components=new HComponent[sumLength];
        for (int i=0; i < sumLength; i++) {
          int ordinal=DataInputOutputUtil.readINT(in);
          Value value=Value.values()[ordinal];
          int componentSize=DataInputOutputUtil.readINT(in);
          HKey[] ids=new HKey[componentSize];
          for (int j=0; j < componentSize; j++) {
            byte[] bytes=new byte[BytecodeAnalysisConverter.HASH_SIZE];
            in.readFully(bytes);
            int rawDirKey=DataInputOutputUtil.readINT(in);
            ids[j]=new HKey(bytes,Math.abs(rawDirKey),in.readBoolean(),rawDirKey < 0);
          }
          components[i]=new HComponent(value,ids);
        }
        results.add(new DirectionResultPair(directionKey,new HPending(components)));
      }
    }
  }
  return new HEquations(results,stable);
}
