{
  final GrParameter[] parameters=closure.getAllParameters();
  GrCall call=findCall(closure);
  if (call == null)   return Collections.emptyList();
  GroovyResolveResult resolveResult=call.advancedResolve();
  PsiElement element=resolveResult.getElement();
  if (!(element instanceof PsiMethod)) {
    return Collections.emptyList();
  }
  while (element instanceof PsiMirrorElement) {
    element=((PsiMirrorElement)element).getPrototype();
  }
  List<Pair<PsiParameter,PsiType>> params=ResolveUtil.collectExpectedParamsByArg(closure,new GroovyResolveResult[]{resolveResult},call.getNamedArguments(),call.getExpressionArguments(),call.getClosureArguments(),closure);
  if (params.isEmpty())   return Collections.emptyList();
  Pair<PsiParameter,PsiType> pair=params.get(0);
  PsiParameter param=pair.getFirst();
  PsiModifierList modifierList=param.getModifierList();
  if (modifierList == null)   return Collections.emptyList();
  PsiAnnotation anno=modifierList.findAnnotation(GroovyCommonClassNames.GROOVY_TRANSFORM_STC_CLOSURE_PARAMS);
  if (anno == null)   return Collections.emptyList();
  PsiClass closureSignatureHint=GrAnnotationUtil.inferClassAttribute(anno,"value");
  if (closureSignatureHint == null)   return Collections.emptyList();
  String qnameOfClosureSignatureHint=closureSignatureHint.getQualifiedName();
  if (qnameOfClosureSignatureHint == null)   return Collections.emptyList();
  SignatureHintProcessor signatureHintProcessor=SignatureHintProcessor.getHintProcessor(qnameOfClosureSignatureHint);
  if (signatureHintProcessor == null)   return Collections.emptyList();
  List<PsiType[]> expectedSignatures=signatureHintProcessor.inferExpectedSignatures((PsiMethod)element,resolveResult.getSubstitutor(),SignatureHintProcessor.buildOptions(anno));
  return ContainerUtil.findAll(expectedSignatures,new Condition<PsiType[]>(){
    @Override public boolean value(    PsiType[] types){
      return types.length == parameters.length;
    }
  }
);
}
