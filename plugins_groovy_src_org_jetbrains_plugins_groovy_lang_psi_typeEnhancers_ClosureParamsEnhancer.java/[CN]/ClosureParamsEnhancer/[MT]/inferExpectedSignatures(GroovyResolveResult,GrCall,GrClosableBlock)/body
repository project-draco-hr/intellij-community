{
  PsiElement element=variant.getElement();
  while (element instanceof PsiMirrorElement)   element=((PsiMirrorElement)element).getPrototype();
  if (!(element instanceof PsiMethod))   return Collections.emptyList();
  List<Pair<PsiParameter,PsiType>> params=ResolveUtil.collectExpectedParamsByArg(closure,new GroovyResolveResult[]{variant},call.getNamedArguments(),call.getExpressionArguments(),call.getClosureArguments(),closure);
  if (params.isEmpty())   return Collections.emptyList();
  Pair<PsiParameter,PsiType> pair=params.get(0);
  PsiParameter param=pair.getFirst();
  PsiModifierList modifierList=param.getModifierList();
  if (modifierList == null)   return Collections.emptyList();
  PsiAnnotation anno=modifierList.findAnnotation(GroovyCommonClassNames.GROOVY_TRANSFORM_STC_CLOSURE_PARAMS);
  if (anno == null)   return Collections.emptyList();
  PsiClass closureSignatureHint=GrAnnotationUtil.inferClassAttribute(anno,"value");
  if (closureSignatureHint == null)   return Collections.emptyList();
  String qnameOfClosureSignatureHint=closureSignatureHint.getQualifiedName();
  if (qnameOfClosureSignatureHint == null)   return Collections.emptyList();
  SignatureHintProcessor signatureHintProcessor=SignatureHintProcessor.getHintProcessor(qnameOfClosureSignatureHint);
  if (signatureHintProcessor == null)   return Collections.emptyList();
  return signatureHintProcessor.inferExpectedSignatures((PsiMethod)element,variant.getSubstitutor(),SignatureHintProcessor.buildOptions(anno));
}
