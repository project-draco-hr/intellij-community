{
  final CountDownLatch started=new CountDownLatch(myMaxTasks);
  final CountDownLatch readyToFinish=new CountDownLatch(1);
  final StringBuffer log=new StringBuffer("waitAllTasksExecuted: " + this + "\n");
  List<Future> futures=ContainerUtil.map(Collections.nCopies(myMaxTasks,null),new Function<Object,Future>(){
    @Override public Future fun(    Object o){
      log.append("Submit task");
      return submit(new Runnable(){
        @Override public void run(){
          try {
            started.countDown();
            log.append("Task run. started=" + started);
            readyToFinish.await();
            log.append("Task finished.");
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
  }
);
  try {
    if (!started.await(timeout,unit)) {
      throw new RuntimeException("Interrupted by timeout. " + this + "\nLog: "+ log+ "\n"+ "; Thread dump:\n"+ ThreadDumper.dumpThreadsToString());
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
 finally {
    readyToFinish.countDown();
  }
  for (  Future future : futures) {
    future.get();
  }
}
