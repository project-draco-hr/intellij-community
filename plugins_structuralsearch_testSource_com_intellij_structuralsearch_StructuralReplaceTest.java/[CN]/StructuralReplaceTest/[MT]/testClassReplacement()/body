{
  boolean formatAccordingToStyle=options.isToReformatAccordingToStyle();
  options.setToReformatAccordingToStyle(true);
  String s1="class A { public void b() {} }";
  String s2="class 'a { 'Other* }";
  String s3="class $a$New { Logger LOG; $Other$ }";
  String expectedResult="    class ANew {\n" + "        Logger LOG;\n\n" + "        public void b() {\n"+ "        }\n"+ "    }";
  String actualResult;
  actualResult=replacer.testReplace(s1,s2,s3,options);
  assertEquals("Basic class replacement",expectedResult,actualResult);
  String s4="class A { class C {} public void b() {} int f; }";
  String s5="class 'a { 'Other* }";
  String s6="class $a$ { Logger LOG; $Other$ }";
  String expectedResult2="    class A {\n" + "        Logger LOG;\n\n" + "        class C {\n"+ "        }\n\n"+ "        public void b() {\n"+ "        }\n\n"+ "        int f;\n"+ "    }";
  actualResult=replacer.testReplace(s4,s5,s6,options);
  assertEquals("Order of members in class replacement",expectedResult2,actualResult);
  String s7="class A extends B { int c; void b() {} { a = 1; } }";
  String s8="class 'A extends B { 'Other* }";
  String s9="class $A$ extends B2 { $Other$ }";
  String expectedResult3="    class A extends B2 {\n" + "        int c;\n\n" + "        void b() {\n"+ "        }\n\n"+ "        {\n"+ "            a = 1;\n"+ "        }\n"+ "    }";
  actualResult=replacer.testReplace(s7,s8,s9,options);
  assertEquals("Unsupported pattern exception",actualResult,expectedResult3);
  options.setToReformatAccordingToStyle(formatAccordingToStyle);
  String s10="/** @example */\n" + "class A {\n" + "  class C {}\n"+ "  public void b() {}\n"+ "  int f;\n"+ "}";
  String s11="class 'a { 'Other* }";
  String s12="public class $a$ {\n" + "  $Other$\n" + "}";
  String expectedResult4="/** @example */\n" + "    public class A {\n" + "      class C {}\n"+ "    public void b() {}\n"+ "    int f;\n"+ "    }";
  actualResult=replacer.testReplace(s10,s11,s12,options);
  assertEquals("Make class public",actualResult,expectedResult4);
  String s13="class CustomThread extends Thread {\n" + "public CustomThread(InputStream in, OutputStream out, boolean closeOutOnExit) {\n" + "    super(CustomThreadGroup.getThreadGroup(), \"CustomThread\");\n"+ "    setDaemon(true);\n"+ "    if (in instanceof BufferedInputStream) {\n"+ "        bis = (BufferedInputStream)in;\n"+ "    } else {\n"+ "    bis = new BufferedInputStream(in);\n"+ "    }\n"+ "    this.out = out;\n"+ "    this.closeOutOnExit = closeOutOnExit;\n"+ "}\n"+ "}";
  String s14="class 'Class extends Thread {\n" + "  'Class('ParameterType* 'ParameterName*) {\n" + "\t  super (CustomThreadGroup.getThreadGroup(), 'superarg* );\n"+ "    'Statement*;\n"+ "  }\n"+ "}";
  String s15="class $Class$ extends CustomThread {\n" + "  $Class$($ParameterType$ $ParameterName$) {\n" + "\t  super($superarg$);\n"+ "    $Statement$;\n"+ "  }\n"+ "}";
  String expectedResult5="    class CustomThread extends CustomThread {\n" + "    CustomThread(InputStream in,OutputStream out,boolean closeOutOnExit ) {\n" + "      super(\"CustomThread\");\n"+ "    setDaemon(true);\n"+ "    if (in instanceof BufferedInputStream) {\n"+ "        bis = (BufferedInputStream)in;\n"+ "    } else {\n"+ "    bis = new BufferedInputStream(in);\n"+ "    }\n"+ "    this.out = out;\n"+ "    this.closeOutOnExit = closeOutOnExit;\n"+ "    }\n"+ "    }";
  actualResult=replacer.testReplace(s13,s14,s15,options);
  assertEquals("Constructor replacement",expectedResult5,actualResult);
  String s16="public class A {}\n" + "final class B {}";
  String s17="class 'A { 'Other* }";
  String s17_2="class 'A { private Log log = LogFactory.createLog(); 'Other* }";
  String s18="class $A$ { private Log log = LogFactory.createLog(); $Other$ }";
  String s18_2="class $A$ { $Other$ }";
  actualResult=replacer.testReplace(s16,s17,s18,options);
  String expectedResult6="public class A { private Log log = LogFactory.createLog();  }\n" + "final class B { private Log log = LogFactory.createLog();  }";
  assertEquals("Modifier list for class",expectedResult6,actualResult);
  actualResult=replacer.testReplace(actualResult,s17_2,s18_2,options);
  String expectedResult7="public class A {  }\n" + "final class B {  }";
  assertEquals("Removing field",expectedResult7,actualResult);
  String s19="public class A extends Object implements Cloneable {}\n";
  String s20="class 'A { 'Other* }";
  String s21="class $A$ { private Log log = LogFactory.createLog(); $Other$ }";
  actualResult=replacer.testReplace(s19,s20,s21,options);
  String expectedResult8="public class A extends Object implements Cloneable { private Log log = LogFactory.createLog();  }\n";
  assertEquals("Extends / implements list for class",expectedResult8,actualResult);
  String s22="public class A<T> { int A; }\n";
  String s23="class 'A { 'Other* }";
  String s24="class $A$ { private Log log = LogFactory.createLog(); $Other$ }";
  actualResult=replacer.testReplace(s22,s23,s24,options);
  String expectedResult9="public class A<T> { private Log log = LogFactory.createLog(); int A; }\n";
  assertEquals("Type parameters for the class",expectedResult9,actualResult);
  String s25="class A {\n" + "  // comment before\n" + "  protected short a; //  comment after\n"+ "}";
  String s26="short a;";
  String s27="Object a;";
  String expectedResult10="class A {\n" + "    // comment before\n" + "    protected Object a;//  comment after\n"+ "}";
  actualResult=replacer.testReplace(s25,s26,s27,options);
  assertEquals("Replacing dcl with saving access modifiers",expectedResult10,actualResult);
  String s28="aaa";
  String s29="class 'Class {\n" + " 'Class('ParameterType 'ParameterName) {\n" + "    'Class('ParameterName);\n"+ "  }\n"+ "}";
  String s30="class $Class$ {\n" + "  $Class$($ParameterType$ $ParameterName$) {\n" + "     this($ParameterName$);\n"+ "  }\n"+ "}";
  String expectedResult11="aaa";
  actualResult=replacer.testReplace(s28,s29,s30,options);
  assertEquals("Complex class replacement",expectedResult11,actualResult);
  String s31="class A {\n" + "  int a; // comment\n" + "  char b;\n"+ "  int c; // comment2\n"+ "}";
  String s32="'Type 'Variable = 'Value?; //'Comment";
  String s33="/**$Comment$*/\n" + "$Type$ $Variable$ = $Value$;";
  String expectedResult12="class A {\n" + "    /** comment*/\n" + "    int a  ;\n"+ "    char b;\n"+ "    /** comment2*/\n"+ "    int c  ;\n"+ "}";
  actualResult=replacer.testReplace(s31,s32,s33,options);
  assertEquals("Replacing comments with javadoc for fields",expectedResult12,actualResult);
  String s34="/**\n" + " * This interface stores XXX\n" + " * <p/>\n"+ " */\n"+ "public interface X {\n"+ "    public static final String HEADER = Headers.HEADER;\n"+ "\n"+ "}";
  String s35="public interface 'MessageInterface {\n" + "    public static final String 'X = 'VALUE;\n" + "    'blah*"+ "}";
  String s36="public interface $MessageInterface$ {\n" + "    public static final String HEADER = $VALUE$;\n" + "    $blah$\n"+ "}";
  String expectedResult13="/**\n" + " * This interface stores XXX\n" + " * <p/>\n"+ " */\n"+ "public interface X {\n"+ "    public static final String HEADER = Headers.HEADER;\n"+ "\n"+ "}";
  actualResult=replacer.testReplace(s34,s35,s36,options,true);
  assertEquals("Replacing interface with interface, saving comments properly",expectedResult13,actualResult);
  String s37="class A { void B() {} int C(char ch) { int z = 1; } }";
  String s38="class 'A { 'T* 'M*('PT* 'PN*) { 'S*; } 'O* }";
  String s39="class $A$ { $T$ $M$($PT$ $PN$) { System.out.println(\"$M$\"); $S$; } $O$ }";
  String expectedResult14="class A { void B () { System.out.println(\"B\");} int C(char ch) { System.out.println(\"C\"); int z = 1; } }";
  if (!IdeaTestUtil.bombExplodes(2005,Calendar.SEPTEMBER,20,12,0,"-maxim.mossienko","Fix class replacements with multiple members"))   return;
  actualResult=replacer.testReplace(s37,s38,s39,options,true);
  assertEquals("Multiple methods replacement",expectedResult14,actualResult);
}
