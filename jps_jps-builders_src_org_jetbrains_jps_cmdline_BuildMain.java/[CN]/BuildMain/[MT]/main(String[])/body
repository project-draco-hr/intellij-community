{
  System.out.println("Build process started. Classpath: " + System.getProperty("java.class.path"));
  final String host=args[0];
  final int port=Integer.parseInt(args[1]);
  final UUID sessionId=UUID.fromString(args[2]);
  @SuppressWarnings("ConstantConditions") final File systemDir=new File(FileUtil.toCanonicalPath(args[3]));
  Utils.setSystemRoot(systemDir);
  ourEventLoopGroup=new NioEventLoopGroup(1,SharedThreadPool.getInstance());
  final Bootstrap bootstrap=new Bootstrap().group(ourEventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer(){
    @Override protected void initChannel(    Channel channel) throws Exception {
      channel.pipeline().addLast(new ProtobufVarint32FrameDecoder(),new ProtobufDecoder(CmdlineRemoteProto.Message.getDefaultInstance()),new ProtobufVarint32LengthFieldPrepender(),new ProtobufEncoder(),new MyMessageHandler(sessionId));
    }
  }
).option(ChannelOption.TCP_NODELAY,true).option(ChannelOption.SO_KEEPALIVE,true);
  final ChannelFuture future=bootstrap.connect(new InetSocketAddress(host,port)).awaitUninterruptibly();
  final boolean success=future.isSuccess();
  if (success) {
    future.channel().writeAndFlush(CmdlineProtoUtil.toMessage(sessionId,CmdlineProtoUtil.createParamRequest()));
  }
 else {
    @SuppressWarnings("ThrowableResultOfMethodCallIgnored") final Throwable reason=future.cause();
    System.err.println("Error connecting to " + host + ":"+ port+ "; reason: "+ (reason != null ? reason.getMessage() : "unknown"));
    if (reason != null) {
      reason.printStackTrace(System.err);
    }
    System.err.println("Exiting.");
    System.exit(-1);
  }
}
