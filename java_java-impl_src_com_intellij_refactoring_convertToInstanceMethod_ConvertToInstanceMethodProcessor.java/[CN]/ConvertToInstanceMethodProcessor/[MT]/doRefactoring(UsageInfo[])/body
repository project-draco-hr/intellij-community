{
  myTypeParameterReplacements=buildTypeParameterReplacements();
  List<PsiClass> inheritors=new ArrayList<PsiClass>();
  CommonRefactoringUtil.sortDepthFirstRightLeftOrder(usages);
  for (  final UsageInfo usage : usages) {
    if (usage instanceof MethodCallUsageInfo) {
      processMethodCall((MethodCallUsageInfo)usage);
    }
 else     if (usage instanceof ParameterUsageInfo) {
      processParameterUsage((ParameterUsageInfo)usage);
    }
 else     if (usage instanceof ImplementingClassUsageInfo) {
      inheritors.add(((ImplementingClassUsageInfo)usage).getPsiClass());
    }
  }
  prepareTypeParameterReplacement();
  myTargetParameter.delete();
  ChangeContextUtil.encodeContextInfo(myMethod,true);
  if (!myTargetClass.isInterface()) {
    PsiMethod method=addMethodToClass(myTargetClass);
    fixVisibility(method,usages);
    EditorHelper.openInEditor(method);
  }
 else {
    final PsiMethod interfaceMethod=addMethodToClass(myTargetClass);
    final PsiModifierList modifierList=interfaceMethod.getModifierList();
    final boolean markAsDefault=PsiUtil.isLanguageLevel8OrHigher(myTargetClass);
    if (markAsDefault) {
      modifierList.setModifierProperty(PsiModifier.DEFAULT,true);
    }
    RefactoringUtil.makeMethodAbstract(myTargetClass,interfaceMethod);
    EditorHelper.openInEditor(interfaceMethod);
    if (!markAsDefault) {
      for (      final PsiClass psiClass : inheritors) {
        final PsiMethod newMethod=addMethodToClass(psiClass);
        PsiUtil.setModifierProperty(newMethod,myNewVisibility != null && !myNewVisibility.equals(VisibilityUtil.ESCALATE_VISIBILITY) ? myNewVisibility : PsiModifier.PUBLIC,true);
      }
    }
  }
  myMethod.delete();
}
