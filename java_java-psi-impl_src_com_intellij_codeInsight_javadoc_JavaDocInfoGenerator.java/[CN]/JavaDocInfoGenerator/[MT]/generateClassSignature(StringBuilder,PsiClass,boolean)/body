{
  generateAnnotations(buffer,aClass,generateLink,true,false);
  String modifiers=PsiFormatUtil.formatModifiers(aClass,PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);
  if (!modifiers.isEmpty()) {
    buffer.append(modifiers);
    buffer.append(" ");
  }
  buffer.append(aClass.isInterface() ? LangBundle.message("java.terms.interface") : LangBundle.message("java.terms.class"));
  buffer.append(" ");
  String refText=JavaDocUtil.getReferenceText(aClass.getProject(),aClass);
  if (refText == null) {
    buffer.setLength(0);
    return true;
  }
  String labelText=JavaDocUtil.getLabelText(aClass.getProject(),aClass.getManager(),refText,aClass);
  buffer.append("<b>");
  buffer.append(labelText);
  buffer.append("</b>");
  buffer.append(generateTypeParameters(aClass,false));
  buffer.append("\n");
  PsiClassType[] refs=aClass.getExtendsListTypes();
  String qName=aClass.getQualifiedName();
  if (refs.length > 0 || !aClass.isInterface() && (qName == null || !qName.equals(CommonClassNames.JAVA_LANG_OBJECT))) {
    buffer.append("extends ");
    if (refs.length == 0) {
      generateLink(buffer,CommonClassNames.JAVA_LANG_OBJECT,null,aClass,false);
    }
 else {
      for (int i=0; i < refs.length; i++) {
        generateType(buffer,refs[i],aClass,generateLink);
        if (i < refs.length - 1) {
          buffer.append(",&nbsp;");
        }
      }
    }
    buffer.append("\n");
  }
  refs=aClass.getImplementsListTypes();
  if (refs.length > 0) {
    buffer.append("implements ");
    for (int i=0; i < refs.length; i++) {
      generateType(buffer,refs[i],aClass,generateLink);
      if (i < refs.length - 1) {
        buffer.append(",&nbsp;");
      }
    }
    buffer.append("\n");
  }
  if (buffer.charAt(buffer.length() - 1) == '\n') {
    buffer.setLength(buffer.length() - 1);
  }
  return false;
}
