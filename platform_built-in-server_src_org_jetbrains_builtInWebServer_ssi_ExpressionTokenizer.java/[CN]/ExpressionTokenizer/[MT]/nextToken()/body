{
  while (index < length && Character.isWhitespace(expr[index])) {
    index++;
  }
  tokenVal=null;
  if (index == length)   return TOKEN_END;
  int start=index;
  char currentChar=expr[index];
  char nextChar=(char)0;
  index++;
  if (index < length)   nextChar=expr[index];
switch (currentChar) {
case '(':
    return TOKEN_LBRACE;
case ')':
  return TOKEN_RBRACE;
case '=':
return TOKEN_EQ;
case '!':
if (nextChar == '=') {
index++;
return TOKEN_NOT_EQ;
}
return TOKEN_NOT;
case '|':
if (nextChar == '|') {
index++;
return TOKEN_OR;
}
break;
case '&':
if (nextChar == '&') {
index++;
return TOKEN_AND;
}
break;
case '>':
if (nextChar == '=') {
index++;
return TOKEN_GE;
}
return TOKEN_GT;
case '<':
if (nextChar == '=') {
index++;
return TOKEN_LE;
}
return TOKEN_LT;
default :
break;
}
int end=index;
if (currentChar == '"' || currentChar == '\'') {
char endChar=currentChar;
boolean escaped=false;
start++;
for (; index < length; index++) {
if (expr[index] == '\\' && !escaped) {
escaped=true;
continue;
}
if (expr[index] == endChar && !escaped) break;
escaped=false;
}
end=index;
index++;
}
 else if (currentChar == '/') {
char endChar=currentChar;
boolean escaped=false;
for (; index < length; index++) {
if (expr[index] == '\\' && !escaped) {
escaped=true;
continue;
}
if (expr[index] == endChar && !escaped) break;
escaped=false;
}
end=++index;
}
 else {
for (; index < length; index++) {
if (isMetaChar(expr[index])) break;
}
end=index;
}
this.tokenVal=new String(expr,start,end - start);
return TOKEN_STRING;
}
