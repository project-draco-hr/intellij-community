{
  if (expression instanceof PsiNewExpression) {
    final PsiAnonymousClass anonymousClass=((PsiNewExpression)expression).getAnonymousClass();
    if (anonymousClass != null) {
      if (AnonymousCanBeLambdaInspection.canBeConvertedToLambda(anonymousClass,true)) {
        return AnonymousCanBeLambdaInspection.replacePsiElementWithLambda(expression,true,true);
      }
    }
 else {
      final GuavaLambda lambda=GuavaLambda.findFor(evaluator.evaluateType(expression));
      if (lambda == null) {
        return expression;
      }
 else {
        final PsiExpression expressionWithMethodReference=addMethodReference(expression,lambda);
        if (insertTypeCase) {
          return adjustLambdaContainingExpression(expressionWithMethodReference,true,targetType,evaluator);
        }
 else {
          return expressionWithMethodReference;
        }
      }
    }
  }
  if (expression instanceof PsiMethodReferenceExpression) {
    final PsiExpression qualifier=((PsiMethodReferenceExpression)expression).getQualifierExpression();
    final PsiType evaluatedType=evaluator.evaluateType(qualifier);
    final GuavaLambda lambda=GuavaLambda.findJavaAnalogueFor(evaluatedType);
    if (lambda != null) {
      return adjustLambdaContainingExpression((PsiExpression)expression.replace(qualifier),insertTypeCase,targetType,evaluator);
    }
  }
  if (expression instanceof PsiFunctionalExpression) {
    if (insertTypeCase) {
      return JavaPsiFacade.getElementFactory(expression.getProject()).createExpressionFromText("((" + targetType.getCanonicalText() + ")"+ expression.getText()+ ")",expression);
    }
  }
 else   if (expression instanceof PsiMethodCallExpression || expression instanceof PsiReferenceExpression) {
    final GuavaLambda lambda=GuavaLambda.findFor(evaluator.evaluateType(expression));
    if (lambda != null) {
      expression=addMethodReference(expression,lambda);
      return adjustLambdaContainingExpression(expression,insertTypeCase,targetType,evaluator);
    }
  }
  return expression;
}
