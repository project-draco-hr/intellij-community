{
  try {
    new ZipFile(newerFile).close();
  }
 catch (  IOException e) {
    Runner.logger.error("Corrupted target file: " + newerFile);
    Runner.printStackTrace(e);
    throw new IOException("Corrupted target file: " + newerFile,e);
  }
  final Set<String> filesToProcess=new HashSet<String>(myFilesToCreate);
  filesToProcess.addAll(myFilesToUpdate);
  if (filesToProcess.isEmpty())   return;
  final ZipFile olderZip;
  try {
    olderZip=new ZipFile(olderFile);
  }
 catch (  IOException e) {
    Runner.logger.error("Corrupted source file: " + olderFile);
    Runner.printStackTrace(e);
    throw new IOException("Corrupted source file: " + olderFile,e);
  }
  try {
    processZipFile(newerFile,new Processor(){
      public void process(      ZipEntry newerEntry,      InputStream newerEntryIn) throws IOException {
        if (newerEntry.isDirectory())         return;
        String name=newerEntry.getName();
        if (!filesToProcess.contains(name))         return;
        try {
          patchOutput.putNextEntry(new ZipEntry(myPath + "/" + name));
          InputStream olderEntryIn=Utils.findEntryInputStream(olderZip,name);
          if (olderEntryIn == null) {
            Utils.copyStream(newerEntryIn,patchOutput);
          }
 else {
            writeDiff(olderEntryIn,newerEntryIn,patchOutput);
          }
          patchOutput.closeEntry();
        }
 catch (        IOException e) {
          Runner.logger.error("Error building patch for .zip entry " + name);
          Runner.printStackTrace(e);
          throw new IOException("Error building patch for .zip entry " + name,e);
        }
      }
    }
);
  }
  finally {
    olderZip.close();
  }
}
