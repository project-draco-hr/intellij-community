{
  while (!myDisposed) {
    boolean isEmpty;
synchronized (filesToResolve) {
      isEmpty=filesToResolve.isEmpty();
    }
    if (enableVetoes.get() > 0 || isEmpty) {
      try {
        waitForQueue();
      }
 catch (      InterruptedException e) {
        break;
      }
      continue;
    }
    upToDate=false;
    final CountDownLatch batchProcessedLatch=new CountDownLatch(1);
    ApplicationManager.getApplication().invokeLater(new Runnable(){
      @Override public void run(){
        final Set<VirtualFile> files=countFilesToResolve();
        Task.Backgroundable backgroundable=new Task.Backgroundable(myProject,"Resolving files...",true){
          @Override public void run(          @NotNull final ProgressIndicator indicator){
            if (ApplicationManager.getApplication().isDisposed())             return;
            try {
              processBatch(indicator,files);
            }
  finally {
              batchProcessedLatch.countDown();
            }
          }
        }
;
        if (files.size() > 1) {
          backgroundable.queue();
        }
 else {
          ProgressManager.getInstance().runProcessWithProgressAsynchronously(backgroundable,new MyProgress());
        }
      }
    }
,myProject.getDisposed());
    try {
      batchProcessedLatch.await();
    }
 catch (    InterruptedException e) {
      break;
    }
synchronized (filesToResolve) {
      upToDate=filesToResolve.isEmpty();
      log("upToDate = " + upToDate);
    }
    flushLog();
  }
}
