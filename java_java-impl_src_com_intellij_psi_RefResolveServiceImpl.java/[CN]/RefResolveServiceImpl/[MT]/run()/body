{
  while (!myDisposed) {
    boolean isEmpty;
synchronized (filesToResolve) {
      isEmpty=filesToResolve.isEmpty();
    }
    Future<?> process=resolveProcess;
    if (enableVetoes.get() > 0 || isEmpty || process != null && !process.isDone()) {
      try {
        waitForQueue();
      }
 catch (      InterruptedException e) {
        break;
      }
      continue;
    }
    final Set<VirtualFile> files=countFilesToResolve();
    if (files.isEmpty())     continue;
    upToDate=false;
    myApplication.invokeLater(new Runnable(){
      @Override public void run(){
        if (resolveProcess != null && !resolveProcess.isDone())         return;
        log("Started to resolve " + files.size() + " files");
        Task.Backgroundable backgroundable=new Task.Backgroundable(myProject,"Resolving files...",true){
          @Override public void run(          @NotNull final ProgressIndicator indicator){
            if (!myApplication.isDisposed()) {
              processBatch(indicator,files);
            }
          }
        }
;
        if (files.size() > 1) {
          resolveProcess=ProgressManagerImpl.runProcessWithProgressAsynchronously(backgroundable);
        }
 else {
          resolveProcess=ProgressManagerImpl.runProcessWithProgressAsynchronously(backgroundable,new MyProgress(),null);
        }
      }
    }
,myProject.getDisposed());
    flushLog();
  }
}
