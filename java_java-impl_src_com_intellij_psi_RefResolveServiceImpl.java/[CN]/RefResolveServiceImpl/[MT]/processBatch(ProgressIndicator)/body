{
  Set<VirtualFile> set;
  int queuedSize;
synchronized (filesToResolve) {
    queuedSize=filesToResolve.size();
    set=new THashSet<VirtualFile>(queuedSize);
    for (    VirtualFile file : filesToResolve) {
      if (fileIsInQueue.clear(getAbsId(file))) {
        set.add(file);
      }
    }
    filesToResolve.clear();
  }
  final Set<VirtualFile> toProcess=Collections.synchronizedSet(set);
  final ConcurrentIntObjectMap<int[]> fileToForwardIds=new StripedLockIntObjectConcurrentHashMap<int[]>();
  final int size=countAndMarkUnresolved(set);
  if (size == 0)   return;
  log("Started to resolve " + size + " files (was queued "+ queuedSize+ ")");
  indicator.setIndeterminate(false);
  ProgressIndicatorUtils.forceWriteActionPriority(indicator,(Disposable)indicator);
  long start=System.currentTimeMillis();
  Processor<VirtualFile> processor=new Processor<VirtualFile>(){
    @Override public boolean process(    VirtualFile file){
      double fraction=1 - toProcess.size() * 1.0 / size;
      indicator.setFraction(fraction);
      try {
        VfsUtilCore.visitChildrenRecursively(file,new VirtualFileVisitor(){
          @Override public boolean visitFile(          @NotNull VirtualFile file){
            if (!toResolve(file,myProject)) {
              return true;
            }
            int fileId=getAbsId(file);
            int i=size - toProcess.size();
            indicator.setText(i + "/" + size+ ": Resolving "+ file.getPresentableUrl());
            int[] forwardIds=processFile(file,fileId,indicator);
            if (forwardIds == null) {
              return false;
            }
            toProcess.remove(file);
            fileToForwardIds.put(fileId,forwardIds);
            return true;
          }
          @Nullable @Override public Iterable<VirtualFile> getChildrenIterable(          @NotNull VirtualFile file){
            return ((NewVirtualFile)file).iterInDbChildren();
          }
        }
,RuntimeException.class);
      }
 catch (      RuntimeException e) {
        indicator.checkCanceled();
      }
      return true;
    }
  }
;
  boolean success=true;
  try {
    success=JobLauncher.getInstance().invokeConcurrentlyUnderProgress(new ArrayList<VirtualFile>(set),indicator,false,false,processor);
  }
  finally {
    queue(toProcess,"re-added after fail. success=" + success);
    storeIds(fileToForwardIds);
    long end=System.currentTimeMillis();
    log("Resolved batch of " + (size - toProcess.size()) + " from "+ size+ " files in "+ ((end - start) / 1000)+ "sec. (Gap: "+ storage.gap+ ")");
  }
}
