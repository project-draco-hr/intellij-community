{
  DfaValue[] argValues=popCallArguments(instruction,runner,memState);
  final DfaValue qualifier=popQualifier(instruction,runner,memState);
  List<DfaMemoryState> currentStates=ContainerUtil.newArrayList(memState);
  Set<DfaMemoryState> finalStates=ContainerUtil.newLinkedHashSet();
  if (argValues != null) {
    for (    MethodContract contract : instruction.getContracts()) {
      currentStates=addContractResults(argValues,contract,currentStates,instruction,runner.getFactory(),finalStates);
    }
  }
  for (  DfaMemoryState state : currentStates) {
    state.push(getMethodResultValue(instruction,qualifier,runner.getFactory()));
    finalStates.add(state);
  }
  return ContainerUtil.map2Array(finalStates,DfaInstructionState.class,new Function<DfaMemoryState,DfaInstructionState>(){
    @Override public DfaInstructionState fun(    DfaMemoryState state){
      if (instruction.shouldFlushFields()) {
        state.flushFields();
      }
      return new DfaInstructionState(runner.getInstruction(instruction.getIndex() + 1),state);
    }
  }
);
}
