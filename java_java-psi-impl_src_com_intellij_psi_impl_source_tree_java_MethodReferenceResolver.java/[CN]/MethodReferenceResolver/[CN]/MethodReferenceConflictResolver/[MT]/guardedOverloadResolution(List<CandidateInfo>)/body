{
  if (mySignature == null)   return null;
  if (conflicts.isEmpty())   return null;
  if (conflicts.size() == 1)   return conflicts.get(0);
  checkSameSignatures(conflicts);
  if (conflicts.size() == 1)   return conflicts.get(0);
  checkAccessStaticLevels(conflicts,true);
  if (conflicts.size() == 1)   return conflicts.get(0);
  final PsiType[] argTypes=mySignature.getParameterTypes();
  boolean hasReceiver=PsiMethodReferenceUtil.isSecondSearchPossible(argTypes,myQualifierResolveResult,myReferenceExpression);
  final List<CandidateInfo> firstCandidates=new ArrayList<CandidateInfo>();
  final List<CandidateInfo> secondCandidates=new ArrayList<CandidateInfo>();
  for (  CandidateInfo conflict : conflicts) {
    if (!(conflict instanceof MethodCandidateInfo))     continue;
    final Boolean applicableByFirstSearch=isApplicableByFirstSearch(conflict,argTypes,hasReceiver,myReferenceExpression,myFunctionalMethodVarArgs);
    if (applicableByFirstSearch != null) {
      (applicableByFirstSearch ? firstCandidates : secondCandidates).add(conflict);
    }
  }
  if (myQualifierResolveResult.isReferenceTypeQualified() && myReferenceExpression.getReferenceNameElement() instanceof PsiIdentifier) {
    CandidateInfo candidateInfo=filterStaticCorrectCandidates(firstCandidates,secondCandidates,true);
    if (candidateInfo != null) {
      return candidateInfo;
    }
    candidateInfo=filterStaticCorrectCandidates(secondCandidates,firstCandidates,false);
    if (candidateInfo != null) {
      return candidateInfo;
    }
  }
  if (resolveConflicts(firstCandidates,secondCandidates,MethodCandidateInfo.ApplicabilityLevel.FIXED_ARITY)) {
    return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);
  }
  if (resolveConflicts(firstCandidates,secondCandidates,MethodCandidateInfo.ApplicabilityLevel.VARARGS)) {
    return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);
  }
  if (firstCandidates.isEmpty() && secondCandidates.isEmpty()) {
    return null;
  }
  conflicts.clear();
  firstCandidates.addAll(secondCandidates);
  conflicts.addAll(firstCandidates);
  return null;
}
