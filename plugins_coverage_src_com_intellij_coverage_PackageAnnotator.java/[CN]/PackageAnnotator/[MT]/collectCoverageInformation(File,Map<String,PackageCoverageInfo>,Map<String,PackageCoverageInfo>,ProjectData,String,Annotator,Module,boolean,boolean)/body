{
  final List<DirCoverageInfo> dirs=new ArrayList<DirCoverageInfo>();
  final ContentEntry[] contentEntries=ModuleRootManager.getInstance(module).getContentEntries();
  for (  ContentEntry contentEntry : contentEntries) {
    for (    SourceFolder folder : contentEntry.getSourceFolders(isTestHierarchy ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE)) {
      final VirtualFile file=folder.getFile();
      if (file == null)       continue;
      final String prefix=folder.getPackagePrefix().replaceAll("\\.","/");
      final VirtualFile relativeSrcRoot=file.findFileByRelativePath(StringUtil.trimStart(packageVMName,prefix));
      dirs.add(new DirCoverageInfo(relativeSrcRoot));
    }
  }
  final PackageCoverageInfo classWithoutSourceCoverageInfo=new PackageCoverageInfo();
  final File[] children=packageOutputRoot.listFiles();
  if (children == null)   return null;
  Map<String,ClassCoverageInfo> toplevelClassCoverage=new HashMap<String,ClassCoverageInfo>();
  for (  File child : children) {
    if (child.isDirectory()) {
      final String childName=child.getName();
      final String childPackageVMName=packageVMName.length() > 0 ? packageVMName + "/" + childName : childName;
      final DirCoverageInfo[] childCoverageInfo=collectCoverageInformation(child,packageCoverageMap,flattenPackageCoverageMap,projectInfo,childPackageVMName,annotator,module,trackTestFolders,isTestHierarchy);
      if (childCoverageInfo != null) {
        for (int i=0; i < childCoverageInfo.length; i++) {
          DirCoverageInfo coverageInfo=childCoverageInfo[i];
          final DirCoverageInfo parentDir=dirs.get(i);
          parentDir.totalClassCount+=coverageInfo.totalClassCount;
          parentDir.coveredClassCount+=coverageInfo.coveredClassCount;
          parentDir.totalLineCount+=coverageInfo.totalLineCount;
          parentDir.coveredLineCount+=coverageInfo.coveredLineCount;
          parentDir.totalMethodCount+=coverageInfo.totalMethodCount;
          parentDir.coveredMethodCount+=coverageInfo.coveredMethodCount;
        }
      }
    }
 else {
      if (isClassFile(child)) {
        final String childName=getClassName(child);
        final String classFqVMName=packageVMName.length() > 0 ? packageVMName + "/" + childName : childName;
        final String toplevelClassSrcFQName=getSourceToplevelFQName(classFqVMName);
        final Ref<VirtualFile> containingFileRef=new Ref<VirtualFile>();
        final Ref<PsiClass> psiClassRef=new Ref<PsiClass>();
        final Boolean isInSource=DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>(){
          public Boolean compute(){
            if (myProject.isDisposed())             return null;
            final PsiClass aClass=JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName,GlobalSearchScope.moduleScope(module));
            if (aClass == null || !aClass.isValid())             return Boolean.FALSE;
            psiClassRef.set(aClass);
            containingFileRef.set(aClass.getNavigationElement().getContainingFile().getVirtualFile());
            if (containingFileRef.isNull()) {
              LOG.info("No virtual file found for: " + aClass);
              return null;
            }
            final ModuleFileIndex fileIndex=ModuleRootManager.getInstance(module).getFileIndex();
            return fileIndex.isUnderSourceRootOfType(containingFileRef.get(),JavaModuleSourceRootTypes.SOURCES) && (trackTestFolders || !fileIndex.isInTestSourceContent(containingFileRef.get()));
          }
        }
);
        PackageCoverageInfo coverageInfoForClass=null;
        String classCoverageKey=classFqVMName.replace('/','.');
        boolean ignoreClass=false;
        for (        JavaCoverageEngineExtension extension : JavaCoverageEngineExtension.EP_NAME.getExtensions()) {
          if (extension.ignoreCoverageForClass(myCoverageManager.getCurrentSuitesBundle(),child)) {
            ignoreClass=true;
            break;
          }
          if (extension.keepCoverageInfoForClassWithoutSource(myCoverageManager.getCurrentSuitesBundle(),child)) {
            coverageInfoForClass=classWithoutSourceCoverageInfo;
            break;
          }
        }
        if (ignoreClass) {
          continue;
        }
        if (coverageInfoForClass == null && isInSource != null && isInSource.booleanValue()) {
          for (          DirCoverageInfo dirCoverageInfo : dirs) {
            if (dirCoverageInfo.sourceRoot != null && VfsUtil.isAncestor(dirCoverageInfo.sourceRoot,containingFileRef.get(),false)) {
              coverageInfoForClass=dirCoverageInfo;
              classCoverageKey=toplevelClassSrcFQName;
              break;
            }
          }
        }
        if (coverageInfoForClass != null) {
          collectClassCoverageInformation(child,psiClassRef.get(),coverageInfoForClass,projectInfo,toplevelClassCoverage,classFqVMName.replace("/","."),classCoverageKey);
        }
      }
    }
  }
  for (  Map.Entry<String,ClassCoverageInfo> entry : toplevelClassCoverage.entrySet()) {
    final String toplevelClassName=entry.getKey();
    final ClassCoverageInfo coverageInfo=entry.getValue();
    annotator.annotateClass(toplevelClassName,coverageInfo);
  }
  PackageCoverageInfo flattenPackageCoverageInfo=getOrCreateCoverageInfo(flattenPackageCoverageMap,packageVMName);
  for (  Map.Entry<String,ClassCoverageInfo> entry : toplevelClassCoverage.entrySet()) {
    final ClassCoverageInfo coverageInfo=entry.getValue();
    flattenPackageCoverageInfo.append(coverageInfo);
  }
  PackageCoverageInfo packageCoverageInfo=getOrCreateCoverageInfo(packageCoverageMap,packageVMName);
  for (  DirCoverageInfo dir : dirs) {
    packageCoverageInfo.append(dir);
    if (isTestHierarchy) {
      annotator.annotateTestDirectory(dir.sourceRoot,dir,module);
    }
 else {
      annotator.annotateSourceDirectory(dir.sourceRoot,dir,module);
    }
  }
  packageCoverageInfo.append(classWithoutSourceCoverageInfo);
  return dirs.toArray(new DirCoverageInfo[dirs.size()]);
}
