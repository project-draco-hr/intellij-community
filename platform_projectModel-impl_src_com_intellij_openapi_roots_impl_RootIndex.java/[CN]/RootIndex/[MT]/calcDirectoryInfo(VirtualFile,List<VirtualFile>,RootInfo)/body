{
  VirtualFile moduleContentRoot=info.findModuleRootInfo(hierarchy);
  VirtualFile libraryClassRoot=info.findLibraryRootInfo(hierarchy,false);
  VirtualFile librarySourceRoot=info.findLibraryRootInfo(hierarchy,true);
  Module parentModuleForExcluded=null;
  if (moduleContentRoot == null && libraryClassRoot == null && librarySourceRoot == null) {
    parentModuleForExcluded=info.findParentModuleForExcluded(hierarchy);
    if (parentModuleForExcluded == null) {
      return new Pair<DirectoryInfo,String>(NonProjectDirectoryInfo.EXCLUDED,null);
    }
  }
  VirtualFile sourceRoot=info.findPackageRootInfo(hierarchy,moduleContentRoot,null,librarySourceRoot);
  VirtualFile moduleSourceRoot=info.findPackageRootInfo(hierarchy,moduleContentRoot,null,null);
  boolean inModuleSources=moduleSourceRoot != null;
  boolean inLibrarySource=librarySourceRoot != null;
  int typeId=moduleSourceRoot != null ? info.rootTypeId.get(moduleSourceRoot) : 0;
  Module module=parentModuleForExcluded != null ? parentModuleForExcluded : info.contentRootOf.get(moduleContentRoot);
  DirectoryInfo directoryInfo=new DirectoryInfoImpl(module,moduleContentRoot,sourceRoot,libraryClassRoot,inModuleSources,inLibrarySource,parentModuleForExcluded != null,typeId){
    @NotNull @Override public OrderEntry[] getOrderEntries(){
      OrderEntry[] entries=RootIndex.this.getOrderEntries().get(root);
      return entries == null ? OrderEntry.EMPTY_ARRAY : entries;
    }
  }
;
  String packagePrefix=info.calcPackagePrefix(root,hierarchy,moduleContentRoot,libraryClassRoot,librarySourceRoot);
  return Pair.create(directoryInfo,packagePrefix);
}
