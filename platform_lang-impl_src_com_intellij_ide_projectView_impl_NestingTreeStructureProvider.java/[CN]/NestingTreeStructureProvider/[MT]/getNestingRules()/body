{
  if (myNestingRules == null) {
    myNestingRules=new THashSet<>();
    final MultiMap<String,String> childToParentSuffix=new MultiMap<>();
    final MultiMap<String,String> parentToChildSuffix=new MultiMap<>();
    final NestingRulesProvider.Consumer consumer=new NestingRulesProvider.Consumer(){
      @Override public void addNestingRule(      @NotNull final String parentFileSuffix,      @NotNull final String childFileSuffix){
        LOG.assertTrue(!parentFileSuffix.isEmpty() && !childFileSuffix.isEmpty(),"file suffix must not be empty");
        LOG.assertTrue(!parentFileSuffix.equals(childFileSuffix),"parent and child suffixes must be different: " + parentFileSuffix);
        myNestingRules.add(new NestingRule(parentFileSuffix,childFileSuffix));
        childToParentSuffix.putValue(childFileSuffix,parentFileSuffix);
        parentToChildSuffix.putValue(parentFileSuffix,childFileSuffix);
        for (        String s : parentToChildSuffix.get(childFileSuffix)) {
          myNestingRules.add(new NestingRule(parentFileSuffix,s));
          parentToChildSuffix.putValue(parentFileSuffix,s);
          childToParentSuffix.putValue(s,parentFileSuffix);
        }
        for (        String s : childToParentSuffix.get(parentFileSuffix)) {
          myNestingRules.add(new NestingRule(s,childFileSuffix));
          parentToChildSuffix.putValue(s,childFileSuffix);
          childToParentSuffix.putValue(childFileSuffix,s);
        }
      }
    }
;
    for (    NestingRulesProvider provider : EP_NAME.getExtensions()) {
      provider.addFileNestingRules(consumer);
    }
  }
  return myNestingRules;
}
