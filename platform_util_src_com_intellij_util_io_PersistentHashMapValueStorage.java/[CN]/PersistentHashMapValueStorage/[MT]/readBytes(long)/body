{
  force();
  checkCancellation();
  long chunk=tailChunkAddress;
  int chunkCount=0;
  byte[] result=null;
  RAReader reader=myCompactionModeReader;
  CacheValue<RAReader> readerHandle=null;
  if (reader == null) {
    readerHandle=ourReadersCache.get(myPath);
    reader=readerHandle.get();
  }
  try {
    while (chunk != 0) {
      if (chunk < 0 || chunk > mySize)       throw new PersistentEnumeratorBase.CorruptedException(myFile);
      int len=(int)Math.min(myBuffer.length,mySize - chunk);
      reader.get(chunk,myBuffer,0,len);
      myBufferStreamWrapper.init(myBuffer,0,len);
      final int chunkSize=DataInputOutputUtil.readINT(myBufferDataStreamWrapper);
      if (chunkSize < 0) {
        throw new IOException("Value storage corrupted: negative chunk size: " + chunkSize);
      }
      final long prevChunkAddress=readPrevChunkAddress(chunk);
      final int headerOffset=len - myBufferStreamWrapper.available();
      byte[] b=new byte[(result != null ? result.length : 0) + chunkSize];
      if (result != null)       System.arraycopy(result,0,b,b.length - result.length,result.length);
      result=b;
      checkPreconditions(result,chunkSize,0);
      if (chunkSize < myBuffer.length - headerOffset) {
        System.arraycopy(myBuffer,headerOffset,result,0,chunkSize);
      }
 else {
        reader.get(chunk + headerOffset,result,0,chunkSize);
      }
      if (prevChunkAddress >= chunk)       throw new PersistentEnumeratorBase.CorruptedException(myFile);
      chunk=prevChunkAddress;
      chunkCount++;
      if (prevChunkAddress != 0)       checkCancellation();
      if (result.length > mySize) {
        throw new PersistentEnumeratorBase.CorruptedException(myFile);
      }
    }
  }
 catch (  OutOfMemoryError error) {
    result=null;
    throw new PersistentEnumeratorBase.CorruptedException(myFile);
  }
 finally {
    if (readerHandle != null) {
      readerHandle.release();
    }
  }
  if (chunkCount > 1 && !myCompactionMode) {
    checkCancellation();
    long l=appendBytes(new ByteSequence(result),0);
    return new ReadResult(l,result);
  }
  return new ReadResult(tailChunkAddress,result);
}
