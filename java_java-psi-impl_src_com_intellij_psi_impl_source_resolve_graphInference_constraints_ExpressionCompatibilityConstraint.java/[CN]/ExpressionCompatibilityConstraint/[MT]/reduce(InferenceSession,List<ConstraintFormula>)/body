{
  if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {
    if (session.isProperType(myT)) {
      return TypeConversionUtil.areTypesAssignmentCompatible(myT,myExpression);
    }
    final PsiType exprType=myExpression.getType();
    if (exprType instanceof PsiLambdaParameterType) {
      return false;
    }
    if (exprType != null && exprType != PsiType.NULL) {
      constraints.add(new TypeCompatibilityConstraint(myT,exprType));
    }
    return true;
  }
  if (myExpression instanceof PsiParenthesizedExpression) {
    final PsiExpression expression=((PsiParenthesizedExpression)myExpression).getExpression();
    if (expression != null) {
      constraints.add(new ExpressionCompatibilityConstraint(expression,myT));
      return true;
    }
  }
  if (myExpression instanceof PsiConditionalExpression) {
    final PsiExpression thenExpression=((PsiConditionalExpression)myExpression).getThenExpression();
    if (thenExpression != null) {
      constraints.add(new ExpressionCompatibilityConstraint(thenExpression,myT));
    }
    final PsiExpression elseExpression=((PsiConditionalExpression)myExpression).getElseExpression();
    if (elseExpression != null) {
      constraints.add(new ExpressionCompatibilityConstraint(elseExpression,myT));
    }
    return true;
  }
  if (myExpression instanceof PsiCallExpression) {
    final PsiExpressionList argumentList=((PsiCallExpression)myExpression).getArgumentList();
    if (argumentList != null) {
      final MethodCandidateInfo.CurrentCandidateProperties candidateProperties=MethodCandidateInfo.getCurrentMethod(((PsiCallExpression)myExpression).getArgumentList());
      final JavaResolveResult resolveResult=candidateProperties != null ? null : ((PsiCallExpression)myExpression).resolveMethodGenerics();
      final PsiMethod method=candidateProperties != null ? candidateProperties.getMethod() : (PsiMethod)resolveResult.getElement();
      PsiType returnType=null;
      PsiTypeParameter[] typeParams=null;
      if (method != null && !method.isConstructor()) {
        returnType=method.getReturnType();
        if (returnType != null) {
          typeParams=method.getTypeParameters();
        }
      }
 else       if (myExpression instanceof PsiNewExpression) {
        final PsiJavaCodeReferenceElement classReference=((PsiNewExpression)myExpression).getClassOrAnonymousClassReference();
        if (classReference != null) {
          final PsiElement psiClass=classReference.resolve();
          if (psiClass instanceof PsiClass) {
            returnType=JavaPsiFacade.getElementFactory(argumentList.getProject()).createType((PsiClass)psiClass,PsiSubstitutor.EMPTY);
            typeParams=((PsiClass)psiClass).getTypeParameters();
          }
        }
      }
      if (typeParams != null) {
        final Set<PsiTypeParameter> oldBounds=ContainerUtil.newHashSet(session.getParamsToInfer());
        final boolean sameMethodCall=session.initBounds(myExpression,typeParams);
        PsiSubstitutor substitutor=PsiSubstitutor.EMPTY;
        final HashSet<InferenceVariable> variables=new HashSet<InferenceVariable>();
        session.collectDependencies(returnType,variables);
        final PsiTypeParameter[] params=new PsiTypeParameter[typeParams.length];
        for (int i=0; i < typeParams.length; i++) {
          if (variables.contains(session.getInferenceVariable(typeParams[i]))) {
            params[i]=JavaPsiFacade.getElementFactory(myExpression.getProject()).createTypeParameterFromText("copyOf" + myExpression.hashCode() + typeParams[i].getName(),null);
            substitutor=substitutor.put(typeParams[i],JavaPsiFacade.getElementFactory(myExpression.getProject()).createType(params[i]));
          }
 else {
            params[i]=typeParams[i];
          }
        }
        PsiSubstitutor siteSubstitutor=PsiSubstitutor.EMPTY;
        if (method != null && !method.isConstructor()) {
          if (resolveResult instanceof MethodCandidateInfo) {
            siteSubstitutor=((MethodCandidateInfo)resolveResult).getSiteSubstitutor();
          }
 else           if (candidateProperties != null) {
            siteSubstitutor=candidateProperties.getSubstitutor();
          }
        }
        for (        PsiTypeParameter typeParameter : siteSubstitutor.getSubstitutionMap().keySet()) {
          substitutor=substitutor.put(typeParameter,substitutor.substitute(siteSubstitutor.substitute(typeParameter)));
        }
        final Collection<PsiTypeParameter> params1=session.getTypeParams();
        final InferenceSession callSession=new InferenceSession(params,substitutor,myExpression.getManager(),myExpression);
        callSession.initBounds(session.getContext(),params1.toArray(new PsiTypeParameter[params1.size()]));
        if (method != null) {
          final PsiExpression[] args=argumentList.getExpressions();
          final PsiParameter[] parameters=method.getParameterList().getParameters();
          callSession.initExpressionConstraints(parameters,args,myExpression,method,resolveResult instanceof MethodCandidateInfo && ((MethodCandidateInfo)resolveResult).isVarargs() || candidateProperties != null && candidateProperties.isVarargs());
        }
        final boolean accepted=callSession.repeatInferencePhases(true);
        if (!accepted) {
          return false;
        }
        callSession.registerReturnTypeConstraints(method != null && !PsiUtil.isRawSubstitutor(method,siteSubstitutor) ? siteSubstitutor.substitute(returnType) : returnType,substitutor.substitute(returnType));
        if (callSession.repeatInferencePhases(true)) {
          final Collection<InferenceVariable> inferenceVariables=callSession.getInferenceVariables();
          if (sameMethodCall) {
            for (Iterator<InferenceVariable> iterator=inferenceVariables.iterator(); iterator.hasNext(); ) {
              InferenceVariable variable=iterator.next();
              if (oldBounds.contains(variable.getParameter())) {
                iterator.remove();
              }
            }
          }
          session.liftBounds(myExpression,inferenceVariables);
        }
 else {
          return false;
        }
        final PsiType capturedReturnType=myExpression instanceof PsiMethodCallExpression ? PsiMethodCallExpressionImpl.captureReturnType((PsiMethodCallExpression)myExpression,method,returnType,substitutor) : substitutor.substitute(returnType);
        constraints.add(new TypeCompatibilityConstraint(myT,capturedReturnType));
      }
    }
    return true;
  }
  if (myExpression instanceof PsiMethodReferenceExpression) {
    constraints.add(new PsiMethodReferenceCompatibilityConstraint(((PsiMethodReferenceExpression)myExpression),myT));
    return true;
  }
  if (myExpression instanceof PsiLambdaExpression) {
    constraints.add(new LambdaExpressionCompatibilityConstraint((PsiLambdaExpression)myExpression,myT));
    return true;
  }
  return true;
}
