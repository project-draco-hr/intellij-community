{
  final int line=position.getLine();
  if (line < 0) {
    return Collections.emptyList();
  }
  final PsiFile file=position.getFile();
  final VirtualFile vFile=file.getVirtualFile();
  if (vFile == null) {
    return Collections.emptyList();
  }
  final Document doc=FileDocumentManager.getInstance().getDocument(vFile);
  if (doc == null)   return Collections.emptyList();
  if (line >= doc.getLineCount()) {
    return Collections.emptyList();
  }
  TextRange curLineRange=DocumentUtil.getLineTextRange(doc,line);
  PsiElement element=position.getElementAt();
  PsiElement method=getBody(DebuggerUtilsEx.getContainingMethod(element));
  final TextRange lineRange=(method != null) ? curLineRange.intersection(method.getTextRange()) : curLineRange;
  if (lineRange == null || lineRange.isEmpty()) {
    return Collections.emptyList();
  }
  if (element != null && !(element instanceof PsiCompiledElement)) {
    do {
      final PsiElement parent=element.getParent();
      if (parent == null || (parent.getTextOffset() < lineRange.getStartOffset())) {
        break;
      }
      element=parent;
    }
 while (true);
    final List<SmartStepTarget> targets=new OrderedSet<SmartStepTarget>();
    final Ref<TextRange> textRange=new Ref<TextRange>(lineRange);
    final PsiElementVisitor methodCollector=new JavaRecursiveElementVisitor(){
      final Stack<PsiMethod> myContextStack=new Stack<PsiMethod>();
      final Stack<String> myParamNameStack=new Stack<String>();
      private int myNextLambdaExpressionOrdinal=0;
      private boolean myInsideLambda=false;
      @Nullable private String getCurrentParamName(){
        return myParamNameStack.isEmpty() ? null : myParamNameStack.peek();
      }
      @Override public void visitAnonymousClass(      PsiAnonymousClass aClass){
        for (        PsiMethod psiMethod : aClass.getMethods()) {
          targets.add(new MethodSmartStepTarget(psiMethod,getCurrentParamName(),psiMethod.getBody(),true,null));
        }
      }
      public void visitLambdaExpression(      PsiLambdaExpression expression){
        boolean inLambda=myInsideLambda;
        myInsideLambda=true;
        super.visitLambdaExpression(expression);
        myInsideLambda=inLambda;
        targets.add(new LambdaSmartStepTarget(expression,getCurrentParamName(),expression.getBody(),myNextLambdaExpressionOrdinal++,null));
      }
      @Override public void visitMethodReferenceExpression(      PsiMethodReferenceExpression expression){
        PsiElement element=expression.resolve();
        if (element instanceof PsiMethod) {
          PsiElement navMethod=element.getNavigationElement();
          if (navMethod instanceof PsiMethod) {
            targets.add(new MethodSmartStepTarget(((PsiMethod)navMethod),null,expression,true,null));
          }
        }
      }
      @Override public void visitStatement(      PsiStatement statement){
        TextRange range=statement.getTextRange();
        if (lineRange.intersects(range)) {
          textRange.set(textRange.get().union(range));
          super.visitStatement(statement);
        }
      }
      @Override public void visitExpression(      PsiExpression expression){
        TextRange range=expression.getTextRange();
        if (lineRange.intersects(range)) {
          textRange.set(textRange.get().union(range));
        }
        super.visitExpression(expression);
      }
      public void visitExpressionList(      PsiExpressionList expressionList){
        final PsiMethod psiMethod=myContextStack.isEmpty() ? null : myContextStack.peek();
        if (psiMethod != null) {
          final String methodName=psiMethod.getName();
          final PsiExpression[] expressions=expressionList.getExpressions();
          final PsiParameter[] parameters=psiMethod.getParameterList().getParameters();
          for (int idx=0; idx < expressions.length; idx++) {
            final String paramName=(idx < parameters.length && !parameters[idx].isVarArgs()) ? parameters[idx].getName() : "arg" + (idx + 1);
            myParamNameStack.push(methodName + ": " + paramName+ ".");
            final PsiExpression argExpression=expressions[idx];
            try {
              argExpression.accept(this);
            }
  finally {
              myParamNameStack.pop();
            }
          }
        }
 else {
          super.visitExpressionList(expressionList);
        }
      }
      @Override public void visitCallExpression(      final PsiCallExpression expression){
        final PsiMethod psiMethod=expression.resolveMethod();
        if (psiMethod != null) {
          myContextStack.push(psiMethod);
          targets.add(new MethodSmartStepTarget(psiMethod,null,expression instanceof PsiMethodCallExpression ? ((PsiMethodCallExpression)expression).getMethodExpression().getReferenceNameElement() : expression instanceof PsiNewExpression ? ((PsiNewExpression)expression).getClassOrAnonymousClassReference() : expression,myInsideLambda,null));
        }
        try {
          super.visitCallExpression(expression);
        }
  finally {
          if (psiMethod != null) {
            myContextStack.pop();
          }
        }
      }
    }
;
    element.accept(methodCollector);
    for (PsiElement sibling=element.getNextSibling(); sibling != null; sibling=sibling.getNextSibling()) {
      if (!lineRange.intersects(sibling.getTextRange())) {
        break;
      }
      sibling.accept(methodCollector);
    }
    Range<Integer> lines=new Range<Integer>(doc.getLineNumber(textRange.get().getStartOffset()),doc.getLineNumber(textRange.get().getEndOffset()));
    for (    SmartStepTarget target : targets) {
      target.setCallingExpressionLines(lines);
    }
    return targets;
  }
  return Collections.emptyList();
}
