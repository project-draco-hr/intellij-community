{
  return new DataIndexer<MethodIncompleteSignature,Multiset<MethodIncompleteSignature>,ClassReader>(){
    @NotNull @Override public Map<MethodIncompleteSignature,Multiset<MethodIncompleteSignature>> map(    final ClassReader inputData){
      final Map<MethodIncompleteSignature,Multiset<MethodIncompleteSignature>> map=new HashMap<MethodIncompleteSignature,Multiset<MethodIncompleteSignature>>();
      for (      final ClassFileData.MethodData data : new ClassFileData(inputData).getMethodDatas()) {
        final SimpleBigramsExtractor extractor=new SimpleBigramsExtractor(new SimpleBigramsExtractor.BigramMethodIncompleteSignatureProcessor(){
          @Override public void process(          final Bigram<MethodIncompleteSignature> bigram){
            final MethodIncompleteSignature secondGram=bigram.getSecond();
            Multiset<MethodIncompleteSignature> occurrences=map.get(secondGram);
            if (occurrences == null) {
              occurrences=HashMultiset.create();
              map.put(secondGram,occurrences);
            }
            occurrences.add(bigram.getFirst());
          }
        }
);
        for (        final ClassFileData.MethodInsnSignature ms : data.getMethodInsnSignatures()) {
          final List<MethodIncompleteSignature> methodInvocations=new SmartList<MethodIncompleteSignature>();
          final String ownerClassName=AsmUtil.getQualifiedClassName(ms.getOwner());
          final String returnType=AsmUtil.getReturnType(ms.getDesc());
          if (ms.getName().equals(MethodIncompleteSignature.CONSTRUCTOR_METHOD_NAME)) {
            methodInvocations.add(MethodIncompleteSignature.constructor(ownerClassName));
          }
 else {
            methodInvocations.add(new MethodIncompleteSignature(ownerClassName,returnType,ms.getName(),ms.getOpcode() == Opcodes.INVOKESTATIC));
          }
          extractor.addChain(new MethodIncompleteSignatureChain(methodInvocations));
        }
      }
      return map;
    }
  }
;
}
