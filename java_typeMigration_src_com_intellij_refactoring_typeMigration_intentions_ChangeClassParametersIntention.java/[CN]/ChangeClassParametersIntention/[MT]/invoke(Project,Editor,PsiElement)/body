{
  if (!FileModificationService.getInstance().preparePsiElementsForWrite(element))   return;
  final PsiTypeElement typeElement=PsiTreeUtil.getTopmostParentOfType(element,PsiTypeElement.class);
  final PsiReferenceParameterList parameterList=PsiTreeUtil.getParentOfType(typeElement,PsiReferenceParameterList.class);
  if (parameterList != null) {
    final PsiClass aClass=PsiTreeUtil.getParentOfType(element,PsiClass.class);
    if (aClass instanceof PsiAnonymousClass) {
      editor.getCaretModel().moveToOffset(aClass.getTextOffset());
      final PsiTypeElement[] typeElements=parameterList.getTypeParameterElements();
      final int changeIdx=ArrayUtil.find(typeElements,typeElement);
      final PsiClassType.ClassResolveResult result=((PsiAnonymousClass)aClass).getBaseClassType().resolveGenerics();
      final PsiClass baseClass=result.getElement();
      LOG.assertTrue(baseClass != null);
      final PsiTypeParameter typeParameter=baseClass.getTypeParameters()[changeIdx];
      final TemplateBuilderImpl templateBuilder=(TemplateBuilderImpl)TemplateBuilderFactory.getInstance().createTemplateBuilder(aClass);
      final String oldTypeText=typeElement.getText();
      final String varName="param";
      templateBuilder.replaceElement(typeElement,varName,new TypeExpression(project,new PsiType[]{typeElement.getType()}),true);
      final Template template=templateBuilder.buildInlineTemplate();
      TemplateManager.getInstance(project).startTemplate(editor,template,false,null,new TemplateEditingAdapter(){
        private String myNewType;
        @Override public void beforeTemplateFinished(        TemplateState state,        Template template){
          final TextResult value=state.getVariableValue(varName);
          myNewType=value != null ? value.getText() : "";
          final int segmentsCount=state.getSegmentsCount();
          final Document document=state.getEditor().getDocument();
          for (int i=0; i < segmentsCount; i++) {
            final TextRange segmentRange=state.getSegmentRange(i);
            document.replaceString(segmentRange.getStartOffset(),segmentRange.getEndOffset(),oldTypeText);
          }
        }
        @Override public void templateFinished(        Template template,        boolean brokenOff){
          if (!brokenOff) {
            final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(project);
            try {
              final PsiType targetParam=elementFactory.createTypeFromText(myNewType,aClass);
              if (!(targetParam instanceof PsiClassType)) {
                HintManager.getInstance().showErrorHint(editor,JavaErrorMessages.message("generics.type.argument.cannot.be.of.primitive.type"));
                return;
              }
              final PsiClassType classType=(PsiClassType)targetParam;
              final PsiClass target=classType.resolve();
              if (target == null) {
                HintManager.getInstance().showErrorHint(editor,JavaErrorMessages.message("cannot.resolve.symbol",classType.getPresentableText()));
                return;
              }
              final TypeMigrationRules myRules=new TypeMigrationRules(((PsiAnonymousClass)aClass).getBaseClassType());
              final PsiSubstitutor substitutor=result.getSubstitutor().put(typeParameter,targetParam);
              final PsiType targetClassType=elementFactory.createType(baseClass,substitutor);
              myRules.setMigrationRootType(targetClassType);
              myRules.setBoundScope(new LocalSearchScope(aClass));
              TypeMigrationProcessor.runHighlightingTypeMigration(project,editor,myRules,((PsiAnonymousClass)aClass).getBaseClassReference().getParameterList());
            }
 catch (            IncorrectOperationException e) {
              HintManager.getInstance().showErrorHint(editor,"Incorrect type");
            }
          }
        }
      }
);
    }
  }
}
