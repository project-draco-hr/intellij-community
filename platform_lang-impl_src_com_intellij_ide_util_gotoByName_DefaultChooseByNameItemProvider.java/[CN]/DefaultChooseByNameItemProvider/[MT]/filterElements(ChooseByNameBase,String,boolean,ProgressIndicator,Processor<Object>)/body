{
  String namePattern=getNamePattern(base,pattern);
  String qualifierPattern=getQualifierPattern(base,pattern);
  if (removeModelSpecificMarkup(base,namePattern).isEmpty() && !base.canShowListForEmptyPattern())   return true;
  final ChooseByNameModel model=base.getModel();
  String matchingPattern=convertToMatchingPattern(base,namePattern);
  List<MatchResult> namesList=new ArrayList<MatchResult>();
  processNamesByPattern(base,base.getNames(everywhere),matchingPattern,new CollectConsumer<MatchResult>(namesList));
  sortNamesList(matchingPattern,namesList);
  indicator.checkCanceled();
  List<Object> sameNameElements=new SmartList<Object>();
  final Map<Object,MatchResult> qualifierMatchResults=new THashMap<Object,MatchResult>();
  Comparator<Object> weightComparator=new Comparator<Object>(){
    Comparator<Object> modelComparator=model instanceof Comparator ? (Comparator<Object>)model : new PathProximityComparator(model,myContext.get());
    @Override public int compare(    Object o1,    Object o2){
      int result=modelComparator.compare(o1,o2);
      return result != 0 ? result : qualifierMatchResults.get(o1).compareTo(qualifierMatchResults.get(o2));
    }
  }
;
  List<Object> qualifierMiddleMatched=new ArrayList<Object>();
  List<Pair<String,MinusculeMatcher>> patternsAndMatchers=getPatternsAndMatchers(qualifierPattern,base);
  boolean sortedByMatchingDegree=!(base.getModel() instanceof CustomMatcherModel);
  boolean afterStartMatch=false;
  for (  MatchResult result : namesList) {
    indicator.checkCanceled();
    String name=result.elementName;
    boolean needSeparator=sortedByMatchingDegree && !result.startMatch && afterStartMatch;
    Object[] elements=model instanceof ContributorsBasedGotoByModel ? ((ContributorsBasedGotoByModel)model).getElementsByName(name,everywhere,namePattern,indicator) : model.getElementsByName(name,everywhere,namePattern);
    if (elements.length > 1) {
      sameNameElements.clear();
      qualifierMatchResults.clear();
      for (      final Object element : elements) {
        indicator.checkCanceled();
        MatchResult qualifierResult=matchQualifier(element,base,patternsAndMatchers);
        if (qualifierResult != null) {
          sameNameElements.add(element);
          qualifierMatchResults.put(element,qualifierResult);
        }
      }
      Collections.sort(sameNameElements,weightComparator);
      for (      Object element : sameNameElements) {
        if (!qualifierMatchResults.get(element).startMatch) {
          qualifierMiddleMatched.add(element);
          continue;
        }
        if (needSeparator && !startMiddleMatchVariants(consumer,qualifierMiddleMatched))         return false;
        if (!consumer.process(element))         return false;
        needSeparator=false;
        afterStartMatch=result.startMatch;
      }
    }
 else     if (elements.length == 1 && matchQualifier(elements[0],base,patternsAndMatchers) != null) {
      if (needSeparator && !startMiddleMatchVariants(consumer,qualifierMiddleMatched))       return false;
      if (!consumer.process(elements[0]))       return false;
      afterStartMatch=result.startMatch;
    }
  }
  return ContainerUtil.process(qualifierMiddleMatched,consumer);
}
