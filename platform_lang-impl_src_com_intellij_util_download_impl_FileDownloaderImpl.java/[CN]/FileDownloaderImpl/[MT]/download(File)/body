{
  final List<Pair<File,DownloadableFileDescription>> downloadedFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
  final List<Pair<File,DownloadableFileDescription>> existingFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
  final ProgressIndicator parentIndicator=getProgressIndicator();
  try {
    final AtomicReference<IOException> ioException=new AtomicReference<IOException>();
    final ConcurrentTasksProgressManager progressManager=new ConcurrentTasksProgressManager(parentIndicator,myFileDescriptions.size());
    parentIndicator.setText(IdeBundle.message("progress.downloading.0.files.text",myFileDescriptions.size()));
    boolean finished=JobLauncher.getInstance().invokeConcurrentlyUnderProgress(myFileDescriptions,parentIndicator,false,false,new Processor<DownloadableFileDescription>(){
      @Override public boolean process(      DownloadableFileDescription description){
        SubTaskProgressIndicator indicator=progressManager.createSubTaskIndicator();
        indicator.checkCanceled();
        final File existing=new File(targetDir,description.getDefaultFileName());
        final String url=description.getDownloadUrl();
        if (url.startsWith(LIB_SCHEMA)) {
          final String path=FileUtil.toSystemDependentName(StringUtil.trimStart(url,LIB_SCHEMA));
          final File file=PathManager.findFileInLibDirectory(path);
          existingFiles.add(Pair.create(file,description));
        }
 else         if (url.startsWith(LocalFileSystem.PROTOCOL_PREFIX)) {
          String path=FileUtil.toSystemDependentName(StringUtil.trimStart(url,LocalFileSystem.PROTOCOL_PREFIX));
          File file=new File(path);
          if (file.exists()) {
            existingFiles.add(Pair.create(file,description));
          }
        }
 else {
          File downloaded;
          try {
            downloaded=downloadFile(description,existing,indicator);
          }
 catch (          IOException e) {
            ioException.compareAndSet(null,new IOException(IdeBundle.message("error.file.download.failed",description.getDownloadUrl(),e.getMessage()),e));
            return false;
          }
          if (FileUtil.filesEqual(downloaded,existing)) {
            existingFiles.add(Pair.create(existing,description));
          }
 else {
            downloadedFiles.add(Pair.create(downloaded,description));
          }
        }
        indicator.finished();
        return true;
      }
    }
);
    if (!finished) {
      if (ioException.get() != null) {
        throw ioException.get();
      }
      throw new ProcessCanceledException();
    }
    List<Pair<File,DownloadableFileDescription>> localFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
    localFiles.addAll(moveToDir(downloadedFiles,targetDir));
    localFiles.addAll(existingFiles);
    return localFiles;
  }
 catch (  ProcessCanceledException e) {
    deleteFiles(downloadedFiles);
    throw e;
  }
catch (  IOException e) {
    deleteFiles(downloadedFiles);
    throw e;
  }
}
