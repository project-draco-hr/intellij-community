{
  final List<Pair<File,DownloadableFileDescription>> downloadedFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
  final List<Pair<File,DownloadableFileDescription>> existingFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
  ProgressIndicator parentIndicator=ProgressManager.getInstance().getProgressIndicator();
  if (parentIndicator == null) {
    parentIndicator=new EmptyProgressIndicator();
  }
  try {
    final ConcurrentTasksProgressManager progressManager=new ConcurrentTasksProgressManager(parentIndicator,myFileDescriptions.size());
    parentIndicator.setText(IdeBundle.message("progress.downloading.0.files.text",myFileDescriptions.size()));
    int maxParallelDownloads=Runtime.getRuntime().availableProcessors();
    LOG.debug("Downloading " + myFileDescriptions.size() + " files using "+ maxParallelDownloads+ " threads");
    long start=System.currentTimeMillis();
    ExecutorService executor=AppExecutorUtil.createBoundedApplicationPoolExecutor(maxParallelDownloads);
    List<Future<Void>> results=new ArrayList<Future<Void>>();
    final AtomicLong totalSize=new AtomicLong();
    for (    final DownloadableFileDescription description : myFileDescriptions) {
      results.add(executor.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          SubTaskProgressIndicator indicator=progressManager.createSubTaskIndicator();
          indicator.checkCanceled();
          final File existing=new File(targetDir,description.getDefaultFileName());
          final String url=description.getDownloadUrl();
          if (url.startsWith(LIB_SCHEMA)) {
            final String path=FileUtil.toSystemDependentName(StringUtil.trimStart(url,LIB_SCHEMA));
            final File file=PathManager.findFileInLibDirectory(path);
            existingFiles.add(Pair.create(file,description));
          }
 else           if (url.startsWith(LocalFileSystem.PROTOCOL_PREFIX)) {
            String path=FileUtil.toSystemDependentName(StringUtil.trimStart(url,LocalFileSystem.PROTOCOL_PREFIX));
            File file=new File(path);
            if (file.exists()) {
              existingFiles.add(Pair.create(file,description));
            }
          }
 else {
            File downloaded;
            try {
              downloaded=downloadFile(description,existing,indicator);
            }
 catch (            IOException e) {
              throw new IOException(IdeBundle.message("error.file.download.failed",description.getDownloadUrl(),e.getMessage()),e);
            }
            if (FileUtil.filesEqual(downloaded,existing)) {
              existingFiles.add(Pair.create(existing,description));
            }
 else {
              totalSize.addAndGet(downloaded.length());
              downloadedFiles.add(Pair.create(downloaded,description));
            }
          }
          indicator.finished();
          return null;
        }
      }
));
    }
    for (    Future<Void> result : results) {
      try {
        result.get();
      }
 catch (      InterruptedException e) {
        throw new ProcessCanceledException();
      }
catch (      ExecutionException e) {
        Throwables.propagateIfInstanceOf(e.getCause(),IOException.class);
        Throwables.propagateIfInstanceOf(e.getCause(),ProcessCanceledException.class);
        LOG.error(e);
      }
    }
    long duration=System.currentTimeMillis() - start;
    LOG.debug("Downloaded " + StringUtil.formatFileSize(totalSize.get()) + " in "+ StringUtil.formatDuration(duration)+ "("+ duration+ "ms)");
    List<Pair<File,DownloadableFileDescription>> localFiles=new ArrayList<Pair<File,DownloadableFileDescription>>();
    localFiles.addAll(moveToDir(downloadedFiles,targetDir));
    localFiles.addAll(existingFiles);
    return localFiles;
  }
 catch (  ProcessCanceledException e) {
    deleteFiles(downloadedFiles);
    throw e;
  }
catch (  IOException e) {
    deleteFiles(downloadedFiles);
    throw e;
  }
}
