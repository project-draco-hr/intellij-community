{
  final HashSet<PyClass> result=Sets.newHashSet();
  for (  final PyClass baseClass : pyClass.getSuperClasses()) {
    final Computable<Set<PyClass>> computable=new Computable<Set<PyClass>>(){
      @Override public Set<PyClass> compute(){
        return getAncestorClassesFast(baseClass);
      }
    }
;
    final Set<PyClass> baseClassAncestors=ourRecursionGuard.doPreventingRecursion(baseClass,false,computable);
    result.add(baseClass);
    if (baseClassAncestors != null) {
      result.addAll(baseClassAncestors);
    }
  }
  return CachedValueProvider.Result.create(Collections.unmodifiableSet(result),PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);
}
