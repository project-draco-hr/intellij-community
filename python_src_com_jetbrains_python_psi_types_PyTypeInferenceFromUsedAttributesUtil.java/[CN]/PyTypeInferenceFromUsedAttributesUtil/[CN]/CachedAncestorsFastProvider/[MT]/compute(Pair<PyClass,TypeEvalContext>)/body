{
  final PyClass pyClass=param.getFirst();
  final TypeEvalContext context=param.getSecond();
  final HashSet<PyClass> result=Sets.newHashSet();
  for (  final PyClassLikeType baseType : pyClass.getSuperClassTypes(context)) {
    if (!(baseType instanceof PyClassType)) {
      continue;
    }
    final PyClass baseClass=((PyClassType)baseType).getPyClass();
    final Computable<Set<PyClass>> computable=new Computable<Set<PyClass>>(){
      @Override public Set<PyClass> compute(){
        return getAncestorClassesFast(baseClass,context);
      }
    }
;
    final Set<PyClass> baseClassAncestors=ourRecursionGuard.doPreventingRecursion(baseClass,false,computable);
    result.add(baseClass);
    if (baseClassAncestors != null) {
      result.addAll(baseClassAncestors);
    }
  }
  return CachedValueProvider.Result.create(Collections.unmodifiableSet(result),PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);
}
