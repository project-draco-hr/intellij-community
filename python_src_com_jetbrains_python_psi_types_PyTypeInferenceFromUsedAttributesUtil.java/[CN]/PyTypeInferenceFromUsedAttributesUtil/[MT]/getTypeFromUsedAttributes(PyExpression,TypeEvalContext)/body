{
  if (!ENABLED || !context.allowLocalUsages(expression)) {
    return null;
  }
  final Set<String> seenAttrs=collectUsedAttributes(expression);
  LOG.debug(String.format("Attempting to infer type for expression: %s. Used attributes: %s",expression.getText(),seenAttrs));
  final Set<PyClass> candidates=Sets.newHashSet();
  for (  String attribute : seenAttrs) {
    if (COMMON_OBJECT_ATTRIBUTES.contains(attribute)) {
      candidates.add(PyBuiltinCache.getInstance(expression).getClass(PyNames.OBJECT));
    }
 else {
      final Collection<PyClass> declaringClasses=PyClassAttributesIndex.find(attribute,expression.getProject());
      LOG.debug("Attribute " + attribute + " is declared in "+ declaringClasses.size()+ " classes");
      candidates.addAll(declaringClasses);
    }
  }
  final Set<PyClass> suitableClasses=Sets.newHashSet();
  for (  PyClass candidate : candidates) {
    if (PyUserSkeletonsUtil.isUnderUserSkeletonsDirectory(candidate.getContainingFile())) {
      continue;
    }
    if (getAllInheritedAttributeNames(candidate,context).containsAll(seenAttrs)) {
      suitableClasses.add(candidate);
    }
  }
  for (  PyClass candidate : Lists.newArrayList(suitableClasses)) {
    for (    PyClass ancestor : candidate.getAncestorClasses()) {
      if (suitableClasses.contains(ancestor)) {
        suitableClasses.remove(candidate);
      }
    }
  }
  final List<CandidateClass> finalists=prepareCandidates(suitableClasses,expression);
  return PyUnionType.createWeakType(PyUnionType.union(ContainerUtil.map(finalists,new Function<CandidateClass,PyType>(){
    @Override public PyType fun(    CandidateClass cls){
      return new PyClassTypeImpl(cls.myClass,false);
    }
  }
)));
}
