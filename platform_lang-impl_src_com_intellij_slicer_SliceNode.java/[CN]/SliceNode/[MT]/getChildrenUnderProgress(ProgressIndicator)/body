{
  if (isUpToDate())   return myCachedChildren == null ? Collections.<AbstractTreeNode>emptyList() : myCachedChildren;
  final List<SliceNode> children=new ArrayList<SliceNode>();
  final SliceManager manager=SliceManager.getInstance(getProject());
  manager.runInterruptibly(progress,new Runnable(){
    @Override public void run(){
      changed=true;
    }
  }
,new Runnable(){
    @Override public void run(){
      Processor<SliceUsage> processor=new Processor<SliceUsage>(){
        @Override public boolean process(        SliceUsage sliceUsage){
          progress.checkCanceled();
          SliceNode node=new SliceNode(myProject,sliceUsage,targetEqualUsages);
synchronized (children) {
            node.index=children.size();
            children.add(node);
          }
          return true;
        }
      }
;
      getValue().processChildren(processor);
    }
  }
);
synchronized (children) {
    myCachedChildren=children;
  }
  return children;
}
