{
  if (UnusedSymbolUtil.isMethodReferenced(myProject,myFile,method,progress,helper))   return null;
  final HighlightInfoType highlightInfoType=myDeadCodeInfoType;
  final HighlightDisplayKey highlightDisplayKey=myDeadCodeKey;
  String key;
  if (method.hasModifierProperty(PsiModifier.PRIVATE)) {
    key=method.isConstructor() ? "private.constructor.is.not.used" : "private.method.is.not.used";
  }
 else {
    key=method.isConstructor() ? "constructor.is.not.used" : "method.is.not.used";
  }
  String symbolName=HighlightMessageUtil.getSymbolName(method,PsiSubstitutor.EMPTY);
  String message=JavaErrorMessages.message(key,symbolName);
  final HighlightInfo highlightInfo=UnusedSymbolUtil.createUnusedSymbolInfo(identifier,message,highlightInfoType);
  QuickFixAction.registerQuickFixAction(highlightInfo,QuickFixFactory.getInstance().createSafeDeleteFix(method),highlightDisplayKey);
  SpecialAnnotationsUtilBase.createAddToSpecialAnnotationFixes(method,new Processor<String>(){
    @Override public boolean process(    final String annoName){
      IntentionAction fix=QuickFixFactory.getInstance().createAddToDependencyInjectionAnnotationsFix(project,annoName,"methods");
      QuickFixAction.registerQuickFixAction(highlightInfo,fix);
      return true;
    }
  }
);
  return highlightInfo;
}
