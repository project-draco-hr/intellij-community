{
  if (HighlightUtil.isSerializationImplicitlyUsedField(field)) {
    return null;
  }
  if (field.hasModifierProperty(PsiModifier.PRIVATE)) {
    final QuickFixFactory quickFixFactory=QuickFixFactory.getInstance();
    if (!myRefCountHolder.isReferenced(field) && !UnusedSymbolUtil.isImplicitUsage(myProject,field,progress)) {
      String message=JavaErrorMessages.message("private.field.is.not.used",identifier.getText());
      HighlightInfo highlightInfo=suggestionsToMakeFieldUsed(field,identifier,message);
      if (!field.hasInitializer() && !field.hasModifierProperty(PsiModifier.FINAL)) {
        QuickFixAction.registerQuickFixAction(highlightInfo,HighlightMethodUtil.getFixRange(field),quickFixFactory.createCreateConstructorParameterFromFieldFix(field));
      }
      return highlightInfo;
    }
    final boolean readReferenced=myRefCountHolder.isReferencedForRead(field);
    if (!readReferenced && !UnusedSymbolUtil.isImplicitRead(project,field,progress)) {
      String message=JavaErrorMessages.message("private.field.is.not.used.for.reading",identifier.getText());
      return suggestionsToMakeFieldUsed(field,identifier,message);
    }
    if (field.hasInitializer()) {
      return null;
    }
    final boolean writeReferenced=myRefCountHolder.isReferencedForWrite(field);
    if (!writeReferenced && !UnusedSymbolUtil.isImplicitWrite(project,field,progress)) {
      String message=JavaErrorMessages.message("private.field.is.not.assigned",identifier.getText());
      final HighlightInfo info=UnusedSymbolUtil.createUnusedSymbolInfo(identifier,message,myDeadCodeInfoType);
      QuickFixAction.registerQuickFixAction(info,quickFixFactory.createCreateGetterOrSetterFix(false,true,field),myDeadCodeKey);
      if (!field.hasModifierProperty(PsiModifier.FINAL)) {
        QuickFixAction.registerQuickFixAction(info,HighlightMethodUtil.getFixRange(field),quickFixFactory.createCreateConstructorParameterFromFieldFix(field));
      }
      SpecialAnnotationsUtilBase.createAddToSpecialAnnotationFixes(field,new Processor<String>(){
        @Override public boolean process(        final String annoName){
          QuickFixAction.registerQuickFixAction(info,quickFixFactory.createAddToDependencyInjectionAnnotationsFix(project,annoName,"fields"));
          return true;
        }
      }
);
      return info;
    }
  }
 else   if (UnusedSymbolUtil.isImplicitUsage(myProject,field,progress)) {
    return null;
  }
 else   if (UnusedSymbolUtil.isFieldUnused(myProject,myFile,field,progress,helper)) {
    return formatUnusedSymbolHighlightInfo(project,"field.is.not.used",field,"fields",myDeadCodeKey,myDeadCodeInfoType,identifier);
  }
  return null;
}
