{
  ApplicationManager.getApplication().assertIsDispatchThread();
  List<LineMarkerInfo> oldMarkers=DaemonCodeAnalyzerImpl.getLineMarkers(document,project);
  List<LineMarkerInfo> result=new ArrayList<LineMarkerInfo>(Math.max(markers.size(),oldMarkers.size()));
  MarkupModel markupModel=DocumentMarkupModel.forDocument(document,project,true);
  HighlightersRecycler toReuse=new HighlightersRecycler();
  for (  LineMarkerInfo info : oldMarkers) {
    RangeHighlighter highlighter=info.highlighter;
    boolean toRemove=!highlighter.isValid() || info.updatePass == group && TextRange.containsRange(bounds,highlighter);
    if (toRemove) {
      toReuse.recycleHighlighter(highlighter);
    }
 else {
      result.add(info);
    }
  }
  for (  final LineMarkerInfo info : markers) {
    PsiElement element=info.getElement();
    if (element == null) {
      continue;
    }
    TextRange textRange=element.getTextRange();
    if (textRange == null)     continue;
    TextRange elementRange=InjectedLanguageManager.getInstance(project).injectedToHost(element,textRange);
    if (!TextRange.containsRange(bounds,elementRange)) {
      continue;
    }
    RangeHighlighter marker=toReuse.pickupHighlighterFromGarbageBin(info.startOffset,info.endOffset,HighlighterLayer.ADDITIONAL_SYNTAX);
    if (marker == null) {
      marker=markupModel.addRangeHighlighter(info.startOffset,info.endOffset,HighlighterLayer.ADDITIONAL_SYNTAX,null,HighlighterTargetArea.LINES_IN_RANGE);
    }
    final LineMarkerInfo.LineMarkerGutterIconRenderer newRenderer=(LineMarkerInfo.LineMarkerGutterIconRenderer)info.createGutterRenderer();
    final LineMarkerInfo.LineMarkerGutterIconRenderer oldRenderer=marker.getGutterIconRenderer() instanceof LineMarkerInfo.LineMarkerGutterIconRenderer ? (LineMarkerInfo.LineMarkerGutterIconRenderer)marker.getGutterIconRenderer() : null;
    final boolean rendererChanged=oldRenderer == null || newRenderer == null || !newRenderer.equals(oldRenderer);
    final boolean lineSeparatorColorChanged=!Comparing.equal(marker.getLineSeparatorColor(),info.separatorColor);
    final boolean lineSeparatorPlacementChanged=!Comparing.equal(marker.getLineSeparatorPlacement(),info.separatorPlacement);
    if (rendererChanged || lineSeparatorColorChanged || lineSeparatorPlacementChanged) {
      ((MarkupModelEx)markupModel).changeAttributesInBatch((RangeHighlighterEx)marker,new Consumer<RangeHighlighterEx>(){
        @Override public void consume(        RangeHighlighterEx markerEx){
          if (rendererChanged) {
            markerEx.setGutterIconRenderer(newRenderer);
          }
          if (lineSeparatorColorChanged) {
            markerEx.setLineSeparatorColor(info.separatorColor);
          }
          if (lineSeparatorPlacementChanged) {
            markerEx.setLineSeparatorPlacement(info.separatorPlacement);
          }
        }
      }
);
    }
    info.highlighter=marker;
    result.add(info);
  }
  for (  RangeHighlighter highlighter : toReuse.forAllInGarbageBin()) {
    highlighter.dispose();
  }
  DaemonCodeAnalyzerImpl.setLineMarkers(document,result,project);
}
