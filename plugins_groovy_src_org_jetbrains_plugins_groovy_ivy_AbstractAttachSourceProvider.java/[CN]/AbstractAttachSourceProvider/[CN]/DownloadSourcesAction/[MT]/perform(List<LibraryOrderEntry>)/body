{
  final ActionCallback callback=new ActionCallback();
  Task task=new Task.Backgroundable(myProject,"Downloading sources...",true){
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      final ByteArrayOutputStream out;
      try {
        LOG.info("Downloading sources JAR: " + myUrl);
        indicator.checkCanceled();
        out=HttpRequests.request(myUrl).connect(new HttpRequests.RequestProcessor<ByteArrayOutputStream>(){
          @Override public ByteArrayOutputStream process(          @NotNull HttpRequests.Request request) throws IOException {
            int contentLength=request.getConnection().getContentLength();
            ByteArrayOutputStream out=new ByteArrayOutputStream(contentLength > 0 ? contentLength : 100 * 1024);
            NetUtils.copyStreamContent(indicator,request.getInputStream(),out,contentLength);
            return out;
          }
        }
);
      }
 catch (      IOException e) {
        LOG.warn(e);
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          @Override public void run(){
            new Notification(myMessageGroupId,"Downloading failed","Failed to download sources: " + myUrl,NotificationType.ERROR).notify(getProject());
            callback.setDone();
          }
        }
);
        return;
      }
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          AccessToken accessToken=WriteAction.start();
          try {
            storeFile(out.toByteArray());
          }
  finally {
            accessToken.finish();
            callback.setDone();
          }
        }
      }
);
    }
    @Override public void onCancel(){
      callback.setRejected();
    }
  }
;
  task.queue();
  return callback;
}
