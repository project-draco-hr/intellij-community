{
  final MatcherImpl.CompiledOptions compiledOptions=SSBasedInspectionCompiledPatternsCache.getCompiledOptions(holder.getProject());
  if (compiledOptions == null)   return super.buildVisitor(holder,isOnTheFly);
  return new PsiElementVisitor(){
    final List<Pair<MatchContext,Configuration>> contexts=compiledOptions.getMatchContexts();
    final Matcher matcher=new Matcher(holder.getManager().getProject());
    final PairProcessor<MatchResult,Configuration> processor=new PairProcessor<MatchResult,Configuration>(){
      @Override public boolean process(      MatchResult matchResult,      Configuration configuration){
        PsiElement element=matchResult.getMatch();
        String name=configuration.getName();
        LocalQuickFix fix=createQuickFix(holder.getManager().getProject(),matchResult,configuration);
        holder.registerProblem(holder.getManager().createProblemDescriptor(element,name,fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING,isOnTheFly));
        return true;
      }
    }
;
    @Override public void visitElement(    PsiElement element){
synchronized (LOCK) {
        if (LexicalNodesFilter.getInstance().accepts(element))         return;
        final SsrFilteringNodeIterator matchedNodes=new SsrFilteringNodeIterator(element);
        for (        Pair<MatchContext,Configuration> pair : contexts) {
          Configuration configuration=pair.second;
          MatchContext context=pair.first;
          if (MatcherImpl.checkIfShouldAttemptToMatch(context,matchedNodes)) {
            final int nodeCount=context.getPattern().getNodeCount();
            try {
              matcher.processMatchesInElement(context,configuration,new CountingNodeIterator(nodeCount,matchedNodes),processor);
            }
 catch (            StructuralSearchException e) {
              if (myProblemsReported.add(configuration.getName())) {
                Notifications.Bus.notify(new Notification(SSRBundle.message("structural.search.title"),SSRBundle.message("template.problem",configuration.getName()),e.getMessage(),NotificationType.ERROR),element.getProject());
              }
            }
            matchedNodes.reset();
          }
        }
      }
    }
  }
;
}
