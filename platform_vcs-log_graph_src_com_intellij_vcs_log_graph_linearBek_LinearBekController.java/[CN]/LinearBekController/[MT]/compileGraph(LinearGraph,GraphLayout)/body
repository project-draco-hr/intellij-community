{
  final WorkingGraph workingGraph=new WorkingGraph(graph);
  final List<Integer> heads=graphLayout.getHeadNodeIndex();
  GraphVisitorAlgorithm graphVisitorAlgorithm=new GraphVisitorAlgorithm(true);
  graphVisitorAlgorithm.visitGraph(graph,graphLayout,new GraphVisitorAlgorithm.GraphVisitor(){
    @Override public void enterSubtree(    int currentNodeIndex,    int currentHead,    BitSetFlags visited){
    }
    @Override public void leaveSubtree(    int currentNodeIndex,    int currentHead,    BitSetFlags visited){
      workingGraph.clear();
      List<Integer> upNodes=workingGraph.getUpNodes(currentNodeIndex);
      if (upNodes.size() != 1)       return;
      int parent=upNodes.get(0);
      if (workingGraph.getDownNodes(parent).size() != 2) {
        return;
      }
      int firstChildIndex=workingGraph.getDownNodes(parent).get(0);
      boolean switchedOrder=false;
      if (firstChildIndex == currentNodeIndex) {
        switchedOrder=true;
        firstChildIndex=workingGraph.getDownNodes(parent).get(1);
      }
      int x=graphLayout.getLayoutIndex(firstChildIndex);
      int y=graphLayout.getLayoutIndex(currentNodeIndex);
      int k=1;
      boolean foundFirstChild=false;
      PriorityQueue<Integer> queue=new PriorityQueue<Integer>();
      queue.addAll(workingGraph.getDownNodes(currentNodeIndex));
      boolean blockTooBig=false;
      while (!queue.isEmpty()) {
        Integer next=queue.poll();
        if (next == firstChildIndex) {
          foundFirstChild=true;
          break;
        }
 else         if (next > currentNodeIndex + k || !visited.get(next)) {
          break;
        }
 else         if (next < currentNodeIndex + k) {
          continue;
        }
        k++;
        if (k >= MAX_BLOCK_SIZE) {
          blockTooBig=true;
          break;
        }
        queue.addAll(workingGraph.getDownNodes(next));
      }
      if (blockTooBig)       return;
      int headNumber=heads.indexOf(currentHead);
      int nextHeadIndex=headNumber == heads.size() - 1 ? Integer.MAX_VALUE : graphLayout.getLayoutIndex(heads.get(headNumber + 1));
      int headIndex=graphLayout.getLayoutIndex(currentHead);
      if (foundFirstChild) {
        for (int i=currentNodeIndex; i < currentNodeIndex + k; i++) {
          boolean isTail=true;
          for (          int downNode : workingGraph.getDownNodes(i)) {
            if (downNode > firstChildIndex) {
              int li=graphLayout.getLayoutIndex(downNode);
              if (li >= y) {
                return;
              }
              if (li < x) {
                if (!(li >= headIndex && li < nextHeadIndex)) {
                  return;
                }
              }
              workingGraph.removeEdge(i,downNode);
            }
 else {
              isTail=false;
            }
          }
          if (isTail) {
            workingGraph.addEdge(i,firstChildIndex);
          }
        }
        workingGraph.removeEdge(parent,firstChildIndex);
      }
 else       if (!switchedOrder) {
        boolean hasTails=false;
        for (int i=currentNodeIndex; i < currentNodeIndex + k; i++) {
          List<Integer> downNodes=workingGraph.getDownNodes(i);
          boolean isTail=!(downNodes.isEmpty());
          for (          int downNode : downNodes) {
            if (!visited.get(downNode)) {
              int li=graphLayout.getLayoutIndex(downNode);
              if (li >= y) {
                return;
              }
              if (li < x) {
                if (!(li >= headIndex && li < nextHeadIndex && downNode > firstChildIndex)) {
                  return;
                }
              }
 else {
                workingGraph.removeEdge(i,downNode);
              }
            }
 else             if (downNode > currentNodeIndex + k) {
              return;
            }
 else {
              isTail=false;
            }
          }
          if (isTail) {
            hasTails=true;
            workingGraph.addEdge(i,firstChildIndex);
          }
        }
        if (hasTails) {
          workingGraph.removeEdge(parent,firstChildIndex);
        }
      }
      workingGraph.apply();
    }
  }
);
  return workingGraph.createLinearBekGraph();
}
