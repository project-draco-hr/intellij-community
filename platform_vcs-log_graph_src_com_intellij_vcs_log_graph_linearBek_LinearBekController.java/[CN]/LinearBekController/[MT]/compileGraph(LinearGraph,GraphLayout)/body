{
  final GraphAdditionalEdges missingEdges=createSimpleAdditionalEdges();
  final GraphAdditionalEdges newEdges=createSimpleAdditionalEdges();
  GraphVisitorAlgorithm graphVisitorAlgorithm=new GraphVisitorAlgorithm(false);
  final IntStack starts=new IntStack();
  graphVisitorAlgorithm.visitGraph(graph,graphLayout,new GraphVisitorAlgorithm.GraphVisitor(){
    @Override public void enterSubtree(    int currentNode){
      if (canBeStructureEnd(graph,currentNode)) {
        int start=-1;
        int currentNodeIndex=graphLayout.getLayoutIndex(currentNode);
        while (!starts.empty()) {
          int candidateStart=starts.peek();
          int candidateIndex=graphLayout.getLayoutIndex(candidateStart);
          if (currentNodeIndex <= candidateIndex) {
            starts.pop();
            if (currentNodeIndex == candidateIndex) {
              start=candidateStart;
              break;
            }
          }
 else {
            break;
          }
        }
        if (start != -1) {
          List<Integer> upNodes=getSortedUpNodes(graph,graphLayout,currentNode);
          int firstChildNode=getDownNodes(graph,start).get(0);
          if (graphLayout.getLayoutIndex(upNodes.get(0)) == graphLayout.getLayoutIndex(firstChildNode) && graphLayout.getLayoutIndex(upNodes.get(1)) == graphLayout.getLayoutIndex(getDownNodes(graph,start).get(1))) {
            if (upNodes.get(0) == start) {
              missingEdges.createEdge(getEdge(graph,start,firstChildNode));
            }
 else {
              missingEdges.createEdge(getEdge(graph,start,firstChildNode));
              missingEdges.createEdge(getEdge(graph,upNodes.get(1),currentNode));
              newEdges.createEdge(new GraphEdge(upNodes.get(1),firstChildNode,null,GraphEdgeType.DOTTED));
            }
          }
        }
      }
      if (canBeStructureStart(graph,currentNode)) {
        starts.push(currentNode);
      }
    }
    @Override public void leaveSubtree(    int currentNode){
      if (canBeStructureStart(graph,currentNode)) {
        while (!starts.empty()) {
          int lastStart=starts.peek();
          if (lastStart >= currentNode) {
            starts.pop();
            if (lastStart == currentNode)             break;
          }
 else {
            break;
          }
        }
      }
    }
  }
);
  return new LinearBekGraph(graph,missingEdges,newEdges);
}
