{
  final WorkingGraph workingGraph=new WorkingGraph(graph);
  GraphVisitorAlgorithm graphVisitorAlgorithm=new GraphVisitorAlgorithm(true);
  graphVisitorAlgorithm.visitGraph(graph,graphLayout,new GraphVisitorAlgorithm.GraphVisitor(){
    @Override public void enterSubtree(    int currentNodeIndex,    BitSetFlags visited){
    }
    @Override public void leaveSubtree(    int currentNodeIndex,    BitSetFlags visited){
      workingGraph.clear();
      List<Integer> upNodes=workingGraph.getUpNodes(currentNodeIndex);
      if (upNodes.size() != 1)       return;
      int parent=upNodes.get(0);
      if (workingGraph.getDownNodes(parent).size() != 2) {
        return;
      }
      int firstChildIndex=workingGraph.getDownNodes(parent).get(0);
      if (firstChildIndex == currentNodeIndex)       return;
      int x=graphLayout.getLayoutIndex(firstChildIndex);
      int y=graphLayout.getLayoutIndex(currentNodeIndex);
      final Map<Integer,Integer> magicMap=new HashMap<Integer,Integer>();
      new GraphVisitorAlgorithm(false).visitSubgraph(workingGraph,new GraphVisitorAlgorithm.SimpleVisitor(){
        @Override public void visitNode(        int nodeIndex){
          int layoutIndex=graphLayout.getLayoutIndex(nodeIndex);
          if (!magicMap.containsKey(layoutIndex) || magicMap.get(layoutIndex) > nodeIndex) {
            magicMap.put(layoutIndex,nodeIndex);
          }
        }
      }
,firstChildIndex,100);
      int k=1;
      PriorityQueue<Integer> queue=new PriorityQueue<Integer>();
      queue.addAll(workingGraph.getDownNodes(currentNodeIndex));
      while (!queue.isEmpty()) {
        Integer next=queue.poll();
        if (next == firstChildIndex) {
          break;
        }
 else         if (next > currentNodeIndex + k || !visited.get(next)) {
          break;
        }
 else         if (next < currentNodeIndex + k) {
          continue;
        }
        k++;
        queue.addAll(workingGraph.getDownNodes(next));
      }
      if (visited.get(firstChildIndex)) {
        if (firstChildIndex == currentNodeIndex + k) {
          for (int i=currentNodeIndex; i < currentNodeIndex + k; i++) {
            boolean isTail=true;
            for (            int downNode : workingGraph.getDownNodes(i)) {
              if (downNode > firstChildIndex) {
                int li=graphLayout.getLayoutIndex(downNode);
                if (li >= y) {
                  return;
                }
                if (li < x) {
                  if (!magicMap.containsKey(li) || magicMap.get(li) > downNode) {
                    return;
                  }
                }
                workingGraph.removeEdge(i,downNode);
              }
 else {
                isTail=false;
              }
            }
            if (isTail) {
              workingGraph.addEdge(i,firstChildIndex);
            }
          }
          workingGraph.removeEdge(parent,firstChildIndex);
        }
      }
 else {
        boolean hasTails=false;
        for (int i=currentNodeIndex; i < currentNodeIndex + k; i++) {
          List<Integer> downNodes=workingGraph.getDownNodes(i);
          boolean isTail=!(downNodes.isEmpty());
          for (          int downNode : downNodes) {
            if (!visited.get(downNode)) {
              int li=graphLayout.getLayoutIndex(downNode);
              if (li >= y) {
                return;
              }
              if (li < x) {
                if (!magicMap.containsKey(li) || magicMap.get(li) > downNode) {
                  return;
                }
              }
              workingGraph.removeEdge(i,downNode);
            }
 else             if (downNode > currentNodeIndex + k) {
              return;
            }
 else {
              isTail=false;
            }
          }
          if (isTail) {
            hasTails=true;
            workingGraph.addEdge(i,firstChildIndex);
          }
        }
        if (hasTails) {
          workingGraph.removeEdge(parent,firstChildIndex);
        }
      }
      workingGraph.apply();
    }
  }
);
  return workingGraph.createLinearBekGraph();
}
