{
  final GraphAdditionalEdges missingEdges=createSimpleAdditionalEdges();
  final GraphAdditionalEdges newEdges=createSimpleAdditionalEdges();
  GraphVisitorAlgorithm graphVisitorAlgorithm=new GraphVisitorAlgorithm(true);
  graphVisitorAlgorithm.visitGraph(graph,graphLayout,new GraphVisitorAlgorithm.GraphVisitor(){
    @Override public void enterSubtree(    int currentNodeIndex,    BitSetFlags visited){
    }
    @Override public void leaveSubtree(    int currentNodeIndex,    BitSetFlags visited){
      List<Integer> upNodes=getUpNodes(graph,currentNodeIndex);
      if (upNodes.size() != 1)       return;
      int parent=upNodes.get(0);
      if (getDownNodes(graph,parent).size() != 2) {
        return;
      }
      int firstChildIndex=getDownNodes(graph,parent).get(0);
      if (firstChildIndex == currentNodeIndex)       return;
      int x=graphLayout.getLayoutIndex(firstChildIndex);
      int y=graphLayout.getLayoutIndex(currentNodeIndex);
      int k=1;
      PriorityQueue<Integer> queue=new PriorityQueue<Integer>();
      queue.addAll(getDownNodes(graph,currentNodeIndex));
      while (!queue.isEmpty()) {
        Integer next=queue.poll();
        if (next > currentNodeIndex + k || !visited.get(next)) {
          break;
        }
 else         if (next < currentNodeIndex + k) {
          continue;
        }
        k++;
        queue.addAll(getDownNodes(graph,next));
      }
      List<GraphEdge> edgesToRemove=new ArrayList<GraphEdge>();
      List<GraphEdge> dottedEdgesToRemove=new ArrayList<GraphEdge>();
      List<Integer> tails=new ArrayList<Integer>();
      for (int i=currentNodeIndex; i < currentNodeIndex + k; i++) {
        boolean isTail=true;
        for (        int upNode : getUpNodes(graph,i)) {
          if (upNode >= currentNodeIndex + k || upNode < currentNodeIndex - 1) {
            return;
          }
        }
        for (        int downNode : getDownNodes(graph,i)) {
          if (!visited.get(downNode)) {
            int li=graphLayout.getLayoutIndex(downNode);
            if (li < x || li >= y) {
              return;
            }
            edgesToRemove.add(getEdge(graph,i,downNode));
          }
 else {
            isTail=false;
          }
        }
        if (isTail) {
          tails.add(i);
        }
        ArrayList<GraphEdge> dottedEdges=new ArrayList<GraphEdge>();
        newEdges.appendAdditionalEdges(dottedEdges,i);
        for (        GraphEdge dottedEdge : dottedEdges) {
          if (dottedEdge.getUpNodeIndex() == i) {
            int li=graphLayout.getLayoutIndex(dottedEdge.getDownNodeIndex());
            if (li >= x && li < y) {
              dottedEdgesToRemove.add(dottedEdge);
            }
          }
        }
      }
      missingEdges.createEdge(getEdge(graph,parent,firstChildIndex));
      for (      Integer t : tails) {
        newEdges.createEdge(new GraphEdge(t,firstChildIndex,null,GraphEdgeType.DOTTED));
      }
      for (      GraphEdge edge : edgesToRemove) {
        missingEdges.createEdge(edge);
      }
      for (      GraphEdge edge : dottedEdgesToRemove) {
        newEdges.removeEdge(edge);
      }
    }
  }
);
  return new LinearBekGraph(graph,missingEdges,newEdges);
}
