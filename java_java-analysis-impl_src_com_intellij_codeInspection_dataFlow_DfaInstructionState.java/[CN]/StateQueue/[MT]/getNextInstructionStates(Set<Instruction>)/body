{
  DfaInstructionState state=myQueue.poll();
  final Instruction instruction=state.getInstruction();
  mySet.remove(Pair.create(instruction,state.getMemoryState()));
  DfaInstructionState next=myQueue.peek();
  if (next == null || next.compareTo(state) != 0)   return Collections.singletonList(state);
  List<DfaMemoryStateImpl> memoryStates=ContainerUtil.newArrayList();
  memoryStates.add((DfaMemoryStateImpl)state.getMemoryState());
  while (!myQueue.isEmpty() && myQueue.peek().compareTo(state) == 0) {
    DfaMemoryState anotherState=myQueue.poll().getMemoryState();
    mySet.remove(Pair.create(instruction,anotherState));
    memoryStates.add((DfaMemoryStateImpl)anotherState);
  }
  if (memoryStates.size() > 1 && joinInstructions.contains(instruction)) {
    MultiMap<Object,DfaMemoryStateImpl> groups=MultiMap.create();
    for (    DfaMemoryStateImpl memoryState : memoryStates) {
      groups.putValue(memoryState.getSuperficialKey(),memoryState);
    }
    memoryStates=ContainerUtil.newArrayList();
    for (    Map.Entry<Object,Collection<DfaMemoryStateImpl>> entry : groups.entrySet()) {
      memoryStates.addAll(mergeGroup((List<DfaMemoryStateImpl>)entry.getValue()));
    }
  }
  return ContainerUtil.map(memoryStates,new Function<DfaMemoryStateImpl,DfaInstructionState>(){
    @Override public DfaInstructionState fun(    DfaMemoryStateImpl state){
      return new DfaInstructionState(instruction,state);
    }
  }
);
}
