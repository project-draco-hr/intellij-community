{
  final List<Equation<Key,Value>> parameterEquations=new ArrayList<Equation<Key,Value>>();
  final List<Equation<Key,Value>> contractEquations=new ArrayList<Equation<Key,Value>>();
  classReader.accept(new ClassVisitor(Opcodes.ASM5){
    private boolean stableClass;
    @Override public void visit(    int version,    int access,    String name,    String signature,    String superName,    String[] interfaces){
      stableClass=(access & Opcodes.ACC_FINAL) != 0;
      super.visit(version,access,name,signature,superName,interfaces);
    }
    @Override public MethodVisitor visitMethod(    int access,    String name,    String desc,    String signature,    String[] exceptions){
      final MethodNode node=new MethodNode(Opcodes.ASM5,access,name,desc,signature,exceptions);
      return new MethodVisitor(Opcodes.ASM5,node){
        @Override public void visitEnd(){
          super.visitEnd();
          processMethod(classReader.getClassName(),node,stableClass);
        }
      }
;
    }
    void processMethod(    final String className,    final MethodNode methodNode,    boolean stableClass){
      ProgressManager.checkCanceled();
      Type[] argumentTypes=Type.getArgumentTypes(methodNode.desc);
      Type resultType=Type.getReturnType(methodNode.desc);
      int resultSort=resultType.getSort();
      boolean isReferenceResult=resultSort == Type.OBJECT || resultSort == Type.ARRAY;
      boolean isBooleanResult=Type.BOOLEAN_TYPE == resultType;
      boolean isInterestingResult=isReferenceResult || isBooleanResult;
      if (argumentTypes.length == 0 && !isInterestingResult) {
        return;
      }
      final Method method=new Method(className,methodNode.name,methodNode.desc);
      int access=methodNode.access;
      final boolean stable=stableClass || (access & Opcodes.ACC_FINAL) != 0 || (access & Opcodes.ACC_PRIVATE) != 0 || (access & Opcodes.ACC_STATIC) != 0 || "<init>".equals(methodNode.name);
      try {
        boolean added=false;
        final ControlFlowGraph graph=cfg.buildControlFlowGraph(className,methodNode);
        boolean maybeLeakingParameter=false;
        for (        Type argType : argumentTypes) {
          int argSort=argType.getSort();
          if (argSort == Type.OBJECT || argSort == Type.ARRAY || (isInterestingResult && Type.BOOLEAN_TYPE.equals(argType))) {
            maybeLeakingParameter=true;
            break;
          }
        }
        if (graph.transitions.length > 0) {
          final DFSTree dfs=cfg.buildDFSTree(graph.transitions);
          boolean complex=!dfs.back.isEmpty();
          if (!complex) {
            for (            int[] transition : graph.transitions) {
              if (transition != null && transition.length > 1) {
                complex=true;
                break;
              }
            }
          }
          boolean reducible=dfs.back.isEmpty() || cfg.reducible(graph,dfs);
          if (true) {
            if (reducible) {
              final NullableLazyValue<boolean[]> resultOrigins=new NullableLazyValue<boolean[]>(){
                @Override protected boolean[] compute(){
                  try {
                    return cfg.resultOrigins(className,methodNode);
                  }
 catch (                  AnalyzerException e) {
                    return null;
                  }
catch (                  LimitReachedException e) {
                    return null;
                  }
                }
              }
;
              NotNullLazyValue<Equation<Key,Value>> resultEquation=new NotNullLazyValue<Equation<Key,Value>>(){
                @NotNull @Override protected Equation<Key,Value> compute(){
                  boolean[] origins=resultOrigins.getValue();
                  if (origins != null) {
                    try {
                      return new InOutAnalysis(new RichControlFlow(graph,dfs),new Out(),origins,stable).analyze();
                    }
 catch (                    AnalyzerException ignored) {
                    }
                  }
                  return new Equation<Key,Value>(new Key(method,new Out(),stable),new Final<Key,Value>(Value.Top));
                }
              }
;
              boolean[] leakingParameters=maybeLeakingParameter ? (argumentTypes.length < 0 ? cfg.fastLeakingParameters(className,methodNode) : cfg.leakingParameters(className,methodNode)) : null;
              if (isReferenceResult) {
                contractEquations.add(resultEquation.getValue());
              }
              for (int i=0; i < argumentTypes.length; i++) {
                Type argType=argumentTypes[i];
                int argSort=argType.getSort();
                boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
                boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
                boolean notNullParam=false;
                if (isReferenceArg) {
                  if (leakingParameters[i]) {
                    Equation<Key,Value> notNullParamEquation=new NonNullInAnalysis(new RichControlFlow(graph,dfs),new In(i),stable).analyze();
                    notNullParam=notNullParamEquation.rhs.equals(new Final<Key,Value>(Value.NotNull));
                    parameterEquations.add(notNullParamEquation);
                  }
 else {
                    parameterEquations.add(new Equation<Key,Value>(new Key(method,new In(i),stable),new Final<Key,Value>(Value.Top)));
                  }
                }
                if (isReferenceArg && isInterestingResult) {
                  if (leakingParameters[i]) {
                    if (resultOrigins.getValue() != null) {
                      if (!notNullParam) {
                        contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.Null),resultOrigins.getValue(),stable).analyze());
                      }
 else {
                        contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),new Final<Key,Value>(Value.Bot)));
                      }
                      contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.NotNull),resultOrigins.getValue(),stable).analyze());
                    }
 else {
                      contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),new Final<Key,Value>(Value.Top)));
                      contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),new Final<Key,Value>(Value.Top)));
                    }
                  }
 else {
                    contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),resultEquation.getValue().rhs));
                    contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),resultEquation.getValue().rhs));
                  }
                }
                if (isBooleanArg && isInterestingResult) {
                  if (leakingParameters[i]) {
                    if (resultOrigins.getValue() != null) {
                      contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.False),resultOrigins.getValue(),stable).analyze());
                      contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.True),resultOrigins.getValue(),stable).analyze());
                    }
 else {
                      contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),new Final<Key,Value>(Value.Top)));
                      contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),new Final<Key,Value>(Value.Top)));
                    }
                  }
 else {
                    contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),resultEquation.getValue().rhs));
                    contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),resultEquation.getValue().rhs));
                  }
                }
              }
              added=true;
            }
 else {
              LOG.debug("CFG for " + method + " is not reducible");
            }
          }
 else {
            CombinedSingleAnalysis analyzer=new CombinedSingleAnalysis(method,graph);
            analyzer.analyze();
            added=true;
          }
        }
        if (!added) {
          if (isReferenceResult) {
            contractEquations.add(new Equation<Key,Value>(new Key(method,new Out(),stable),new Final<Key,Value>(Value.Top)));
          }
          for (int i=0; i < argumentTypes.length; i++) {
            Type argType=argumentTypes[i];
            int argSort=argType.getSort();
            boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
            boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
            if (isReferenceArg) {
              parameterEquations.add(new Equation<Key,Value>(new Key(method,new In(i),stable),new Final<Key,Value>(Value.Top)));
            }
            if (isReferenceArg && isInterestingResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),new Final<Key,Value>(Value.Top)));
            }
            if (isBooleanArg && isInterestingResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),new Final<Key,Value>(Value.Top)));
            }
          }
        }
      }
 catch (      ProcessCanceledException e) {
        throw e;
      }
catch (      Throwable e) {
        LOG.debug("Unexpected Error during processing of " + method + " in "+ presentableUrl,e);
      }
    }
  }
,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
  return new ClassEquations(parameterEquations,contractEquations);
}
