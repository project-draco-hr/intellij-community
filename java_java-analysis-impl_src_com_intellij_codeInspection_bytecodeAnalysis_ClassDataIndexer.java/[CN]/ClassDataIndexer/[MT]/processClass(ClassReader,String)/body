{
  final List<Equation<Key,Value>> parameterEqs=new ArrayList<Equation<Key,Value>>();
  final List<Equation<Key,Value>> contractEqs=new ArrayList<Equation<Key,Value>>();
  classReader.accept(new ClassVisitor(Opcodes.ASM5){
    private String className;
    private boolean stableClass;
    @Override public void visit(    int version,    int access,    String name,    String signature,    String superName,    String[] interfaces){
      className=name;
      stableClass=(access & Opcodes.ACC_FINAL) != 0;
      super.visit(version,access,name,signature,superName,interfaces);
    }
    @Override public MethodVisitor visitMethod(    int access,    String name,    String desc,    String signature,    String[] exceptions){
      final MethodNode node=new MethodNode(Opcodes.ASM5,access,name,desc,signature,exceptions);
      return new MethodVisitor(Opcodes.ASM5,node){
        @Override public void visitEnd(){
          super.visitEnd();
          processMethod(node);
        }
      }
;
    }
    private void processMethod(    final MethodNode methodNode){
      ProgressManager.checkCanceled();
      final Type[] argumentTypes=Type.getArgumentTypes(methodNode.desc);
      final Type resultType=Type.getReturnType(methodNode.desc);
      final boolean isReferenceResult=ASMUtils.isReferenceType(resultType);
      final boolean isBooleanResult=ASMUtils.isBooleanType(resultType);
      final boolean isInterestingResult=isReferenceResult || isBooleanResult;
      if (argumentTypes.length == 0 && !isInterestingResult) {
        return;
      }
      final Method method=new Method(className,methodNode.name,methodNode.desc);
      final boolean stable=stableClass || (methodNode.access & STABLE_FLAGS) != 0 || "<init>".equals(methodNode.name);
      try {
        final ControlFlowGraph graph=cfg.buildControlFlowGraph(className,methodNode);
        if (graph.transitions.length > 0) {
          final DFSTree dfs=cfg.buildDFSTree(graph.transitions,graph.edgeCount);
          boolean complex=!dfs.back.isEmpty();
          if (!complex) {
            for (            int[] transition : graph.transitions) {
              if (transition != null && transition.length > 1) {
                complex=true;
                break;
              }
            }
          }
          if (complex) {
            if (dfs.back.isEmpty() || cfg.reducible(graph,dfs)) {
              processBranchingMethod(method,methodNode,graph,dfs,argumentTypes,isReferenceResult,isInterestingResult,stable);
              return;
            }
            LOG.debug(method + ": CFG is not reducible");
          }
 else {
            processNonBranchingMethod(method,argumentTypes,graph,isReferenceResult,isBooleanResult,stable);
            return;
          }
        }
        if (isReferenceResult) {
          contractEqs.add(new Equation<Key,Value>(new Key(method,new Out(),stable),FINAL_TOP));
        }
        for (int i=0; i < argumentTypes.length; i++) {
          Type argType=argumentTypes[i];
          boolean isReferenceArg=ASMUtils.isReferenceType(argType);
          boolean isBooleanArg=ASMUtils.isBooleanType(argType);
          if (isReferenceArg) {
            parameterEqs.add(new Equation<Key,Value>(new Key(method,new In(i),stable),FINAL_TOP));
          }
          if (isReferenceArg && isInterestingResult) {
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),FINAL_TOP));
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),FINAL_TOP));
          }
          if (isBooleanArg && isInterestingResult) {
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),FINAL_TOP));
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),FINAL_TOP));
          }
        }
      }
 catch (      ProcessCanceledException e) {
        throw e;
      }
catch (      Throwable e) {
        LOG.debug("Unexpected Error during processing of " + method + " in "+ presentableUrl,e);
      }
    }
    private void processBranchingMethod(    final Method method,    final MethodNode methodNode,    final ControlFlowGraph graph,    final DFSTree dfs,    Type[] argumentTypes,    boolean isReferenceResult,    boolean isInterestingResult,    final boolean stable) throws AnalyzerException {
      boolean maybeLeakingParameter=isInterestingResult;
      for (      Type argType : argumentTypes) {
        if (ASMUtils.isReferenceType(argType) || (isReferenceResult && ASMUtils.isBooleanType(argType))) {
          maybeLeakingParameter=true;
          break;
        }
      }
      final Pair<boolean[],Frame<org.jetbrains.org.objectweb.asm.tree.analysis.Value>[]> leakingParametersAndFrames=maybeLeakingParameter ? leakingParametersAndFrames(method,methodNode,argumentTypes) : null;
      boolean[] leakingParameters=leakingParametersAndFrames != null ? leakingParametersAndFrames.first : null;
      final RichControlFlow richControlFlow=new RichControlFlow(graph,dfs);
      final NullableLazyValue<boolean[]> origins=new NullableLazyValue<boolean[]>(){
        @Override protected boolean[] compute(){
          try {
            return OriginsAnalysis.resultOrigins(leakingParametersAndFrames.second,methodNode.instructions,graph);
          }
 catch (          AnalyzerException e) {
            LOG.debug("when processing " + method + " in "+ presentableUrl,e);
            return null;
          }
        }
      }
;
      NotNullLazyValue<Equation<Key,Value>> outEquation=new NotNullLazyValue<Equation<Key,Value>>(){
        @NotNull @Override protected Equation<Key,Value> compute(){
          if (origins.getValue() != null) {
            try {
              return new InOutAnalysis(richControlFlow,new Out(),origins.getValue(),stable).analyze();
            }
 catch (            AnalyzerException ignored) {
            }
          }
          return new Equation<Key,Value>(new Key(method,new Out(),stable),FINAL_TOP);
        }
      }
;
      if (isReferenceResult) {
        contractEqs.add(outEquation.getValue());
      }
      for (int i=0; i < argumentTypes.length; i++) {
        boolean isReferenceArg=ASMUtils.isReferenceType(argumentTypes[i]);
        boolean notNullParam=false;
        if (isReferenceArg) {
          if (leakingParameters[i]) {
            Equation<Key,Value> notNullParamEquation=new NonNullInAnalysis(richControlFlow,new In(i),stable).analyze();
            notNullParam=notNullParamEquation.rhs.equals(FINAL_NOT_NULL);
            parameterEqs.add(notNullParamEquation);
          }
 else {
            parameterEqs.add(new Equation<Key,Value>(new Key(method,new In(i),stable),FINAL_TOP));
          }
        }
        if (isReferenceArg && isInterestingResult) {
          if (leakingParameters[i]) {
            if (origins.getValue() != null) {
              if (!notNullParam) {
                contractEqs.add(new InOutAnalysis(richControlFlow,new InOut(i,Value.Null),origins.getValue(),stable).analyze());
              }
 else {
                contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),FINAL_BOT));
              }
              contractEqs.add(new InOutAnalysis(richControlFlow,new InOut(i,Value.NotNull),origins.getValue(),stable).analyze());
            }
 else {
              contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),FINAL_TOP));
              contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),FINAL_TOP));
            }
          }
 else {
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),outEquation.getValue().rhs));
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),outEquation.getValue().rhs));
          }
        }
        if (ASMUtils.isBooleanType(argumentTypes[i]) && isInterestingResult) {
          if (leakingParameters[i]) {
            if (origins.getValue() != null) {
              contractEqs.add(new InOutAnalysis(richControlFlow,new InOut(i,Value.False),origins.getValue(),stable).analyze());
              contractEqs.add(new InOutAnalysis(richControlFlow,new InOut(i,Value.True),origins.getValue(),stable).analyze());
            }
 else {
              contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),FINAL_TOP));
              contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),FINAL_TOP));
            }
          }
 else {
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),outEquation.getValue().rhs));
            contractEqs.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),outEquation.getValue().rhs));
          }
        }
      }
    }
    private void processNonBranchingMethod(    Method method,    Type[] argumentTypes,    ControlFlowGraph graph,    boolean isReferenceResult,    boolean isBooleanResult,    boolean stable) throws AnalyzerException {
      CombinedSingleAnalysis analyzer=new CombinedSingleAnalysis(method,graph);
      analyzer.analyze();
      if (isReferenceResult) {
        contractEqs.add(analyzer.outContractEquation(stable));
      }
      for (int i=0; i < argumentTypes.length; i++) {
        Type argType=argumentTypes[i];
        boolean isRefArg=ASMUtils.isReferenceType(argType);
        if (isRefArg) {
          parameterEqs.add(analyzer.notNullParamEquation(i,stable));
        }
        if (isRefArg && (isReferenceResult || isBooleanResult)) {
          contractEqs.add(analyzer.nullContractEquation(i,stable));
          contractEqs.add(analyzer.notNullContractEquation(i,stable));
        }
        if (ASMUtils.isBooleanType(argType) && (isReferenceResult || isBooleanResult)) {
          contractEqs.add(analyzer.trueContractEquation(i,stable));
          contractEqs.add(analyzer.falseContractEquation(i,stable));
        }
      }
    }
    private Pair<boolean[],Frame<org.jetbrains.org.objectweb.asm.tree.analysis.Value>[]> leakingParametersAndFrames(    Method method,    MethodNode methodNode,    Type[] argumentTypes) throws AnalyzerException {
      return argumentTypes.length < 32 ? LeakingParametersAnalysis.fastLeakingParameters(method.internalClassName,methodNode) : LeakingParametersAnalysis.leakingParameters(method.internalClassName,methodNode);
    }
  }
,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
  return new ClassEquations(parameterEqs,contractEqs);
}
