{
  final List<Equation<Key,Value>> parameterEquations=new ArrayList<Equation<Key,Value>>();
  final List<Equation<Key,Value>> contractEquations=new ArrayList<Equation<Key,Value>>();
  classReader.accept(new ClassVisitor(Opcodes.ASM5){
    private boolean stableClass;
    @Override public void visit(    int version,    int access,    String name,    String signature,    String superName,    String[] interfaces){
      stableClass=(access & Opcodes.ACC_FINAL) != 0;
      super.visit(version,access,name,signature,superName,interfaces);
    }
    @Override public MethodVisitor visitMethod(    int access,    String name,    String desc,    String signature,    String[] exceptions){
      final MethodNode node=new MethodNode(Opcodes.ASM5,access,name,desc,signature,exceptions);
      return new MethodVisitor(Opcodes.ASM5,node){
        @Override public void visitEnd(){
          super.visitEnd();
          processMethod(classReader.getClassName(),node,stableClass);
        }
      }
;
    }
    void processMethod(    String className,    MethodNode methodNode,    boolean stableClass){
      ProgressManager.checkCanceled();
      Method method=new Method(className,methodNode.name,methodNode.desc);
      int access=methodNode.access;
      boolean stable=stableClass || (access & Opcodes.ACC_FINAL) != 0 || (access & Opcodes.ACC_PRIVATE) != 0 || (access & Opcodes.ACC_STATIC) != 0 || "<init>".equals(methodNode.name);
      try {
        boolean added=false;
        ControlFlowGraph graph=cfg.buildControlFlowGraph(className,methodNode);
        Type[] argumentTypes=Type.getArgumentTypes(methodNode.desc);
        Type resultType=Type.getReturnType(methodNode.desc);
        int resultSort=resultType.getSort();
        boolean isReferenceResult=resultSort == Type.OBJECT || resultSort == Type.ARRAY;
        boolean isBooleanResult=Type.BOOLEAN_TYPE == resultType;
        boolean isInterestingResult=isReferenceResult || isBooleanResult;
        boolean maybeLeakingParameter=false;
        for (        Type argType : argumentTypes) {
          int argSort=argType.getSort();
          if (argSort == Type.OBJECT || argSort == Type.ARRAY || (isInterestingResult && Type.BOOLEAN_TYPE.equals(argType))) {
            maybeLeakingParameter=true;
            break;
          }
        }
        if (graph.transitions.length > 0) {
          DFSTree dfs=cfg.buildDFSTree(graph.transitions);
          boolean reducible=dfs.back.isEmpty() || cfg.reducible(graph,dfs);
          if (reducible) {
            TIntHashSet resultOrigins=cfg.resultOrigins(className,methodNode);
            boolean[] leakingParameters=maybeLeakingParameter ? cfg.leakingParameters(className,methodNode) : null;
            boolean shouldComputeResult=isReferenceResult;
            if (!shouldComputeResult && isInterestingResult && maybeLeakingParameter) {
              loop:               for (int i=0; i < argumentTypes.length; i++) {
                Type argType=argumentTypes[i];
                int argSort=argType.getSort();
                boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
                boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
                if ((isReferenceArg || isBooleanArg) && !leakingParameters[i]) {
                  shouldComputeResult=true;
                  break loop;
                }
              }
            }
            Equation<Key,Value> resultEquation=shouldComputeResult ? new InOutAnalysis(new RichControlFlow(graph,dfs),new Out(),resultOrigins,stable).analyze() : null;
            for (int i=0; i < argumentTypes.length; i++) {
              Type argType=argumentTypes[i];
              int argSort=argType.getSort();
              boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
              boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
              if (isReferenceArg) {
                if (leakingParameters[i]) {
                  parameterEquations.add(new NonNullInAnalysis(new RichControlFlow(graph,dfs),new In(i),stable).analyze());
                }
 else {
                  parameterEquations.add(new Equation<Key,Value>(new Key(method,new In(i),stable),new Final<Key,Value>(Value.Top)));
                }
              }
              if (isReferenceArg && isInterestingResult) {
                if (leakingParameters[i]) {
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.Null),resultOrigins,stable).analyze());
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.NotNull),resultOrigins,stable).analyze());
                }
 else {
                  contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),resultEquation.rhs));
                  contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),resultEquation.rhs));
                }
              }
              if (isBooleanArg && isInterestingResult) {
                if (leakingParameters[i]) {
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.False),resultOrigins,stable).analyze());
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.True),resultOrigins,stable).analyze());
                }
 else {
                  contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),resultEquation.rhs));
                  contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),resultEquation.rhs));
                }
              }
            }
            if (isReferenceResult) {
              if (resultEquation != null) {
                contractEquations.add(resultEquation);
              }
 else {
                contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new Out(),resultOrigins,stable).analyze());
              }
            }
            added=true;
          }
 else {
            LOG.debug("CFG for " + method + " is not reducible");
          }
        }
        if (!added) {
          method=new Method(className,methodNode.name,methodNode.desc);
          for (int i=0; i < argumentTypes.length; i++) {
            Type argType=argumentTypes[i];
            int argSort=argType.getSort();
            boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
            boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
            if (isReferenceArg) {
              parameterEquations.add(new Equation<Key,Value>(new Key(method,new In(i),stable),new Final<Key,Value>(Value.Top)));
            }
            if (isReferenceArg && isInterestingResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null),stable),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull),stable),new Final<Key,Value>(Value.Top)));
            }
            if (isBooleanArg && isInterestingResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False),stable),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True),stable),new Final<Key,Value>(Value.Top)));
            }
          }
          if (isReferenceResult) {
            contractEquations.add(new Equation<Key,Value>(new Key(method,new Out(),stable),new Final<Key,Value>(Value.Top)));
          }
        }
      }
 catch (      ProcessCanceledException e) {
        throw e;
      }
catch (      Throwable e) {
        LOG.debug("Unexpected Error during processing of " + method,e);
      }
    }
  }
,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
  return new ClassEquations(parameterEquations,contractEquations);
}
