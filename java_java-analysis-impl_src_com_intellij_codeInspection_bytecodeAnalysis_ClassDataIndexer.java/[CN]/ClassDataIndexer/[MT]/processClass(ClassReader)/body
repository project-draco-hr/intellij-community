{
  final List<Equation<Key,Value>> parameterEquations=new ArrayList<Equation<Key,Value>>();
  final List<Equation<Key,Value>> contractEquations=new ArrayList<Equation<Key,Value>>();
  classReader.accept(new ClassVisitor(Opcodes.ASM5){
    @Override public MethodVisitor visitMethod(    int access,    String name,    String desc,    String signature,    String[] exceptions){
      final MethodNode node=new MethodNode(Opcodes.ASM5,access,name,desc,signature,exceptions);
      return new MethodVisitor(Opcodes.ASM5,node){
        @Override public void visitEnd(){
          super.visitEnd();
          processMethod(classReader.getClassName(),node);
        }
      }
;
    }
    void processMethod(    String className,    MethodNode methodNode){
      Method method=new Method(className,methodNode.name,methodNode.desc);
      ControlFlowGraph graph=cfg.buildControlFlowGraph(className,methodNode);
      boolean added=false;
      Type[] argumentTypes=Type.getArgumentTypes(methodNode.desc);
      Type resultType=Type.getReturnType(methodNode.desc);
      int resultSort=resultType.getSort();
      boolean isReferenceResult=resultSort == Type.OBJECT || resultSort == Type.ARRAY;
      boolean isBooleanResult=Type.BOOLEAN_TYPE == resultType;
      if (graph.transitions.length > 0) {
        DFSTree dfs=cfg.buildDFSTree(graph.transitions);
        boolean reducible=dfs.back.isEmpty() || cfg.reducible(graph,dfs);
        if (reducible) {
          try {
            for (int i=0; i < argumentTypes.length; i++) {
              Type argType=argumentTypes[i];
              int argSort=argType.getSort();
              boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
              boolean isBooleanArg=Type.BOOLEAN_TYPE.equals(argType);
              if (isReferenceArg) {
                parameterEquations.add(new NonNullInAnalysis(new RichControlFlow(graph,dfs),new In(i)).analyze());
              }
              if (isReferenceResult || isBooleanResult) {
                if (isReferenceArg) {
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.Null)).analyze());
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.NotNull)).analyze());
                }
                if (isBooleanArg) {
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.False)).analyze());
                  contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new InOut(i,Value.True)).analyze());
                }
              }
            }
            if (isReferenceResult) {
              contractEquations.add(new InOutAnalysis(new RichControlFlow(graph,dfs),new Out()).analyze());
            }
            added=true;
          }
 catch (          AnalyzerException e) {
            LOG.error(e);
          }
        }
 else {
          LOG.debug("CFG for " + method + " is not reducible");
        }
      }
      if (!added) {
        method=new Method(className,methodNode.name,methodNode.desc);
        for (int i=0; i < argumentTypes.length; i++) {
          Type argType=argumentTypes[i];
          int argSort=argType.getSort();
          boolean isReferenceArg=argSort == Type.OBJECT || argSort == Type.ARRAY;
          if (isReferenceArg) {
            contractEquations.add(new Equation<Key,Value>(new Key(method,new In(i)),new Final<Key,Value>(Value.Top)));
            if (isReferenceResult || isBooleanResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.Null)),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.NotNull)),new Final<Key,Value>(Value.Top)));
            }
          }
          if (Type.BOOLEAN_TYPE.equals(argType)) {
            if (isReferenceResult || isBooleanResult) {
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.False)),new Final<Key,Value>(Value.Top)));
              contractEquations.add(new Equation<Key,Value>(new Key(method,new InOut(i,Value.True)),new Final<Key,Value>(Value.Top)));
            }
          }
        }
        if (isReferenceResult) {
          parameterEquations.add(new Equation<Key,Value>(new Key(method,new Out()),new Final<Key,Value>(Value.Top)));
        }
      }
    }
  }
,0);
  return new ClassEquations(parameterEquations,contractEquations);
}
