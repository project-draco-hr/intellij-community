{
  PsiReferenceExpression methodExpression=call.getMethodExpression();
  PsiType theOnly=null;
  final JavaResolveResult[] results=methodExpression.multiResolve(false);
  LanguageLevel languageLevel=PsiUtil.getLanguageLevel(call);
  final PsiExpressionList parentArgList;
  if (languageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {
    final PsiElement callParent=PsiUtil.skipParenthesizedExprUp(call.getParent());
    parentArgList=callParent instanceof PsiConditionalExpression && !PsiPolyExpressionUtil.isPolyExpression((PsiExpression)callParent) ? null : PsiTreeUtil.getParentOfType(call,PsiExpressionList.class);
  }
 else {
    parentArgList=null;
  }
  final MethodCandidateInfo.CurrentCandidateProperties properties=MethodCandidateInfo.getCurrentMethod(parentArgList);
  final boolean genericMethodCall=properties != null && properties.getInfo().isToInferApplicability();
  for (int i=0; i < results.length; i++) {
    final JavaResolveResult candidateInfo=results[i];
    if (genericMethodCall && PsiPolyExpressionUtil.isMethodCallPolyExpression(call,(PsiMethod)candidateInfo.getElement())) {
      LOG.error("poly expression evaluation during overload resolution");
    }
    final PsiType type=getResultType(call,methodExpression,candidateInfo,languageLevel);
    if (type == null) {
      return null;
    }
    if (i == 0) {
      theOnly=type;
    }
 else     if (!theOnly.equals(type)) {
      return null;
    }
  }
  return PsiClassImplUtil.correctType(theOnly,call.getResolveScope());
}
