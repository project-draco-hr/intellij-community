{
  final HintManagerImpl hintManager=HintManagerImpl.getInstanceImpl();
  boolean needDelay=false;
  if (myEditorPreviewHint == null) {
    needDelay=true;
    final JPanel editorFragmentPreviewPanel=new JPanel(){
      private static final int R=6;
      private static final int LEFT_INDENT=BalloonImpl.ARC;
      @Override public Dimension getPreferredSize(){
        int width=myEditor.getGutterComponentEx().getWidth();
        width+=Math.min(myEditor.getScrollingModel().getVisibleArea().width,myEditor.getContentComponent().getWidth());
        if (UISettings.getInstance().HIDE_TOOL_STRIPES)         width-=2;
        return new Dimension(width - BalloonImpl.POINTER_WIDTH - LEFT_INDENT,myEditor.getLineHeight() * (myEndLine - myStartLine));
      }
      @Override protected void paintComponent(      Graphics g){
        if (myLine == -1)         return;
        Dimension size=getPreferredSize();
        EditorGutterComponentEx gutterComponentEx=myEditor.getGutterComponentEx();
        int gutterWidth=gutterComponentEx.getWidth();
        if (myCacheLevel2 == null || myCacheStartLine > myStartLine || myCacheEndLine < myEndLine) {
          int oldCacheLineCount=myCacheEndLine - myCacheStartLine;
          myCacheStartLine=Math.max(0,myLine - myCachePreviewLines);
          myCacheEndLine=Math.min(myEditor.getDocument().getLineCount() - 1,myLine + myCachePreviewLines + 1);
          if (myCacheLevel2 == null || oldCacheLineCount != (myCacheEndLine - myCacheStartLine)) {
            myCacheLevel2=UIUtil.createImage(size.width,myEditor.getLineHeight() * 2 * myCachePreviewLines + 1,BufferedImage.TYPE_INT_RGB);
          }
          Graphics2D cg=myCacheLevel2.createGraphics();
          final AffineTransform t=cg.getTransform();
          UISettings.setupAntialiasing(cg);
          int lineShift=-myEditor.getLineHeight() * myCacheStartLine;
          AffineTransform translateInstance=AffineTransform.getTranslateInstance(0,lineShift);
          translateInstance.preConcatenate(t);
          cg.setTransform(translateInstance);
          cg.setClip(0,0,gutterWidth,myCacheLevel2.getHeight());
          gutterComponentEx.paint(cg);
          translateInstance=AffineTransform.getTranslateInstance(gutterWidth,lineShift);
          translateInstance.preConcatenate(t);
          cg.setTransform(translateInstance);
          EditorComponentImpl contentComponent=myEditor.getContentComponent();
          cg.setClip(0,0,contentComponent.getWidth(),myCacheLevel2.getHeight());
          contentComponent.paint(cg);
        }
        if (myCacheLevel1 == null) {
          myCacheLevel1=UIUtil.createImage(size.width,myEditor.getLineHeight() * (2 * myPreviewLines + 1),BufferedImage.TYPE_INT_RGB);
          isDirty=true;
        }
        if (isDirty) {
          myRelativeY=SwingUtilities.convertPoint(this,0,0,myEditor.getScrollPane()).y;
          Graphics2D g2d=myCacheLevel1.createGraphics();
          final AffineTransform transform=g2d.getTransform();
          UISettings.setupAntialiasing(g2d);
          GraphicsUtil.setupAAPainting(g2d);
          g2d.setColor(myEditor.getBackgroundColor());
          g2d.fillRect(0,0,getWidth(),getHeight());
          AffineTransform translateInstance=AffineTransform.getTranslateInstance(-LEFT_INDENT + gutterWidth,myEditor.getLineHeight() * (myCacheStartLine - myStartLine));
          translateInstance.preConcatenate(transform);
          g2d.setTransform(translateInstance);
          UIUtil.drawImage(g2d,myCacheLevel2,-gutterWidth,0,null);
          TIntIntHashMap rightEdges=new TIntIntHashMap();
          int h=myEditor.getLineHeight() - 2;
          for (          RangeHighlighterEx ex : myHighlighters) {
            int hEndOffset=ex.getAffectedAreaEndOffset();
            Object tooltip=ex.getErrorStripeTooltip();
            if (tooltip == null)             continue;
            String s=String.valueOf(tooltip);
            if (s.isEmpty())             continue;
            LogicalPosition logicalPosition=myEditor.offsetToLogicalPosition(hEndOffset);
            int endOfLineOffset=myEditor.getDocument().getLineEndOffset(logicalPosition.line);
            logicalPosition=myEditor.offsetToLogicalPosition(endOfLineOffset);
            Point placeToShow=myEditor.logicalPositionToXY(logicalPosition);
            logicalPosition=myEditor.xyToLogicalPosition(placeToShow);
            placeToShow.x+=R * 3 / 2;
            placeToShow.y-=myCacheStartLine * myEditor.getLineHeight();
            int w=g2d.getFontMetrics().stringWidth(s);
            int a=g2d.getFontMetrics().getAscent();
            int rightEdge=rightEdges.get(logicalPosition.line);
            placeToShow.x=Math.max(placeToShow.x,rightEdge);
            rightEdge=Math.max(rightEdge,placeToShow.x + w + 3 * R);
            rightEdges.put(logicalPosition.line,rightEdge);
            g2d.setColor(MessageType.WARNING.getPopupBackground());
            g2d.fillRoundRect(placeToShow.x,placeToShow.y,w + 2 * R,h,R,R);
            g2d.setColor(new JBColor(JBColor.GRAY,Gray._200));
            g2d.drawRoundRect(placeToShow.x,placeToShow.y,w + 2 * R,h,R,R);
            g2d.setColor(JBColor.foreground());
            g2d.drawString(s,placeToShow.x + R,placeToShow.y - g2d.getFontMetrics().getDescent() + R / 2 + a);
          }
          isDirty=false;
        }
        UIUtil.drawImage(g,myCacheLevel1,0,0,this);
        if (UIUtil.isUnderDarcula()) {
          GraphicsUtil.setupAAPainting(g);
          Shape s=new Rectangle(0,0,size.width,size.height);
          Graphics2D g2=(Graphics2D)g;
          double cx=size.width / 2;
          double cy=0;
          double rx=size.width / 10;
          int ry=myEditor.getLineHeight() * 3 / 2;
          g2.setPaint(new GradientPaint(0,0,new Color(255,255,255,135),0,ry,new Color(255,255,255,40)));
          double pseudoMajorAxis=size.width - rx * 9 / 5;
          Shape topShape1=new Ellipse2D.Double(cx - rx - pseudoMajorAxis / 2,cy - ry,2 * rx,2 * ry);
          Shape topShape2=new Ellipse2D.Double(cx - rx + pseudoMajorAxis / 2,cy - ry,2 * rx,2 * ry);
          Area topArea=new Area(topShape1);
          topArea.add(new Area(topShape2));
          topArea.add(new Area(new Rectangle.Double(cx - pseudoMajorAxis / 2,cy,pseudoMajorAxis,ry)));
          g2.fill(topArea);
          Area bottomArea=new Area(s);
          bottomArea.subtract(topArea);
          g2.setPaint(new GradientPaint(0,size.height - ry,new Color(0,0,0,10),0,size.height,new Color(255,255,255,30)));
          g2.fill(bottomArea);
        }
      }
    }
;
    myEditorPreviewHint=new LightweightHint(editorFragmentPreviewPanel){
      @Override public void hide(      boolean ok){
        super.hide(ok);
        myCacheLevel1=null;
        if (myCacheLevel2 != null) {
          myCacheLevel2=null;
          myCacheStartLine=-1;
          myCacheEndLine=-1;
        }
        myDelayed=false;
      }
    }
;
  }
  Point point=new Point(hintInfo.getOriginalPoint());
  hintInfo.setTextBg(myEditor.getColorsScheme().getDefaultBackground());
  hintInfo.setBorderColor(new JBColor(Gray._0,Gray._111));
  point=SwingUtilities.convertPoint(((EditorImpl)editor).getVerticalScrollBar(),point,myEditor.getComponent().getRootPane());
  myPointHolder.set(point);
  myHintHolder.set(hintInfo);
  if (needDelay) {
    myDelayed=true;
    Alarm alarm=new Alarm();
    alarm.addRequest(new Runnable(){
      @Override public void run(){
        if (myEditorPreviewHint == null || !myDelayed)         return;
        hintManager.showEditorHint(myEditorPreviewHint,myEditor,myPointHolder.get(),HintManager.HIDE_BY_ANY_KEY | HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_MOUSEOVER| HintManager.HIDE_BY_ESCAPE| HintManager.HIDE_BY_SCROLLING,0,false,myHintHolder.get());
        myDelayed=false;
      }
    }
,Registry.intValue("ide.tooltip.initialDelay"));
  }
 else   if (!myDelayed) {
    hintManager.showEditorHint(myEditorPreviewHint,myEditor,point,HintManager.HIDE_BY_ANY_KEY | HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_MOUSEOVER| HintManager.HIDE_BY_ESCAPE| HintManager.HIDE_BY_SCROLLING,0,false,hintInfo);
  }
  return myEditorPreviewHint;
}
