{
  tracer.addMapping(bytecode);
  if (exitType == EXIT_RETURN) {
    TextBuffer buffer=new TextBuffer("return");
    if (retType.type != CodeConstants.TYPE_VOID) {
      buffer.append(' ');
      ExprProcessor.getCastedExprent(value,retType,buffer,indent,false,tracer);
    }
    return buffer;
  }
 else {
    MethodWrapper method=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
    ClassNode node=((ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE));
    if (method != null && node != null) {
      StructExceptionsAttribute attr=(StructExceptionsAttribute)method.methodStruct.getAttributes().getWithKey("Exceptions");
      if (attr != null) {
        String classname=null;
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          String exClassName=attr.getExcClassname(i,node.classStruct.getPool());
          if ("java/lang/Throwable".equals(exClassName)) {
            classname=exClassName;
            break;
          }
 else           if ("java/lang/Exception".equals(exClassName)) {
            classname=exClassName;
          }
        }
        if (classname != null) {
          VarType exType=new VarType(classname,true);
          TextBuffer buffer=new TextBuffer("throw ");
          ExprProcessor.getCastedExprent(value,exType,buffer,indent,false,tracer);
          return buffer;
        }
      }
    }
    return value.toJava(indent,tracer).prepend("throw ");
  }
}
