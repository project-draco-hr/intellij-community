{
  if (!CodeInsightSettings.getInstance().INDENT_TO_CARET_ON_PASTE) {
    return text;
  }
  final CodeStyleSettings codeStyleSettings=CodeStyleSettingsManager.getSettings(project);
  final boolean useTabs=codeStyleSettings.useTabCharacter(PythonFileType.INSTANCE);
  final int indentSize=codeStyleSettings.getIndentSize(PythonFileType.INSTANCE);
  CharFilter NOT_INDENT_FILTER=new CharFilter(){
    public boolean accept(    char ch){
      return useTabs ? ch != '\t' : ch != ' ';
    }
  }
;
  final String indentChar=useTabs ? "\t" : " ";
  final CaretModel caretModel=editor.getCaretModel();
  final SelectionModel selectionModel=editor.getSelectionModel();
  final Document document=editor.getDocument();
  final int caretOffset=selectionModel.getSelectionStart() != selectionModel.getSelectionEnd() ? selectionModel.getSelectionStart() : caretModel.getOffset();
  final int lineNumber=document.getLineNumber(caretOffset);
  final int lineStartOffset=getLineStartSafeOffset(document,lineNumber);
  text=addLeadingSpaces(text,NOT_INDENT_FILTER,indentSize,indentChar);
  final String indentText=getIndentText(file,document,caretOffset,lineNumber);
  int toRemove=calculateIndentToRemove(text,NOT_INDENT_FILTER);
  if (StringUtil.isEmptyOrSpaces(indentText) && isApplicable(file,text,caretOffset)) {
    caretModel.moveToOffset(lineStartOffset);
    editor.getSelectionModel().setSelection(lineStartOffset,selectionModel.getSelectionEnd());
  }
  final List<String> strings=StringUtil.split(text,"\n",false);
  String newText="";
  if (StringUtil.isEmptyOrSpaces(indentText)) {
    for (    String s : strings) {
      newText+=indentText + StringUtil.trimStart(s,StringUtil.repeat(indentChar,toRemove));
    }
  }
 else {
    newText=text;
  }
  String toString=document.getText(TextRange.create(lineStartOffset,document.getLineEndOffset(lineNumber)));
  if (addLinebreak(text,toString,useTabs) && selectionModel.getSelectionStart() == selectionModel.getSelectionEnd())   newText+="\n";
  return newText;
}
