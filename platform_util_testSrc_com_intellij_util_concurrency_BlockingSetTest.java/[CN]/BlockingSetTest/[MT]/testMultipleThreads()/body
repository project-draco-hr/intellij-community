{
  final BlockingSet<String> lock=new BlockingSet<String>();
  int threads=10;
  int tasks=10000;
  ExecutorService service=Executors.newFixedThreadPool(threads);
  List<Callable<Void>> taskList=new ArrayList<Callable<Void>>(tasks);
  final AtomicBoolean check=new AtomicBoolean(false);
  for (int i=0; i < tasks; i++) {
    taskList.add(new Callable<Void>(){
      @Override public Void call() throws Exception {
        lock.put("key");
        try {
          Assert.assertFalse(check.get());
          check.set(true);
          Thread.sleep(1);
          check.set(false);
        }
  finally {
          lock.remove("key");
        }
        return null;
      }
    }
);
  }
  List<Future<Void>> futures=service.invokeAll(taskList);
  service.shutdown();
  for (  Future<Void> future : futures) {
    future.get();
  }
  Assert.assertTrue(service.awaitTermination(100,TimeUnit.SECONDS));
}
