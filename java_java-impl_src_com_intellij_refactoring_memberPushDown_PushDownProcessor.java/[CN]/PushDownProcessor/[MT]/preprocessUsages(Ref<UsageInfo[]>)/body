{
  final UsageInfo[] usagesIn=refUsages.get();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(myClass,myMemberInfos);
  pushDownConflicts.checkSourceClassConflicts();
  if (usagesIn.length == 0) {
    if (myClass.isEnum() || myClass.hasModifierProperty(PsiModifier.FINAL)) {
      if (Messages.showOkCancelDialog((myClass.isEnum() ? "Enum " + myClass.getQualifiedName() + " doesn't have constants to inline to. " : "Final class " + myClass.getQualifiedName() + "does not have inheritors. ") + "Pushing members down will result in them being deleted. " + "Would you like to proceed?",JavaPushDownHandler.REFACTORING_NAME,Messages.getWarningIcon()) != Messages.OK) {
        return false;
      }
    }
 else {
      String noInheritors=myClass.isInterface() ? RefactoringBundle.message("interface.0.does.not.have.inheritors",myClass.getQualifiedName()) : RefactoringBundle.message("class.0.does.not.have.inheritors",myClass.getQualifiedName());
      final String message=noInheritors + "\n" + RefactoringBundle.message("push.down.will.delete.members");
      final int answer=Messages.showYesNoCancelDialog(message,JavaPushDownHandler.REFACTORING_NAME,Messages.getWarningIcon());
      if (answer == Messages.YES) {
        myCreateClassDlg=CreateSubclassAction.chooseSubclassToCreate(myClass);
        if (myCreateClassDlg != null) {
          pushDownConflicts.checkTargetClassConflicts(null,false,myCreateClassDlg.getTargetDirectory());
          return showConflicts(pushDownConflicts.getConflicts(),usagesIn);
        }
 else {
          return false;
        }
      }
 else       if (answer != Messages.NO)       return false;
    }
  }
  Runnable runnable=new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          for (          UsageInfo usage : usagesIn) {
            final PsiElement element=usage.getElement();
            if (element instanceof PsiClass) {
              pushDownConflicts.checkTargetClassConflicts((PsiClass)element,usagesIn.length > 1,element);
            }
          }
        }
      }
);
    }
  }
;
  if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable,RefactoringBundle.message("detecting.possible.conflicts"),true,myProject)) {
    return false;
  }
  for (  UsageInfo info : usagesIn) {
    final PsiElement element=info.getElement();
    if (element instanceof PsiFunctionalExpression) {
      pushDownConflicts.getConflicts().putValue(element,RefactoringBundle.message("functional.interface.broken"));
    }
  }
  final PsiAnnotation annotation=AnnotationUtil.findAnnotation(myClass,CommonClassNames.JAVA_LANG_FUNCTIONAL_INTERFACE);
  if (annotation != null && isMoved(LambdaUtil.getFunctionalInterfaceMethod(myClass))) {
    pushDownConflicts.getConflicts().putValue(annotation,RefactoringBundle.message("functional.interface.broken"));
  }
  return showConflicts(pushDownConflicts.getConflicts(),usagesIn);
}
