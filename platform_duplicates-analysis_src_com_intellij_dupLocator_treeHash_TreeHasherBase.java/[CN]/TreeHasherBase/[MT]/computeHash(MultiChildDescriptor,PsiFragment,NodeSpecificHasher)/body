{
  final PsiElement[] elements=childDescriptor.getElements();
  if (elements == null) {
    return new Pair<Integer,Integer>(0,0);
  }
switch (childDescriptor.getType()) {
case OPTIONALLY_IN_PATTERN:
case DEFAULT:
    TreeHashResult[] childResults=computeHashes(elements,parentFragment,nodeSpecificHasher);
  int[] hashes=getHashes(childResults);
int[] costs=getCosts(childResults);
int hash=AbstractTreeHasher.vector(hashes,31);
int cost=AbstractTreeHasher.vector(costs);
return new Pair<Integer,Integer>(hash,cost);
case IN_ANY_ORDER:
childResults=computeHashes(elements,parentFragment,nodeSpecificHasher);
hashes=getHashes(childResults);
costs=getCosts(childResults);
hash=AbstractTreeHasher.vector(hashes);
cost=AbstractTreeHasher.vector(costs);
return new Pair<Integer,Integer>(hash,cost);
default :
return new Pair<Integer,Integer>(0,0);
}
}
