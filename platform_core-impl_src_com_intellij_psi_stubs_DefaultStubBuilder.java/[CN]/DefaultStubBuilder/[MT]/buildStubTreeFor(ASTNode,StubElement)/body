{
  Stack<StubElement> parentStubs=new Stack<StubElement>();
  Stack<ASTNode> parentNodes=new Stack<ASTNode>();
  BooleanStack parentNodesStubbed=new BooleanStack();
  parentNodes.push(root);
  parentStubs.push(parentStub);
  parentNodesStubbed.push(true);
  while (!parentStubs.isEmpty()) {
    StubElement stub=parentStubs.pop();
    ASTNode node=parentNodes.pop();
    boolean immediateParentStubbed=parentNodesStubbed.pop();
    IElementType nodeType=node.getElementType();
    boolean hasStub=node == root;
    if (nodeType instanceof IStubElementType) {
      final IStubElementType type=(IStubElementType)nodeType;
      if (type.shouldCreateStub(node)) {
        PsiElement element=node.getPsi();
        if (!(element instanceof StubBasedPsiElement)) {
          LOG.error("Non-StubBasedPsiElement requests stub creation. Stub type: " + type + ", PSI: "+ element);
        }
        @SuppressWarnings("unchecked") StubElement s=type.createStub(element,stub);
        if (!immediateParentStubbed) {
          ((ObjectStubBase)s).markDangling();
        }
        stub=s;
        hasStub=true;
        LOG.assertTrue(stub != null,element);
      }
    }
    for (ASTNode childNode=node.getLastChildNode(); childNode != null; childNode=childNode.getTreePrev()) {
      if (!skipChildProcessingWhenBuildingStubs(node,childNode)) {
        parentNodes.push(childNode);
        parentStubs.push(stub);
        parentNodesStubbed.push(hasStub);
      }
    }
  }
  return parentStub;
}
