{
  final AlienDirtyScope dirtyScope=new AlienDirtyScope();
  if (myMergeTarget != null) {
    dirtyScope.addDir(myMergeTarget);
  }
 else {
    UpdateFilesHelper.iterateFileGroupFiles(myAccomulatedFiles.getUpdatedFiles(),new UpdateFilesHelper.Callback(){
      public void onFile(      final String filePath,      final String groupId){
        final FilePath file=FilePathImpl.create(new File(filePath));
        dirtyScope.addFile(file);
      }
    }
);
  }
  new Task.Backgroundable(myVcs.getProject(),SvnBundle.message("action.Subversion.integrate.changes.collecting.changes.to.commit.task.title")){
    private final GatheringChangelistBuilder changesBuilder=new GatheringChangelistBuilder(myVcs,myAccomulatedFiles);
    private final Ref<String> caughtError=new Ref<String>();
    @Override public void run(    @NotNull ProgressIndicator indicator){
      indicator.setIndeterminate(true);
      if (!myVcs.getProject().isDisposed()) {
        final SvnChangeProvider provider=new SvnChangeProvider(myVcs);
        try {
          provider.getChanges(dirtyScope,changesBuilder,indicator,null);
        }
 catch (        VcsException e) {
          caughtError.set(SvnBundle.message("action.Subversion.integrate.changes.error.unable.to.collect.changes.text",e.getMessage()));
        }
      }
    }
    @Override public void onSuccess(){
      if (!caughtError.isNull()) {
        VcsBalloonProblemNotifier.showOverVersionControlView(myVcs.getProject(),caughtError.get(),MessageType.ERROR);
      }
 else       if (!changesBuilder.getChanges().isEmpty()) {
        CommitChangeListDialog.commitAlienChanges(myProject,changesBuilder.getChanges(),myVcs,myMerger.getComment(),myMerger.getComment());
      }
    }
  }
.queue();
}
