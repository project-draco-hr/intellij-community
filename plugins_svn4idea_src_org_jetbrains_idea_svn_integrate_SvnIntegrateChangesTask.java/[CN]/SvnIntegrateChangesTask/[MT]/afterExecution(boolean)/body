{
  if (!myRecentlyUpdatedFiles.isEmpty()) {
    myResolveWorker.execute(myRecentlyUpdatedFiles);
  }
  final boolean haveConflicts=ResolveWorker.haveUnresolvedConflicts(myRecentlyUpdatedFiles);
  accumulate();
  if ((!myMerger.hasNext()) || haveConflicts || (!myExceptions.isEmpty())|| myAccumulatedFiles.containErrors()|| wasCanceled) {
    initMergeTarget();
    if (myAccumulatedFiles.isEmpty() && myExceptions.isEmpty() && (myMergeTarget == null)&& (!wasCanceled)) {
      Messages.showMessageDialog(SvnBundle.message("action.Subversion.integrate.changes.message.files.up.to.date.text"),myTitle,Messages.getInformationIcon());
    }
 else {
      if (haveConflicts) {
        myExceptions.add(createWarning(SvnBundle.message("svn.integrate.changelist.warning.unresolved.conflicts.text")));
      }
      if (wasCanceled) {
        myExceptions.add(createWarning("Integration was canceled",myMerger.getSkipped()));
      }
      finishActions(wasCanceled);
    }
    myMerger.afterProcessing();
  }
 else {
    stepToNextChangeList();
  }
}
