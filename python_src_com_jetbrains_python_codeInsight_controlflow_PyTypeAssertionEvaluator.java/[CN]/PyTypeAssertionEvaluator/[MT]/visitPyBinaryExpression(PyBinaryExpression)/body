{
  final PyExpression lhs=node.getLeftExpression();
  final PyExpression rhs=node.getRightExpression();
  if (node.isOperator("isnot")) {
    if (lhs instanceof PyReferenceExpression && rhs instanceof PyReferenceExpression) {
      final PyReferenceExpression target=(PyReferenceExpression)lhs;
      if (PyNames.NONE.equals(rhs.getName())) {
        final boolean positive=myPositive;
        pushAssertion(target,new InstructionTypeCallback(){
          @Override public PyType getType(          TypeEvalContext context,          @Nullable PsiElement anchor){
            final List<PyType> types=new ArrayList<>();
            types.add(PyNoneType.INSTANCE);
            return createAssertionType(context.getType(target),types,!positive,context);
          }
        }
);
        return;
      }
    }
  }
  final Object leftValue=PyConstantExpressionEvaluator.evaluate(lhs);
  final Object rightValue=PyConstantExpressionEvaluator.evaluate(rhs);
  if (leftValue instanceof Boolean && rightValue instanceof Boolean) {
    return;
  }
  if (node.isOperator(PyNames.IS) && (leftValue == Boolean.FALSE || rightValue == Boolean.FALSE) || node.isOperator("isnot") && (leftValue == Boolean.TRUE || rightValue == Boolean.TRUE)) {
    myPositive=!myPositive;
    super.visitPyBinaryExpression(node);
    myPositive=!myPositive;
    return;
  }
  super.visitPyBinaryExpression(node);
}
