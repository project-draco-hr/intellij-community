{
  final PyExpression lhs=node.getLeftExpression();
  final PyExpression rhs=node.getRightExpression();
  if (lhs instanceof PyReferenceExpression && rhs instanceof PyReferenceExpression) {
    final boolean leftIsNone=PyNames.NONE.equals(lhs.getName());
    final boolean rightIsNone=PyNames.NONE.equals(rhs.getName());
    if (leftIsNone && rightIsNone) {
      return;
    }
    final PyReferenceExpression target=(PyReferenceExpression)(rightIsNone ? lhs : rhs);
    final boolean positive=myPositive;
    if (node.isOperator(PyNames.IS)) {
      pushAssertion(target,new InstructionTypeCallback(){
        @Override public PyType getType(        TypeEvalContext context,        @Nullable PsiElement anchor){
          final List<PyType> types=new ArrayList<>();
          types.add(PyNoneType.INSTANCE);
          return createAssertionType(context.getType(target),types,positive,context);
        }
      }
);
      return;
    }
    if (node.isOperator("isnot")) {
      pushAssertion(target,new InstructionTypeCallback(){
        @Override public PyType getType(        TypeEvalContext context,        @Nullable PsiElement anchor){
          final List<PyType> types=new ArrayList<>();
          types.add(PyNoneType.INSTANCE);
          return createAssertionType(context.getType(target),types,!positive,context);
        }
      }
);
      return;
    }
  }
  final Object leftValue=PyConstantExpressionEvaluator.evaluate(lhs);
  final Object rightValue=PyConstantExpressionEvaluator.evaluate(rhs);
  if (leftValue instanceof Boolean && rightValue instanceof Boolean) {
    return;
  }
  if (node.isOperator(PyNames.IS) && (leftValue == Boolean.FALSE || rightValue == Boolean.FALSE) || node.isOperator("isnot") && (leftValue == Boolean.TRUE || rightValue == Boolean.TRUE)) {
    myPositive=!myPositive;
    super.visitPyBinaryExpression(node);
    myPositive=!myPositive;
    return;
  }
  super.visitPyBinaryExpression(node);
}
