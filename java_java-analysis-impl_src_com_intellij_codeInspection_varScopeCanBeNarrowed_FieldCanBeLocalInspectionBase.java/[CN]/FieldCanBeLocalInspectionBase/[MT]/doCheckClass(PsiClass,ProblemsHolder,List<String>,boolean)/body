{
  if (aClass.isInterface())   return;
  final PsiField[] fields=aClass.getFields();
  final Set<PsiField> candidates=new LinkedHashSet<PsiField>();
  for (  PsiField field : fields) {
    if (AnnotationUtil.isAnnotated(field,excludeAnnos)) {
      continue;
    }
    if (field.hasModifierProperty(PsiModifier.PRIVATE) && !(field.hasModifierProperty(PsiModifier.STATIC) && field.hasModifierProperty(PsiModifier.FINAL))) {
      candidates.add(field);
    }
  }
  removeFieldsReferencedFromInitializers(aClass,candidates);
  if (candidates.isEmpty())   return;
  final Set<PsiField> usedFields=new THashSet<PsiField>();
  removeReadFields(aClass,candidates,usedFields,ignoreFieldsUsedInMultipleMethods);
  if (candidates.isEmpty())   return;
  final ImplicitUsageProvider[] implicitUsageProviders=Extensions.getExtensions(ImplicitUsageProvider.EP_NAME);
  for (  final PsiField field : candidates) {
    if (usedFields.contains(field) && !hasImplicitReadOrWriteUsage(field,implicitUsageProviders)) {
      final String message=InspectionsBundle.message("inspection.field.can.be.local.problem.descriptor");
      final ArrayList<LocalQuickFix> fixes=new ArrayList<LocalQuickFix>();
      SpecialAnnotationsUtilBase.createAddToSpecialAnnotationFixes(field,new Processor<String>(){
        @Override public boolean process(        String qualifiedName){
          final LocalQuickFix quickFix=SpecialAnnotationsUtilBase.createAddToSpecialAnnotationsListQuickFix(InspectionGadgetsBundle.message("add.0.to.ignore.if.annotated.by.list.quickfix",qualifiedName),QuickFixBundle.message("fix.add.special.annotation.family"),EXCLUDE_ANNOS,qualifiedName,field);
          fixes.add(quickFix);
          return true;
        }
      }
);
      final LocalQuickFix fix=createFix();
      if (fix != null) {
        fixes.add(fix);
      }
      holder.registerProblem(field.getNameIdentifier(),message,fixes.toArray(new LocalQuickFix[fixes.size()]));
    }
  }
}
