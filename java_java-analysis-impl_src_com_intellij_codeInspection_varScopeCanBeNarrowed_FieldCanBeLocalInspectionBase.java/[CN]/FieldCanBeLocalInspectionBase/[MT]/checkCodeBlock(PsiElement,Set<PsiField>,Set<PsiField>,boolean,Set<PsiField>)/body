{
  try {
    final Ref<Collection<PsiVariable>> writtenVariables=new Ref<>();
    final ControlFlow controlFlow=ControlFlowFactory.getInstance(body.getProject()).getControlFlow(body,AllVariablesControlFlowPolicy.getInstance(),false,false);
    final List<PsiVariable> usedVars=ControlFlowUtil.getUsedVariables(controlFlow,0,controlFlow.getSize());
    for (    PsiVariable usedVariable : usedVars) {
      if (usedVariable instanceof PsiField) {
        final PsiField usedField=(PsiField)usedVariable;
        if (!getWrittenVariables(controlFlow,writtenVariables).contains(usedField)) {
          ignored.add(usedField);
        }
        if (!usedFields.add(usedField) && (ignoreFieldsUsedInMultipleMethods || ignored.contains(usedField))) {
          candidates.remove(usedField);
        }
      }
    }
    if (candidates.isEmpty())     return;
    final List<PsiReferenceExpression> readBeforeWrites=ControlFlowUtil.getReadBeforeWrite(controlFlow);
    for (    final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {
      final PsiElement resolved=readBeforeWrite.resolve();
      if (resolved instanceof PsiField) {
        final PsiField field=(PsiField)resolved;
        if (!isImmutableState(field.getType()) || !PsiUtil.isConstantExpression(field.getInitializer()) || getWrittenVariables(controlFlow,writtenVariables).contains(field)) {
          PsiElement parent=body.getParent();
          if (!(parent instanceof PsiMethod) || !((PsiMethod)parent).isConstructor() || field.getInitializer() == null || field.hasModifierProperty(PsiModifier.STATIC) || !PsiTreeUtil.isAncestor(((PsiMethod)parent).getContainingClass(),field,true)) {
            candidates.remove(field);
          }
        }
      }
    }
  }
 catch (  AnalysisCanceledException e) {
    candidates.clear();
  }
}
