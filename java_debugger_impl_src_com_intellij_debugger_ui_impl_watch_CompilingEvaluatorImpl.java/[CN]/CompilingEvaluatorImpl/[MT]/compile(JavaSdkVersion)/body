{
  final Pair<Sdk,JavaSdkVersion> runtime=BuildManager.getBuildProcessRuntimeSdk(myEvaluationContext.getProject());
  final Module module=ApplicationManager.getApplication().runReadAction(new Computable<Module>(){
    @Override public Module compute(){
      return ModuleUtilCore.findModuleForPsiElement(myPsiContext);
    }
  }
);
  String javaHome=null;
  final Sdk sdk=runtime.getFirst();
  final SdkTypeId type=sdk.getSdkType();
  if (type instanceof JavaSdkType) {
    javaHome=sdk.getHomePath();
  }
  if (javaHome == null) {
    throw new EvaluateException("Was not able to determine JDK for current evaluation context");
  }
  final List<String> options=new ArrayList<String>();
  options.add("-proc:none");
  options.add("-encoding");
  options.add("UTF-8");
  final List<File> platformClasspath=new ArrayList<File>();
  final List<File> classpath=new ArrayList<File>();
  if (module != null) {
    final ModuleRootManager rootManager=ModuleRootManager.getInstance(module);
    rootManager.orderEntries().compileOnly().recursively().exportedOnly().withoutSdk().getPathsList().addAllFiles(classpath);
    rootManager.orderEntries().compileOnly().sdkOnly().getPathsList().addAllFiles(platformClasspath);
    final String sourceOption=getSourceOption(ApplicationManager.getApplication().runReadAction(new Computable<LanguageLevel>(){
      public LanguageLevel compute(){
        return EffectiveLanguageLevelUtil.getEffectiveLanguageLevel(module);
      }
    }
));
    options.add("-source");
    options.add(sourceOption);
    String target=CompilerConfiguration.getInstance(module.getProject()).getBytecodeTargetLevel(module);
    if (target == null) {
      target=sourceOption;
    }
    options.add("-target");
    options.add(target);
  }
 else {
    if (debuggeeVersion != null) {
      String sourceOption;
      final JavaSdkVersion buildRuntimeVersion=runtime.getSecond();
      if (buildRuntimeVersion == null) {
        sourceOption=getSourceOption(debuggeeVersion.getMaxLanguageLevel());
      }
 else {
        final JavaSdkVersion minVersion=buildRuntimeVersion.ordinal() > debuggeeVersion.ordinal() ? debuggeeVersion : buildRuntimeVersion;
        sourceOption=getSourceOption(minVersion.getMaxLanguageLevel());
      }
      options.add("-source");
      options.add(sourceOption);
      options.add("-target");
      options.add(sourceOption);
    }
  }
  File sourceFile=null;
  final OutputCollector outputSink=new OutputCollector();
  try {
    final ExternalJavacManager javacManager=getJavacManager();
    if (javacManager == null) {
      throw new EvaluateException("Cannot compile java code");
    }
    sourceFile=generateTempSourceFile(javacManager.getWorkingDir());
    final File srcDir=sourceFile.getParentFile();
    final Map<File,Set<File>> output=Collections.singletonMap(srcDir,Collections.singleton(srcDir));
    DiagnosticCollector diagnostic=new DiagnosticCollector();
    final List<String> vmOptions=Collections.emptyList();
    final List<File> sourcePath=Collections.emptyList();
    final Set<File> sources=Collections.singleton(sourceFile);
    boolean compiledOK=javacManager.forkJavac(javaHome,-1,vmOptions,options,platformClasspath,classpath,sourcePath,sources,output,diagnostic,outputSink,new JavacCompilerTool(),CanceledStatus.NULL);
    if (!compiledOK) {
      final StringBuilder res=new StringBuilder("Compilation failed:\n");
      for (      Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) {
        if (d.getKind() == Diagnostic.Kind.ERROR) {
          res.append(d.getMessage(Locale.US));
        }
      }
      throw new EvaluateException(res.toString());
    }
  }
 catch (  EvaluateException e) {
    throw e;
  }
catch (  Exception e) {
    throw new EvaluateException(e.getMessage());
  }
 finally {
    if (sourceFile != null) {
      FileUtil.delete(sourceFile);
    }
  }
  return outputSink.getCompiledClasses();
}
