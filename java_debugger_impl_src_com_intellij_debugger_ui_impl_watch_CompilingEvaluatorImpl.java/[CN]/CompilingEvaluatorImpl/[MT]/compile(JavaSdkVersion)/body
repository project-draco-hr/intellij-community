{
  final Module module=ApplicationManager.getApplication().runReadAction(new Computable<Module>(){
    @Override public Module compute(){
      return ModuleUtilCore.findModuleForPsiElement(myPsiContext);
    }
  }
);
  final List<String> options=new ArrayList<>();
  options.add("-encoding");
  options.add("UTF-8");
  final List<File> platformClasspath=new ArrayList<>();
  final List<File> classpath=new ArrayList<>();
  AnnotationProcessingConfiguration profile=null;
  if (module != null) {
    profile=CompilerConfiguration.getInstance(module.getProject()).getAnnotationProcessingConfiguration(module);
    final ModuleRootManager rootManager=ModuleRootManager.getInstance(module);
    for (    String s : rootManager.orderEntries().compileOnly().recursively().exportedOnly().withoutSdk().getPathsList().getPathList()) {
      classpath.add(new File(s));
    }
    for (    String s : rootManager.orderEntries().compileOnly().sdkOnly().getPathsList().getPathList()) {
      platformClasspath.add(new File(s));
    }
  }
  JavaBuilder.addAnnotationProcessingOptions(options,profile);
  final Pair<Sdk,JavaSdkVersion> runtime=BuildManager.getJavacRuntimeSdk(myEvaluationContext.getProject());
  final JavaSdkVersion buildRuntimeVersion=runtime.getSecond();
  if (buildRuntimeVersion != null && debuggeeVersion != null) {
    final JavaSdkVersion minVersion=buildRuntimeVersion.ordinal() > debuggeeVersion.ordinal() ? debuggeeVersion : buildRuntimeVersion;
    final String sourceOption=getSourceOption(minVersion.getMaxLanguageLevel());
    options.add("-source");
    options.add(sourceOption);
    options.add("-target");
    options.add(sourceOption);
  }
  final CompilerManager compilerManager=CompilerManager.getInstance(myEvaluationContext.getProject());
  File sourceFile=null;
  try {
    sourceFile=generateTempSourceFile(compilerManager.getJavacCompilerWorkingDir());
    final File srcDir=sourceFile.getParentFile();
    final List<File> sourcePath=Collections.emptyList();
    final Set<File> sources=Collections.singleton(sourceFile);
    return compilerManager.compileJavaCode(options,platformClasspath,classpath,Collections.emptyList(),sourcePath,sources,srcDir);
  }
 catch (  CompilationException e) {
    final StringBuilder res=new StringBuilder("Compilation failed:\n");
    for (    CompilationException.Message m : e.getMessages()) {
      if (m.getCategory() == CompilerMessageCategory.ERROR) {
        res.append(m.getText()).append("\n");
      }
    }
    throw new EvaluateException(res.toString());
  }
catch (  Exception e) {
    throw new EvaluateException(e.getMessage());
  }
 finally {
    if (sourceFile != null) {
      FileUtil.delete(sourceFile);
    }
  }
}
