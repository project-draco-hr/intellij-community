{
  final Pair<Sdk,JavaSdkVersion> runtime=BuildManager.getBuildProcessRuntimeSdk(myEvaluationContext.getProject());
  final Module module=ApplicationManager.getApplication().runReadAction(new Computable<Module>(){
    @Override public Module compute(){
      return ModuleUtilCore.findModuleForPsiElement(myPsiContext);
    }
  }
);
  String javaHome=null;
  final Sdk sdk=runtime.getFirst();
  final SdkTypeId type=sdk.getSdkType();
  if (type instanceof JavaSdkType) {
    javaHome=sdk.getHomePath();
  }
  if (javaHome == null) {
    throw new EvaluateException("Was not able to determine JDK for current evaluation context");
  }
  final List<String> options=new ArrayList<String>();
  options.add("-proc:none");
  options.add("-encoding");
  options.add("UTF-8");
  final List<File> platformClasspath=new ArrayList<File>();
  final List<File> classpath=new ArrayList<File>();
  if (module != null) {
    final ModuleRootManager rootManager=ModuleRootManager.getInstance(module);
    for (    String s : rootManager.orderEntries().compileOnly().recursively().exportedOnly().withoutSdk().getPathsList().getPathList()) {
      classpath.add(new File(s));
    }
    for (    String s : rootManager.orderEntries().compileOnly().sdkOnly().getPathsList().getPathList()) {
      platformClasspath.add(new File(s));
    }
  }
  final JavaSdkVersion buildRuntimeVersion=runtime.getSecond();
  if (buildRuntimeVersion != null && debuggeeVersion != null) {
    final JavaSdkVersion minVersion=buildRuntimeVersion.ordinal() > debuggeeVersion.ordinal() ? debuggeeVersion : buildRuntimeVersion;
    final String sourceOption=getSourceOption(minVersion.getMaxLanguageLevel());
    options.add("-source");
    options.add(sourceOption);
    options.add("-target");
    options.add(sourceOption);
  }
  File sourceFile=null;
  final OutputCollector outputSink=new OutputCollector();
  try {
    final ExternalJavacManager javacManager=getJavacManager();
    if (javacManager == null) {
      throw new EvaluateException("Cannot compile java code");
    }
    sourceFile=generateTempSourceFile(javacManager.getWorkingDir());
    final File srcDir=sourceFile.getParentFile();
    final Map<File,Set<File>> output=Collections.singletonMap(srcDir,Collections.singleton(srcDir));
    DiagnosticCollector diagnostic=new DiagnosticCollector();
    final List<String> vmOptions=Collections.emptyList();
    final List<File> sourcePath=Collections.emptyList();
    final Set<File> sources=Collections.singleton(sourceFile);
    boolean compiledOK=javacManager.forkJavac(javaHome,-1,vmOptions,options,platformClasspath,classpath,sourcePath,sources,output,diagnostic,outputSink,new JavacCompilerTool(),CanceledStatus.NULL);
    if (!compiledOK) {
      final StringBuilder res=new StringBuilder("Compilation failed:\n");
      for (      Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) {
        if (d.getKind() == Diagnostic.Kind.ERROR) {
          res.append(d.getMessage(Locale.US));
        }
      }
      throw new EvaluateException(res.toString());
    }
  }
 catch (  EvaluateException e) {
    throw e;
  }
catch (  Exception e) {
    throw new EvaluateException(e.getMessage());
  }
 finally {
    if (sourceFile != null) {
      FileUtil.delete(sourceFile);
    }
  }
  return outputSink.getCompiledClasses();
}
