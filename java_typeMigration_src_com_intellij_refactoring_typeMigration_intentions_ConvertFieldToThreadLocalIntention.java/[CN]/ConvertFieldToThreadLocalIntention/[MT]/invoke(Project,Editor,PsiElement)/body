{
  final PsiField psiField=PsiTreeUtil.getParentOfType(element,PsiField.class);
  LOG.assertTrue(psiField != null);
  psiField.normalizeDeclaration();
  final Query<PsiReference> refs=ReferencesSearch.search(psiField);
  final Set<PsiElement> elements=new HashSet<PsiElement>();
  elements.add(element);
  for (  PsiReference reference : refs) {
    elements.add(reference.getElement());
  }
  if (!FileModificationService.getInstance().preparePsiElementsForWrite(elements))   return;
  final JavaPsiFacade psiFacade=JavaPsiFacade.getInstance(project);
  final PsiElementFactory factory=JavaPsiFacade.getElementFactory(project);
  final PsiType fromType=psiField.getType();
  final PsiClass threadLocalClass=psiFacade.findClass(ThreadLocal.class.getName(),GlobalSearchScope.allScope(project));
  if (threadLocalClass == null) {
    return;
  }
  final Map<PsiTypeParameter,PsiType> substitutor=ContainerUtil.newHashMap();
  final PsiTypeParameter[] typeParameters=threadLocalClass.getTypeParameters();
  if (typeParameters.length == 1) {
    PsiType type=fromType;
    if (fromType instanceof PsiPrimitiveType)     type=((PsiPrimitiveType)fromType).getBoxedType(element);
    substitutor.put(typeParameters[0],type);
  }
  final PsiClassType toType=factory.createType(threadLocalClass,factory.createSubstitutor(substitutor));
  try {
    final TypeMigrationRules rules=new TypeMigrationRules(fromType);
    rules.setMigrationRootType(toType);
    rules.setBoundScope(GlobalSearchScope.fileScope(element.getContainingFile()));
    final TypeMigrationLabeler labeler=new TypeMigrationLabeler(rules);
    labeler.getMigratedUsages(false,psiField);
    for (    PsiReference reference : refs) {
      PsiElement psiElement=reference.getElement();
      if (psiElement instanceof PsiExpression) {
        final PsiElement parent=psiElement.getParent();
        if (parent instanceof PsiExpression && !(parent instanceof PsiReferenceExpression || parent instanceof PsiPolyadicExpression)) {
          psiElement=parent;
        }
        final TypeConversionDescriptor conversion=ThreadLocalConversionRule.findDirectConversion(psiElement,toType,fromType,labeler);
        if (conversion != null) {
          TypeMigrationReplacementUtil.replaceExpression((PsiExpression)psiElement,project,conversion);
        }
      }
    }
    PsiExpression initializer=psiField.getInitializer();
    if (initializer != null) {
      if (initializer instanceof PsiArrayInitializerExpression) {
        PsiExpression normalizedExpr=RefactoringUtil.createNewExpressionFromArrayInitializer((PsiArrayInitializerExpression)initializer,psiField.getType());
        initializer=(PsiExpression)initializer.replace(normalizedExpr);
      }
      final TypeConversionDescriptor conversion=ThreadLocalConversionRule.wrapWithNewExpression(toType,fromType,initializer);
      TypeMigrationReplacementUtil.replaceExpression(initializer,project,conversion);
      CodeStyleManager.getInstance(project).reformat(psiField);
    }
 else     if (!assertNotNull(psiField.getModifierList()).hasModifierProperty(PsiModifier.FINAL)) {
      final String text="new " + PsiDiamondTypeUtil.getCollapsedType(toType,psiField) + "()";
      final PsiExpression newInitializer=factory.createExpressionFromText(text,psiField);
      psiField.setInitializer(newInitializer);
    }
    assertNotNull(psiField.getTypeElement()).replace(factory.createTypeElement(toType));
    final PsiModifierList modifierList=assertNotNull(psiField.getModifierList());
    modifierList.setModifierProperty(PsiModifier.FINAL,true);
    modifierList.setModifierProperty(PsiModifier.VOLATILE,false);
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
