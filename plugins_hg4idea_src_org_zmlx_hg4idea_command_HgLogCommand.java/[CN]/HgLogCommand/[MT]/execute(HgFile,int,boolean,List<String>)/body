{
  if ((limit <= 0 && limit != -1) || hgFile == null) {
    return Collections.emptyList();
  }
  String[] templates=constructTemplateArgument(includeFiles,myVersion);
  String template=HgChangesetUtil.makeTemplate(templates);
  int expectedItemCount=templates.length;
  boolean shouldParseOldTemplate=!myVersion.isBuiltInFunctionSupported();
  FilePath originalFileName=HgUtil.getOriginalFileName(hgFile.toFilePath(),ChangeListManager.getInstance(myProject));
  HgFile originalHgFile=new HgFile(hgFile.getRepo(),originalFileName);
  HgCommandResult result=execute(hgFile.getRepo(),template,limit,originalHgFile,argsForCmd);
  final List<HgFileRevision> revisions=new LinkedList<HgFileRevision>();
  if (result == null) {
    return revisions;
  }
  List<String> errors=result.getErrorLines();
  if (errors != null && !errors.isEmpty()) {
    if (result.getExitValue() != 0) {
      throw new HgCommandException(errors.toString());
    }
    LOG.warn(errors.toString());
  }
  String output=result.getRawOutput();
  String[] changeSets=output.split(HgChangesetUtil.CHANGESET_SEPARATOR);
  for (  String line : changeSets) {
    try {
      String[] attributes=line.split(HgChangesetUtil.ITEM_SEPARATOR);
      int numAttributes=attributes.length;
      if (!includeFiles && (numAttributes != expectedItemCount)) {
        LOG.debug("Wrong format. Skipping line " + line);
        continue;
      }
 else       if (includeFiles && (numAttributes < FILES_ADDED_INDEX)) {
        LOG.debug("Wrong format for long template. Skipping line " + line);
        continue;
      }
      String revisionString=attributes[REVISION_INDEX];
      String changeset=attributes[CHANGESET_INDEX];
      String parentsString=attributes[PARENTS_INDEX];
      List<HgRevisionNumber> parents=parseParentRevisions(parentsString,revisionString);
      Date revisionDate=DATE_FORMAT.parse(attributes[DATE_INDEX]);
      String author=attributes[AUTHOR_INDEX];
      String branchName=attributes[BRANCH_INDEX];
      String commitMessage=attributes[MESSAGE_INDEX];
      final HgRevisionNumber vcsRevisionNumber=new HgRevisionNumber(revisionString,changeset,author,commitMessage,parents);
      Set<String> filesAdded=Collections.emptySet();
      Set<String> filesModified=Collections.emptySet();
      Set<String> filesDeleted=Collections.emptySet();
      Map<String,String> copies=Collections.emptyMap();
      if (numAttributes > FILES_ADDED_INDEX) {
        filesAdded=parseFileList(attributes[FILES_ADDED_INDEX]);
        if (numAttributes > FILES_MODIFIED_INDEX) {
          filesModified=parseFileList(attributes[FILES_MODIFIED_INDEX]);
          if (numAttributes > FILES_DELETED_INDEX) {
            filesDeleted=parseFileList(attributes[FILES_DELETED_INDEX]);
            if (numAttributes > FILES_COPIED_INDEX) {
              copies=shouldParseOldTemplate ? parseCopiesFileListAsOldVersion(attributes[FILES_COPIED_INDEX]) : parseCopiesFileList(attributes[FILES_COPIED_INDEX]);
              Iterator<String> keys=copies.keySet().iterator();
              while (keys.hasNext()) {
                String s=keys.next();
                if (filesAdded.contains(copies.get(s)) && filesDeleted.contains(s)) {
                  filesAdded.remove(copies.get(s));
                  filesDeleted.remove(s);
                }
 else                 if (!filesDeleted.contains(s)) {
                  keys.remove();
                }
              }
            }
          }
        }
      }
      revisions.add(new HgFileRevision(myProject,hgFile,vcsRevisionNumber,branchName,revisionDate,author,commitMessage,filesModified,filesAdded,filesDeleted,copies));
    }
 catch (    NumberFormatException e) {
      LOG.warn("Error parsing rev in line " + line);
    }
catch (    ParseException e) {
      LOG.warn("Error parsing date in line " + line);
    }
  }
  return revisions;
}
