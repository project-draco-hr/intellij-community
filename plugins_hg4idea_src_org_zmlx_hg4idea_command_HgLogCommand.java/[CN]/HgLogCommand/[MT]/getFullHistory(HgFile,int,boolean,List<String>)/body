{
  if ((limit <= 0 && limit != -1) || hgFile == null) {
    return Collections.emptyList();
  }
  String template=HgChangesetUtil.makeTemplate(includeFiles ? LOG_TEMPLATE_ITEMS : SHORT_LOG_TEMPLATE_ITEMS);
  FilePath originalFileName=HgUtil.getOriginalFileName(hgFile.toFilePath(),ChangeListManager.getInstance(myProject));
  HgFile originalHgFile=new HgFile(hgFile.getRepo(),originalFileName);
  HgCommandResult result=execute(hgFile.getRepo(),template,limit,originalHgFile,argsForCmd);
  final List<HgFileRevision> revisions=new LinkedList<HgFileRevision>();
  if (result == null) {
    return revisions;
  }
  int P1_REV_INDEX=2;
  int P1_HASH_INDEX=3;
  int P2_REV_INDEX=4;
  int P2_HASH_INDEX=5;
  int DATE_INDEX=6;
  int AUTHOR_INDEX=7;
  int BRANCH_INDEX=8;
  int MESSAGE_INDEX=10;
  int ADDED_INDEX=11;
  int MODIFIED_INDEX=12;
  int DELETED_INDEX=13;
  int COPIED_INDEX=14;
  List<String> errors=result.getErrorLines();
  if (errors != null && !errors.isEmpty()) {
    throw new HgCommandException(errors.toString());
  }
  String output=result.getRawOutput();
  if (output.isEmpty()) {
    return revisions;
  }
  String[] changeSets=output.split(HgChangesetUtil.CHANGESET_SEPARATOR);
  for (  String line : changeSets) {
    try {
      String[] attributes=line.split(HgChangesetUtil.ITEM_SEPARATOR);
      int numAttributes=attributes.length;
      String revisionString=attributes[REVISION_INDEX];
      String changeset=attributes[CHANGESET_INDEX];
      String[] prevs={attributes[P1_REV_INDEX],attributes[P2_REV_INDEX]};
      String[] phashes={attributes[P1_HASH_INDEX],attributes[P2_HASH_INDEX]};
      List<HgRevisionNumber> parents=new ArrayList<HgRevisionNumber>(2);
      for (int i=0; i < prevs.length; ++i) {
        if (Integer.valueOf(prevs[i]) >= 0) {
          parents.add(HgRevisionNumber.getInstance(prevs[i],phashes[i]));
        }
      }
      Date revisionDate=DATE_FORMAT.parse(attributes[DATE_INDEX]);
      String author=attributes[AUTHOR_INDEX];
      String commitMessage=attributes[MESSAGE_INDEX];
      final HgRevisionNumber vcsRevisionNumber=new HgRevisionNumber(revisionString,changeset,author,commitMessage,parents);
      String branchName=attributes[BRANCH_INDEX];
      if (includeFiles && (numAttributes < ADDED_INDEX)) {
        LOG.debug("Wrong format for long template. Skipping line " + line);
        continue;
      }
      Set<String> filesAdded=Collections.emptySet();
      Set<String> filesModified=Collections.emptySet();
      Set<String> filesDeleted=Collections.emptySet();
      Map<String,String> copies=Collections.emptyMap();
      if (numAttributes > ADDED_INDEX) {
        filesAdded=parseFileList(attributes[ADDED_INDEX]);
        if (numAttributes > MODIFIED_INDEX) {
          filesModified=parseFileList(attributes[MODIFIED_INDEX]);
          if (numAttributes > DELETED_INDEX) {
            filesDeleted=parseFileList(attributes[DELETED_INDEX]);
            if (numAttributes > COPIED_INDEX) {
              copies=parseCopiesFileList(attributes[COPIED_INDEX]);
              Iterator<String> keys=copies.keySet().iterator();
              while (keys.hasNext()) {
                String s=keys.next();
                if (filesAdded.contains(copies.get(s)) && filesDeleted.contains(s)) {
                  filesAdded.remove(copies.get(s));
                  filesDeleted.remove(s);
                }
 else                 if (!filesDeleted.contains(s)) {
                  keys.remove();
                }
              }
            }
          }
        }
      }
      revisions.add(new HgFileRevision(myProject,hgFile,vcsRevisionNumber,branchName,revisionDate,author,commitMessage,filesModified,filesAdded,filesDeleted,copies));
    }
 catch (    NumberFormatException e) {
      LOG.warn("Error parsing rev in line " + line);
    }
catch (    ParseException e) {
      LOG.warn("Error parsing date in line " + line);
    }
  }
  return revisions;
}
