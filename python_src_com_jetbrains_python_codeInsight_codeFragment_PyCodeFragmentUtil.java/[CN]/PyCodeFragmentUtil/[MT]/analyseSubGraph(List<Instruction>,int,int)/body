{
  int returnSources=0;
  int regularSources=0;
  final Set<Instruction> targetInstructions=new HashSet<Instruction>();
  int starImports=0;
  for (  Pair<Instruction,Instruction> edge : getOutgoingEdges(subGraph)) {
    final Instruction sourceInstruction=edge.getFirst();
    final Instruction targetInstruction=edge.getSecond();
    final PsiElement source=sourceInstruction.getElement();
    final PsiElement target=targetInstruction.getElement();
    final PyReturnStatement returnStatement=PsiTreeUtil.getParentOfType(source,PyReturnStatement.class,false);
    final boolean isExceptTarget=target instanceof PyExceptPart || target instanceof PyFinallyPart;
    final boolean isLoopTarget=target instanceof PyWhileStatement || PyForStatementNavigator.getPyForStatementByIterable(target) != null;
    if (target != null && !isExceptTarget && !isLoopTarget) {
      targetInstructions.add(targetInstruction);
    }
    if (returnStatement != null && CodeFragmentUtil.getPosition(returnStatement,start,end) == Position.INSIDE) {
      returnSources++;
    }
 else     if (!isExceptTarget) {
      regularSources++;
    }
  }
  for (  Instruction instruction : subGraph) {
    final PsiElement element=instruction.getElement();
    if (element instanceof PyFromImportStatement) {
      final PyFromImportStatement fromImportStatement=(PyFromImportStatement)element;
      if (fromImportStatement.getStarImportElement() != null) {
        starImports++;
      }
    }
  }
  return new AnalysisResult(starImports,targetInstructions.size(),returnSources,regularSources);
}
