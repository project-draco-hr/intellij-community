{
  final int start=startInScope.getTextOffset();
  final int end=endInScope.getTextOffset() + endInScope.getTextLength();
  owner.acceptChildren(new PyRecursiveElementVisitor(){
    @Override public void visitPyClass(    final PyClass node){
      if (CodeFragmentUtil.getPosition(node,start,end) == Position.INSIDE) {
        throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.when.class.declaration.inside"));
      }
    }
    @Override public void visitPyFunction(    final PyFunction node){
      if (CodeFragmentUtil.getPosition(node,start,end) == Position.INSIDE) {
        throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.when.function.declaration.inside"));
      }
    }
    @Override public void visitPyFromImportStatement(    PyFromImportStatement node){
      if (CodeFragmentUtil.getPosition(node,start,end) == Position.INSIDE) {
        throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.when.from.import.inside"));
      }
    }
  }
);
  final HashSet<Instruction> outerInstructions=new HashSet<Instruction>();
  boolean returnInstructionInside=false;
  final Instruction[] flow=owner.getControlFlow().getInstructions();
  for (  Instruction instruction : flow) {
    final PsiElement element=instruction.getElement();
    if (element != null && CodeFragmentUtil.elementFit(element,start,end)) {
      if (element instanceof PyReturnStatement) {
        returnInstructionInside=true;
      }
      if (element instanceof PyBreakStatement && !CodeFragmentUtil.elementFit(((PyBreakStatement)element).getLoopStatement(),start,end)) {
        throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.break"));
      }
      if (element instanceof PyContinueStatement && !CodeFragmentUtil.elementFit(((PyContinueStatement)element).getLoopStatement(),start,end)) {
        throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.continue"));
      }
      for (      Instruction next : instruction.allSucc()) {
        if (next instanceof ConditionalInstruction) {
          continue;
        }
        final PsiElement nextElement=next.getElement();
        if (nextElement != null && PyBinaryExpressionNavigator.getBinaryExpressionByOperand(nextElement) != null) {
          continue;
        }
        if (nextElement instanceof PyExceptPart) {
          continue;
        }
        if (!CodeFragmentUtil.elementFit(nextElement,start,end)) {
          outerInstructions.add(next);
        }
      }
    }
  }
  if (outerInstructions.size() > 2) {
    throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.when.execution.flow.is.interrupted"));
  }
  if (outerInstructions.size() == 2) {
    boolean errorFound=true;
    for (    Instruction outerInstruction : outerInstructions) {
      if (outerInstruction instanceof ReadWriteInstruction && PyForStatementNavigator.getPyForStatementByIterable(outerInstruction.getElement()) != null) {
        errorFound=false;
        break;
      }
    }
    if (errorFound) {
      throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.when.execution.flow.is.interrupted"));
    }
  }
  final PyCodeFragmentBuilder builder=new PyCodeFragmentBuilder(owner,start,end);
  owner.acceptChildren(builder);
  return new CodeFragment(builder.inElements,builder.outElements,returnInstructionInside);
}
