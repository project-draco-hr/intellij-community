{
  final int start=startInScope.getTextOffset();
  final int end=endInScope.getTextOffset() + endInScope.getTextLength();
  final ControlFlow flow=ControlFlowCache.getControlFlow(owner);
  if (flow == null) {
    throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.undetermined.execution.flow"));
  }
  final List<Instruction> graph=Arrays.asList(flow.getInstructions());
  final List<Instruction> subGraph=getFragmentSubGraph(graph,start,end);
  final AnalysisResult subGraphAnalysis=analyseSubGraph(subGraph,start,end);
  if ((subGraphAnalysis.regularExits > 0 && subGraphAnalysis.returns > 0) || subGraphAnalysis.targetInstructions > 1 || subGraphAnalysis.outerLoopBreaks > 0) {
    throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.interrupted.execution.flow"));
  }
  if (subGraphAnalysis.starImports > 0) {
    throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.star.import"));
  }
  final Set<String> globalWrites=getGlobalWrites(subGraph,owner);
  final Set<String> nonlocalWrites=getNonlocalWrites(subGraph,owner);
  final Set<String> inputNames=new HashSet<String>();
  for (  PsiElement element : filterElementsInScope(getInputElements(subGraph,graph),owner)) {
    final String name=getName(element);
    if (name != null) {
      if (resolvesToBoundMethodParameter(element)) {
        continue;
      }
      if (globalWrites.contains(name) || nonlocalWrites.contains(name)) {
        continue;
      }
      inputNames.add(name);
    }
  }
  final Set<String> outputNames=new HashSet<String>();
  for (  PsiElement element : getOutputElements(subGraph,graph)) {
    final String name=getName(element);
    if (name != null) {
      if (globalWrites.contains(name) || nonlocalWrites.contains(name)) {
        continue;
      }
      outputNames.add(name);
    }
  }
  final boolean yieldsFound=subGraphAnalysis.yieldExpressions > 0;
  if (yieldsFound && LanguageLevel.forElement(owner).isOlderThan(LanguageLevel.PYTHON33)) {
    throw new CannotCreateCodeFragmentException(PyBundle.message("refactoring.extract.method.error.yield"));
  }
  final boolean isAsync=owner instanceof PyFunction && ((PyFunction)owner).isAsync();
  return new PyCodeFragment(inputNames,outputNames,globalWrites,nonlocalWrites,subGraphAnalysis.returns > 0,yieldsFound,isAsync);
}
