{
  return new JavaElementVisitor(){
    @Override public void visitClass(    PsiClass aClass){
      super.visitClass(aClass);
      if (InheritanceUtil.isInheritor(aClass,true,BASE_WALKING_VISITOR_NAME) || InheritanceUtil.isInheritor(aClass,true,BASE_VISITOR_NAME)) {
        if (findVisitMethod(aClass,"visitReturnStatement",PsiReturnStatement.class.getName())) {
          final boolean skipLambdaFound=findVisitMethod(aClass,"visitLambdaExpression",PsiLambdaExpression.class.getName());
          final boolean skipClassFound=findVisitMethod(aClass,"visitClass",PsiClass.class.getName());
          if (!(skipClassFound && skipLambdaFound)) {
            final String[] methods;
            final String name;
            if (!skipLambdaFound ^ !skipClassFound) {
              if (!skipLambdaFound) {
                name="Insert visitLambdaExpression method";
                methods=new String[]{EMPTY_LAMBDA};
              }
 else {
                name="Insert visitClass method";
                methods=new String[]{EMPTY_CLASS};
              }
            }
 else {
              name="Insert visitLambdaExpression/visitClass methods";
              methods=new String[]{EMPTY_LAMBDA,EMPTY_CLASS};
            }
            holder.registerProblem(aClass,HighlightNamesUtil.getClassDeclarationTextRange(aClass).shiftRight(-aClass.getTextRange().getStartOffset()),"Recursive visitors which visit return statements most probably should specifically process anonymous/local classes as well as lambda expressions",new MySkipVisitFix(name,methods));
          }
        }
      }
    }
  }
;
}
