{
  final Project project=e.getData(PlatformDataKeys.PROJECT);
  if (project == null || !GithubUtil.testGitExecutable(project)) {
    return;
  }
  BasicAction.saveAll();
  final VirtualFile root=project.getBaseDir();
  final GitRepositoryManager manager=GitUtil.getRepositoryManager(project);
  final GitRepository gitRepository=manager.getRepositoryForFile(root);
  final boolean gitDetected=gitRepository != null;
  boolean externalRemoteDetected=false;
  if (gitDetected) {
    if (GithubUtil.isRepositoryOnGitHub(gitRepository)) {
      showNotificationWithLink(project,"Project is already on GitHub","GitHub",StringUtil.notNullize(GithubUtil.findGithubRemoteUrl(gitRepository)));
      return;
    }
 else {
      externalRemoteDetected=!gitRepository.getRemotes().isEmpty();
    }
  }
  final Ref<HashSet<String>> repoNamesRef=new Ref<HashSet<String>>();
  final Ref<GithubUser> userInfoRef=new Ref<GithubUser>();
  final Ref<GithubAuthData> authRef=new Ref<GithubAuthData>();
  final Ref<IOException> exceptionRef=new Ref<IOException>();
  ProgressManager.getInstance().run(new Task.Modal(project,"Access to GitHub",true){
    public void run(    @NotNull ProgressIndicator indicator){
      try {
        final Ref<List<RepositoryInfo>> availableReposRef=new Ref<List<RepositoryInfo>>();
        final GithubAuthData auth=GithubUtil.runAndGetValidAuth(project,indicator,new ThrowableConsumer<GithubAuthData,IOException>(){
          @Override public void consume(          GithubAuthData authData) throws IOException {
            availableReposRef.set(GithubUtil.getAvailableRepos(authData));
          }
        }
);
        if (auth == null || availableReposRef.isNull()) {
          return;
        }
        final HashSet<String> names=new HashSet<String>();
        for (        RepositoryInfo info : availableReposRef.get()) {
          names.add(info.getName());
        }
        repoNamesRef.set(names);
        final GithubUser userInfo=GithubUtil.getCurrentUserInfo(auth);
        if (userInfo == null) {
          return;
        }
        userInfoRef.set(userInfo);
        authRef.set(auth);
      }
 catch (      IOException e) {
        exceptionRef.set(e);
      }
    }
  }
);
  if (!exceptionRef.isNull()) {
    Messages.showErrorDialog(exceptionRef.get().getMessage(),"Failed to connect to GitHub");
    return;
  }
  if (repoNamesRef.isNull() || userInfoRef.isNull()) {
    return;
  }
  final GithubShareDialog shareDialog=new GithubShareDialog(project,repoNamesRef.get(),userInfoRef.get().getPlan().isPrivateRepoAllowed());
  shareDialog.show();
  if (!shareDialog.isOK()) {
    return;
  }
  final boolean isPrivate=shareDialog.isPrivate();
  final String name=shareDialog.getRepositoryName();
  final String description=shareDialog.getDescription();
  final boolean finalExternalRemoteDetected=externalRemoteDetected;
  new Task.Backgroundable(project,"Sharing project on GitHub"){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      try {
        LOG.info("Creating GitHub repository");
        indicator.setText("Creating GitHub repository");
        if (createGithubRepository(authRef.get(),name,description,isPrivate)) {
          LOG.info("Successfully created GitHub repository");
        }
 else {
          showErrorDialog(project,"Failed to create new GitHub repository","Create GitHub Repository",indicator);
          return;
        }
        LOG.info("Binding local project with GitHub");
        if (!gitDetected) {
          if (!createEmptyGitRepository(project,root,indicator)) {
            return;
          }
        }
        GitRepositoryManager repositoryManager=ServiceManager.getService(project,GitRepositoryManager.class);
        final GitRepository repository=repositoryManager.getRepositoryForRoot(root);
        LOG.assertTrue(repository != null,"GitRepository is null for root " + root);
        LOG.info("Adding GitHub as a remote host");
        indicator.setText("Adding GitHub as a remote host");
        final GitSimpleHandler addRemoteHandler=new GitSimpleHandler(project,root,GitCommand.REMOTE);
        addRemoteHandler.setSilent(true);
        final String remoteUrl=GithubApiUtil.getGitHost() + "/" + userInfoRef.get().getLogin()+ "/"+ name+ ".git";
        final String remoteName=finalExternalRemoteDetected ? "github" : "origin";
        addRemoteHandler.addParameters("add",remoteName,remoteUrl);
        try {
          addRemoteHandler.run();
          repository.update();
          if (addRemoteHandler.getExitCode() != 0) {
            showErrorDialog("Failed to add GitHub repository as remote","Failed to add GitHub repository as remote",indicator);
            return;
          }
        }
 catch (        VcsException e) {
          showErrorDialog(e.getMessage(),"Failed to add GitHub repository as remote",indicator);
          LOG.info("Failed to add GitHub as remote: " + e.getMessage());
          return;
        }
        if (!performFirstCommitIfRequired(project,root,indicator)) {
          return;
        }
        LOG.info("Pushing to github master");
        indicator.setText("Pushing to github master");
        Git git=ServiceManager.getService(Git.class);
        GitCommandResult result=git.push(repository,remoteName,remoteUrl,"refs/heads/master:refs/heads/master");
        if (result.success()) {
          Notificator.getInstance(project).notify(new Notification(GithubUtil.GITHUB_NOTIFICATION_GROUP,"Success","Successfully created project '" + name + "' on GitHub",NotificationType.INFORMATION));
        }
 else {
          Notification notification=new Notification(GithubUtil.GITHUB_NOTIFICATION_GROUP,"Push to GitHub failed","Push failed: <br/>" + result.getErrorOutputAsHtmlString(),NotificationType.ERROR);
          Notificator.getInstance(project).notify(notification);
        }
      }
 catch (      IOException e) {
        exceptionRef.set(e);
      }
    }
  }
.queue();
  if (!exceptionRef.isNull()) {
    Messages.showErrorDialog(exceptionRef.get().getMessage(),"Failed to create new GitHub repository");
  }
}
