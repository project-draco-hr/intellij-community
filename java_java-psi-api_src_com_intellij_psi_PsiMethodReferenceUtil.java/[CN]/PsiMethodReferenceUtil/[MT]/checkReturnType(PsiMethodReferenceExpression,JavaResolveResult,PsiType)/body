{
  final PsiElement resolve=result.getElement();
  if (resolve instanceof PsiMethod) {
    final PsiClass containingClass=((PsiMethod)resolve).getContainingClass();
    LOG.assertTrue(containingClass != null);
    PsiSubstitutor subst=result.getSubstitutor();
    PsiClass qContainingClass=getQualifierResolveResult(expression).getContainingClass();
    if (qContainingClass != null && isReceiverType(getFirstParameterType(functionalInterfaceType,expression),qContainingClass,subst)) {
      subst=TypeConversionUtil.getClassSubstitutor(containingClass,qContainingClass,subst);
      LOG.assertTrue(subst != null);
    }
    final PsiType interfaceReturnType=LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType);
    PsiType returnType=PsiTypesUtil.patchMethodGetClassReturnType(expression,expression,(PsiMethod)resolve,null,PsiUtil.getLanguageLevel(expression));
    if (returnType == null) {
      returnType=((PsiMethod)resolve).getReturnType();
    }
    PsiType methodReturnType=subst.substitute(returnType);
    if (interfaceReturnType != null && interfaceReturnType != PsiType.VOID) {
      if (methodReturnType == null) {
        methodReturnType=JavaPsiFacade.getElementFactory(expression.getProject()).createType(containingClass,subst);
      }
      if (!TypeConversionUtil.isAssignable(interfaceReturnType,methodReturnType,false)) {
        return "Bad return type in method reference: cannot convert " + methodReturnType.getCanonicalText() + " to "+ interfaceReturnType.getCanonicalText();
      }
    }
  }
  return null;
}
