{
  if (elements.length > 0) {
    final AbstractInplaceIntroducer inplaceIntroducer=AbstractInplaceIntroducer.getActiveIntroducer(editor);
    if (inplaceIntroducer instanceof InplaceIntroduceParameterPopup) {
      return false;
    }
    final PsiMethod containingMethod=Util.getContainingMethod(elements[0]);
    if (containingMethod == null) {
      return false;
    }
    final List<PsiMethod> enclosingMethods=getEnclosingMethods(containingMethod);
    if (enclosingMethods.isEmpty()) {
      return false;
    }
    final PsiElement[] elementsCopy;
    if (!elements[0].isPhysical()) {
      elementsCopy=elements;
    }
 else {
      final PsiFile copy=PsiFileFactory.getInstance(project).createFileFromText(file.getName(),file.getFileType(),file.getText(),file.getModificationStamp(),false);
      final TextRange range=new TextRange(elements[0].getTextRange().getStartOffset(),elements[elements.length - 1].getTextRange().getEndOffset());
      final PsiExpression exprInRange=CodeInsightUtil.findExpressionInRange(copy,range.getStartOffset(),range.getEndOffset());
      elementsCopy=exprInRange != null ? new PsiElement[]{exprInRange} : CodeInsightUtil.findStatementsInRange(copy,range.getStartOffset(),range.getEndOffset());
    }
    final PsiMethod containingMethodCopy=Util.getContainingMethod(elementsCopy[0]);
    LOG.assertTrue(containingMethodCopy != null);
    final List<PsiMethod> enclosingMethodsInCopy=getEnclosingMethods(containingMethodCopy);
    final MyExtractMethodProcessor processor=new MyExtractMethodProcessor(project,editor,elementsCopy,enclosingMethodsInCopy.get(enclosingMethodsInCopy.size() - 1));
    try {
      if (!processor.prepare())       return false;
      processor.showDialog();
      final PsiMethod emptyMethod=JavaPsiFacade.getElementFactory(project).createMethodFromText(processor.generateEmptyMethod("name").getText(),elements[0]);
      final Collection<? extends PsiType> types=FunctionalInterfaceSuggester.suggestFunctionalInterfaces(emptyMethod);
      if (types.isEmpty()) {
        return false;
      }
      if (types.size() == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
        final PsiType next=types.iterator().next();
        functionalInterfaceSelected(next,enclosingMethods,project,editor,processor,elements);
      }
 else {
        final Map<PsiClass,PsiType> classes=new LinkedHashMap<>();
        for (        PsiType type : types) {
          classes.put(PsiUtil.resolveClassInType(type),type);
        }
        final PsiClass[] psiClasses=classes.keySet().toArray(new PsiClass[classes.size()]);
        final String methodSignature=PsiFormatUtil.formatMethod(emptyMethod,PsiSubstitutor.EMPTY,PsiFormatUtilBase.SHOW_PARAMETERS,PsiFormatUtilBase.SHOW_TYPE);
        final PsiType returnType=emptyMethod.getReturnType();
        LOG.assertTrue(returnType != null);
        final String title="Choose Applicable Functional Interface: " + methodSignature + " -> "+ returnType.getPresentableText();
        NavigationUtil.getPsiElementPopup(psiClasses,PsiClassListCellRenderer.INSTANCE,title,new PsiElementProcessor<PsiClass>(){
          @Override public boolean execute(          @NotNull PsiClass psiClass){
            functionalInterfaceSelected(classes.get(psiClass),enclosingMethods,project,editor,processor,elements);
            return true;
          }
        }
).showInBestPositionFor(editor);
        return true;
      }
      return true;
    }
 catch (    IncorrectOperationException ignore) {
    }
catch (    PrepareFailedException ignore) {
    }
  }
  return false;
}
