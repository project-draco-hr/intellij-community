{
  final UnusedLocalFilter[] filters=Extensions.getExtensions(UnusedLocalFilter.EP_NAME);
  Set<PyFunction> functionsWithInheritors=new HashSet<PyFunction>();
  for (  PsiElement element : myUnusedElements) {
    boolean ignoreUnused=false;
    for (    UnusedLocalFilter filter : filters) {
      if (filter.ignoreUnused(element)) {
        ignoreUnused=true;
      }
    }
    if (ignoreUnused)     continue;
    if (element instanceof PyFunction) {
      registerWarning(((PyFunction)element).getNameIdentifier(),PyBundle.message("INSP.unused.locals.local.function.isnot.used",((PyFunction)element).getName()));
    }
 else {
      String name=element.getText();
      if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {
        PyNamedParameter namedParameter=element instanceof PyNamedParameter ? (PyNamedParameter)element : (PyNamedParameter)element.getParent();
        name=namedParameter.getName();
        if ("self".equals(name) && PyPsiUtils.isMethodContext(element)) {
          continue;
        }
        if ("cls".equals(name)) {
          final Set<PyFunction.Flag> flagSet=PyUtil.detectDecorationsAndWrappersOf(PsiTreeUtil.getParentOfType(element,PyFunction.class));
          if (flagSet.contains(PyFunction.Flag.CLASSMETHOD)) {
            continue;
          }
        }
        boolean isInitMethod=false;
        PyClass containingClass=null;
        PyParameterList paramList=PsiTreeUtil.getParentOfType(element,PyParameterList.class);
        if (paramList != null && paramList.getParent() instanceof PyFunction) {
          PyFunction func=(PyFunction)paramList.getParent();
          containingClass=func.getContainingClass();
          if (PyNames.INIT.equals(func.getName()) && containingClass != null) {
            isInitMethod=true;
          }
 else           if (ignoreUnusedParameters(func,functionsWithInheritors)) {
            continue;
          }
        }
        LocalQuickFix[] fixes=isInitMethod ? new LocalQuickFix[]{new AddFieldQuickFix(name,containingClass,name)} : LocalQuickFix.EMPTY_ARRAY;
        registerWarning(element,PyBundle.message("INSP.unused.locals.parameter.isnot.used",name),fixes);
      }
 else {
        if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {
          continue;
        }
        if (PyForStatementNavigator.getPyForStatementByIterable(element) != null) {
          registerProblem(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name),ProblemHighlightType.LIKE_UNUSED_SYMBOL,null,new ReplaceWithWildCard());
        }
 else {
          registerWarning(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name));
        }
      }
    }
  }
}
