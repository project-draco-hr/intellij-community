{
  final PyInspectionExtension[] filters=Extensions.getExtensions(PyInspectionExtension.EP_NAME);
  final Set<PyFunction> functionsWithInheritors=new HashSet<>();
  final Map<PyFunction,Boolean> emptyFunctions=new HashMap<>();
  for (  PsiElement element : myUnusedElements) {
    boolean ignoreUnused=false;
    for (    PyInspectionExtension filter : filters) {
      if (filter.ignoreUnused(element)) {
        ignoreUnused=true;
      }
    }
    if (ignoreUnused)     continue;
    if (element instanceof PyFunction) {
      final PsiElement nameIdentifier=((PyFunction)element).getNameIdentifier();
      registerWarning(nameIdentifier == null ? element : nameIdentifier,PyBundle.message("INSP.unused.locals.local.function.isnot.used",((PyFunction)element).getName()),new PyRemoveStatementQuickFix());
    }
 else     if (element instanceof PyClass) {
      final PyClass cls=(PyClass)element;
      final PsiElement name=cls.getNameIdentifier();
      registerWarning(name != null ? name : element,PyBundle.message("INSP.unused.locals.local.class.isnot.used",cls.getName()),new PyRemoveStatementQuickFix());
    }
 else {
      String name=element.getText();
      if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {
        PyNamedParameter namedParameter=element instanceof PyNamedParameter ? (PyNamedParameter)element : (PyNamedParameter)element.getParent();
        name=namedParameter.getName();
        if (namedParameter.isSelf()) {
          continue;
        }
        if (myIgnoreLambdaParameters && PsiTreeUtil.getParentOfType(element,PyCallable.class) instanceof PyLambdaExpression) {
          continue;
        }
        boolean mayBeField=false;
        PyClass containingClass=null;
        PyParameterList paramList=PsiTreeUtil.getParentOfType(element,PyParameterList.class);
        if (paramList != null && paramList.getParent() instanceof PyFunction) {
          final PyFunction func=(PyFunction)paramList.getParent();
          containingClass=func.getContainingClass();
          if (PyNames.INIT.equals(func.getName()) && containingClass != null && !namedParameter.isKeywordContainer() && !namedParameter.isPositionalContainer()) {
            mayBeField=true;
          }
 else           if (ignoreUnusedParameters(func,functionsWithInheritors)) {
            continue;
          }
          if (func.asMethod() != null) {
            Boolean isEmpty=emptyFunctions.get(func);
            if (isEmpty == null) {
              isEmpty=PyUtil.isEmptyFunction(func);
              emptyFunctions.put(func,isEmpty);
            }
            if (isEmpty && !mayBeField) {
              continue;
            }
          }
        }
        boolean canRemove=!(PsiTreeUtil.getPrevSiblingOfType(element,PyParameter.class) instanceof PySingleStarParameter) || PsiTreeUtil.getNextSiblingOfType(element,PyParameter.class) != null;
        final List<LocalQuickFix> fixes=new ArrayList<>();
        if (mayBeField) {
          fixes.add(new AddFieldQuickFix(name,name,containingClass.getName(),false));
        }
        if (canRemove) {
          fixes.add(new PyRemoveParameterQuickFix());
        }
        registerWarning(element,PyBundle.message("INSP.unused.locals.parameter.isnot.used",name),fixes.toArray(new LocalQuickFix[fixes.size()]));
      }
 else {
        if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {
          continue;
        }
        final PyForStatement forStatement=PyForStatementNavigator.getPyForStatementByIterable(element);
        if (forStatement != null) {
          if (!myIgnoreRangeIterationVariables || !isRangeIteration(forStatement)) {
            registerProblem(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name),ProblemHighlightType.LIKE_UNUSED_SYMBOL,null,new ReplaceWithWildCard());
          }
        }
 else {
          registerWarning(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name),new PyRemoveStatementQuickFix());
        }
      }
    }
  }
}
