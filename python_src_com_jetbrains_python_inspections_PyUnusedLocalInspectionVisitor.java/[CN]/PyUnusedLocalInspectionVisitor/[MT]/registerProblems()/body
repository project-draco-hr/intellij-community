{
  final UnusedLocalFilter[] filters=Extensions.getExtensions(UnusedLocalFilter.EP_NAME);
  Set<PyFunction> functionsWithInheritors=new HashSet<PyFunction>();
  for (  PsiElement element : myUnusedElements) {
    boolean ignoreUnused=false;
    for (    UnusedLocalFilter filter : filters) {
      if (filter.ignoreUnused(element)) {
        ignoreUnused=true;
      }
    }
    if (ignoreUnused)     continue;
    if (element instanceof PyFunction) {
      final PsiElement nameIdentifier=((PyFunction)element).getNameIdentifier();
      registerWarning(nameIdentifier == null ? element : nameIdentifier,PyBundle.message("INSP.unused.locals.local.function.isnot.used",((PyFunction)element).getName()));
    }
 else {
      String name=element.getText();
      if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {
        PyNamedParameter namedParameter=element instanceof PyNamedParameter ? (PyNamedParameter)element : (PyNamedParameter)element.getParent();
        if (((PyParameterList)namedParameter.getParent()).getParameters()[0] == namedParameter) {
          final PyFunction function=PsiTreeUtil.getParentOfType(element,PyFunction.class);
          if (function != null) {
            final PyClass clazzz=PsiTreeUtil.getParentOfType(function,PyClass.class);
            if (clazzz != null) {
              if ("self".equals(name)) {
                continue;
              }
              if ("cls".equals(name)) {
                final Set<PyFunction.Flag> flagSet=PyUtil.detectDecorationsAndWrappersOf(function);
                if (flagSet.contains(PyFunction.Flag.CLASSMETHOD)) {
                  continue;
                }
                boolean metaClass=false;
                for (                PyClass superClass : clazzz.getSuperClasses()) {
                  if ("Type".equals(superClass.getName())) {
                    metaClass=true;
                    break;
                  }
                }
                if (metaClass) {
                  continue;
                }
              }
            }
          }
        }
        boolean isInitMethod=false;
        PyClass containingClass=null;
        PyParameterList paramList=PsiTreeUtil.getParentOfType(element,PyParameterList.class);
        if (paramList != null && paramList.getParent() instanceof PyFunction) {
          PyFunction func=(PyFunction)paramList.getParent();
          containingClass=func.getContainingClass();
          if (PyNames.INIT.equals(func.getName()) && containingClass != null) {
            isInitMethod=true;
          }
 else           if (ignoreUnusedParameters(func,functionsWithInheritors)) {
            continue;
          }
        }
        LocalQuickFix[] fixes=isInitMethod ? new LocalQuickFix[]{new AddFieldQuickFix(name,containingClass,name)} : LocalQuickFix.EMPTY_ARRAY;
        registerWarning(element,PyBundle.message("INSP.unused.locals.parameter.isnot.used",name),fixes);
      }
 else {
        if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {
          continue;
        }
        if (PyForStatementNavigator.getPyForStatementByIterable(element) != null) {
          registerProblem(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name),ProblemHighlightType.LIKE_UNUSED_SYMBOL,null,new ReplaceWithWildCard());
        }
 else {
          registerWarning(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name));
        }
      }
    }
  }
}
