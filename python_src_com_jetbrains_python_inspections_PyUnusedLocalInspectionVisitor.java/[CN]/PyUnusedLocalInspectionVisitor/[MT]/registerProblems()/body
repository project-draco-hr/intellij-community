{
  final UnusedLocalFilter[] filters=Extensions.getExtensions(UnusedLocalFilter.EP_NAME);
  Set<PyFunction> functionsWithInheritors=new HashSet<PyFunction>();
  for (  PsiElement element : myUnusedElements) {
    boolean ignoreUnused=false;
    for (    UnusedLocalFilter filter : filters) {
      if (filter.ignoreUnused(element)) {
        ignoreUnused=true;
      }
    }
    if (ignoreUnused)     continue;
    if (element instanceof PyFunction) {
      final PsiElement nameIdentifier=((PyFunction)element).getNameIdentifier();
      registerWarning(nameIdentifier == null ? element : nameIdentifier,PyBundle.message("INSP.unused.locals.local.function.isnot.used",((PyFunction)element).getName()));
    }
 else {
      String name=element.getText();
      if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {
        PyNamedParameter namedParameter=element instanceof PyNamedParameter ? (PyNamedParameter)element : (PyNamedParameter)element.getParent();
        name=namedParameter.getName();
        if (((PyParameterList)namedParameter.getParent()).getParameters()[0] == namedParameter && PsiTreeUtil.getParentOfType(element,PyClass.class) != null) {
          continue;
        }
        if (myIgnoreLambdaParameters && PsiTreeUtil.getParentOfType(element,Callable.class) instanceof PyLambdaExpression) {
          continue;
        }
        boolean isInitMethod=false;
        PyClass containingClass=null;
        PyParameterList paramList=PsiTreeUtil.getParentOfType(element,PyParameterList.class);
        if (paramList != null && paramList.getParent() instanceof PyFunction) {
          PyFunction func=(PyFunction)paramList.getParent();
          containingClass=func.getContainingClass();
          if (PyNames.INIT.equals(func.getName()) && containingClass != null) {
            isInitMethod=true;
          }
 else           if (ignoreUnusedParameters(func,functionsWithInheritors)) {
            continue;
          }
        }
        LocalQuickFix[] fixes=isInitMethod ? new LocalQuickFix[]{new AddFieldQuickFix(name,containingClass,name)} : LocalQuickFix.EMPTY_ARRAY;
        registerWarning(element,PyBundle.message("INSP.unused.locals.parameter.isnot.used",name),fixes);
      }
 else {
        if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {
          continue;
        }
        final PyForStatement forStatement=PyForStatementNavigator.getPyForStatementByIterable(element);
        if (forStatement != null) {
          if (!myIgnoreRangeIterationVariables || !isRangeIteration(forStatement)) {
            registerProblem(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name),ProblemHighlightType.LIKE_UNUSED_SYMBOL,null,new ReplaceWithWildCard());
          }
        }
 else {
          registerWarning(element,PyBundle.message("INSP.unused.locals.local.variable.isnot.used",name));
        }
      }
    }
  }
}
