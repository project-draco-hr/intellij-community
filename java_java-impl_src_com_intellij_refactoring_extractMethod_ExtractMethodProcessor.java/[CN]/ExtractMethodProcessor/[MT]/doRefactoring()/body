{
  initDuplicates();
  chooseAnchor();
  LogicalPosition pos1;
  if (myEditor != null) {
    int col=myEditor.getCaretModel().getLogicalPosition().column;
    int line=myEditor.getCaretModel().getLogicalPosition().line;
    pos1=new LogicalPosition(line,col);
    LogicalPosition pos=new LogicalPosition(0,0);
    myEditor.getCaretModel().moveToLogicalPosition(pos);
  }
 else {
    pos1=null;
  }
  final SearchScope processConflictsScope=myMethodVisibility.equals(PsiModifier.PRIVATE) ? new LocalSearchScope(myTargetClass) : GlobalSearchScope.projectScope(myProject);
  final Map<PsiMethodCallExpression,PsiMethod> overloadsResolveMap=new HashMap<PsiMethodCallExpression,PsiMethod>();
  final Runnable collectOverloads=new Runnable(){
    public void run(){
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        public void run(){
          Map<PsiMethodCallExpression,PsiMethod> overloads=ExtractMethodUtil.encodeOverloadTargets(myTargetClass,processConflictsScope,myMethodName,myCodeFragmentMember);
          overloadsResolveMap.putAll(overloads);
        }
      }
);
    }
  }
;
  final Runnable extract=new Runnable(){
    public void run(){
      doExtract();
      ExtractMethodUtil.decodeOverloadTargets(overloadsResolveMap,myExtractedMethod,myCodeFragmentMember);
    }
  }
;
  if (ApplicationManager.getApplication().isWriteAccessAllowed()) {
    collectOverloads.run();
    extract.run();
  }
 else {
    if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(collectOverloads,"Collect overloads...",true,myProject))     return;
    ApplicationManager.getApplication().runWriteAction(extract);
  }
  if (myEditor != null) {
    myEditor.getCaretModel().moveToLogicalPosition(pos1);
    int offset=myMethodCall.getMethodExpression().getTextRange().getStartOffset();
    myEditor.getCaretModel().moveToOffset(offset);
    myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
    myEditor.getSelectionModel().removeSelection();
  }
}
