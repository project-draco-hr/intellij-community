{
  final List<VariableData> variables=myInputVariables.getInputVariables();
  myVariableDatum=variables.toArray(new VariableData[variables.size()]);
  myNullness=initNullness();
  return new ExtractMethodDialog(myProject,myTargetClass,myInputVariables,myReturnType,getTypeParameterList(),getThrownExceptions(),isStatic(),isCanBeStatic(),myCanBeChainedConstructor,suggestInitialMethodName(),myRefactoringName,myHelpId,myNullness,myElements){
    protected boolean areTypesDirected(){
      return direct;
    }
    @Override protected boolean isOutputVariable(    PsiVariable var){
      return ExtractMethodProcessor.this.isOutputVariable(var);
    }
    @Override protected void checkMethodConflicts(    MultiMap<PsiElement,String> conflicts){
      super.checkMethodConflicts(conflicts);
      final VariableData[] parameters=getChosenParameters();
      final PsiResolveHelper resolveHelper=PsiResolveHelper.SERVICE.getInstance(myProject);
      for (      VariableData parameter : parameters) {
        final PsiVariable variable=resolveHelper.resolveReferencedVariable(parameter.name,myElements[0]);
        if (variable != null && isDeclaredInside(variable)) {
          conflicts.putValue(variable,"Variable with name " + parameter.name + " is already defined in the selected scope");
        }
      }
    }
  }
;
}
