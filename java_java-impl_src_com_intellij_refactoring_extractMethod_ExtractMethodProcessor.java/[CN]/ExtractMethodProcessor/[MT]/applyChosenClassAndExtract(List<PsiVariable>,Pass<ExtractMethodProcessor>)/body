{
  myStatic=shouldBeStatic();
  final Set<PsiField> fields=new LinkedHashSet<>();
  if (!PsiUtil.isLocalOrAnonymousClass(myTargetClass) && (myTargetClass.getContainingClass() == null || myTargetClass.hasModifierProperty(PsiModifier.STATIC))) {
    boolean canBeStatic=true;
    if (myTargetClass.isInterface()) {
      final PsiMethod containingMethod=PsiTreeUtil.getParentOfType(myCodeFragmentMember,PsiMethod.class,false);
      canBeStatic=containingMethod == null || containingMethod.hasModifierProperty(PsiModifier.STATIC);
    }
    if (canBeStatic) {
      ElementNeedsThis needsThis=new ElementNeedsThis(myTargetClass){
        @Override protected void visitClassMemberReferenceElement(        PsiMember classMember,        PsiJavaCodeReferenceElement classMemberReference){
          if (classMember instanceof PsiField && !classMember.hasModifierProperty(PsiModifier.STATIC)) {
            final PsiExpression expression=PsiTreeUtil.getParentOfType(classMemberReference,PsiExpression.class,false);
            if (expression == null || !PsiUtil.isAccessedForWriting(expression)) {
              fields.add((PsiField)classMember);
              return;
            }
          }
          super.visitClassMemberReferenceElement(classMember,classMemberReference);
        }
      }
;
      for (int i=0; i < myElements.length && !needsThis.usesMembers(); i++) {
        PsiElement element=myElements[i];
        element.accept(needsThis);
      }
      myCanBeStatic=!needsThis.usesMembers();
    }
 else {
      myCanBeStatic=false;
    }
  }
 else {
    myCanBeStatic=false;
  }
  myInputVariables=new InputVariables(inputVariables,myProject,new LocalSearchScope(myElements),isFoldingApplicable());
  myInputVariables.setUsedInstanceFields(fields);
  if (!checkExitPoints()) {
    return false;
  }
  checkCanBeChainedConstructor();
  if (extractPass != null) {
    extractPass.pass(this);
  }
  return true;
}
