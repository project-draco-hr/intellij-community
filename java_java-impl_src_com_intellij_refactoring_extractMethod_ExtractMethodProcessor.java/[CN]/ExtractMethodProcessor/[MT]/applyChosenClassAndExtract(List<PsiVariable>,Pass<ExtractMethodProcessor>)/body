{
  myStatic=shouldBeStatic();
  final Set<PsiField> fields=new LinkedHashSet<PsiField>();
  if (!PsiUtil.isLocalOrAnonymousClass(myTargetClass) && (myTargetClass.getContainingClass() == null || myTargetClass.hasModifierProperty(PsiModifier.STATIC))) {
    ElementNeedsThis needsThis=new ElementNeedsThis(myTargetClass){
      @Override protected void visitClassMemberReferenceElement(      PsiMember classMember,      PsiJavaCodeReferenceElement classMemberReference){
        if (classMember instanceof PsiField && !classMember.hasModifierProperty(PsiModifier.STATIC)) {
          final PsiExpression expression=PsiTreeUtil.getParentOfType(classMemberReference,PsiExpression.class,false);
          if (expression == null || !PsiUtil.isAccessedForWriting(expression)) {
            fields.add((PsiField)classMember);
            return;
          }
        }
        super.visitClassMemberReferenceElement(classMember,classMemberReference);
      }
    }
;
    for (int i=0; i < myElements.length && !needsThis.usesMembers(); i++) {
      PsiElement element=myElements[i];
      element.accept(needsThis);
    }
    myCanBeStatic=!needsThis.usesMembers();
  }
 else {
    myCanBeStatic=false;
  }
  myInputVariables=new InputVariables(inputVariables,myProject,new LocalSearchScope(myElements),true);
  myInputVariables.setUsedInstanceFields(fields);
  if (!checkExitPoints()) {
    return false;
  }
  checkCanBeChainedConstructor();
  if (extractPass != null) {
    extractPass.pass(this);
  }
  return true;
}
