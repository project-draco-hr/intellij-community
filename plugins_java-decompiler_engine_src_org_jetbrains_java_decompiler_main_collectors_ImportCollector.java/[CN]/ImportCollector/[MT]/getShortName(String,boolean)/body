{
  ClassesProcessor clproc=DecompilerContext.getClassProcessor();
  ClassNode node=clproc.getMapRootClasses().get(fullname.replace('.','/'));
  String retname=null;
  if (node != null && node.classStruct.isOwn()) {
    retname=node.simpleName;
    while (node.parent != null && node.type == ClassNode.CLASS_MEMBER) {
      retname=node.parent.simpleName + "." + retname;
      node=node.parent;
    }
    if (node.type == ClassNode.CLASS_ROOT) {
      fullname=node.classStruct.qualifiedName;
      fullname=fullname.replace('/','.');
    }
 else {
      return retname;
    }
  }
 else   if (node == null || !node.classStruct.isOwn()) {
    fullname=fullname.replace('$','.');
  }
  String nshort=fullname;
  String npackage="";
  int lastpoint=fullname.lastIndexOf(".");
  if (lastpoint >= 0) {
    nshort=fullname.substring(lastpoint + 1);
    npackage=fullname.substring(0,lastpoint);
  }
  StructContext context=DecompilerContext.getStructContext();
  boolean existsDefaultClass=(context.getClass(currentPackageSlash + nshort) != null && !npackage.equals(currentPackagePoint)) || (context.getClass(nshort) != null);
  if (existsDefaultClass || (mapSimpleNames.containsKey(nshort) && !npackage.equals(mapSimpleNames.get(nshort)))) {
    return fullname;
  }
 else   if (!mapSimpleNames.containsKey(nshort)) {
    mapSimpleNames.put(nshort,npackage);
    if (!imported) {
      setNotImportedNames.add(nshort);
    }
  }
  return retname == null ? nshort : retname;
}
