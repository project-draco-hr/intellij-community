{
  super.visitDeclarationStatement(psiDeclarationStatement);
  final PsiElement firstChild=psiDeclarationStatement.getFirstChild();
  if (firstChild instanceof PsiTypeElement) {
    final PsiJavaCodeReferenceElement reference=((PsiTypeElement)firstChild).getInnermostComponentReferenceElement();
    if (reference != null && reference.getParameterList().getTypeParameterElements().length > 0) {
      myCompilingVisitor.setHandler(psiDeclarationStatement,new TypedSymbolHandler());
      final MatchingHandler handler=myCompilingVisitor.getContext().getPattern().getHandler(psiDeclarationStatement);
      handler.setFilter(TypedSymbolNodeFilter.getInstance());
      final PsiTypeElement[] params=reference.getParameterList().getTypeParameterElements();
      for (      PsiTypeElement param : params) {
        if (param.getInnermostComponentReferenceElement() != null && (myCompilingVisitor.getContext().getPattern().isRealTypedVar(param.getInnermostComponentReferenceElement().getReferenceNameElement()))) {
          myCompilingVisitor.getContext().getPattern().getHandler(param).setFilter(TypeParameterFilter.getInstance());
        }
      }
      return;
    }
  }
 else   if (firstChild instanceof PsiModifierList) {
    final PsiModifierList modifierList=(PsiModifierList)firstChild;
    final PsiAnnotation[] annotations=modifierList.getAnnotations();
    if (annotations.length != 1) {
      throw new UnsupportedPatternException("Pattern is malformed");
    }
    for (    String modifier : PsiModifier.MODIFIERS) {
      if (modifierList.hasExplicitModifier(modifier)) {
        throw new UnsupportedPatternException("Pattern is malformed");
      }
    }
    myCompilingVisitor.setHandler(psiDeclarationStatement,new AnnotationHandler());
    final MatchingHandler handler=myCompilingVisitor.getContext().getPattern().getHandler(psiDeclarationStatement);
    handler.setFilter(AnnotationFilter.getInstance());
    return;
  }
  final MatchingHandler handler=new DeclarationStatementHandler();
  myCompilingVisitor.getContext().getPattern().setHandler(psiDeclarationStatement,handler);
  final PsiElement previousNonWhiteSpace=PsiTreeUtil.skipSiblingsBackward(psiDeclarationStatement,PsiWhiteSpace.class);
  if (previousNonWhiteSpace instanceof PsiComment) {
    ((DeclarationStatementHandler)handler).setCommentHandler(myCompilingVisitor.getContext().getPattern().getHandler(previousNonWhiteSpace));
    myCompilingVisitor.getContext().getPattern().setHandler(previousNonWhiteSpace,handler);
  }
  handler.setFilter(DeclarationFilter.getInstance());
}
