{
  final PsiClass[] psiClasses;
  if (methods != null && methods.length > 0) {
    final Set<PsiClass> containingClasses=new LinkedHashSet<PsiClass>();
    for (    final PsiMethod method : methods) {
      containingClasses.add(ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>(){
        @Override public PsiClass compute(){
          return method.getContainingClass();
        }
      }
));
    }
    psiClasses=containingClasses.toArray(new PsiClass[containingClasses.size()]);
  }
 else {
    psiClasses=classes;
  }
  for (  final PsiClass containingClass : psiClasses) {
    final Set<String> testMethodDependencies=new LinkedHashSet<String>();
    final HashMap<String,Collection<String>> valuesMap=new HashMap<>();
    valuesMap.put("dependsOnMethods",testMethodDependencies);
    TestNGUtil.collectAnnotationValues(valuesMap,methods,containingClass);
    if (!testMethodDependencies.isEmpty()) {
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        public void run(){
          final Project project=containingClass.getProject();
          final JavaPsiFacade psiFacade=JavaPsiFacade.getInstance(project);
          for (          String dependency : testMethodDependencies) {
            final String className=StringUtil.getPackageName(dependency);
            final String methodName=StringUtil.getShortName(dependency);
            if (StringUtil.isEmpty(className)) {
              checkClassMethods(methodName,containingClass,alreadyMarkedToBeChecked,membersToCheckNow,results);
            }
 else {
              final PsiClass aClass=psiFacade.findClass(className,containingClass.getResolveScope());
              if (aClass != null) {
                checkClassMethods(methodName,aClass,alreadyMarkedToBeChecked,membersToCheckNow,results);
              }
            }
          }
        }
      }
);
    }
  }
}
