{
  return new JavaElementVisitor(){
    @Override public void visitLambdaExpression(    PsiLambdaExpression expression){
      super.visitLambdaExpression(expression);
      final PsiElement body=expression.getBody();
      if (body instanceof PsiCodeBlock) {
        PsiExpression psiExpression=LambdaUtil.extractSingleExpressionFromBody(body);
        if (psiExpression != null && !findCommentsOutsideExpression(body,psiExpression)) {
          if (LambdaUtil.isExpressionStatementExpression(psiExpression)) {
            final PsiElement parent=PsiUtil.skipParenthesizedExprUp(expression.getParent());
            if (parent instanceof PsiExpressionList) {
              final PsiElement gParent=parent.getParent();
              if (gParent instanceof PsiCallExpression) {
                final CandidateInfo[] candidates=PsiResolveHelper.SERVICE.getInstance(gParent.getProject()).getReferencedMethodCandidates((PsiCallExpression)gParent,false);
                if (candidates.length > 1) {
                  final List<CandidateInfo> info=new ArrayList<CandidateInfo>(Arrays.asList(candidates));
                  final LanguageLevel level=PsiUtil.getLanguageLevel(parent);
                  final JavaMethodsConflictResolver conflictResolver=new JavaMethodsConflictResolver((PsiExpressionList)parent,level);
                  conflictResolver.checkSpecifics(info,MethodCandidateInfo.ApplicabilityLevel.FIXED_ARITY,level);
                  if (info.size() > 1) {
                    return;
                  }
                }
              }
            }
          }
          final PsiElement errorElement;
          final PsiElement parent=psiExpression.getParent();
          if (parent instanceof PsiReturnStatement) {
            errorElement=parent.getFirstChild();
          }
 else {
            errorElement=body.getFirstChild();
          }
          holder.registerProblem(errorElement,"Statement lambda can be replaced with expression lambda",ProblemHighlightType.LIKE_UNUSED_SYMBOL,new ReplaceWithExprFix());
        }
      }
    }
    private boolean findCommentsOutsideExpression(    PsiElement body,    PsiExpression psiExpression){
      final Collection<PsiComment> comments=PsiTreeUtil.findChildrenOfType(body,PsiComment.class);
      for (      PsiComment comment : comments) {
        if (!PsiTreeUtil.isAncestor(psiExpression,comment,true)) {
          return true;
        }
      }
      return false;
    }
  }
;
}
