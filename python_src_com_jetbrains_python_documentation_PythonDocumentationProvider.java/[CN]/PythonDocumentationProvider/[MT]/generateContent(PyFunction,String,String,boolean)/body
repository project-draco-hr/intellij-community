{
  final StringBuilder builder=new StringBuilder(offset);
  final TypeEvalContext context=TypeEvalContext.userInitiated(function.getProject(),function.getContainingFile());
  final PySignature signature=PySignatureCacheManager.getInstance(function.getProject()).findSignature(function);
  final PyDecoratorList decoratorList=function.getDecoratorList();
  final PyDecorator classMethod=decoratorList == null ? null : decoratorList.findDecorator(PyNames.CLASSMETHOD);
  for (  PyParameter p : PyUtil.getParameters(function,context)) {
    final String parameterName=p.getName();
    if (p.getText().equals(PyNames.CANONICAL_SELF) || parameterName == null) {
      continue;
    }
    if (classMethod != null && parameterName.equals(PyNames.CANONICAL_CLS))     continue;
    final String argType=signature == null ? null : signature.getArgTypeQualifiedName(parameterName);
    if (argType == null) {
      builder.append(prefix);
      builder.append("param ");
      builder.append(parameterName);
      builder.append(": ");
      builder.append(offset);
    }
    if (PyCodeInsightSettings.getInstance().INSERT_TYPE_DOCSTUB || argType != null) {
      builder.append(prefix);
      builder.append("type ");
      builder.append(parameterName);
      builder.append(": ");
      if (signature != null && argType != null) {
        builder.append(PySignatureUtil.getShortestImportableName(function,argType));
      }
      builder.append(offset);
    }
  }
  builder.append(generateRaiseOrReturn(function,offset,prefix,checkReturn));
  return builder.toString();
}
