{
  myVcs=vcs;
  myLastPathCorrector=new SvnPathThroughHistoryCorrection(lastPath);
  myLastPath=lastPath;
  myCharset=charset;
  myIndicator=ProgressManager.getInstance().getProgressIndicator();
  myResult=result;
  myPegRevision=pegRevision;
  myUrl=url;
  myRepositoryRoot=repoRootURL;
  myTracker=new SvnMergeSourceTracker(new ThrowableConsumer<Pair<LogEntry,Integer>,SVNException>(){
    @Override public void consume(    final Pair<LogEntry,Integer> svnLogEntryIntegerPair) throws SVNException {
      final LogEntry logEntry=svnLogEntryIntegerPair.getFirst();
      if (myIndicator != null) {
        if (myIndicator.isCanceled()) {
          SVNErrorManager.cancel(SvnBundle.message("exception.text.update.operation.cancelled"),SVNLogType.DEFAULT);
        }
        myIndicator.setText2(SvnBundle.message("progress.text2.revision.processed",logEntry.getRevision()));
      }
      LogEntryPath entryPath=null;
      String copyPath=null;
      final int mergeLevel=svnLogEntryIntegerPair.getSecond();
      if (!myLastPathCorrector.isRoot()) {
        myLastPathCorrector.consume(logEntry);
        entryPath=myLastPathCorrector.getDirectlyMentioned();
        copyPath=null;
        if (entryPath != null) {
          copyPath=entryPath.getCopyPath();
        }
 else {
        }
      }
      final SvnFileRevision revision=createRevision(logEntry,copyPath,entryPath);
      if (mergeLevel >= 0) {
        addToListByLevel((SvnFileRevision)myPrevious,revision,mergeLevel);
      }
 else {
        myResult.consume(revision);
        myPrevious=revision;
      }
      if (myThrowCancelOnMeetPathCreation && myUrl.equals(revision.getURL()) && entryPath != null && entryPath.getType() == 'A') {
        throw new SVNCancelException();
      }
    }
  }
);
}
