{
  HttpResponse response=prepareSend(request,channel,file.lastModified(),file.getPath());
  if (response == null) {
    return;
  }
  boolean keepAlive=addKeepAliveIfNeed(response,request);
  boolean fileWillBeClosed=false;
  RandomAccessFile raf;
  try {
    raf=new RandomAccessFile(file,"r");
  }
 catch (  FileNotFoundException ignored) {
    send(response(HttpResponseStatus.NOT_FOUND),channel,request);
    return;
  }
  try {
    long fileLength=raf.length();
    if (request.method() != HttpMethod.HEAD) {
      HttpHeaderUtil.setContentLength(response,fileLength);
    }
    channel.write(response);
    if (request.method() != HttpMethod.HEAD) {
      if (channel.pipeline().get(SslHandler.class) == null) {
        channel.write(new DefaultFileRegion(raf.getChannel(),0,fileLength));
      }
 else {
        channel.write(new ChunkedFile(raf));
      }
    }
    fileWillBeClosed=true;
  }
  finally {
    if (!fileWillBeClosed) {
      raf.close();
    }
  }
  ChannelFuture future=channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
  if (!keepAlive) {
    future.addListener(ChannelFutureListener.CLOSE);
  }
}
