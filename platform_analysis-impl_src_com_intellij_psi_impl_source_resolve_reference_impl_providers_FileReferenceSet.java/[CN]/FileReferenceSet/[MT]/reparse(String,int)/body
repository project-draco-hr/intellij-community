{
  LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper;
  TextRange valueRange;
  CharSequence decoded;
  if (myElement instanceof PsiLanguageInjectionHost) {
    escaper=((PsiLanguageInjectionHost)myElement).createLiteralTextEscaper();
    valueRange=ElementManipulators.getValueTextRange(myElement);
    StringBuilder sb=new StringBuilder();
    escaper.decode(valueRange,sb);
    decoded=sb;
  }
 else {
    escaper=null;
    valueRange=null;
    decoded=str;
  }
  List<FileReference> referencesList=ContainerUtil.newArrayList();
  String separatorString=getSeparatorString();
  int sepLen=separatorString.length();
  int currentSlash=-sepLen;
  int wsTail=0;
  for (int i=currentSlash + sepLen; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) {
    currentSlash++;
  }
  for (int i=decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) {
    wsTail++;
  }
  if (currentSlash + 2 * sepLen < decoded.length() && StringUtil.equals(decoded.subSequence(currentSlash + sepLen,currentSlash + 2 * sepLen),separatorString)) {
    currentSlash+=sepLen;
  }
  int index=0;
  if (decoded.equals(separatorString)) {
    TextRange r=new TextRange(startInElement,offset(sepLen,escaper,valueRange) + 1);
    referencesList.add(createFileReference(r,index++,separatorString));
  }
  while (true) {
    int nextSlash=StringUtil.indexOf(decoded,separatorString,currentSlash + sepLen);
    String subReferenceText=decoded.subSequence(currentSlash + sepLen,nextSlash > 0 ? nextSlash : decoded.length()).toString();
    TextRange r=new TextRange(offset(currentSlash + sepLen,escaper,valueRange),offset((nextSlash > 0 ? nextSlash : startInElement + decoded.length() - 1 - wsTail),escaper,valueRange));
    referencesList.add(createFileReference(r,index++,subReferenceText));
    if ((currentSlash=nextSlash) < 0) {
      break;
    }
  }
  return referencesList;
}
