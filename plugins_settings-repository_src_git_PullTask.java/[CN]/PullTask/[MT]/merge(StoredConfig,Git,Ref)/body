{
  Repository repository=git.getRepository();
  Ref head=repository.getRef(Constants.HEAD);
  if (head == null) {
    throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
  }
  MergeConfig mergeConfig=config.get(MergeConfig.getParser(Constants.MASTER));
  boolean squash=mergeConfig.isSquash();
  boolean commit=mergeConfig.isCommit();
  FastForwardMode fastForwardMode=mergeConfig.getFastForwardMode();
  if (squash && fastForwardMode == FastForwardMode.NO_FF) {
    throw new JGitInternalException(JGitText.get().cannotCombineSquashWithNoff);
  }
  MergeStrategy mergeStrategy=MergeStrategy.RECURSIVE;
  RevWalk revWalk=null;
  DirCacheCheckout dirCacheCheckout=null;
  try {
    revWalk=new RevWalk(repository);
    ref=repository.peel(ref);
    ObjectId objectId=ref.getPeeledObjectId();
    if (objectId == null) {
      objectId=ref.getObjectId();
    }
    RevCommit srcCommit=revWalk.lookupCommit(objectId);
    ObjectId headId=head.getObjectId();
    if (headId == null) {
      revWalk.parseHeaders(srcCommit);
      dirCacheCheckout=new DirCacheCheckout(repository,repository.lockDirCache(),srcCommit.getTree());
      dirCacheCheckout.setFailOnConflict(true);
      dirCacheCheckout.checkout();
      RefUpdate refUpdate=repository.updateRef(head.getTarget().getName());
      refUpdate.setNewObjectId(objectId);
      refUpdate.setExpectedOldObjectId(null);
      refUpdate.setRefLogMessage("initial pull",false);
      if (refUpdate.update() != RefUpdate.Result.NEW) {
        throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
      }
      return new MergeResult(srcCommit,srcCommit,new ObjectId[]{null,srcCommit},MergeResult.MergeStatus.FAST_FORWARD,mergeStrategy,null);
    }
    StringBuilder refLogMessage=new StringBuilder("merge ");
    refLogMessage.append(ref.getName());
    RevCommit headCommit=revWalk.lookupCommit(headId);
    if (revWalk.isMergedInto(srcCommit,headCommit)) {
      return new MergeResult(headCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeResult.MergeStatus.ALREADY_UP_TO_DATE,mergeStrategy,null);
    }
 else     if (revWalk.isMergedInto(headCommit,srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {
      refLogMessage.append(": ").append(MergeResult.MergeStatus.FAST_FORWARD);
      dirCacheCheckout=new DirCacheCheckout(repository,headCommit.getTree(),repository.lockDirCache(),srcCommit.getTree());
      dirCacheCheckout.setFailOnConflict(true);
      dirCacheCheckout.checkout();
      String msg=null;
      ObjectId newHead, base;
      MergeResult.MergeStatus mergeStatus;
      if (squash) {
        msg=JGitText.get().squashCommitNotUpdatingHEAD;
        newHead=base=headId;
        mergeStatus=MergeResult.MergeStatus.FAST_FORWARD_SQUASHED;
        List<RevCommit> squashedCommits=RevWalkUtils.find(revWalk,srcCommit,headCommit);
        repository.writeSquashCommitMsg(new SquashMessageFormatter().format(squashedCommits,head));
      }
 else {
        updateHead(refLogMessage,srcCommit,headId,repository);
        newHead=base=srcCommit;
        mergeStatus=MergeResult.MergeStatus.FAST_FORWARD;
      }
      return new MergeResult(newHead,base,new ObjectId[]{headCommit,srcCommit},mergeStatus,mergeStrategy,null,msg);
    }
 else {
      if (fastForwardMode == FastForwardMode.FF_ONLY) {
        return new MergeResult(headCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeResult.MergeStatus.ABORTED,mergeStrategy,null);
      }
      String mergeMessage;
      if (squash) {
        mergeMessage="";
        List<RevCommit> squashedCommits=RevWalkUtils.find(revWalk,srcCommit,headCommit);
        repository.writeSquashCommitMsg(new SquashMessageFormatter().format(squashedCommits,head));
      }
 else {
        mergeMessage=new MergeMessageFormatter().format(Collections.singletonList(ref),head);
        repository.writeMergeCommitMsg(mergeMessage);
        repository.writeMergeHeads(Arrays.asList(ref.getObjectId()));
      }
      Merger merger=mergeStrategy.newMerger(repository);
      boolean noProblems;
      Map<String,org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults=null;
      Map<String,ResolveMerger.MergeFailureReason> failingPaths=null;
      List<String> unmergedPaths=null;
      if (merger instanceof ResolveMerger) {
        ResolveMerger resolveMerger=(ResolveMerger)merger;
        resolveMerger.setCommitNames(new String[]{"BASE","HEAD",ref.getName()});
        resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repository));
        noProblems=merger.merge(headCommit,srcCommit);
        lowLevelResults=resolveMerger.getMergeResults();
        failingPaths=resolveMerger.getFailingPaths();
        unmergedPaths=resolveMerger.getUnmergedPaths();
      }
 else {
        noProblems=merger.merge(headCommit,srcCommit);
      }
      refLogMessage.append(": Merge made by ");
      if (revWalk.isMergedInto(headCommit,srcCommit)) {
        refLogMessage.append("recursive");
      }
 else {
        refLogMessage.append(mergeStrategy.getName());
      }
      refLogMessage.append('.');
      if (noProblems) {
        dirCacheCheckout=new DirCacheCheckout(repository,headCommit.getTree(),repository.lockDirCache(),merger.getResultTreeId());
        dirCacheCheckout.setFailOnConflict(true);
        dirCacheCheckout.checkout();
        String msg=null;
        ObjectId newHeadId=null;
        MergeResult.MergeStatus mergeStatus=null;
        if (!commit && squash) {
          mergeStatus=MergeResult.MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;
        }
        if (!commit && !squash) {
          mergeStatus=MergeResult.MergeStatus.MERGED_NOT_COMMITTED;
        }
        if (commit && !squash) {
          newHeadId=git.commit().setReflogComment(refLogMessage.toString()).call().getId();
          mergeStatus=MergeResult.MergeStatus.MERGED;
        }
        if (commit && squash) {
          msg=JGitText.get().squashCommitNotUpdatingHEAD;
          newHeadId=headCommit.getId();
          mergeStatus=MergeResult.MergeStatus.MERGED_SQUASHED;
        }
        return new MergeResult(newHeadId,null,new ObjectId[]{headCommit.getId(),srcCommit.getId()},mergeStatus,mergeStrategy,null,msg);
      }
 else {
        if (failingPaths == null) {
          String mergeMessageWithConflicts=new MergeMessageFormatter().formatWithConflicts(mergeMessage,unmergedPaths);
          repository.writeMergeCommitMsg(mergeMessageWithConflicts);
          return new MergeResult(null,merger.getBaseCommitId(),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeResult.MergeStatus.CONFLICTING,mergeStrategy,lowLevelResults);
        }
 else {
          repository.writeMergeCommitMsg(null);
          repository.writeMergeHeads(null);
          return new MergeResult(null,merger.getBaseCommitId(),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeResult.MergeStatus.FAILED,mergeStrategy,lowLevelResults,failingPaths,null);
        }
      }
    }
  }
 catch (  org.eclipse.jgit.errors.CheckoutConflictException e) {
    throw new CheckoutConflictException(dirCacheCheckout == null ? Collections.<String>emptyList() : dirCacheCheckout.getConflicts(),e);
  }
 finally {
    if (revWalk != null) {
      revWalk.release();
    }
  }
}
