{
  final DebugProcessImpl debugProcess=context.getDebugProcess();
  if (isLogEnabled() || isLogExpressionEnabled()) {
    final StringBuilder buf=StringBuilderSpinAllocator.alloc();
    try {
      if (myXBreakpoint.isLogMessage()) {
        buf.append(getEventMessage(event));
        buf.append("\n");
      }
      if (isLogExpressionEnabled()) {
        if (!debugProcess.isAttached()) {
          return;
        }
        final TextWithImports expressionToEvaluate=getLogMessage();
        try {
          SourcePosition position=ContextUtil.getSourcePosition(context);
          PsiElement element=ContextUtil.getContextElement(context,position);
          ExpressionEvaluator evaluator=DebuggerInvocationUtil.commitAndRunReadAction(myProject,new EvaluatingComputable<ExpressionEvaluator>(){
            @Override public ExpressionEvaluator compute() throws EvaluateException {
              return EvaluatorBuilderImpl.build(expressionToEvaluate,element,position,myProject);
            }
          }
);
          final Value eval=evaluator.evaluate(context);
          final String result=eval instanceof VoidValue ? "void" : DebuggerUtils.getValueAsString(context,eval);
          buf.append(result);
        }
 catch (        EvaluateException e) {
          buf.append(DebuggerBundle.message("error.unable.to.evaluate.expression"));
          buf.append(" \"");
          buf.append(expressionToEvaluate);
          buf.append("\"");
          buf.append(" : ");
          buf.append(e.getMessage());
        }
        buf.append("\n");
      }
      if (buf.length() > 0) {
        debugProcess.printToConsole(buf.toString());
      }
    }
  finally {
      StringBuilderSpinAllocator.dispose(buf);
    }
  }
  if (isRemoveAfterHit()) {
    handleTemporaryBreakpointHit(debugProcess);
  }
}
