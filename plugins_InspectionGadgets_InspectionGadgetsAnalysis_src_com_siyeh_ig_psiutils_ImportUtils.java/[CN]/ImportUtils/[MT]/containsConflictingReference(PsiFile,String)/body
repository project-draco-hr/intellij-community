{
  final Map<String,Boolean> cachedValue=CachedValuesManager.getCachedValue(element,new CachedValueProvider<Map<String,Boolean>>(){
    @Nullable @Override public Result<Map<String,Boolean>> compute(){
      return new Result<Map<String,Boolean>>(Collections.synchronizedMap(new HashMap<String,Boolean>()),PsiModificationTracker.MODIFICATION_COUNT);
    }
  }
);
  Boolean conflictingRef=cachedValue.get(fullyQualifiedName);
  if (conflictingRef != null) {
    return conflictingRef.booleanValue();
  }
  final ConflictingClassReferenceVisitor visitor=new ConflictingClassReferenceVisitor(fullyQualifiedName);
  element.accept(visitor);
  conflictingRef=visitor.isConflictingReferenceFound();
  cachedValue.put(fullyQualifiedName,conflictingRef);
  return conflictingRef.booleanValue();
}
