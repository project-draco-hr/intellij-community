{
  PsiReturnStatement returnStatement=(PsiReturnStatement)tb.getSingleStatement();
  PsiExpression value=returnStatement.getReturnValue();
  if (!isLiteral(value,Boolean.TRUE) && !isLiteral(value,Boolean.FALSE))   return;
  boolean foundResult=(boolean)((PsiLiteralExpression)value).getValue();
  PsiElement nextStatement=PsiTreeUtil.skipSiblingsForward(foreachStatement,PsiWhiteSpace.class,PsiComment.class);
  if (!(nextStatement instanceof PsiReturnStatement))   return;
  PsiReturnStatement nextReturnStatement=(PsiReturnStatement)nextStatement;
  if (!isLiteral(nextReturnStatement.getReturnValue(),!foundResult))   return;
  String methodName=foundResult ? "anyMatch" : "noneMatch";
  final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(project);
  String streamText=generateStream(iteratedValue,intermediateOps).toString();
  PsiExpression stream=elementFactory.createExpressionFromText(streamText,foreachStatement);
  if (!(stream instanceof PsiMethodCallExpression))   return;
  PsiElement nameElement=((PsiMethodCallExpression)stream).getMethodExpression().getReferenceNameElement();
  if (nameElement != null && nameElement.getText().equals("filter")) {
    nameElement.replace(elementFactory.createIdentifier(methodName));
    streamText=stream.getText();
  }
 else {
    streamText+="." + methodName + "("+ tb.getVariable().getName()+ " -> true)";
  }
  PsiElement result=foreachStatement.replace(elementFactory.createStatementFromText("return " + streamText + ";",foreachStatement));
  nextReturnStatement.delete();
  simplifyAndFormat(project,result);
}
