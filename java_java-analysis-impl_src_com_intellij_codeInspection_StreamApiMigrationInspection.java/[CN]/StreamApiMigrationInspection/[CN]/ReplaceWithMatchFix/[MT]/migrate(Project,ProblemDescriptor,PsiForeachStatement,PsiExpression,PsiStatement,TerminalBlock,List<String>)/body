{
  PsiReturnStatement returnStatement=(PsiReturnStatement)tb.getSingleStatement();
  PsiExpression value=returnStatement.getReturnValue();
  if (!isLiteral(value,Boolean.TRUE) && !isLiteral(value,Boolean.FALSE))   return;
  boolean foundResult=(boolean)((PsiLiteralExpression)value).getValue();
  PsiElement nextStatement=PsiTreeUtil.skipSiblingsForward(foreachStatement,PsiWhiteSpace.class,PsiComment.class);
  if (!(nextStatement instanceof PsiReturnStatement))   return;
  PsiReturnStatement nextReturnStatement=(PsiReturnStatement)nextStatement;
  if (!isLiteral(nextReturnStatement.getReturnValue(),!foundResult))   return;
  String methodName=foundResult ? "anyMatch" : "noneMatch";
  final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(project);
  String streamText=generateStream(iteratedValue,intermediateOps).toString();
  PsiExpression stream=elementFactory.createExpressionFromText(streamText,foreachStatement);
  if (!(stream instanceof PsiMethodCallExpression))   return;
  PsiElement nameElement=((PsiMethodCallExpression)stream).getMethodExpression().getReferenceNameElement();
  if (nameElement != null && nameElement.getText().equals("filter")) {
    if (!foundResult) {
      PsiExpression[] expressions=((PsiMethodCallExpression)stream).getArgumentList().getExpressions();
      if (expressions.length == 1 && expressions[0] instanceof PsiLambdaExpression) {
        PsiLambdaExpression lambda=(PsiLambdaExpression)expressions[0];
        PsiElement lambdaBody=lambda.getBody();
        if (lambdaBody instanceof PsiExpression && BoolUtils.isNegation((PsiExpression)lambdaBody)) {
          PsiExpression negated=BoolUtils.getNegated((PsiExpression)lambdaBody);
          LOG.assertTrue(negated != null);
          String methodReferenceText=LambdaCanBeMethodReferenceInspection.convertToMethodReference(negated,lambda.getParameterList().getParameters(),lambda.getFunctionalInterfaceType(),lambda);
          if (methodReferenceText != null) {
            lambda.replace(elementFactory.createExpressionFromText(methodReferenceText,lambda));
          }
 else {
            lambdaBody.replace(negated);
          }
          methodName="allMatch";
        }
      }
    }
    nameElement.replace(elementFactory.createIdentifier(methodName));
    streamText=stream.getText();
  }
 else {
    streamText+="." + methodName + "("+ tb.getVariable().getName()+ " -> true)";
  }
  PsiElement result=foreachStatement.replace(elementFactory.createStatementFromText("return " + streamText + ";",foreachStatement));
  nextReturnStatement.delete();
  simplifyAndFormat(project,result);
}
