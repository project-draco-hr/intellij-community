{
  ArrayList<FoldRegion> topLevels=new ArrayList<FoldRegion>(myRegions.size() / 2);
  ArrayList<FoldRegion> visible=new ArrayList<FoldRegion>(myRegions.size());
  ArrayList<FoldRegion> allValid=new ArrayList<FoldRegion>(myRegions.size());
  FoldRegion[] regions=toFoldArray(myRegions);
  FoldRegion currentCollapsed=null;
  for (  FoldRegion region : regions) {
    if (!region.isValid()) {
      continue;
    }
    allValid.add(region);
    if (!region.isExpanded()) {
      removeRegionsWithSameStartOffset(visible,region);
      removeRegionsWithSameStartOffset(topLevels,region);
    }
    if (currentCollapsed == null || !contains(currentCollapsed,region)) {
      visible.add(region);
      if (!region.isExpanded()) {
        currentCollapsed=region;
        topLevels.add(region);
      }
    }
  }
  if (allValid.size() < myRegions.size()) {
    myRegions=allValid;
  }
  myCachedTopLevelRegions=toFoldArray(topLevels);
  myCachedVisible=toFoldArray(visible);
  Arrays.sort(myCachedTopLevelRegions,BY_END_OFFSET);
  Arrays.sort(myCachedVisible,BY_END_OFFSET_REVERSE);
  updateCachedOffsets();
}
