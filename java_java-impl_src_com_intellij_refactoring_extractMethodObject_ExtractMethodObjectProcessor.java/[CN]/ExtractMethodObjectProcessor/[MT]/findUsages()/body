{
  final ArrayList<UsageInfo> result=new ArrayList<>();
  final PsiClass containingClass=getMethod().getContainingClass();
  final SearchScope scope=PsiUtilCore.getVirtualFile(containingClass) == null ? new LocalSearchScope(containingClass) : GlobalSearchScope.projectScope(myProject);
  PsiReference[] refs=ReferencesSearch.search(getMethod(),scope,false).toArray(PsiReference.EMPTY_ARRAY);
  for (  PsiReference ref : refs) {
    final PsiElement element=ref.getElement();
    if (element != null && element.isValid()) {
      result.add(new UsageInfo(element));
    }
  }
  if (isCreateInnerClass()) {
    final Set<PsiMethod> usedMethods=new LinkedHashSet<>();
    getMethod().accept(new JavaRecursiveElementWalkingVisitor(){
      @Override public void visitMethodCallExpression(      PsiMethodCallExpression expression){
        super.visitMethodCallExpression(expression);
        final PsiMethod method=expression.resolveMethod();
        if (method != null) {
          usedMethods.add(method);
        }
      }
    }
);
    for (    PsiMethod usedMethod : usedMethods) {
      if (usedMethod.hasModifierProperty(PsiModifier.PRIVATE) && (!usedMethod.hasModifierProperty(PsiModifier.STATIC) || myExtractProcessor.isStatic())) {
        PsiMethod toMove=usedMethod;
        for (        PsiReference reference : ReferencesSearch.search(usedMethod)) {
          if (!PsiTreeUtil.isAncestor(getMethod(),reference.getElement(),false)) {
            toMove=null;
            break;
          }
        }
        if (toMove != null) {
          myUsages.add(new MethodToMoveUsageInfo(toMove));
        }
      }
    }
  }
  UsageInfo[] usageInfos=result.toArray(new UsageInfo[result.size()]);
  return UsageViewUtil.removeDuplicatedUsages(usageInfos);
}
