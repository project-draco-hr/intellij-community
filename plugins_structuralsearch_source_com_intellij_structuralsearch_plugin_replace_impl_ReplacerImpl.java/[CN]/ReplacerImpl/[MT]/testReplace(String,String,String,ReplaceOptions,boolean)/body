{
  this.options=options;
  this.options.getMatchOptions().setSearchPattern(what);
  this.options.setReplacement(by);
  replacementBuilder=null;
  context=null;
  this.options.getMatchOptions().clearVariableConstraints();
  MatcherImplUtil.transform(this.options.getMatchOptions());
  checkSupportedReplacementPattern(project,this.options.getMatchOptions().getSearchPattern(),by,this.options.getMatchOptions().getFileType());
  Matcher matcher=new Matcher(project);
  try {
    PsiElement[] elements=MatcherImplUtil.createTreeFromText(in,filePattern,this.options.getMatchOptions().getFileType(),project);
    PsiElement firstElement=elements[0];
    PsiElement lastElement=elements[elements.length - 1];
    PsiElement parent=firstElement.getParent();
    this.options.getMatchOptions().setScope(new LocalSearchScope(parent));
    this.options.getMatchOptions().setResultIsContextMatch(true);
    CollectingMatchResultSink sink=new CollectingMatchResultSink();
    matcher.testFindMatches(sink,this.options.getMatchOptions());
    final List<ReplacementInfo> resultPtrList=new LinkedList<ReplacementInfo>();
    for (    final MatchResult result : sink.getMatches()) {
      resultPtrList.add(buildReplacement(result));
    }
    sink.getMatches().clear();
    int startOffset=firstElement.getTextRange().getStartOffset();
    int endOffset=filePattern ? 0 : parent.getTextLength() - (lastElement.getTextRange().getEndOffset());
    PsiElement prevSibling=firstElement.getPrevSibling();
    if (prevSibling instanceof PsiWhiteSpace) {
      startOffset-=prevSibling.getTextLength() - 1;
    }
    PsiElement nextSibling=lastElement.getNextSibling();
    if (nextSibling instanceof PsiWhiteSpace) {
      endOffset-=nextSibling.getTextLength() - 1;
    }
    replaceAll(resultPtrList);
    String result=parent.getText();
    result=result.substring(startOffset);
    result=result.substring(0,result.length() - endOffset);
    return result;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return "";
  }
}
