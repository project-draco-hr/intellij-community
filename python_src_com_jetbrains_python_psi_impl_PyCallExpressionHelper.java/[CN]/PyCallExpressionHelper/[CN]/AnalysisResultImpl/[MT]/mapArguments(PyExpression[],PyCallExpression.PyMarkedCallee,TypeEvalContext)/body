{
  if (type_context == null)   type_context=TypeEvalContext.fast();
  myMarkedCallee=resolved_callee;
  List<PyExpression> unmatched_args=new LinkedList<PyExpression>();
  Collections.addAll(unmatched_args,arguments);
  final List<PyExpression> unmatched_subargs=new LinkedList<PyExpression>();
  for (  PyExpression arg : arguments) {
    if (arg instanceof PyStarArgument) {
      PyStarArgument star_arg=(PyStarArgument)arg;
      if (star_arg.isKeyword()) {
        if (myKwdArg == null)         myKwdArg=star_arg;
 else {
          markArgument(arg,PyArgumentList.ArgFlag.IS_DUP_KWD);
          unmatched_args.remove(arg);
        }
      }
 else {
        if (myTupleArg == null)         myTupleArg=star_arg;
 else {
          markArgument(arg,PyArgumentList.ArgFlag.IS_DUP_TUPLE);
          unmatched_args.remove(arg);
        }
      }
    }
  }
  final PyParameter[] parameters=myMarkedCallee.getCallable().getParameterList().getParameters();
  Map<PyNamedParameter,PyExpression> slots=new HashMap<PyNamedParameter,PyExpression>();
  PyNamedParameter kwd_par=null;
  PyNamedParameter tuple_par=null;
  Set<PyExpression> mapped_args=new HashSet<PyExpression>();
  final int implicit_offset=resolved_callee.getImplicitOffset();
  int positional_index=0;
  int i=0;
  for (  PyParameter par : parameters) {
    if (tuple_par == null && kwd_par == null && positional_index < implicit_offset) {
      positional_index+=1;
      continue;
    }
    PyNamedParameter n_par=par.getAsNamed();
    if (n_par != null) {
      if (n_par.isPositionalContainer())       tuple_par=n_par;
 else       if (n_par.isKeywordContainer())       kwd_par=n_par;
 else {
        slots.put(n_par,null);
        positional_index+=1;
      }
    }
 else {
      PyTupleParameter t_par=par.getAsTuple();
      if (t_par != null)       positional_index+=1;
    }
    i+=1;
  }
  for (i=0; i < implicit_offset && i < parameters.length; i+=1) {
    slots.remove(parameters[i].getAsNamed());
    positional_index+=1;
  }
  int cnt=implicit_offset;
  int positional_bound=arguments.length;
  ListIterator<PyExpression> unmatched_arg_iter=unmatched_args.listIterator();
  while (unmatched_arg_iter.hasNext()) {
    PyExpression arg=unmatched_arg_iter.next();
    if (arg instanceof PyStarArgument || arg instanceof PyKeywordArgument) {
      positional_bound=cnt;
      break;
    }
    if (cnt < parameters.length && cnt < positional_index) {
      final PyParameter par=parameters[cnt];
      PyNamedParameter n_par=par.getAsNamed();
      if (n_par != null) {
        cnt+=1;
        slots.put(n_par,PyUtil.peelArgument(arg));
        mapped_args.add(arg);
      }
 else {
        PyTupleParameter t_par=par.getAsTuple();
        if (t_par != null) {
          if (arg instanceof PyParenthesizedExpression) {
            mapped_args.add(arg);
          }
 else {
            PyType arg_type=type_context.getType(arg);
            if (arg_type != null && arg_type.isBuiltin() && "list".equals(arg_type.getName())) {
              mapped_args.add(arg);
            }
          }
          unmatched_arg_iter.previous();
          MyParamVisitor visitor=new MyParamVisitor(unmatched_arg_iter,this);
          visitor.enterTuple(t_par.getAsTuple());
          unmatched_subargs.addAll(visitor.getUnmatchedSubargs());
          cnt+=1;
        }
      }
    }
 else     break;
  }
  for (  Map.Entry<PyExpression,List<PyNamedParameter>> pair : myNestedMappedParams.entrySet()) {
    PyExpression arg=pair.getKey();
    List<PyNamedParameter> params=pair.getValue();
    mapped_args.add(arg);
    for (    PyNamedParameter n_par : params)     slots.remove(n_par);
  }
  for (  PyExpression arg : unmatched_subargs) {
    markArgument(arg,PyArgumentList.ArgFlag.IS_UNMAPPED);
  }
  i=positional_bound;
  while (i < arguments.length) {
    PyExpression arg=arguments[i];
    if (!(arg instanceof PyStarArgument) && !(arg instanceof PyKeywordArgument)) {
      markArgument(arg,PyArgumentList.ArgFlag.IS_POS_PAST_KWD);
    }
    i+=1;
  }
  boolean seen_named_args=false;
  Map<String,PyNamedParameter> parameter_by_name=new HashMap<String,PyNamedParameter>();
  for (  PyParameter par : parameters) {
    PyNamedParameter n_par=par.getAsNamed();
    if (n_par != null)     parameter_by_name.put(n_par.getName(),n_par);
  }
  for (  PyExpression arg : arguments) {
    if (arg instanceof PyKeywordArgument) {
      String arg_name=((PyKeywordArgument)arg).getKeyword();
      PyNamedParameter respective_par=parameter_by_name.get(arg_name);
      if (respective_par != null && !respective_par.isKeywordContainer() && !respective_par.isPositionalContainer()) {
        if (slots.get(respective_par) != null)         markArgument(arg,PyArgumentList.ArgFlag.IS_DUP);
 else         slots.put(respective_par,arg);
      }
 else {
        if (kwd_par != null) {
          myPlainMappedParams.put(arg,kwd_par);
          mapped_args.add(arg);
        }
      }
      seen_named_args=true;
    }
  }
  boolean tuple_arg_not_exhausted=false;
  boolean tuple_dup_found=false;
  if (cnt < parameters.length && cnt < positional_index && myTupleArg != null) {
    PyType tuple_arg_type=null;
    if (type_context != null) {
      final PyExpression expression=PsiTreeUtil.getChildOfType(myTupleArg,PyExpression.class);
      if (expression != null) {
        tuple_arg_type=type_context.getType(expression);
      }
    }
    int tuple_length;
    boolean tuple_length_known;
    if (tuple_arg_type instanceof PyTupleType) {
      tuple_length=((PyTupleType)tuple_arg_type).getElementCount();
      tuple_length_known=true;
    }
 else {
      tuple_length=2000000;
      tuple_length_known=false;
    }
    int mapped_params_count=0;
    while (cnt < parameters.length && cnt < positional_index && mapped_params_count < tuple_length) {
      PyParameter par=parameters[cnt];
      if (par instanceof PySingleStarParameter)       break;
      PyNamedParameter n_par=par.getAsNamed();
      if (slots.containsKey(n_par)) {
        final PyExpression arg_here=slots.get(n_par);
        if (arg_here != null) {
          if (tuple_length_known) {
            final EnumSet<PyArgumentList.ArgFlag> flags=myArgFlags.get(arg_here);
            if (flags == null || flags.isEmpty()) {
              markArgument(arg_here,PyArgumentList.ArgFlag.IS_DUP);
              tuple_dup_found=true;
            }
          }
          break;
        }
 else         if (n_par != null) {
          myTupleMappedParams.add(n_par);
          mapped_args.add(myTupleArg);
          slots.remove(n_par);
        }
      }
 else       if (n_par == tuple_par) {
        mapped_params_count=tuple_length;
        break;
      }
      cnt+=1;
      mapped_params_count+=1;
    }
    if (tuple_length_known && (mapped_params_count < tuple_length) || mapped_params_count == 0) {
      tuple_arg_not_exhausted=true;
    }
  }
  if (tuple_par != null) {
    i=0;
    while (i < arguments.length && mapped_args.contains(arguments[i]) && isPositionalArg(arguments[i])) {
      i+=1;
    }
    if (i < arguments.length && isPositionalArg(arguments[i])) {
      while (i < arguments.length && !mapped_args.contains(arguments[i]) && isPositionalArg(arguments[i])) {
        myPlainMappedParams.put(arguments[i],tuple_par);
        mapped_args.add(arguments[i]);
        i+=1;
      }
    }
  }
  if (myTupleArg != null && tuple_par != null) {
    if (!mapped_args.contains(myTupleArg)) {
      myTupleMappedParams.add(tuple_par);
      mapped_args.add(myTupleArg);
    }
 else     if (!seen_named_args && tuple_arg_not_exhausted) {
      myTupleMappedParams.add(tuple_par);
      mapped_args.add(myTupleArg);
      tuple_arg_not_exhausted=false;
    }
  }
  if (tuple_arg_not_exhausted && !tuple_dup_found) {
    markArgument(myTupleArg,PyArgumentList.ArgFlag.IS_TOO_LONG);
  }
  if (myKwdArg != null) {
    for (    PyParameter par : parameters) {
      PyNamedParameter n_par=par.getAsNamed();
      if (n_par != null && !n_par.isKeywordContainer() && !n_par.isPositionalContainer() && slots.get(n_par) == null) {
        slots.put(n_par,myKwdArg);
      }
    }
  }
  if (myKwdArg != null && kwd_par != null && !mapped_args.contains(myKwdArg)) {
    myKwdMappedParams.add(kwd_par);
    mapped_args.add(myKwdArg);
  }
  for (  Map.Entry<PyNamedParameter,PyExpression> pair : slots.entrySet()) {
    PyNamedParameter n_par=pair.getKey();
    PyExpression arg=pair.getValue();
    if (arg == null) {
      if (!n_par.hasDefaultValue())       myUnmappedParams.add(n_par);
    }
 else {
      if (arg == myTupleArg) {
        myTupleMappedParams.add(n_par);
      }
 else       if (arg == myKwdArg) {
        myKwdMappedParams.add(n_par);
      }
 else {
        myPlainMappedParams.put(arg,n_par);
      }
    }
  }
  for (  PyExpression arg : slots.values()) {
    if (arg != null)     mapped_args.add(arg);
  }
  for (  PyExpression arg : arguments) {
    if (!mapped_args.contains(arg)) {
      final EnumSet<PyArgumentList.ArgFlag> flags=myArgFlags.get(arg);
      if (flags == null || flags.isEmpty()) {
        markArgument(arg,PyArgumentList.ArgFlag.IS_UNMAPPED);
      }
    }
  }
}
