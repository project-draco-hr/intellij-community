{
  if (!TypeEvalStack.mayEvaluate(call)) {
    return null;
  }
  try {
    PyExpression callee=call.getCallee();
    if (callee instanceof PyReferenceExpression) {
      if (PyNames.SUPER.equals(callee.getText())) {
        final Maybe<PyType> superCallType=getSuperCallType(call,context);
        if (superCallType.isDefined()) {
          return superCallType.value();
        }
      }
      if ("type".equals(callee.getText())) {
        final PyExpression[] args=call.getArguments();
        if (args.length == 1) {
          final PyExpression arg=args[0];
          final PyType argType=context.getType(arg);
          if (argType instanceof PyClassType) {
            final PyClassType classType=(PyClassType)argType;
            if (!classType.isDefinition()) {
              final PyClass cls=classType.getPyClass();
              return context.getType(cls);
            }
          }
 else {
            return null;
          }
        }
      }
      final PyResolveContext resolveContext=PyResolveContext.noImplicits().withTypeEvalContext(context);
      final PsiPolyVariantReference reference=((PyReferenceExpression)callee).getReference(resolveContext);
      final List<PyType> members=new ArrayList<PyType>();
      for (      PsiElement target : PyUtil.multiResolveTopPriority(reference)) {
        if (target != null) {
          final Ref<? extends PyType> typeRef=getCallTargetReturnType(call,target,context);
          if (typeRef != null) {
            members.add(typeRef.get());
          }
        }
      }
      if (!members.isEmpty()) {
        return PyUnionType.union(members);
      }
    }
    if (callee == null) {
      return null;
    }
 else {
      final PyType type=context.getType(callee);
      if (type instanceof PyCallableType) {
        final PyCallableType callableType=(PyCallableType)type;
        return callableType.getCallType(context,call);
      }
      return null;
    }
  }
  finally {
    TypeEvalStack.evaluated(call);
  }
}
