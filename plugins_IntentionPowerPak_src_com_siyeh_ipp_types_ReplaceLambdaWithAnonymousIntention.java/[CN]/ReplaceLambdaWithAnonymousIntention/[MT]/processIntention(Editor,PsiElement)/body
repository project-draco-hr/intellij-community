{
  final PsiLambdaExpression lambdaExpression=PsiTreeUtil.getParentOfType(element,PsiLambdaExpression.class);
  LOG.assertTrue(lambdaExpression != null);
  final PsiParameter[] paramListCopy=((PsiParameterList)lambdaExpression.getParameterList().copy()).getParameters();
  final PsiType functionalInterfaceType=lambdaExpression.getFunctionalInterfaceType();
  LOG.assertTrue(functionalInterfaceType != null);
  final PsiMethod method=LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);
  LOG.assertTrue(method != null);
  final String blockText=getBodyText(lambdaExpression);
  if (blockText == null)   return;
  final PsiElementFactory psiElementFactory=JavaPsiFacade.getElementFactory(element.getProject());
  PsiCodeBlock blockFromText=psiElementFactory.createCodeBlockFromText(blockText,lambdaExpression);
  ChangeContextUtil.encodeContextInfo(blockFromText,true);
  PsiNewExpression newExpression=(PsiNewExpression)psiElementFactory.createExpressionFromText("new " + functionalInterfaceType.getCanonicalText() + "(){}",lambdaExpression);
  final PsiClass thisClass=RefactoringChangeUtil.getThisClass(lambdaExpression);
  final String thisClassName=thisClass != null ? thisClass.getName() : null;
  if (thisClassName != null) {
    final PsiThisExpression thisAccessExpr=thisClass instanceof PsiAnonymousClass ? null : RefactoringChangeUtil.createThisExpression(lambdaExpression.getManager(),thisClass);
    ChangeContextUtil.decodeContextInfo(blockFromText,thisClass,thisAccessExpr);
    final Map<PsiElement,PsiElement> replacements=new HashMap<PsiElement,PsiElement>();
    blockFromText.accept(new JavaRecursiveElementWalkingVisitor(){
      @Override public void visitClass(      PsiClass aClass){
      }
      @Override public void visitSuperExpression(      PsiSuperExpression expression){
        super.visitSuperExpression(expression);
        if (expression.getQualifier() == null) {
          replacements.put(expression,psiElementFactory.createExpressionFromText(thisClassName + "." + expression.getText(),expression));
        }
      }
      @Override public void visitMethodCallExpression(      PsiMethodCallExpression expression){
        super.visitMethodCallExpression(expression);
        if (thisAccessExpr != null) {
          final PsiMethod psiMethod=expression.resolveMethod();
          if (psiMethod != null && !psiMethod.hasModifierProperty(PsiModifier.STATIC) && expression.getMethodExpression().getQualifierExpression() == null) {
            replacements.put(expression,psiElementFactory.createExpressionFromText(thisAccessExpr.getText() + "." + expression.getText(),expression));
          }
        }
      }
    }
);
    for (    PsiElement psiElement : replacements.keySet()) {
      psiElement.replace(replacements.get(psiElement));
    }
  }
  blockFromText=psiElementFactory.createCodeBlockFromText(blockFromText.getText(),null);
  newExpression=(PsiNewExpression)JavaCodeStyleManager.getInstance(lambdaExpression.getProject()).shortenClassReferences(lambdaExpression.replace(newExpression));
  final PsiAnonymousClass anonymousClass=newExpression.getAnonymousClass();
  LOG.assertTrue(anonymousClass != null);
  final List<PsiGenerationInfo<PsiMethod>> infos=OverrideImplementUtil.overrideOrImplement(anonymousClass,method);
  if (infos != null && infos.size() == 1) {
    final PsiMethod member=infos.get(0).getPsiMember();
    final PsiParameter[] parameters=member.getParameterList().getParameters();
    for (int i=0; i < parameters.length; i++) {
      final PsiParameter parameter=parameters[i];
      final String lambdaParamName=paramListCopy[i].getName();
      if (lambdaParamName != null) {
        parameter.setName(lambdaParamName);
      }
    }
    PsiCodeBlock codeBlock=member.getBody();
    LOG.assertTrue(codeBlock != null);
    codeBlock=(PsiCodeBlock)codeBlock.replace(blockFromText);
    GenerateMembersUtil.positionCaret(editor,member,true);
  }
}
