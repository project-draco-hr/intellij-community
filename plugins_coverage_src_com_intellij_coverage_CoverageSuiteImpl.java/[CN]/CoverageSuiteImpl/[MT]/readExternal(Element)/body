{
  final String sourceProvider=element.getAttributeValue(SOURCE_PROVIDER);
  final String relativePath=FileUtil.toSystemDependentName(element.getAttributeValue(FILE_PATH));
  final File file=new File(relativePath);
  myCoverageDataFileProvider=new DefaultCoverageFileProvider(file.exists() ? file : new File(PathManager.getSystemPath(),relativePath),sourceProvider != null ? sourceProvider : DefaultCoverageFileProvider.class.getName());
  myName=element.getAttributeValue(NAME_ATTRIBUTE);
  if (myName == null)   myName=generateName();
  myLastCoverageTimeStamp=Long.parseLong(element.getAttributeValue(MODIFIED_STAMP));
  final List children=element.getChildren(FILTER);
  List<String> filters=new ArrayList<String>();
  for (  Element child : ((Iterable<Element>)children)) {
    filters.add(child.getValue());
  }
  myFilters=filters.isEmpty() ? null : ArrayUtil.toStringArray(filters);
  mySuiteToMerge=element.getAttributeValue(MERGE_SUITE);
  final String runner=element.getAttributeValue(COVERAGE_RUNNER);
  if (runner != null) {
    for (    CoverageRunner coverageRunner : Extensions.getExtensions(CoverageRunner.EP_NAME)) {
      if (Comparing.strEqual(coverageRunner.getId(),runner)) {
        myRunner=coverageRunner;
        break;
      }
    }
  }
 else {
    myRunner=CoverageRunner.getInstance(IDEACoverageRunner.class);
  }
  final String collectedLineInfo=element.getAttributeValue(COVERAGE_BY_TEST_ENABLED_ATTRIBUTE_NAME);
  myCoverageByTestEnabled=collectedLineInfo != null && Boolean.valueOf(collectedLineInfo).booleanValue();
  final String tracingEnabled=element.getAttributeValue(TRACING_ENABLED_ATTRIBUTE_NAME);
  myTracingEnabled=tracingEnabled != null && Boolean.valueOf(tracingEnabled).booleanValue();
}
