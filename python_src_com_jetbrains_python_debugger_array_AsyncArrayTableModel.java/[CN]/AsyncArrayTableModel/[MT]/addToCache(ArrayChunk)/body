{
  Object[][] data=chunk.getData();
  int cols=data.length;
  int rows=data[0].length;
  for (int roffset=0; roffset < rows / CHUNK_ROW_SIZE; roffset++) {
    for (int coffset=0; coffset < cols / CHUNK_COL_SIZE; coffset++) {
      Pair<Integer,Integer> key=itemToChunkKey(roffset * CHUNK_ROW_SIZE,coffset * CHUNK_COL_SIZE);
      final Object[][] chunkData=new Object[CHUNK_ROW_SIZE][CHUNK_COL_SIZE];
      for (int r=0; r < CHUNK_ROW_SIZE; r++) {
        System.arraycopy(data[roffset * CHUNK_ROW_SIZE + r],coffset * 30,chunkData[r],0,CHUNK_COL_SIZE);
      }
      myChunkCache.put(key,new ListenableFuture<ArrayChunk>(){
        @Override public void addListener(        @NotNull Runnable listener,        @NotNull Executor executor){
        }
        @Override public boolean cancel(        boolean mayInterruptIfRunning){
          return false;
        }
        @Override public boolean isCancelled(){
          return false;
        }
        @Override public boolean isDone(){
          return true;
        }
        @Override public ArrayChunk get() throws InterruptedException, ExecutionException {
          return new ArrayChunkBuilder().setValue(chunk.getValue()).setSlicePresentation(null).setRows(0).setColumns(0).setMax(null).setMin(null).setFormat(null).setType(null).setData(chunkData).createArrayChunk();
        }
        @Override public ArrayChunk get(        long timeout,        TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
          return new ArrayChunkBuilder().setValue(chunk.getValue()).setSlicePresentation(null).setRows(0).setColumns(0).setMax(null).setMin(null).setFormat(null).setType(null).setData(chunkData).createArrayChunk();
        }
      }
);
    }
  }
  handleChunkAdded(0,0,chunk);
}
