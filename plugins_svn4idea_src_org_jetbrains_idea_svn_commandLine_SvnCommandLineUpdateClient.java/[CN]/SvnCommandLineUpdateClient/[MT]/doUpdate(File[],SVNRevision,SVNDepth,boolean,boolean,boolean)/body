{
  final SvnCommandLineInfoClient infoClient=new SvnCommandLineInfoClient(myProject);
  final SVNInfo info=infoClient.doInfo(paths[0],SVNRevision.UNDEFINED);
  if (info == null || info.getURL() == null) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.WC_NOT_WORKING_COPY,paths[0].getPath()));
  }
  final AtomicReference<long[]> updatedToRevision=new AtomicReference<long[]>();
  updatedToRevision.set(new long[0]);
  File base=myCommonAncestor == null ? paths[0] : new File(myCommonAncestor.getPath());
  base=base.isDirectory() ? base : base.getParentFile();
  final List<String> parameters=prepareParameters(paths,revision,depth,allowUnversionedObstructions,depthIsSticky,makeParents);
  final BaseUpdateCommandListener listener=createCommandListener(paths,updatedToRevision,base);
  try {
    SvnLineCommand.runWithAuthenticationAttempt(base,info.getURL(),SvnCommandName.up,listener,new IdeaSvnkitBasedAuthenticationCallback(SvnVcs.getInstance(myProject)),ArrayUtil.toStringArray(parameters));
  }
 catch (  SvnBindException e) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR,e));
  }
  listener.throwIfException();
  return updatedToRevision.get();
}
