{
  if (myArgumentList == null || !PsiUtil.isLanguageLevel8OrHigher(myArgumentList)) {
    return getApplicabilityLevel();
  }
  @ApplicabilityLevelConstant int level;
  Integer boxedLevel=ourOverloadGuard.doPreventingRecursion(myArgumentList,false,new Computable<Integer>(){
    @Override public Integer compute(){
      if (PsiUtil.isLanguageLevel8OrHigher(myArgumentList)) {
        PsiSubstitutor substitutor=getSubstitutor(false);
        Map<PsiElement,CurrentCandidateProperties> map=CURRENT_CANDIDATE.get();
        if (map == null) {
          map=new ConcurrentWeakHashMap<PsiElement,CurrentCandidateProperties>();
          CURRENT_CANDIDATE.set(map);
        }
        final PsiMethod method=getElement();
        final CurrentCandidateProperties properties=new CurrentCandidateProperties(method,substitutor,isVarargs(),true);
        final CurrentCandidateProperties alreadyThere=map.put(getMarkerList(),properties);
        try {
          properties.setSubstitutor(substitutor);
          PsiType[] argumentTypes=getArgumentTypes();
          if (argumentTypes == null) {
            return ApplicabilityLevel.NOT_APPLICABLE;
          }
          final int applicabilityLevel=PsiUtil.getApplicabilityLevel(method,substitutor,argumentTypes,myLanguageLevel);
          if (!isVarargs() && applicabilityLevel < ApplicabilityLevel.FIXED_ARITY) {
            return ApplicabilityLevel.NOT_APPLICABLE;
          }
          return applicabilityLevel;
        }
  finally {
          if (alreadyThere == null)           map.remove(getMarkerList());
        }
      }
      return getApplicabilityLevelInner();
    }
  }
);
  if (boxedLevel == null) {
    return getApplicabilityLevel();
  }
  level=boxedLevel;
  if (level > ApplicabilityLevel.NOT_APPLICABLE && !isTypeArgumentsApplicable(false))   level=ApplicabilityLevel.NOT_APPLICABLE;
  return level;
}
