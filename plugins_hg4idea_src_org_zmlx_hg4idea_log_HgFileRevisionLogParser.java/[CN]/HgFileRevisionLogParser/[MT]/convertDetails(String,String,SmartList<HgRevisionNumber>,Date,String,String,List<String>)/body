{
  int numAttributes=attributes.size();
  String commitMessage=parseAdditionalStringAttribute(attributes,MESSAGE_INDEX);
  String branchName=parseAdditionalStringAttribute(attributes,BRANCH_INDEX);
  final HgRevisionNumber vcsRevisionNumber=new HgRevisionNumber(rev,changeset,author,commitMessage,parents);
  Set<String> filesAdded=Collections.emptySet();
  Set<String> filesModified=Collections.emptySet();
  Set<String> filesDeleted=Collections.emptySet();
  Map<String,String> copies=Collections.emptyMap();
  boolean shouldParseOldTemplate=!myVersion.isBuiltInFunctionSupported();
  if (numAttributes > FILES_ADDED_INDEX) {
    filesAdded=parseFileList(attributes.get(FILES_ADDED_INDEX));
    if (numAttributes > FILES_MODIFIED_INDEX) {
      filesModified=parseFileList(attributes.get(FILES_MODIFIED_INDEX));
      if (numAttributes > FILES_DELETED_INDEX) {
        filesDeleted=parseFileList(attributes.get(FILES_DELETED_INDEX));
        if (numAttributes > FILES_COPIED_INDEX) {
          copies=shouldParseOldTemplate ? parseCopiesFileListAsOldVersion(attributes.get(FILES_COPIED_INDEX)) : parseCopiesFileList(attributes.get(FILES_COPIED_INDEX));
          Iterator<String> keys=copies.keySet().iterator();
          while (keys.hasNext()) {
            String s=keys.next();
            if (filesAdded.contains(copies.get(s)) && filesDeleted.contains(s)) {
              filesAdded.remove(copies.get(s));
              filesDeleted.remove(s);
            }
 else             if (!filesDeleted.contains(s)) {
              keys.remove();
            }
          }
        }
      }
    }
  }
  return new HgFileRevision(myProject,myHgFile,vcsRevisionNumber,branchName,revisionDate,author,commitMessage,filesModified,filesAdded,filesDeleted,copies);
}
