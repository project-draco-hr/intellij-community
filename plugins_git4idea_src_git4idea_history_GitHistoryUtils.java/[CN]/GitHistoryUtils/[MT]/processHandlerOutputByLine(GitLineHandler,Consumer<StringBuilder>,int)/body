{
  final StringBuilder output=new StringBuilder();
  final StringBuilder errors=new StringBuilder();
  final Ref<Boolean> foundRecordEnd=Ref.create(false);
  final Ref<VcsException> ex=new Ref<>();
  final AtomicInteger records=new AtomicInteger();
  handler.addLineListener(new GitLineHandlerListener(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (outputType == ProcessOutputTypes.STDERR) {
        errors.append(line).append("\n");
      }
 else       if (outputType == ProcessOutputTypes.STDOUT) {
        try {
          String tail=null;
          if (!foundRecordEnd.get()) {
            int recordEnd=line.indexOf(GitLogParser.RECORD_END);
            if (recordEnd != -1) {
              foundRecordEnd.set(true);
              output.append(line.substring(0,recordEnd + 1));
              line=line.substring(recordEnd + 1);
            }
 else {
              output.append(line).append("\n");
            }
          }
          if (foundRecordEnd.get()) {
            int nextRecordStart=line.indexOf(GitLogParser.RECORD_START);
            if (nextRecordStart == -1) {
              output.append(line).append("\n");
            }
 else             if (nextRecordStart == 0) {
              tail=line + "\n";
            }
 else {
              output.append(line.substring(0,nextRecordStart));
              tail=line.substring(nextRecordStart) + "\n";
            }
          }
          if (tail != null) {
            if (records.incrementAndGet() > bufferSize) {
              recordConsumer.consume(output);
              output.setLength(0);
            }
            output.append(tail);
            foundRecordEnd.set(false);
          }
        }
 catch (        Exception e) {
          ex.set(new VcsException(e));
        }
      }
    }
    @Override public void processTerminated(    int exitCode){
      if (exitCode != 0) {
        String errorMessage=errors.toString();
        if (errorMessage.isEmpty()) {
          errorMessage=GitBundle.message("git.error.exit",exitCode);
        }
        ex.set(new VcsException(errorMessage));
      }
 else {
        try {
          recordConsumer.consume(output);
        }
 catch (        Exception e) {
          ex.set(new VcsException(e));
        }
      }
    }
    @Override public void startFailed(    Throwable exception){
      ex.set(new VcsException(exception));
    }
  }
);
  handler.runInCurrentThread(null);
  if (!ex.isNull()) {
    if (ex.get().getCause() instanceof ProcessCanceledException) {
      throw (ProcessCanceledException)ex.get().getCause();
    }
    throw ex.get();
  }
}
