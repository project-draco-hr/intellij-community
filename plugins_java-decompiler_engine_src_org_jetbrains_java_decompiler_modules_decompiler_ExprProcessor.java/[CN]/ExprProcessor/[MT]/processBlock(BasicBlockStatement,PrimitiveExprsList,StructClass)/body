{
  ConstantPool pool=cl.getPool();
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  BasicBlock block=stat.getBlock();
  ExprentStack stack=data.getStack();
  List<Exprent> exprlist=data.getLstExprents();
  InstructionSequence seq=block.getSeq();
  for (int i=0; i < seq.length(); i++) {
    Instruction instr=seq.getInstr(i);
    Integer bytecode_offset=block.getOldOffset(i);
    Set<Integer> bytecode_offsets=bytecode_offset >= 0 ? Collections.singleton(bytecode_offset) : null;
switch (instr.opcode) {
case opc_aconst_null:
      pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_NULL,null,bytecode_offsets));
    break;
case opc_bipush:
case opc_sipush:
  pushEx(stack,exprlist,new ConstExprent(instr.getOperand(0),true,bytecode_offsets));
break;
case opc_lconst_0:
case opc_lconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_LONG,new Long(instr.opcode - opc_lconst_0),bytecode_offsets));
break;
case opc_fconst_0:
case opc_fconst_1:
case opc_fconst_2:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_FLOAT,new Float(instr.opcode - opc_fconst_0),bytecode_offsets));
break;
case opc_dconst_0:
case opc_dconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_DOUBLE,new Double(instr.opcode - opc_dconst_0),bytecode_offsets));
break;
case opc_ldc:
case opc_ldc_w:
case opc_ldc2_w:
PooledConstant cn=pool.getConstant(instr.getOperand(0));
if (cn instanceof PrimitiveConstant) {
pushEx(stack,exprlist,new ConstExprent(consts[cn.type - CONSTANT_Integer],((PrimitiveConstant)cn).value,bytecode_offsets));
}
 else if (cn instanceof LinkConstant) {
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_STRING,((LinkConstant)cn).elementname,bytecode_offsets));
}
break;
case opc_iload:
case opc_lload:
case opc_fload:
case opc_dload:
case opc_aload:
pushEx(stack,exprlist,new VarExprent(instr.getOperand(0),vartypes[instr.opcode - opc_iload],varProcessor));
break;
case opc_iaload:
case opc_laload:
case opc_faload:
case opc_daload:
case opc_aaload:
case opc_baload:
case opc_caload:
case opc_saload:
Exprent index=stack.pop();
Exprent arr=stack.pop();
VarType vartype=null;
switch (instr.opcode) {
case opc_laload:
vartype=VarType.VARTYPE_LONG;
break;
case opc_daload:
vartype=VarType.VARTYPE_DOUBLE;
}
pushEx(stack,exprlist,new ArrayExprent(arr,index,arrtypes[instr.opcode - opc_iaload],bytecode_offsets),vartype);
break;
case opc_istore:
case opc_lstore:
case opc_fstore:
case opc_dstore:
case opc_astore:
Exprent top=stack.pop();
int varindex=instr.getOperand(0);
AssignmentExprent assign=new AssignmentExprent(new VarExprent(varindex,vartypes[instr.opcode - opc_istore],varProcessor),top,bytecode_offsets);
exprlist.add(assign);
break;
case opc_iastore:
case opc_lastore:
case opc_fastore:
case opc_dastore:
case opc_aastore:
case opc_bastore:
case opc_castore:
case opc_sastore:
Exprent value=stack.pop();
Exprent index_store=stack.pop();
Exprent arr_store=stack.pop();
AssignmentExprent arrassign=new AssignmentExprent(new ArrayExprent(arr_store,index_store,arrtypes[instr.opcode - opc_iastore],bytecode_offsets),value,bytecode_offsets);
exprlist.add(arrassign);
break;
case opc_iadd:
case opc_ladd:
case opc_fadd:
case opc_dadd:
case opc_isub:
case opc_lsub:
case opc_fsub:
case opc_dsub:
case opc_imul:
case opc_lmul:
case opc_fmul:
case opc_dmul:
case opc_idiv:
case opc_ldiv:
case opc_fdiv:
case opc_ddiv:
case opc_irem:
case opc_lrem:
case opc_frem:
case opc_drem:
pushEx(stack,exprlist,new FunctionExprent(func1[(instr.opcode - opc_iadd) / 4],stack,bytecode_offsets));
break;
case opc_ishl:
case opc_lshl:
case opc_ishr:
case opc_lshr:
case opc_iushr:
case opc_lushr:
case opc_iand:
case opc_land:
case opc_ior:
case opc_lor:
case opc_ixor:
case opc_lxor:
pushEx(stack,exprlist,new FunctionExprent(func2[(instr.opcode - opc_ishl) / 2],stack,bytecode_offsets));
break;
case opc_ineg:
case opc_lneg:
case opc_fneg:
case opc_dneg:
pushEx(stack,exprlist,new FunctionExprent(FunctionExprent.FUNCTION_NEG,stack,bytecode_offsets));
break;
case opc_iinc:
VarExprent vevar=new VarExprent(instr.getOperand(0),VarType.VARTYPE_INT,varProcessor);
exprlist.add(new AssignmentExprent(vevar,new FunctionExprent(instr.getOperand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD,Arrays.asList(vevar.copy(),new ConstExprent(VarType.VARTYPE_INT,Math.abs(instr.getOperand(1)),null)),bytecode_offsets),bytecode_offsets));
break;
case opc_i2l:
case opc_i2f:
case opc_i2d:
case opc_l2i:
case opc_l2f:
case opc_l2d:
case opc_f2i:
case opc_f2l:
case opc_f2d:
case opc_d2i:
case opc_d2l:
case opc_d2f:
case opc_i2b:
case opc_i2c:
case opc_i2s:
pushEx(stack,exprlist,new FunctionExprent(func3[instr.opcode - opc_i2l],stack,bytecode_offsets));
break;
case opc_lcmp:
case opc_fcmpl:
case opc_fcmpg:
case opc_dcmpl:
case opc_dcmpg:
pushEx(stack,exprlist,new FunctionExprent(func4[instr.opcode - opc_lcmp],stack,bytecode_offsets));
break;
case opc_ifeq:
case opc_ifne:
case opc_iflt:
case opc_ifge:
case opc_ifgt:
case opc_ifle:
exprlist.add(new IfExprent(negifs[func5[instr.opcode - opc_ifeq]],stack,bytecode_offsets));
break;
case opc_if_icmpeq:
case opc_if_icmpne:
case opc_if_icmplt:
case opc_if_icmpge:
case opc_if_icmpgt:
case opc_if_icmple:
case opc_if_acmpeq:
case opc_if_acmpne:
exprlist.add(new IfExprent(negifs[func6[instr.opcode - opc_if_icmpeq]],stack,bytecode_offsets));
break;
case opc_ifnull:
case opc_ifnonnull:
exprlist.add(new IfExprent(negifs[func7[instr.opcode - opc_ifnull]],stack,bytecode_offsets));
break;
case opc_tableswitch:
case opc_lookupswitch:
exprlist.add(new SwitchExprent(stack.pop(),bytecode_offsets));
break;
case opc_ireturn:
case opc_lreturn:
case opc_freturn:
case opc_dreturn:
case opc_areturn:
case opc_return:
case opc_athrow:
exprlist.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,instr.opcode == opc_return ? null : stack.pop(),instr.opcode == opc_athrow ? null : ((MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR)).ret,bytecode_offsets));
break;
case opc_monitorenter:
case opc_monitorexit:
exprlist.add(new MonitorExprent(func8[instr.opcode - opc_monitorenter],stack.pop(),bytecode_offsets));
break;
case opc_checkcast:
case opc_instanceof:
stack.push(new ConstExprent(new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true),null,null));
case opc_arraylength:
pushEx(stack,exprlist,new FunctionExprent(mapConsts.get(instr.opcode).intValue(),stack,bytecode_offsets));
break;
case opc_getstatic:
case opc_getfield:
pushEx(stack,exprlist,new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_getstatic ? null : stack.pop(),bytecode_offsets));
break;
case opc_putstatic:
case opc_putfield:
Exprent valfield=stack.pop();
Exprent exprfield=new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_putstatic ? null : stack.pop(),bytecode_offsets);
exprlist.add(new AssignmentExprent(exprfield,valfield,bytecode_offsets));
break;
case opc_invokevirtual:
case opc_invokespecial:
case opc_invokestatic:
case opc_invokeinterface:
case opc_invokedynamic:
if (instr.opcode != opc_invokedynamic || instr.bytecode_version >= CodeConstants.BYTECODE_JAVA_7) {
LinkConstant invoke_constant=pool.getLinkConstant(instr.getOperand(0));
int dynamic_invokation_type=-1;
if (instr.opcode == opc_invokedynamic && bootstrap != null) {
List<PooledConstant> bootstrap_arguments=bootstrap.getMethodArguments(invoke_constant.index1);
LinkConstant content_method_handle=(LinkConstant)bootstrap_arguments.get(1);
dynamic_invokation_type=content_method_handle.index1;
}
InvocationExprent exprinv=new InvocationExprent(instr.opcode,invoke_constant,stack,dynamic_invokation_type,bytecode_offsets);
if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
exprlist.add(exprinv);
}
 else {
pushEx(stack,exprlist,exprinv);
}
}
break;
case opc_new:
case opc_anewarray:
case opc_multianewarray:
int dimensions=(instr.opcode == opc_new) ? 0 : (instr.opcode == opc_anewarray) ? 1 : instr.getOperand(1);
VarType arrType=new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true);
if (instr.opcode != opc_multianewarray) {
arrType=arrType.resizeArrayDim(arrType.arrayDim + dimensions);
}
pushEx(stack,exprlist,new NewExprent(arrType,stack,dimensions,bytecode_offsets));
break;
case opc_newarray:
pushEx(stack,exprlist,new NewExprent(new VarType(arr_type[instr.getOperand(0) - 4],1),stack,1,bytecode_offsets));
break;
case opc_dup:
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
break;
case opc_dup_x1:
insertByOffsetEx(-2,stack,exprlist,-1);
break;
case opc_dup_x2:
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
}
 else {
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
}
break;
case opc_dup2_x1:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2_x2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
}
 else {
if (stack.getByOffset(-3).getExprType().stackSize == 2) {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-4,stack,exprlist,-2);
insertByOffsetEx(-4,stack,exprlist,-1);
}
}
break;
case opc_swap:
insertByOffsetEx(-2,stack,exprlist,-1);
stack.pop();
break;
case opc_pop:
case opc_pop2:
stack.pop();
}
}
}
