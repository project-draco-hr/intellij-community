{
  final ThreadReferenceProxyImpl thread=myDebuggerContext.getThreadProxy();
  try {
    if (!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {
      DebuggerInvocationUtil.swingInvokeLater(getProject(),new Runnable(){
        @Override public void run(){
          try {
            myFramesListener.setEnabled(false);
synchronized (myFramesList) {
              myFramesLastUpdateTime=getNextStamp();
              final DefaultListModel model=myFramesList.getModel();
              model.clear();
              model.addElement(new Object(){
                public String toString(){
                  return DebuggerBundle.message("frame.panel.frames.not.available");
                }
              }
);
              myFramesList.setSelectedIndex(0);
            }
          }
  finally {
            myFramesListener.setEnabled(true);
          }
        }
      }
);
      return;
    }
  }
 catch (  ObjectCollectedException ignored) {
    return;
  }
  List<StackFrameProxyImpl> frames;
  try {
    frames=thread.frames();
  }
 catch (  EvaluateException ignored) {
    frames=Collections.emptyList();
  }
  final StackFrameProxyImpl contextFrame=myDebuggerContext.getFrameProxy();
  final EvaluationContextImpl evaluationContext=myDebuggerContext.createEvaluationContext();
  final DebuggerManagerThreadImpl managerThread=myDebuggerContext.getDebugProcess().getManagerThread();
  final MethodsTracker tracker=new MethodsTracker();
  final int totalFramesCount=frames.size();
  int index=0;
  final IndexCounter indexCounter=new IndexCounter(totalFramesCount);
  final long timestamp=getNextStamp();
  for (  StackFrameProxyImpl stackFrameProxy : frames) {
    managerThread.schedule(new AppendFrameCommand(getSuspendContext(),stackFrameProxy,evaluationContext,tracker,index++,stackFrameProxy.equals(contextFrame),timestamp,indexCounter));
  }
}
