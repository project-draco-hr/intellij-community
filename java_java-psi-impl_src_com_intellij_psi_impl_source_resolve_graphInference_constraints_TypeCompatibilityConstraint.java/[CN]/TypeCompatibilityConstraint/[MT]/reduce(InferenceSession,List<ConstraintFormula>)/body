{
  if (session.isProperType(myT) && session.isProperType(myS)) {
    final boolean assignable=TypeConversionUtil.isAssignable(myT,myS);
    if (!assignable) {
      session.registerIncompatibleErrorMessage("Incompatible types: " + session.getPresentableText(myS) + " is not convertible to "+ session.getPresentableText(myT));
    }
    return assignable;
  }
  if (myS instanceof PsiPrimitiveType && !PsiType.VOID.equals(myS)) {
    final PsiClassType boxedType=((PsiPrimitiveType)myS).getBoxedType(session.getManager(),session.getScope());
    if (boxedType != null) {
      constraints.add(new TypeCompatibilityConstraint(myT,boxedType));
      return true;
    }
  }
  if (myT instanceof PsiPrimitiveType && !PsiType.VOID.equals(myT)) {
    final PsiClassType boxedType=((PsiPrimitiveType)myT).getBoxedType(session.getManager(),session.getScope());
    if (boxedType != null) {
      constraints.add(new TypeEqualityConstraint(boxedType,myS));
      return true;
    }
  }
  if (isUncheckedConversion(myT,myS)) {
    session.setErased();
    return true;
  }
  constraints.add(new StrictSubtypingConstraint(myT,myS));
  return true;
}
