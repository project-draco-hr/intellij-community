{
  final AtomicBoolean errorReceived=new AtomicBoolean(false);
  final SvnLineCommand command=new SvnLineCommand(base,commandName,exePath,configDir){
    int myErrCnt=0;
    @Override protected void onTextAvailable(    String text,    Key outputType){
      if (ProcessOutputTypes.STDERR.equals(outputType)) {
        ++myErrCnt;
        errorReceived.set(true);
      }
      super.onTextAvailable(text,outputType);
    }
  }
;
  command.setOriginalParameters(originalParameters);
  command.addParameters(parameters);
  command.addParameters("--non-interactive");
  final AtomicReference<Throwable> exceptionRef=new AtomicReference<Throwable>();
  command.addLineListener(new LineProcessEventListener(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (LOG.isDebugEnabled()) {
        LOG.debug("==> " + line);
      }
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        System.out.println("==> " + line);
      }
      listener.onLineAvailable(line,outputType);
      if (listener.isCanceled()) {
        LOG.info("Cancelling command: " + command.getCommandText());
        command.destroyProcess();
      }
    }
    @Override public void processTerminated(    int exitCode){
      listener.processTerminated(exitCode);
      command.setExitCodeReference(exitCode);
    }
    @Override public void startFailed(    Throwable exception){
      listener.startFailed(exception);
      exceptionRef.set(exception);
    }
  }
);
  command.start();
  boolean finished;
  do {
    finished=command.waitFor(500);
    if (!finished && (errorReceived.get() || command.needsDestroy())) {
      command.waitFor(1000);
      command.doDestroyProcess();
      break;
    }
  }
 while (!finished);
  if (exceptionRef.get() != null) {
    throw new SvnBindException(exceptionRef.get());
  }
  return command;
}
