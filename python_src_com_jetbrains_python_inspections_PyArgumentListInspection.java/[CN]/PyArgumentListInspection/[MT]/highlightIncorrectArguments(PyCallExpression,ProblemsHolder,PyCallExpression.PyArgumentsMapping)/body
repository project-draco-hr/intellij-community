{
  final Set<PyExpression> problematicArguments=new HashSet<PyExpression>();
  for (  Map.Entry<PyExpression,ArgumentProblem> entry : analyzeArguments(callExpr).entrySet()) {
    final PyExpression argument=entry.getKey();
    final ArgumentProblem problem=entry.getValue();
switch (problem) {
case OK:
      break;
case DUPLICATE_KEYWORD_ARGUMENT:
    holder.registerProblem(argument,PyBundle.message("INSP.duplicate.argument"),new PyRemoveArgumentQuickFix());
  break;
case DUPLICATE_KEYWORD_CONTAINER:
holder.registerProblem(argument,PyBundle.message("INSP.duplicate.doublestar.arg"),new PyRemoveArgumentQuickFix());
break;
case DUPLICATE_POSITIONAL_CONTAINER:
holder.registerProblem(argument,PyBundle.message("INSP.duplicate.star.arg"),new PyRemoveArgumentQuickFix());
break;
case CANNOT_APPEAR_AFTER_KEYWORD_OR_CONTAINER:
holder.registerProblem(argument,PyBundle.message("INSP.cannot.appear.past.keyword.arg"),ProblemHighlightType.ERROR,new PyRemoveArgumentQuickFix());
}
if (problem != ArgumentProblem.OK) {
problematicArguments.add(argument);
}
}
for (PyExpression argument : mapping.getUnmappedArguments()) {
if (!problematicArguments.contains(argument)) {
final List<LocalQuickFix> quickFixes=Lists.<LocalQuickFix>newArrayList(new PyRemoveArgumentQuickFix());
if (argument instanceof PyKeywordArgument) {
quickFixes.add(new PyRenameArgumentQuickFix());
}
holder.registerProblem(argument,PyBundle.message("INSP.unexpected.arg"),quickFixes.toArray(new LocalQuickFix[quickFixes.size() - 1]));
}
}
}
