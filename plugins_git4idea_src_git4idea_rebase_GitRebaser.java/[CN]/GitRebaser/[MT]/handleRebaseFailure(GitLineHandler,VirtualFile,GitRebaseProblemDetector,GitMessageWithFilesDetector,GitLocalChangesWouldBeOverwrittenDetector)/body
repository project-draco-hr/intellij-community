{
  if (rebaseConflictDetector.isMergeConflict()) {
    LOG.info("handleRebaseFailure merge conflict");
    final boolean allMerged=new GitRebaser.ConflictResolver(myProject,myGit,root,this).merge();
    return allMerged ? GitUpdateResult.SUCCESS_WITH_RESOLVED_CONFLICTS : GitUpdateResult.INCOMPLETE;
  }
 else   if (untrackedWouldBeOverwrittenDetector.wasMessageDetected()) {
    LOG.info("handleRebaseFailure: untracked files would be overwritten by checkout");
    GitUntrackedFilesHelper.notifyUntrackedFilesOverwrittenBy(myProject,root,untrackedWouldBeOverwrittenDetector.getRelativeFilePaths(),"rebase",null);
    return GitUpdateResult.ERROR;
  }
 else   if (localChangesDetector.wasMessageDetected()) {
    LocalChangesWouldBeOverwrittenHelper.showErrorNotification(myProject,root,"rebase",localChangesDetector.getRelativeFilePaths());
    return GitUpdateResult.ERROR;
  }
 else {
    LOG.info("handleRebaseFailure error " + handler.errors());
    GitUIUtil.notifyImportantError(myProject,"Rebase error",GitUIUtil.stringifyErrors(handler.errors()));
    return GitUpdateResult.ERROR;
  }
}
