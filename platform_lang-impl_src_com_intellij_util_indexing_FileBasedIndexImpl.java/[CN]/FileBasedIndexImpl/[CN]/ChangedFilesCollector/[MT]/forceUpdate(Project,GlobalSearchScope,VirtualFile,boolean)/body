{
  myChangedFilesCollector.ensureAllInvalidateTasksCompleted();
  ProjectIndexableFilesFilter indexableFilesFilter=projectIndexableFiles(project);
  int filesProcessedOutsideScope=0;
  UpdateSemaphore updateSemaphore;
  do {
    updateSemaphore=obtainForceUpdateSemaphore();
    try {
      List<VirtualFile> filesToUpdate=getAllFilesToUpdate();
      for (int i=0, size=filesToUpdate.size(); i < size; ++i) {
        VirtualFile file=filesToUpdate.get(i);
        if ((indexableFilesFilter != null && file instanceof VirtualFileWithId && !indexableFilesFilter.containsFileId(((VirtualFileWithId)file).getId())) || filter != null && !filter.accept(file) || restrictedTo != null && restrictedTo != file) {
          if (filesProcessedOutsideScope >= MAX_FILES_TO_PROCESS_OUTSIDE_SCOPE)           continue;
          ++filesProcessedOutsideScope;
        }
        try {
          updateSemaphore.down();
          processFileImpl(project,new com.intellij.ide.caches.FileContent(file),onlyRemoveOutdatedData);
        }
 catch (        ProcessCanceledException e) {
          updateSemaphore.reportUpdateCanceled();
          throw e;
        }
 finally {
          updateSemaphore.up();
        }
      }
      while (!updateSemaphore.waitFor(500)) {
        if (Thread.holdsLock(PsiLock.LOCK)) {
          break;
        }
      }
    }
  finally {
      releaseForceUpdateSemaphore(updateSemaphore);
    }
  }
 while (updateSemaphore.isUpdateCanceled());
}
