{
  myChangedFilesCollector.ensureAllInvalidateTasksCompleted();
  ProjectIndexableFilesFilter indexableFilesFilter=projectIndexableFiles(project);
  int filesProcessedOutsideProject=0;
  UpdateSemaphore updateSemaphore;
  do {
    updateSemaphore=obtainForceUpdateSemaphore();
    try {
      List<VirtualFile> filesToUpdate=getAllFilesToUpdate();
      for (int i=0, size=filesToUpdate.size(); i < size; ++i) {
        VirtualFile file=filesToUpdate.get(i);
        boolean forceProcessFile;
        if (indexableFilesFilter != null && file instanceof VirtualFileWithId && !indexableFilesFilter.containsFileId(((VirtualFileWithId)file).getId())) {
          if (filesProcessedOutsideProject >= MAX_FILES_TO_PROCESS_OUTSIDE_PROJECT)           continue;
          ++filesProcessedOutsideProject;
          forceProcessFile=true;
        }
 else {
          forceProcessFile=Comparing.equal(file,restrictedTo);
        }
        if (filter == null || filter.accept(file) || forceProcessFile) {
          try {
            updateSemaphore.down();
            processFileImpl(project,new com.intellij.ide.caches.FileContent(file),onlyRemoveOutdatedData);
          }
 catch (          ProcessCanceledException e) {
            updateSemaphore.reportUpdateCanceled();
            throw e;
          }
 finally {
            updateSemaphore.up();
          }
        }
      }
      while (!updateSemaphore.waitFor(500)) {
        if (Thread.holdsLock(PsiLock.LOCK)) {
          break;
        }
      }
    }
  finally {
      releaseForceUpdateSemaphore(updateSemaphore);
    }
  }
 while (updateSemaphore.isUpdateCanceled());
}
