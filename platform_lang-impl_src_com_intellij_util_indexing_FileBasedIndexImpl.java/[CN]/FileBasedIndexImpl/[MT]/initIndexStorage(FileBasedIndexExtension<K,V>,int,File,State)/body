{
  MapIndexStorage<K,V> storage=null;
  final ID<K,V> name=extension.getName();
  boolean contentHashesEnumeratorOk=false;
  for (int attempt=0; attempt < 2; attempt++) {
    try {
      if (extension.hasSnapshotMapping()) {
        ContentHashesSupport.initContentHashesEnumerator();
        contentHashesEnumeratorOk=true;
      }
      storage=new MapIndexStorage<K,V>(IndexInfrastructure.getStorageFile(name),extension.getKeyDescriptor(),extension.getValueExternalizer(),extension.getCacheSize(),extension.keyIsUniqueForIndexedFile(),extension.traceKeyHashToVirtualFileMapping());
      InputFilter inputFilter=extension.getInputFilter();
      Pair<UpdatableIndex<?,?,FileContent>,InputFilter> pair=new Pair<>(createIndex(extension,new MemoryIndexStorage<K,V>(storage)),new IndexableFilesFilter(inputFilter));
      if (inputFilter instanceof FileTypeSpecificInputFilter) {
        ((FileTypeSpecificInputFilter)inputFilter).registerFileTypesUsedForIndexing(new Consumer<FileType>(){
          final Set<FileType> addedTypes=new THashSet<FileType>();
          @Override public void consume(          FileType type){
            if (type == null || !addedTypes.add(type)) {
              return;
            }
synchronized (state) {
              List<ID<?,?>> ids=state.myFileType2IndicesWithFileTypeInfoMap.get(type);
              if (ids == null)               state.myFileType2IndicesWithFileTypeInfoMap.put(type,ids=new ArrayList<ID<?,?>>(5));
              ids.add(name);
            }
          }
        }
);
      }
 else {
synchronized (state) {
          state.myIndicesWithoutFileTypeInfo.add(name);
        }
      }
synchronized (state) {
        state.myIndices.put(name,pair);
      }
      break;
    }
 catch (    Exception e) {
      LOG.info(e);
      boolean instantiatedStorage=storage != null;
      try {
        if (storage != null)         storage.close();
        storage=null;
      }
 catch (      Exception ignored) {
      }
      FileUtil.deleteWithRenaming(IndexInfrastructure.getIndexRootDir(name));
      if (extension.hasSnapshotMapping() && (!contentHashesEnumeratorOk || instantiatedStorage)) {
        FileUtil.deleteWithRenaming(IndexInfrastructure.getPersistentIndexRootDir(name));
      }
      IndexingStamp.rewriteVersion(versionFile,version);
    }
  }
}
