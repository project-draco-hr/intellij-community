{
  super(project,true);
  myCallback=callback;
  myExecutors=executors;
  setModal(false);
  setTitle(applyPatchMode.getTitle());
  final FileChooserDescriptor descriptor=createSelectPatchDescriptor();
  descriptor.setTitle(VcsBundle.message("patch.apply.select.title"));
  myProject=project;
  myPatches=new LinkedList<AbstractFilePatchInProgress>();
  myRecentPathFileChange=new AtomicReference<FilePresentation>();
  myBinaryShelvedPatches=binaryShelvedPatches;
  myPreselectedChanges=preselectedChanges;
  myChangesTreeList=new MyChangeTreeList(project,Collections.<AbstractFilePatchInProgress.PatchChange>emptyList(),new Runnable(){
    public void run(){
      final NamedTrinity includedTrinity=new NamedTrinity();
      final Collection<AbstractFilePatchInProgress.PatchChange> includedChanges=myChangesTreeList.getIncludedChanges();
      final Set<Couple<String>> set=new HashSet<Couple<String>>();
      for (      AbstractFilePatchInProgress.PatchChange change : includedChanges) {
        final FilePatch patch=change.getPatchInProgress().getPatch();
        final Couple<String> pair=Couple.of(patch.getBeforeName(),patch.getAfterName());
        if (set.contains(pair))         continue;
        set.add(pair);
        acceptChange(includedTrinity,change);
      }
      myInfoCalculator.setIncluded(includedTrinity);
      myCommitLegendPanel.update();
    }
  }
,new MyChangeNodeDecorator());
  myChangesTreeList.setDoubleClickHandler(new Runnable(){
    @Override public void run(){
      new MyShowDiff().showDiff();
    }
  }
);
  myUpdater=new MyUpdater();
  myPatchFile=new TextFieldWithBrowseButton();
  myPatchFile.addBrowseFolderListener(VcsBundle.message("patch.apply.select.title"),"",project,descriptor);
  myPatchFile.getTextField().getDocument().addDocumentListener(new DocumentAdapter(){
    protected void textChanged(    DocumentEvent e){
      setPathFileChangeDefault();
      queueRequest();
    }
  }
);
  myLoadQueue=new ZipperUpdater(500,Alarm.ThreadToUse.POOLED_THREAD,getDisposable());
  myCanChangePatchFile=applyPatchMode.isCanChangePatchFile();
  myReset=myCanChangePatchFile ? new Runnable(){
    public void run(){
      reset();
    }
  }
 : EmptyRunnable.getInstance();
  myChangeListChooser=new ChangeListChooserPanel(project,new NullableConsumer<String>(){
    public void consume(    final @Nullable String errorMessage){
      setOKActionEnabled(errorMessage == null);
      setErrorText(errorMessage);
    }
  }
);
  ChangeListManager changeListManager=ChangeListManager.getInstance(project);
  myChangeListChooser.setChangeLists(changeListManager.getChangeListsCopy());
  myChangeListChooser.setDefaultSelection(changeListManager.getDefaultChangeList());
  myChangeListChooser.init();
  myInfoCalculator=new ChangesLegendCalculator();
  myCommitLegendPanel=new CommitLegendPanel(myInfoCalculator);
  init();
  if (patchFile != null && patchFile.isValid()) {
    init(patchFile);
  }
 else   if (patches != null) {
    init(patches,defaultList);
  }
  myPatchFileLabel.setVisible(myCanChangePatchFile);
  myPatchFile.setVisible(myCanChangePatchFile);
  if (myCanChangePatchFile) {
    myListener=new VirtualFileAdapter(){
      @Override public void contentsChanged(      @NotNull VirtualFileEvent event){
        if (myRecentPathFileChange.get() != null && myRecentPathFileChange.get().getVf() != null && event.getFile().equals(myRecentPathFileChange.get().getVf())) {
          queueRequest();
        }
      }
    }
;
    final VirtualFileManager fileManager=VirtualFileManager.getInstance();
    fileManager.addVirtualFileListener(myListener);
    Disposer.register(getDisposable(),new Disposable(){
      @Override public void dispose(){
        fileManager.removeVirtualFileListener(myListener);
      }
    }
);
  }
}
