{
  final ExecutionResult executionResult=startSMRunner(executor);
  if (executionResult != null) {
    return executionResult;
  }
  final JUnitProcessHandler handler=createHandler(executor);
  final RunnerSettings runnerSettings=getRunnerSettings();
  JavaRunConfigurationExtensionManager.getInstance().attachExtensionsToProcess(getConfiguration(),handler,runnerSettings);
  final TestProxy unboundOutputRoot=new TestProxy(new RootTestInfo());
  final JUnitConsoleProperties consoleProperties=new JUnitConsoleProperties(getConfiguration(),executor);
  final JUnitTreeConsoleView consoleView=new JUnitTreeConsoleView(consoleProperties,getEnvironment(),unboundOutputRoot);
  Disposer.register(getConfiguration().getProject(),consoleView);
  consoleView.initUI();
  consoleView.attachToProcess(handler);
  unboundOutputRoot.setPrinter(consoleView.getPrinter());
  Disposer.register(consoleView,unboundOutputRoot);
  final TestsPacketsReceiver packetsReceiver=new TestsPacketsReceiver(consoleView,unboundOutputRoot){
    @Override public synchronized void notifyStart(    TestProxy root){
      if (!isRunning())       return;
      super.notifyStart(root);
      unboundOutputRoot.addChild(root);
      if (getConfiguration().isSaveOutputToFile()) {
        unboundOutputRoot.setOutputFilePath(getConfiguration().getOutputFilePath());
      }
      final JUnitRunningModel model=getModel();
      if (model != null) {
        handler.getOut().setDispatchListener(model.getNotifier());
        Disposer.register(model,new Disposable(){
          @Override public void dispose(){
            handler.getOut().setDispatchListener(DispatchListener.DEAF);
          }
        }
);
        consoleView.attachToModel(model);
      }
    }
  }
;
  Disposer.register(consoleView,packetsReceiver);
  final DeferredActionsQueue queue=new DeferredActionsQueueImpl();
  handler.getOut().setPacketDispatcher(packetsReceiver,queue);
  handler.getErr().setPacketDispatcher(packetsReceiver,queue);
  handler.addProcessListener(new ProcessAdapter(){
    private boolean myStarted=false;
    @Override public void startNotified(    ProcessEvent event){
      myStarted=true;
    }
    @Override public void processTerminated(    ProcessEvent event){
      handler.removeProcessListener(this);
      if (myTempFile != null) {
        FileUtil.delete(myTempFile);
      }
      if (myListenersFile != null) {
        FileUtil.delete(myListenersFile);
      }
      final Runnable runnable=new Runnable(){
        @Override public void run(){
          unboundOutputRoot.flush();
          packetsReceiver.checkTerminated();
          final JUnitRunningModel model=packetsReceiver.getModel();
          notifyByBalloon(model,myStarted,consoleProperties);
        }
      }
;
      handler.getOut().addRequest(runnable,queue);
    }
    @Override public void onTextAvailable(    final ProcessEvent event,    final Key outputType){
      final String text=event.getText();
      final ConsoleViewContentType consoleViewType=ConsoleViewContentType.getConsoleViewType(outputType);
      final Printable printable=new Printable(){
        @Override public void printOn(        final Printer printer){
          printer.print(text,consoleViewType);
        }
      }
;
      final Extractor extractor;
      if (consoleViewType == ConsoleViewContentType.ERROR_OUTPUT || consoleViewType == ConsoleViewContentType.SYSTEM_OUTPUT) {
        extractor=handler.getErr();
      }
 else {
        extractor=handler.getOut();
      }
      extractor.getEventsDispatcher().processOutput(printable);
    }
  }
);
  final RerunFailedTestsAction rerunFailedTestsAction=new RerunFailedTestsAction(consoleView,consoleProperties);
  rerunFailedTestsAction.setModelProvider(new Getter<TestFrameworkRunningModel>(){
    @Override public TestFrameworkRunningModel get(){
      return packetsReceiver.getModel();
    }
  }
);
  final DefaultExecutionResult result=new DefaultExecutionResult(consoleView,handler);
  result.setRestartActions(rerunFailedTestsAction);
  return result;
}
