{
  final InferenceVariable inferenceVariable=shouldResolveAndInstantiate(returnType,targetType);
  if (inferenceVariable != null) {
    final PsiSubstitutor substitutor=resolveSubset(Collections.singletonList(inferenceVariable),mySiteSubstitutor);
    final PsiType substitutedReturnType=substitutor.substitute(inferenceVariable.getParameter());
    if (substitutedReturnType != null) {
      addConstraint(new TypeCompatibilityConstraint(targetType,PsiUtil.captureToplevelWildcards(substitutedReturnType,myContext)));
    }
  }
 else {
    if (FunctionalInterfaceParameterizationUtil.isWildcardParameterized(returnType)) {
      final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(returnType);
      final PsiClass psiClass=resolveResult.getElement();
      if (psiClass != null) {
        LOG.assertTrue(returnType instanceof PsiClassType);
        final PsiTypeParameter[] typeParameters=psiClass.getTypeParameters();
        PsiSubstitutor subst=PsiSubstitutor.EMPTY;
        final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(psiClass.getProject());
        PsiTypeParameter[] copy=new PsiTypeParameter[typeParameters.length];
        for (int i=0; i < typeParameters.length; i++) {
          PsiTypeParameter typeParameter=typeParameters[i];
          copy[i]=elementFactory.createTypeParameterFromText("rCopy" + typeParameter.getName(),null);
          initBounds(copy[i]);
          subst=subst.put(typeParameter,elementFactory.createType(copy[i]));
        }
        final PsiType substitutedCapture=PsiUtil.captureToplevelWildcards(subst.substitute(returnType),myContext);
        myIncorporationPhase.addCapture(copy,(PsiClassType)returnType);
        addConstraint(new TypeCompatibilityConstraint(targetType,substitutedCapture));
      }
    }
 else {
      addConstraint(new TypeCompatibilityConstraint(targetType,myErased ? TypeConversionUtil.erasure(returnType) : returnType));
    }
  }
}
