{
  try {
    if (initialSubstitutor == null && !repeatInferencePhases(true)) {
      return resolveSubset(myInferenceVariables,mySiteSubstitutor);
    }
    if (properties != null && !properties.isApplicabilityCheck()) {
      if (initialSubstitutor == null) {
        initReturnTypeConstraint(properties.getMethod(),(PsiCall)parent);
        if (!repeatInferencePhases(true)) {
          return prepareSubstitution();
        }
      }
      if (parameters != null && args != null) {
        final Set<ConstraintFormula> additionalConstraints=new LinkedHashSet<ConstraintFormula>();
        if (parameters.length > 0) {
          collectAdditionalConstraints(parameters,args,properties.getMethod(),mySiteSubstitutor,additionalConstraints,properties.isVarargs());
        }
        if (!additionalConstraints.isEmpty() && !proceedWithAdditionalConstraints(additionalConstraints)) {
          return prepareSubstitution().putAll(retrieveNonPrimitiveEqualsBounds(myInferenceVariables));
        }
      }
    }
    if (initialSubstitutor == null) {
      initialSubstitutor=PsiSubstitutor.EMPTY;
    }
    final PsiSubstitutor substitutor=resolveBounds(myInferenceVariables,initialSubstitutor);
    if (substitutor != null) {
      if (myContext != null) {
        myContext.putUserData(ERASED,myErased);
      }
      final Map<PsiTypeParameter,PsiType> map=substitutor.getSubstitutionMap();
      for (      PsiTypeParameter parameter : map.keySet()) {
        final PsiType mapping=map.get(parameter);
        PsiTypeParameter param;
        if (parameter instanceof InferenceVariable) {
          ((InferenceVariable)parameter).setInstantiation(mapping);
          if (((InferenceVariable)parameter).getCallContext() != myContext) {
            continue;
          }
          param=((InferenceVariable)parameter).getParameter();
        }
 else {
          param=parameter;
        }
        mySiteSubstitutor=mySiteSubstitutor.put(param,mapping);
      }
    }
 else {
      return prepareSubstitution();
    }
    return prepareSubstitution();
  }
  finally {
    for (    ConstraintFormula formula : myConstraintsCopy) {
      if (formula instanceof InputOutputConstraintFormula) {
        LambdaUtil.getFunctionalTypeMap().remove(((InputOutputConstraintFormula)formula).getExpression());
      }
    }
    if (properties != null && myErrorMessages != null) {
      properties.getInfo().setInferenceError(StringUtil.join(myErrorMessages,"\n"));
    }
  }
}
