{
  for (int i=0; i < args.length; i++) {
    if (args[i] != null) {
      InferenceSession session=myNestedSessions.get(PsiTreeUtil.getParentOfType(args[i],PsiCallExpression.class));
      if (session == null) {
        session=this;
      }
      PsiType parameterType=session.substituteWithInferenceVariables(getParameterType(parameters,i,siteSubstitutor,varargs));
      if (!isPertinentToApplicability(args[i],parentMethod)) {
        additionalConstraints.add(new ExpressionCompatibilityConstraint(args[i],parameterType));
      }
      additionalConstraints.add(new CheckedExceptionCompatibilityConstraint(args[i],parameterType));
      if (args[i] instanceof PsiCallExpression && PsiPolyExpressionUtil.isPolyExpression(args[i])) {
        final PsiCallExpression callExpression=(PsiCallExpression)args[i];
        collectAdditionalConstraints(additionalConstraints,callExpression);
      }
 else       if (args[i] instanceof PsiLambdaExpression && toplevel) {
        final PsiType interfaceReturnType=LambdaUtil.getFunctionalInterfaceReturnType(parameterType);
        if (interfaceReturnType != null) {
          final List<PsiExpression> returnExpressions=LambdaUtil.getReturnExpressions((PsiLambdaExpression)args[i]);
          for (          PsiExpression returnExpression : returnExpressions) {
            if (returnExpression instanceof PsiCallExpression) {
              final PsiCallExpression callExpression=(PsiCallExpression)returnExpression;
              collectAdditionalConstraints(additionalConstraints,callExpression);
            }
          }
        }
      }
    }
  }
}
