{
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
  final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
  LOG.assertTrue(interfaceMethod != null,myContext);
  final PsiSubstitutor functionalInterfaceSubstitutor=LambdaUtil.getSubstitutor(interfaceMethod,resolveResult);
  final MethodSignature signature=interfaceMethod.getSignature(functionalInterfaceSubstitutor);
  final boolean varargs=candidateInfo.isVarargs();
  final PsiMethod method=candidateInfo.getElement();
  final PsiClass methodContainingClass=method.getContainingClass();
  final PsiMethodReferenceUtil.QualifierResolveResult qualifierResolveResult=PsiMethodReferenceUtil.getQualifierResolveResult(reference);
  final PsiClass containingClass=qualifierResolveResult.getContainingClass();
  LOG.assertTrue(containingClass != null,myContext);
  final PsiParameter[] functionalMethodParameters=interfaceMethod.getParameterList().getParameters();
  final PsiParameter[] parameters=method.getParameterList().getParameters();
  final boolean isStatic=method.hasModifierProperty(PsiModifier.STATIC);
  PsiSubstitutor psiSubstitutor=qualifierResolveResult.getSubstitutor();
  if (parameters.length == functionalMethodParameters.length && !varargs || isStatic && varargs) {
    if (method.isConstructor() && PsiUtil.isRawSubstitutor(containingClass,psiSubstitutor)) {
      initBounds(containingClass.getTypeParameters());
      psiSubstitutor=PsiSubstitutor.EMPTY;
    }
    if (methodContainingClass != null) {
      psiSubstitutor=TypeConversionUtil.getClassSubstitutor(methodContainingClass,containingClass,psiSubstitutor);
      LOG.assertTrue(psiSubstitutor != null,"derived: " + containingClass + "; super: "+ methodContainingClass);
    }
    for (int i=0; i < functionalMethodParameters.length; i++) {
      final PsiType pType=signature.getParameterTypes()[i];
      addConstraint(new TypeCompatibilityConstraint(substituteWithInferenceVariables(getParameterType(parameters,i,psiSubstitutor,varargs)),PsiImplUtil.normalizeWildcardTypeByPosition(pType,reference)));
    }
  }
 else   if (PsiMethodReferenceUtil.isResolvedBySecondSearch(reference,signature,varargs,isStatic,parameters.length)) {
    initBounds(containingClass.getTypeParameters());
    final PsiType pType=signature.getParameterTypes()[0];
    if (PsiUtil.isRawSubstitutor(containingClass,psiSubstitutor)) {
      final PsiClassType.ClassResolveResult pResult=PsiUtil.resolveGenericsClassInType(PsiImplUtil.normalizeWildcardTypeByPosition(pType,(PsiExpression)myContext));
      final PsiClass pClass=pResult.getElement();
      final PsiSubstitutor receiverSubstitutor=pClass != null ? TypeConversionUtil.getClassSubstitutor(containingClass,pClass,pResult.getSubstitutor()) : null;
      if (receiverSubstitutor != null) {
        if (!method.hasTypeParameters()) {
          if (signature.getParameterTypes().length == 1 || PsiUtil.isRawSubstitutor(containingClass,receiverSubstitutor)) {
            return receiverSubstitutor;
          }
        }
        psiSubstitutor=receiverSubstitutor;
      }
    }
 else     if (methodContainingClass != null) {
      psiSubstitutor=TypeConversionUtil.getClassSubstitutor(methodContainingClass,containingClass,psiSubstitutor);
      LOG.assertTrue(psiSubstitutor != null,"derived: " + containingClass + "; super: "+ methodContainingClass);
    }
    final PsiType qType=JavaPsiFacade.getElementFactory(method.getProject()).createType(containingClass,psiSubstitutor);
    addConstraint(new TypeCompatibilityConstraint(substituteWithInferenceVariables(qType),pType));
    for (int i=0; i < signature.getParameterTypes().length - 1; i++) {
      final PsiType interfaceParamType=signature.getParameterTypes()[i + 1];
      addConstraint(new TypeCompatibilityConstraint(substituteWithInferenceVariables(getParameterType(parameters,i,psiSubstitutor,varargs)),PsiImplUtil.normalizeWildcardTypeByPosition(interfaceParamType,reference)));
    }
  }
  return null;
}
