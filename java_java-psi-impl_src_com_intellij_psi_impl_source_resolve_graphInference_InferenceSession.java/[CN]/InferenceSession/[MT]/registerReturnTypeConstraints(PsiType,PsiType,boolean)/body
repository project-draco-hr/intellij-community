{
  returnType=substituteWithInferenceVariables(returnType);
  final InferenceVariable inferenceVariable=shouldResolveAndInstantiate(returnType,targetType);
  if (inferenceVariable != null) {
    final PsiSubstitutor substitutor=resolveSubset(Collections.singletonList(inferenceVariable),mySiteSubstitutor);
    final PsiType substitutedReturnType=substitutor.substitute(inferenceVariable.getParameter());
    if (substitutedReturnType != null) {
      addConstraint(new TypeCompatibilityConstraint(targetType,PsiUtil.captureToplevelWildcards(substitutedReturnType,(PsiExpression)myContext)));
    }
  }
 else {
    if (FunctionalInterfaceParameterizationUtil.isWildcardParameterized(returnType)) {
      final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(returnType);
      final PsiClass psiClass=resolveResult.getElement();
      if (psiClass != null) {
        LOG.assertTrue(returnType instanceof PsiClassType);
        PsiClassType substitutedCapture=(PsiClassType)returnType;
        if (!toplevel) {
          substitutedCapture=(PsiClassType)PsiUtil.captureToplevelWildcards(returnType,(PsiExpression)myContext);
          final PsiTypeParameter[] typeParameters=psiClass.getTypeParameters();
          final InferenceVariable[] copy=initBounds(null,typeParameters);
          final PsiType[] parameters=substitutedCapture.getParameters();
          final PsiType[] newParameters=new PsiType[parameters.length];
          final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(myManager.getProject());
          for (int i=0; i < parameters.length; i++) {
            newParameters[i]=parameters[i];
            if (parameters[i] instanceof PsiCapturedWildcardType) {
              newParameters[i]=elementFactory.createType(copy[i]);
            }
          }
          substitutedCapture=elementFactory.createType(psiClass,newParameters);
          myIncorporationPhase.addCapture(copy,substitutedCapture);
        }
        addConstraint(new TypeCompatibilityConstraint(targetType,substitutedCapture));
      }
    }
 else {
      addConstraint(new TypeCompatibilityConstraint(targetType,myErased ? TypeConversionUtil.erasure(returnType) : returnType));
    }
  }
}
