{
  while (!additionalConstraints.isEmpty()) {
    final Set<InferenceVariable> outputVariables=new HashSet<InferenceVariable>();
    for (    ConstraintFormula constraint : additionalConstraints) {
      if (constraint instanceof InputOutputConstraintFormula) {
        final Set<InferenceVariable> inputVariables=((InputOutputConstraintFormula)constraint).getInputVariables(this);
        final Set<InferenceVariable> outputVars=((InputOutputConstraintFormula)constraint).getOutputVariables(inputVariables,this);
        if (outputVars != null) {
          outputVariables.addAll(outputVars);
        }
      }
    }
    Set<ConstraintFormula> subset=new HashSet<ConstraintFormula>();
    final Set<InferenceVariable> varsToResolve=new HashSet<InferenceVariable>();
    for (    ConstraintFormula constraint : additionalConstraints) {
      if (constraint instanceof InputOutputConstraintFormula) {
        final Set<InferenceVariable> inputVariables=((InputOutputConstraintFormula)constraint).getInputVariables(this);
        if (inputVariables != null) {
          boolean dependsOnOutput=false;
          for (          InferenceVariable inputVariable : inputVariables) {
            final Set<InferenceVariable> dependencies=inputVariable.getDependencies(this);
            dependencies.add(inputVariable);
            dependencies.retainAll(outputVariables);
            if (!dependencies.isEmpty()) {
              dependsOnOutput=true;
              break;
            }
          }
          if (!dependsOnOutput) {
            subset.add(constraint);
            varsToResolve.addAll(inputVariables);
          }
        }
 else {
          subset.add(constraint);
          Set<InferenceVariable> outputVars=((InputOutputConstraintFormula)constraint).getOutputVariables(null,this);
          if (outputVars != null) {
            varsToResolve.addAll(outputVars);
          }
        }
      }
 else {
        subset.add(constraint);
      }
    }
    if (subset.isEmpty()) {
      subset=Collections.singleton(additionalConstraints.iterator().next());
    }
    additionalConstraints.removeAll(subset);
    myConstraints.addAll(subset);
    if (!repeatInferencePhases(true)) {
      return false;
    }
    PsiSubstitutor substitutor=resolveBounds(varsToResolve,mySiteSubstitutor,false);
    for (    ConstraintFormula additionalConstraint : additionalConstraints) {
      additionalConstraint.apply(substitutor);
    }
  }
  return true;
}
