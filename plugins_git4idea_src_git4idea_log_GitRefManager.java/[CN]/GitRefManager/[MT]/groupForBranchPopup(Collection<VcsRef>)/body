{
  List<RefGroup> simpleGroups=ContainerUtil.newArrayList();
  List<VcsRef> localBranches=ContainerUtil.newArrayList();
  List<VcsRef> trackedBranches=ContainerUtil.newArrayList();
  MultiMap<GitRemote,VcsRef> remoteRefGroups=MultiMap.create();
  MultiMap<VirtualFile,VcsRef> refsByRoot=groupRefsByRoot(refs);
  for (  Map.Entry<VirtualFile,Collection<VcsRef>> entry : refsByRoot.entrySet()) {
    VirtualFile root=entry.getKey();
    List<VcsRef> refsInRoot=ContainerUtil.sorted(entry.getValue(),myLabelsComparator);
    GitRepository repository=myRepositoryManager.getRepositoryForRoot(root);
    if (repository == null) {
      LOG.warn("No repository for root: " + root);
      continue;
    }
    Set<String> locals=getLocalBranches(repository);
    Set<String> tracked=getTrackedRemoteBranches(repository);
    Map<String,GitRemote> allRemote=getAllRemoteBranches(repository);
    for (    VcsRef ref : refsInRoot) {
      if (ref.getType() == HEAD) {
        simpleGroups.add(new SingletonRefGroup(ref));
        continue;
      }
      String refName=ref.getName();
      if (locals.contains(refName)) {
        localBranches.add(ref);
      }
 else       if (allRemote.containsKey(refName)) {
        if (tracked.contains(refName)) {
          trackedBranches.add(ref);
        }
 else {
          remoteRefGroups.putValue(allRemote.get(refName),ref);
        }
      }
 else {
        LOG.debug("Didn't find ref neither in local nor in remote branches: " + ref);
      }
    }
  }
  List<RefGroup> result=ContainerUtil.newArrayList();
  result.addAll(simpleGroups);
  if (!localBranches.isEmpty())   result.add(new LogicalRefGroup("Local",localBranches));
  if (!trackedBranches.isEmpty())   result.add(new LogicalRefGroup("Tracked",trackedBranches));
  for (  Map.Entry<GitRemote,Collection<VcsRef>> entry : remoteRefGroups.entrySet()) {
    final GitRemote remote=entry.getKey();
    final Collection<VcsRef> branches=entry.getValue();
    result.add(new RemoteRefGroup(remote,branches));
  }
  return result;
}
