{
  try {
    final Project project=aClass.getProject();
    EncapsulateFieldsProcessor processor=new EncapsulateFieldsProcessor(project,new EncapsulateFieldsDescriptor(){
      @Override public FieldDescriptor[] getSelectedFields(){
        final FieldDescriptor[] descriptors=new FieldDescriptor[fields.length];
        for (int i=0; i < fields.length; i++) {
          descriptors[i]=new FieldDescriptorImpl(fields[i],GenerateMembersUtil.suggestGetterName(fields[i]),GenerateMembersUtil.suggestSetterName(fields[i]),isToEncapsulateGet() ? GenerateMembersUtil.generateGetterPrototype(fields[i]) : null,isToEncapsulateSet() ? GenerateMembersUtil.generateSetterPrototype(fields[i]) : null);
        }
        return descriptors;
      }
      @Override public boolean isToEncapsulateGet(){
        return generateGetters;
      }
      @Override public boolean isToEncapsulateSet(){
        return generateSetters;
      }
      @Override public boolean isToUseAccessorsWhenAccessible(){
        return true;
      }
      @Override public String getFieldsVisibility(){
        return null;
      }
      @Override public String getAccessorsVisibility(){
        return PsiModifier.PUBLIC;
      }
      @Override public int getJavadocPolicy(){
        return DocCommentPolicy.MOVE;
      }
      @Override public PsiClass getTargetClass(){
        return aClass;
      }
    }
);
    processor.run();
    LocalFileSystem.getInstance().refresh(false);
    FileDocumentManager.getInstance().saveAllDocuments();
  }
 catch (  BaseRefactoringProcessor.ConflictsInTestsException e) {
    if (conflicts != null) {
      Assert.assertEquals(conflicts,e.getMessage());
      return;
    }
 else {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  if (conflicts != null) {
    fail("Conflicts were not detected: " + conflicts);
  }
}
