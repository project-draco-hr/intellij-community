{
  Map<MethodSignature,CandidateInfo> signatures=new THashMap<MethodSignature,CandidateInfo>(conflicts.size());
  Set<PsiMethod> superMethods=new HashSet<PsiMethod>();
  for (  CandidateInfo conflict : conflicts) {
    final PsiMethod method=((MethodCandidateInfo)conflict).getElement();
    for (    HierarchicalMethodSignature methodSignature : method.getHierarchicalMethodSignature().getSuperSignatures()) {
      final PsiMethod superMethod=methodSignature.getMethod();
      final PsiClass aClass=superMethod.getContainingClass();
      if (aClass != null && !CommonClassNames.JAVA_LANG_OBJECT.equals(aClass.getQualifiedName())) {
        superMethods.add(superMethod);
      }
    }
  }
  nextConflict:   for (int i=0; i < conflicts.size(); i++) {
    ProgressManager.checkCanceled();
    CandidateInfo info=conflicts.get(i);
    PsiMethod method=(PsiMethod)info.getElement();
    if (!method.hasModifierProperty(PsiModifier.STATIC) && superMethods.contains(method)) {
      conflicts.remove(i);
      i--;
      continue;
    }
    PsiClass class1=method.getContainingClass();
    PsiSubstitutor infoSubstitutor=getSubstitutor((MethodCandidateInfo)info,map);
    MethodSignature signature=method.getSignature(infoSubstitutor);
    CandidateInfo existing=signatures.get(signature);
    if (existing == null) {
      signatures.put(signature,info);
      continue;
    }
    PsiMethod existingMethod=(PsiMethod)existing.getElement();
    PsiClass existingClass=existingMethod.getContainingClass();
    if (class1 != null && existingClass != null) {
      if (class1.isInterface() && CommonClassNames.JAVA_LANG_OBJECT.equals(existingClass.getQualifiedName())) {
        signatures.put(signature,info);
        continue;
      }
 else       if (existingClass.isInterface() && CommonClassNames.JAVA_LANG_OBJECT.equals(class1.getQualifiedName())) {
        conflicts.remove(info);
        i--;
        continue;
      }
    }
    if (method == existingMethod) {
      PsiElement scope1=info.getCurrentFileResolveScope();
      PsiElement scope2=existing.getCurrentFileResolveScope();
      if (scope1 instanceof PsiClass && scope2 instanceof PsiClass && PsiTreeUtil.isAncestor(scope1,scope2,true)&& !existing.isAccessible()) {
        signatures.put(signature,info);
        continue;
      }
    }
    boolean existingTypeParamAgree=areTypeParametersAgree(existing);
    boolean infoTypeParamAgree=areTypeParametersAgree(info);
    if (existingTypeParamAgree && !infoTypeParamAgree && !PsiSuperMethodImplUtil.isSuperMethodSmart(method,existingMethod)) {
      conflicts.remove(i);
      i--;
      continue;
    }
    if (!existingTypeParamAgree && infoTypeParamAgree && !PsiSuperMethodImplUtil.isSuperMethodSmart(existingMethod,method)) {
      signatures.put(signature,info);
      int index=conflicts.indexOf(existing);
      conflicts.remove(index);
      i--;
      continue;
    }
    if (InheritanceUtil.isInheritorOrSelf(class1,existingClass,true) || InheritanceUtil.isInheritorOrSelf(existingClass,class1,true)) {
      PsiParameter[] parameters=method.getParameterList().getParameters();
      final PsiParameter[] existingParameters=existingMethod.getParameterList().getParameters();
      for (int i1=0, parametersLength=parameters.length; i1 < parametersLength; i1++) {
        if (parameters[i1].getType() instanceof PsiArrayType && !(existingParameters[i1].getType() instanceof PsiArrayType)) {
          signatures.put(signature,info);
          continue nextConflict;
        }
      }
      PsiType returnType1=method.getReturnType();
      PsiType returnType2=existingMethod.getReturnType();
      if (returnType1 != null && returnType2 != null) {
        returnType1=infoSubstitutor.substitute(returnType1);
        returnType2=getSubstitutor((MethodCandidateInfo)existing,map).substitute(returnType2);
        if (!returnType1.equals(returnType2) && returnType1.isAssignableFrom(returnType2)) {
          conflicts.remove(i);
          i--;
          continue;
        }
      }
      signatures.put(signature,info);
    }
 else {
      final PsiMethodCallExpression methodCallExpression=PsiTreeUtil.getParentOfType(myArgumentsList,PsiMethodCallExpression.class);
      if (methodCallExpression != null) {
        final PsiReferenceExpression expression=methodCallExpression.getMethodExpression();
        final PsiExpression qualifierExpression=expression.getQualifierExpression();
        PsiClass currentClass;
        if (qualifierExpression != null) {
          currentClass=PsiUtil.resolveClassInClassTypeOnly(qualifierExpression.getType());
        }
 else {
          currentClass=PsiTreeUtil.getParentOfType(expression,PsiClass.class);
        }
        if (currentClass != null && existingClass != null && class1 != null) {
          final PsiSubstitutor eSubstitutor=TypeConversionUtil.getMaybeSuperClassSubstitutor(existingClass,currentClass,PsiSubstitutor.EMPTY,null);
          final PsiSubstitutor cSubstitutor=TypeConversionUtil.getMaybeSuperClassSubstitutor(class1,currentClass,PsiSubstitutor.EMPTY,null);
          if (eSubstitutor != null && cSubstitutor != null && MethodSignatureUtil.areSignaturesEqual(existingMethod.getSignature(eSubstitutor),method.getSignature(cSubstitutor))) {
            final PsiType returnType=eSubstitutor.substitute(existingMethod.getReturnType());
            final PsiType returnType1=cSubstitutor.substitute(method.getReturnType());
            if (returnType != null && returnType1 != null && !returnType1.equals(returnType)) {
              if (TypeConversionUtil.isAssignable(returnType,returnType1,false)) {
                if (class1.isInterface() && !existingClass.isInterface())                 continue;
                conflicts.remove(existing);
              }
 else {
                if (!TypeConversionUtil.isAssignable(returnType1,returnType,false))                 continue;
                conflicts.remove(i);
              }
              i--;
              break;
            }
          }
        }
      }
    }
  }
}
