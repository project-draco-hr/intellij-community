{
  replacementVarsMap=new HashMap<String,ScriptSupport>();
  this.options=options;
  String _replacement=options.getReplacement();
  FileType fileType=options.getMatchOptions().getFileType();
  final Template template=TemplateManager.getInstance(project).createTemplate("","",_replacement);
  final int segmentsCount=template.getSegmentsCount();
  replacement=template.getTemplateText();
  for (int i=0; i < segmentsCount; ++i) {
    final int offset=template.getSegmentOffset(i);
    final String name=template.getSegmentName(i);
    final ParameterInfo info=new ParameterInfo();
    info.startIndex=offset;
    info.name=name;
    info.replacementVariable=options.getVariableDefinition(name) != null;
    int pos;
    for (pos=offset - 1; pos >= 0 && pos < replacement.length() && Character.isWhitespace(replacement.charAt(pos)); ) {
      --pos;
    }
    if (pos >= 0) {
      if (replacement.charAt(pos) == ',') {
        info.hasCommaBefore=true;
      }
      info.beforeDelimiterPos=pos;
    }
    for (pos=offset; pos < replacement.length() && Character.isWhitespace(replacement.charAt(pos)); ) {
      ++pos;
    }
    if (pos < replacement.length()) {
      final char ch=replacement.charAt(pos);
      if (ch == ';') {
        info.statementContext=true;
      }
 else       if (ch == ',' || ch == ')') {
        info.parameterContext=true;
        info.hasCommaAfter=ch == ',';
      }
 else       if (ch == '}') {
        info.classContext=true;
      }
      info.afterDelimiterPos=pos;
    }
    if (parameterizations == null) {
      parameterizations=new ArrayList<ParameterInfo>();
    }
    parameterizations.add(info);
  }
  try {
    final PsiElement[] elements=MatcherImplUtil.createTreeFromText(_replacement,PatternTreeContext.Block,fileType,project);
    if (elements.length > 0) {
      final PsiElement patternNode=elements[0].getParent();
      patternNode.accept(this);
    }
  }
 catch (  IncorrectOperationException e) {
    throw new MalformedPatternException();
  }
}
