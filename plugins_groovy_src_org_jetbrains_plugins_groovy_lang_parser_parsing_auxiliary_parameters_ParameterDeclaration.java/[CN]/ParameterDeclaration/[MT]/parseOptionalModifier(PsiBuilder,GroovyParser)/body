{
  Set<IElementType> modSet=new HashSet<IElementType>();
  PsiBuilder.Marker marker=builder.mark();
  boolean hasModifiers=false;
  while (builder.getTokenType() == GroovyTokenTypes.kFINAL || builder.getTokenType() == GroovyTokenTypes.kDEF || builder.getTokenType() == GroovyTokenTypes.mAT) {
    hasModifiers=true;
    if (GroovyTokenTypes.kFINAL.equals(builder.getTokenType())) {
      if (modSet.contains(GroovyTokenTypes.kFINAL)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("duplicate.modifier",PsiModifier.FINAL));
      }
 else {
        builder.advanceLexer();
        modSet.add(GroovyTokenTypes.kFINAL);
      }
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    }
 else     if (GroovyTokenTypes.kDEF.equals(builder.getTokenType())) {
      if (modSet.contains(GroovyTokenTypes.kDEF)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("duplicate.modifier",GrModifier.DEF));
      }
 else {
        builder.advanceLexer();
        modSet.add(GroovyTokenTypes.kDEF);
      }
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    }
 else {
      if (!Annotation.parse(builder,parser)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("annotation.expected"));
      }
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    }
  }
  marker.done(GroovyElementTypes.MODIFIERS);
  return hasModifiers;
}
