{
  result.mergeFrom(previousResult);
  if (result.isEmpty()) {
    VcsNotifier.getInstance(myProject).notifyInfo("Nothing to push");
  }
 else   if (result.wasErrorCancelOrNotAuthorized()) {
    result.createPushNotificationAndNotify();
  }
 else {
    Map<GitRepository,GitBranch> rejectedPushesForCurrentBranch=result.getRejectedPushesFromCurrentBranchToTrackedBranch(pushInfo);
    if (pushAttempt <= MAX_PUSH_ATTEMPTS && !rejectedPushesForCurrentBranch.isEmpty()) {
      LOG.info(String.format("Rejected pushes for current branches: %n%s%nUpdate settings: %s",rejectedPushesForCurrentBranch,updateSettings));
      if (updateSettings == null) {
        updateSettings=readUpdateSettings();
        if (!mySettings.autoUpdateIfPushRejected()) {
          final GitRejectedPushUpdateDialog dialog=new GitRejectedPushUpdateDialog(myProject,rejectedPushesForCurrentBranch.keySet(),updateSettings);
          final int exitCode=showDialogAndGetExitCode(dialog);
          updateSettings=new UpdateSettings(dialog.shouldUpdateAll(),getUpdateMethodFromDialogExitCode(exitCode));
          saveUpdateSettings(updateSettings);
        }
      }
      if (updateSettings.shouldUpdate()) {
        Collection<GitRepository> repositoriesToUpdate=getRootsToUpdate(rejectedPushesForCurrentBranch,updateSettings.shouldUpdateAllRoots());
        GitPushResult adjustedPushResult=result.remove(rejectedPushesForCurrentBranch);
        adjustedPushResult.markUpdateStartIfNotMarked(repositoriesToUpdate);
        boolean updateResult=update(repositoriesToUpdate,updateSettings.getUpdateMethod());
        if (updateResult) {
          myProgressIndicator.setText(INDICATOR_TEXT);
          GitPushInfo newPushInfo=pushInfo.retain(rejectedPushesForCurrentBranch);
          push(newPushInfo,adjustedPushResult,updateSettings,pushAttempt + 1);
          return;
        }
      }
    }
    result.createPushNotificationAndNotify();
  }
}
