{
  assertFalse("subexpr match",findMatchesCount(s2,s3) == 0);
  assertEquals("search for new ",findMatchesCount(s10,s11),0);
  assertEquals("search for anonymous classes",findMatchesCount(s12,s13),1);
  assertEquals("expr in def initializer",3,findMatchesCount(s53,s54));
  assertEquals("a.class pattern",findMatchesCount(s55,s56),1);
  String complexCode="interface I { void b(); } interface I2 extends I {} class I3 extends I {} " + "class A implements I2 {  void b() {} } class B implements I3 { void b() {}} " + "I2 a; I3 b; a.b(); b.b(); b.b(); A c; B d; c.b(); d.b(); d.b(); ";
  String exprTypePattern1="'t:[exprtype( I2 )].b();";
  String exprTypePattern2="'t:[!exprtype( I2 )].b();";
  String exprTypePattern3="'t:[exprtype( *I2 )].b();";
  String exprTypePattern4="'t:[!exprtype( *I2 )].b();";
  assertEquals("expr type condition",findMatchesCount(complexCode,exprTypePattern1),1);
  assertEquals("expr type condition 2",5,findMatchesCount(complexCode,exprTypePattern2));
  assertEquals("expr type condition 3",findMatchesCount(complexCode,exprTypePattern3),2);
  assertEquals("expr type condition 4",findMatchesCount(complexCode,exprTypePattern4),4);
  String complexCode2="enum X { XXX, YYY }\n class C { static void ordinal() {} void test() { C c; c.ordinal(); c.ordinal(); X.XXX.ordinal(); } }";
  assertEquals("expr type condition with enums",findMatchesCount(complexCode2,"'t:[exprtype( *java\\.lang\\.Enum )].ordinal()"),1);
  assertEquals("no smart detection of search target",findMatchesCount("processInheritors(1,2,3,4); processInheritors(1,2,3); processInheritors(1,2,3,4,5,6);","'instance?.processInheritors('_param1{1,6});"),3);
  String arrays="int[] a = new int[20];\n" + "byte[] b = new byte[30]";
  String arrayPattern="new int['_a]";
  assertEquals("Improper array search",1,findMatchesCount(arrays,arrayPattern));
  String someCode="a *= 2; a+=2;";
  String otherCode="a *= 2;";
  assertEquals("Improper *= 2 search",1,findMatchesCount(someCode,otherCode));
  String s1="Thread t = new Thread(\"my thread\",\"my another thread\") {\n" + "    public void run() {\n" + "        // do stuff\n"+ "    }\n"+ "}";
  String s2="new Thread('args*) { '_Other* }";
  assertEquals("Find inner class parameters",2,findMatchesCount(s1,s2));
  String s3="Thread t = new Thread(\"my thread\") {\n" + "    public void run() {\n" + "        // do stuff\n"+ "    }\n"+ "};";
  String s4="new Thread('_args)";
  assertEquals("Find inner class by new",1,findMatchesCount(s3,s4));
  String s5="class A {\n" + "public static <T> T[] copy(T[] array, Class<T> aClass) {\n" + "    int i = (int)0;\n"+ "    int b = (int)0;\n"+ "    return (T[])array.clone();\n"+ "  }\n"+ "}";
  String s6="('_T[])'_expr";
  assertEquals("Find cast to array",1,findMatchesCount(s5,s6));
  String s7="import java.math.BigDecimal;\n" + "\n" + "public class Prorator {\n"+ "        public void prorate(BigDecimal[] array) {\n"+ "                // do nothing\n"+ "        }\n"+ "        public void prorate2(java.math.BigDecimal[] array) {\n"+ "                // do nothing\n"+ "        }\n"+ "        public void prorate(BigDecimal bd) {\n"+ "                // do nothing\n"+ "        }\n"+ "\n"+ "        public static void main(String[] args) {\n"+ "                BigDecimal[] something = new BigDecimal[2];\n"+ "                java.math.BigDecimal[] something2 = new BigDecimal[2];\n"+ "                something[0] = new BigDecimal(1.0);\n"+ "                something[1] = new BigDecimal(1.0);\n"+ "\n"+ "                Prorator prorator = new Prorator();\n"+ "\n"+ "// ---------------------------------------------------\n"+ "// the line below should've been found, in my opinion.\n"+ "// --------------------------------------------------\n"+ "                prorator.prorate(something);\n"+ "                prorator.prorate(something2);\n"+ "                prorator.prorate(something[0]);\n"+ "                prorator.prorate(something[1]);\n"+ "                prorator.prorate(something[0]);\n"+ "        }\n"+ "}";
  String s8="'_Instance.'_MethodCall:[regex( prorate )]('_Param:[exprtype( BigDecimal\\[\\] )]) ";
  assertEquals("Find method call with array for parameter expr type",2,findMatchesCount(s7,s8,true));
  String s13="try { } catch(Exception e) { e.printStackTrace(); }";
  String s14="'_Instance.'_MethodCall('_Parameter*)";
  assertEquals("Find statement in catch",1,findMatchesCount(s13,s14));
  String s9="int a[] = new int[] { 1,2,3,4};\n" + "int b[] = { 2,3,4,5 };\n" + "Object[] c = new Object[] { \"\", null};\n"+ "Object[] d = {null, null};\n"+ "Object[] e = {};\n"+ "Object[] f = new Object[]{}\n"+ "String[] g = new String[]{}\n"+ "String[] h = new String[]{new String()}";
  assertEquals("Find new array expressions, but no array initializer expressions",5,findMatchesCount(s9,"new '_ []{ '_* }"));
  assertEquals("Find new int array expressions, including array initializer expressions",2,findMatchesCount(s9,"new int []{ '_* }"));
  assertEquals("Find new int array expressions, including array initializer expressions using variable ",2,findMatchesCount(s9,"new 'a?:int [] { '_* }"));
  assertEquals("Find all new array expressions, including array initializers",8,findMatchesCount(s9,"new '_? []{ '_* }"));
  assertEquals("Find new Object array expressions, including array initializer expressions",4,findMatchesCount(s9,"new Object[] { '_* }"));
  assertEquals("Find only array initializer expressions",3,findMatchesCount(s9,"new '_{0,0}[] { '_* }"));
  assertEquals("Find only int array initializer expressions",1,findMatchesCount(s9,"new '_{0,0}:int [] { '_* }"));
  assertEquals("Try to find String array initializer expressions",0,findMatchesCount(s9,"new '_{0,0}:String [] { '_* }"));
  String s10="int time = 99;\n" + "String str = time < 0 ? \"\" : \"\";" + "String str2 = time < time ? \"\" : \"\";";
  assertEquals("Find expressions mistaken for declarations by parser in block mode",1,findMatchesCount(s10,"time < time"));
  assertEquals("Find expressions mistaken for declarations by parser in block mode 2",1,findMatchesCount(s10,"time < 0"));
  assertEquals("Find expressions mistaken for declarations by parser in block mode 3",1,findMatchesCount(s10,"time < 0 ? '_a : '_b"));
  assertEquals("Find expressions mistaken for declarations by parser in block mode 4",2,findMatchesCount(s10,"'_a < '_b"));
}
