{
  args=myForkedDebuggerStarter.excludeDebugPortFromArgs(args);
  final List parameters=new ArrayList();
  final BufferedReader bufferedReader=new BufferedReader(new FileReader(commandLinePath));
  final String dynamicClasspath=bufferedReader.readLine();
  try {
    String line;
    while ((line=bufferedReader.readLine()) != null) {
      parameters.add(line);
    }
  }
  finally {
    bufferedReader.close();
  }
  final Object rootDescription=createRootDescription(args,newArgs,configName,out,err);
  if (rootDescription == null)   return -1;
  sendTree(rootDescription);
  long time=System.currentTimeMillis();
  int result=0;
  if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {
    final List children=getChildren(rootDescription);
    final boolean forkTillMethod=forkMode.equalsIgnoreCase("method");
    result=processChildren(newArgs,out,err,parameters,children,0,forkTillMethod,null,System.getProperty("java.class.path"),dynamicClasspath);
  }
 else {
    final BufferedReader perDirReader=new BufferedReader(new FileReader(workingDirsPath));
    try {
      final String packageName=perDirReader.readLine();
      String workingDir;
      while ((workingDir=perDirReader.readLine()) != null) {
        final String moduleName=perDirReader.readLine();
        final String classpath=perDirReader.readLine();
        try {
          List classNames=new ArrayList();
          final int classNamesSize=Integer.parseInt(perDirReader.readLine());
          for (int i=0; i < classNamesSize; i++) {
            String className=perDirReader.readLine();
            if (className == null) {
              System.err.println("Class name is expected. Working dir: " + workingDir);
              return -1;
            }
            classNames.add(className);
          }
          final Object rootDescriptor=findByClassName((String)classNames.get(0),rootDescription);
          final int childResult;
          final File dir=new File(workingDir);
          if (forkMode.equals("none")) {
            final List childArgs=createChildArgsForClasses(newArgs,moduleName,packageName,workingDir,classNames,rootDescriptor);
            childResult=runChild(wrapOutputStream((OutputStream)out),wrapOutputStream((OutputStream)err),parameters,childArgs,dir,classpath,dynamicClasspath);
          }
 else {
            final List children=new ArrayList(getChildren(rootDescription));
            for (Iterator iterator=children.iterator(); iterator.hasNext(); ) {
              if (!classNames.contains(getTestClassName(iterator.next()))) {
                iterator.remove();
              }
            }
            final boolean forkTillMethod=forkMode.equalsIgnoreCase("method");
            childResult=processChildren(newArgs,out,err,parameters,children,result,forkTillMethod,dir,classpath,dynamicClasspath);
          }
          result=Math.min(childResult,result);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  finally {
      perDirReader.close();
    }
  }
  myForkedDebuggerStarter.closeDebugSocket();
  sendTime(time);
  return result;
}
