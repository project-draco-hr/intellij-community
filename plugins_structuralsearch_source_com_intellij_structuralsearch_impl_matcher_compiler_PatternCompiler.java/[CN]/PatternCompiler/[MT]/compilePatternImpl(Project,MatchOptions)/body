{
  final StringBuffer buf=new StringBuffer();
  final CompileContext context=new CompileContext();
  if (ApplicationManager.getApplication().isUnitTestMode())   lastTestingContext=context;
  CompiledPattern result=options.getFileType() == StdFileTypes.JAVA ? new CompiledPattern.JavaCompiledPattern() : new CompiledPattern.XmlCompiledPattern();
  try {
    context.init(result,options,project,options.getScope() instanceof GlobalSearchScope);
    Template template=TemplateManager.getInstance(project).createTemplate("","",options.getSearchPattern());
    int segmentsCount=template.getSegmentsCount();
    String text=template.getTemplateText();
    buf.setLength(0);
    int prevOffset=0;
    for (int i=0; i < segmentsCount; ++i) {
      final int offset=template.getSegmentOffset(i);
      final String name=template.getSegmentName(i);
      buf.append(text.substring(prevOffset,offset));
      buf.append(result.getTypedVarPrefix());
      buf.append(name);
      MatchVariableConstraint constraint=options.getVariableConstraint(name);
      if (constraint == null) {
        constraint=new MatchVariableConstraint();
        constraint.setName(name);
        options.addVariableConstraint(constraint);
      }
      SubstitutionHandler handler=result.createSubstitutionHandler(name,result.getTypedVarPrefix() + name,constraint.isPartOfSearchResults(),constraint.getMinCount(),constraint.getMaxCount(),constraint.isGreedy());
      if (constraint.isWithinHierarchy()) {
        handler.setSubtype(true);
      }
      if (constraint.isStrictlyWithinHierarchy()) {
        handler.setStrictSubtype(true);
      }
      Handler predicate;
      if (constraint.getRegExp() != null && constraint.getRegExp().length() > 0) {
        predicate=new RegExpPredicate(constraint.getRegExp(),options.isCaseSensitiveMatch(),name,constraint.isWholeWordsOnly(),constraint.isPartOfSearchResults());
        if (constraint.isInvertRegExp()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.isReadAccess()) {
        predicate=new ReadPredicate();
        if (constraint.isInvertReadAccess()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.isWriteAccess()) {
        predicate=new WritePredicate();
        if (constraint.isInvertWriteAccess()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.isReference()) {
        predicate=new ReferencePredicate(constraint.getNameOfReferenceVar());
        if (constraint.isInvertReference()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.getNameOfExprType() != null && constraint.getNameOfExprType().length() > 0) {
        predicate=new ExprTypePredicate(constraint.getNameOfExprType(),name,constraint.isExprTypeWithinHierarchy(),options.isCaseSensitiveMatch(),constraint.isPartOfSearchResults());
        if (constraint.isInvertExprType()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.getNameOfFormalArgType() != null && constraint.getNameOfFormalArgType().length() > 0) {
        predicate=new FormalArgTypePredicate(constraint.getNameOfFormalArgType(),name,constraint.isFormalArgTypeWithinHierarchy(),options.isCaseSensitiveMatch(),constraint.isPartOfSearchResults());
        if (constraint.isInvertFormalType()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.getScriptCodeConstraint() != null && constraint.getScriptCodeConstraint().length() > 0) {
        predicate=new ScriptPredicate(name,constraint.getScriptCodeConstraint());
        addPredicate(handler,predicate);
      }
      if (constraint.getContainsConstraint() != null && constraint.getContainsConstraint().length() > 0) {
        predicate=new ContainsPredicate(name,constraint.getContainsConstraint());
        if (constraint.isInvertContainsConstraint()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      if (constraint.getWithinConstraint() != null && constraint.getWithinConstraint().length() > 0) {
        predicate=new WithinPredicate(name,constraint.getWithinConstraint(),project);
        if (constraint.isInvertWithinConstraint()) {
          predicate=new NotPredicate(predicate);
        }
        addPredicate(handler,predicate);
      }
      prevOffset=offset;
    }
    buf.append(text.substring(prevOffset,text.length()));
    PsiElement patternNode;
    PsiElement[] matchStatements;
    try {
      matchStatements=MatcherImplUtil.createTreeFromText(buf.toString(),MatcherImplUtil.TreeContext.Block,options.getFileType(),project);
      if (matchStatements.length == 0)       throw new MalformedPatternException();
      patternNode=matchStatements[0].getParent();
    }
 catch (    IncorrectOperationException e) {
      throw new MalformedPatternException(e.getMessage());
    }
    NodeFilter filter=LexicalNodesFilter.getInstance();
    CompilingVisitor compilingVisitor=new CompilingVisitor();
    compilingVisitor.compile(patternNode,context);
    List<PsiElement> elements=new LinkedList<PsiElement>();
    for (    PsiElement matchStatement : matchStatements) {
      if (!filter.accepts(matchStatement)) {
        elements.add(matchStatement);
      }
    }
    context.pattern.setNodes(new ArrayBackedNodeIterator(elements.toArray(new PsiElement[elements.size()])));
    ApplicationManager.getApplication().runWriteAction(new DeleteNodesAction(compilingVisitor.getLexicalNodes()));
    if (context.searchHelper.doOptimizing() && context.searchHelper.isScannedSomething()) {
      final Set<PsiFile> set=context.searchHelper.getFilesSetToScan();
      final List<PsiFile> filesToScan=new ArrayList<PsiFile>(set.size());
      final GlobalSearchScope scope=(GlobalSearchScope)options.getScope();
      for (      final PsiFile file : set) {
        if (!scope.contains(file.getVirtualFile())) {
          continue;
        }
        if (file instanceof PsiFileImpl) {
          ((PsiFileImpl)file).clearCaches();
        }
        filesToScan.add(file);
      }
      if (filesToScan.size() == 0) {
        throw new MalformedPatternException(SSRBundle.message("ssr.will.not.find.anything"));
      }
      result.setScope(new LocalSearchScope(filesToScan.toArray(new PsiElement[filesToScan.size()])));
    }
  }
  finally {
    context.clear();
  }
  return result;
}
