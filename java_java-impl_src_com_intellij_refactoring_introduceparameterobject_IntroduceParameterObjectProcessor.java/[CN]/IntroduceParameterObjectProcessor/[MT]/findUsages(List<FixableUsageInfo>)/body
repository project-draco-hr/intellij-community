{
  if (myUseExistingClass && existingClass != null) {
    myExistingClassCompatibleConstructor=existingClassIsCompatible(existingClass,parameters);
  }
  final PsiCodeBlock body=method.getBody();
  final String baseParameterName=StringUtil.decapitalize(className);
  final String fixedParamName=body != null ? JavaCodeStyleManager.getInstance(myProject).suggestUniqueVariableName(baseParameterName,body.getLBrace(),true) : JavaCodeStyleManager.getInstance(myProject).propertyNameToVariableName(baseParameterName,VariableKind.PARAMETER);
  myChangeInfo=new MergeMethodArguments(method,className,packageName,fixedParamName,paramsToMerge,typeParams,keepMethodAsDelegate,myCreateInnerClass ? method.getContainingClass() : null).createChangeInfo();
  for (  UsageInfo info : ChangeSignatureProcessorBase.findUsages(myChangeInfo)) {
    usages.add(new ChangeSignatureUsageWrapper(info));
  }
  findUsagesForMethod(method,usages,fixedParamName);
  if (myUseExistingClass && existingClass != null && !(paramsNeedingGetters.isEmpty() && paramsNeedingSetters.isEmpty())) {
    usages.add(new AppendAccessorsUsageInfo(existingClass,myGenerateAccessors,paramsNeedingGetters,paramsNeedingSetters,parameters));
  }
  final PsiMethod[] overridingMethods=OverridingMethodsSearch.search(method).toArray(PsiMethod.EMPTY_ARRAY);
  for (  PsiMethod siblingMethod : overridingMethods) {
    findUsagesForMethod(siblingMethod,usages,fixedParamName);
  }
  if (myNewVisibility != null) {
    usages.add(new BeanClassVisibilityUsageInfo(existingClass,usages.toArray(new UsageInfo[usages.size()]),myNewVisibility,myExistingClassCompatibleConstructor));
  }
}
