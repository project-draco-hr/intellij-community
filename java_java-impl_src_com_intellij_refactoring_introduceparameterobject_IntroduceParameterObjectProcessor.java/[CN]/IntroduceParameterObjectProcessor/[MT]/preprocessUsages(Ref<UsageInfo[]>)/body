{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (myUseExistingClass) {
    if (existingClass == null) {
      conflicts.putValue(null,RefactorJBundle.message("cannot.perform.the.refactoring") + "Could not find the selected class");
    }
    if (myExistingClassCompatibleConstructor == null) {
      conflicts.putValue(existingClass,RefactorJBundle.message("cannot.perform.the.refactoring") + "Selected class has no compatible constructors");
    }
  }
 else {
    if (existingClass != null) {
      conflicts.putValue(existingClass,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("there.already.exists.a.class.with.the.chosen.name"));
    }
    if (myMoveDestination != null) {
      if (!myMoveDestination.isTargetAccessible(myProject,method.getContainingFile().getVirtualFile())) {
        conflicts.putValue(method,"Created class won't be accessible");
      }
    }
  }
  List<UsageInfo> changeSignatureUsages=new ArrayList<>();
  for (  UsageInfo usageInfo : refUsages.get()) {
    if (usageInfo instanceof FixableUsageInfo) {
      final String conflictMessage=((FixableUsageInfo)usageInfo).getConflictMessage();
      if (conflictMessage != null) {
        conflicts.putValue(usageInfo.getElement(),conflictMessage);
      }
    }
 else {
      changeSignatureUsages.add(usageInfo);
    }
  }
  ChangeSignatureProcessorBase.collectConflictsFromExtensions(new Ref<>(changeSignatureUsages.toArray(new UsageInfo[changeSignatureUsages.size()])),conflicts,myChangeInfo);
  return showConflicts(conflicts,refUsages.get());
}
