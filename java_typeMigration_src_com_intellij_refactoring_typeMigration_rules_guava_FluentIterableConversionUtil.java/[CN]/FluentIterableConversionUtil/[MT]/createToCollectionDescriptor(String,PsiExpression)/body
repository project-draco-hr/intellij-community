{
  final String findTemplate;
  final String replaceTemplate;
  final String returnType;
  if ("toMap".equals(methodName) || "uniqueIndex".equals(methodName)) {
    final GuavaTypeConversionDescriptor descriptor=new GuavaTypeConversionDescriptor("$it$.$methodName$($f$)","$it$.collect(java.util.stream.Collectors.toMap(java.util.function.Function.identity(), $f$))");
    return descriptor.withConversionType(GuavaConversionUtil.addTypeParameters(CommonClassNames.JAVA_UTIL_MAP,context.getType(),context));
  }
 else   if ("toList".equals(methodName)) {
    findTemplate="$it$.toList()";
    replaceTemplate=GuavaFluentIterableConversionRule.STREAM_COLLECT_TO_LIST;
    returnType=CommonClassNames.JAVA_UTIL_LIST;
  }
 else   if ("toSet".equals(methodName)) {
    findTemplate="$it$.toSet()";
    replaceTemplate="$it$.collect(java.util.stream.Collectors.toSet())";
    returnType=CommonClassNames.JAVA_UTIL_SET;
  }
 else   if ("toSortedList".equals(methodName)) {
    findTemplate="$it$.toSortedList($c$)";
    replaceTemplate="$it$.sorted($c$).collect(java.util.stream.Collectors.toList())";
    returnType=CommonClassNames.JAVA_UTIL_LIST;
  }
 else   if ("toSortedSet".equals(methodName)) {
    findTemplate="$it$.toSortedSet($c$)";
    replaceTemplate="$it$.collect(java.util.stream.Collectors.toCollection(() -> new java.util.TreeSet<>($c$)))";
    returnType=CommonClassNames.JAVA_UTIL_SET;
  }
 else {
    return null;
  }
  final PsiType type=GuavaConversionUtil.addTypeParameters(returnType,context.getType(),context);
  return new TypeConversionDescriptor(findTemplate,replaceTemplate).withConversionType(type);
}
