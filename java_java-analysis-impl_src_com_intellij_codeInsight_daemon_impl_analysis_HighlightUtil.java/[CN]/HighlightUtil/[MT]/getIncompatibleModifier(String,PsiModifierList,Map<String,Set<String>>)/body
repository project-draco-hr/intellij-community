{
  if (modifierList == null)   return null;
  PsiElement[] modifiers=modifierList.getChildren();
  int modifierCount=0;
  for (  PsiElement otherModifier : modifiers) {
    if (Comparing.equal(modifier,otherModifier.getText(),true))     modifierCount++;
  }
  if (modifierCount > 1) {
    return modifier;
  }
  Set<String> incompatibles=incompatibleModifiersHash.get(modifier);
  if (incompatibles == null)   return null;
  final boolean level8OrHigher=PsiUtil.isLanguageLevel8OrHigher(modifierList);
  final boolean level9OrHigher=PsiUtil.isLanguageLevel9OrHigher(modifierList);
  for (  @PsiModifier.ModifierConstant String incompatible : incompatibles) {
    if (level8OrHigher) {
      if (modifier.equals(PsiModifier.STATIC) && incompatible.equals(PsiModifier.ABSTRACT)) {
        continue;
      }
    }
    if (level9OrHigher && modifier.equals(PsiModifier.PRIVATE) && incompatible.equals(PsiModifier.PUBLIC)) {
      continue;
    }
    if (modifier.equals(PsiModifier.STATIC) && incompatible.equals(PsiModifier.FINAL)) {
      final PsiElement parent=modifierList.getParent();
      if (parent instanceof PsiMethod) {
        final PsiClass containingClass=((PsiMethod)parent).getContainingClass();
        if (containingClass == null || !containingClass.isInterface()) {
          continue;
        }
      }
    }
    if (modifierList.hasModifierProperty(incompatible)) {
      return incompatible;
    }
 else     if (PsiModifier.ABSTRACT.equals(incompatible) && modifierList.hasExplicitModifier(incompatible)) {
      return incompatible;
    }
  }
  return null;
}
