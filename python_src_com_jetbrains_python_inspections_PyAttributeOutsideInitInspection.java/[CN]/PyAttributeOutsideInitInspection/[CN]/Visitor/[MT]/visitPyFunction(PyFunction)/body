{
  final PyClass containingClass=node.getContainingClass();
  if (containingClass == null)   return;
  if (!isApplicable(containingClass)) {
    return;
  }
  final List<PyTargetExpression> classAttributes=containingClass.getClassAttributes();
  Map<String,PyTargetExpression> attributesInInit=new HashMap<String,PyTargetExpression>();
  for (  PyTargetExpression classAttr : classAttributes) {
    attributesInInit.put(classAttr.getName(),classAttr);
  }
  final PyFunction initMethod=containingClass.findMethodByName(PyNames.INIT,false);
  if (initMethod != null) {
    PyClassImpl.collectInstanceAttributes(initMethod,attributesInInit);
  }
  for (  PyClass superClass : containingClass.getAncestorClasses(myTypeEvalContext)) {
    final PyFunction superInit=superClass.findMethodByName(PyNames.INIT,false);
    if (superInit != null)     PyClassImpl.collectInstanceAttributes(superInit,attributesInInit);
  }
  Map<String,PyTargetExpression> attributes=new HashMap<String,PyTargetExpression>();
  PyClassImpl.collectInstanceAttributes(node,attributes);
  for (  Map.Entry<String,PyTargetExpression> attribute : attributes.entrySet()) {
    final Property property=containingClass.findProperty(attribute.getKey());
    if (!attributesInInit.containsKey(attribute.getKey()) && property == null) {
      registerProblem(attribute.getValue(),PyBundle.message("INSP.attribute.$0.outside.init",attribute.getKey()),new PyMoveAttributeToInitQuickFix());
    }
  }
}
