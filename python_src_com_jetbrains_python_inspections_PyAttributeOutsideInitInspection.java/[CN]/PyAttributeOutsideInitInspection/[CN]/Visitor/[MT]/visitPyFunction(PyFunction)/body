{
  final PyClass containingClass=node.getContainingClass();
  if (containingClass == null)   return;
  if (!isApplicable(containingClass)) {
    return;
  }
  final List<PyTargetExpression> classAttributes=containingClass.getClassAttributes();
  Map<String,PyTargetExpression> attributesInInit=new HashMap<String,PyTargetExpression>();
  for (  PyTargetExpression classAttr : classAttributes) {
    attributesInInit.put(classAttr.getName(),classAttr);
  }
  final PyFunction initMethod=containingClass.findMethodByName(PyNames.INIT,false);
  if (initMethod != null) {
    PyClassImpl.collectInstanceAttributes(initMethod,attributesInInit);
    collectAttributesFromSuper(attributesInInit,initMethod);
  }
 else {
    for (    PyClass superClass : containingClass.getAncestorClasses(myTypeEvalContext)) {
      final PyFunction superInit=superClass.findMethodByName(PyNames.INIT,false);
      if (superInit != null)       PyClassImpl.collectInstanceAttributes(superInit,attributesInInit);
    }
  }
  Map<String,PyTargetExpression> attributes=new HashMap<String,PyTargetExpression>();
  PyClassImpl.collectInstanceAttributes(node,attributes);
  for (  Map.Entry<String,PyTargetExpression> attribute : attributes.entrySet()) {
    if (!attributesInInit.containsKey(attribute.getKey())) {
      registerProblem(attribute.getValue(),PyBundle.message("INSP.attribute.$0.outside.init",attribute.getKey()),new PyMoveAttributeToInitQuickFix());
    }
  }
}
