{
  final PyDocStringOwner docStringOwner=PsiTreeUtil.getParentOfType(element,PyDocStringOwner.class);
  if (docStringOwner != null && element == docStringOwner.getDocStringExpression()) {
    final PyStringLiteralExpression expr=(PyStringLiteralExpression)element;
    final List<TextRange> ranges=expr.getStringValueTextRanges();
    final String text=expr.getStringValue();
    if (!ranges.isEmpty()) {
      final List<PsiReference> result=new ArrayList<PsiReference>();
      final int offset=ranges.get(0).getStartOffset();
      StructuredDocString docString=StructuredDocString.parse(text);
      if (docString != null) {
        final List<Substring> paramNames=new ArrayList<Substring>();
        paramNames.addAll(docString.getParameterSubstrings());
        paramNames.addAll(docString.getKeywordArgumentSubstrings());
        for (        Substring name : paramNames) {
          final String s=name.toString();
          if (PyNames.isIdentifier(s)) {
            result.add(new DocStringParameterReference(element,name.getTextRange().shiftRight(offset)));
          }
          final Substring type=docString.getParamTypeSubstring(s);
          if (type != null) {
            result.addAll(parseTypeReferences(element,type,offset));
          }
        }
        final Substring rtype=docString.getReturnTypeSubstring();
        if (rtype != null) {
          result.addAll(parseTypeReferences(element,rtype,offset));
        }
      }
      return result.toArray(new PsiReference[result.size()]);
    }
  }
  return PsiReference.EMPTY_ARRAY;
}
