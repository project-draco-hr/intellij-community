{
  Project project=e.getData(CommonDataKeys.PROJECT);
  if (project == null) {
    return;
  }
  project.save();
  List<Module> modules=new SmartList<Module>();
  List<Module> incompatibleModules=new SmartList<Module>();
  for (  Module module : ModuleManager.getInstance(project).getModules()) {
    if (!EclipseModuleManagerImpl.isEclipseStorage(module)) {
      try {
        ClasspathStorageProvider provider=ClasspathStorage.getProvider(JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID);
        if (provider != null) {
          provider.assertCompatible(ModuleRootManager.getInstance(module));
        }
        modules.add(module);
      }
 catch (      ConfigurationException ignored) {
        incompatibleModules.add(module);
      }
    }
  }
  if (incompatibleModules.isEmpty()) {
    if (modules.isEmpty()) {
      Messages.showInfoMessage(project,EclipseBundle.message("eclipse.export.nothing.to.do"),EclipseBundle.message("eclipse.export.dialog.title"));
      return;
    }
  }
 else   if (Messages.showOkCancelDialog(project,"<html><body>Eclipse incompatible modules found:<ul><br><li>" + StringUtil.join(incompatibleModules,new Function<Module,String>(){
    @Override public String fun(    Module module){
      return module.getName();
    }
  }
,"<br><li>") + "</ul><br>Would you like to proceed and possibly lose your configurations?</body></html>",EclipseBundle.message("eclipse.export.dialog.title"),Messages.getWarningIcon()) != Messages.OK) {
    return;
  }
  modules.addAll(incompatibleModules);
  ExportEclipseProjectsDialog dialog=new ExportEclipseProjectsDialog(project,modules);
  if (!dialog.showAndGet()) {
    return;
  }
  if (dialog.isLink()) {
    for (    Module module : dialog.getSelectedModules()) {
      ClasspathStorage.setStorageType(ModuleRootManager.getInstance(module),JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID);
    }
  }
 else {
    LinkedHashMap<Module,String> module2StorageRoot=new LinkedHashMap<Module,String>();
    for (    Module module : dialog.getSelectedModules()) {
      VirtualFile[] contentRoots=ModuleRootManager.getInstance(module).getContentRoots();
      String storageRoot=contentRoots.length == 1 ? contentRoots[0].getPath() : ClasspathStorage.getStorageRootFromOptions(module);
      module2StorageRoot.put(module,storageRoot);
      try {
        DotProjectFileHelper.saveDotProjectFile(module,storageRoot);
      }
 catch (      Exception e1) {
        LOG.error(e1);
      }
    }
    for (    Module module : module2StorageRoot.keySet()) {
      ModuleRootModel model=ModuleRootManager.getInstance(module);
      String storageRoot=module2StorageRoot.get(module);
      try {
        Element classpathElement=new EclipseClasspathWriter().writeClasspath(null,model);
        File classpathFile=new File(storageRoot,EclipseXml.CLASSPATH_FILE);
        if (!FileUtil.createIfDoesntExist(classpathFile)) {
          continue;
        }
        EclipseJDOMUtil.output(classpathElement,classpathFile,project);
        final Element ideaSpecific=new Element(IdeaXml.COMPONENT_TAG);
        if (IdeaSpecificSettings.writeIdeaSpecificClasspath(ideaSpecific,model)) {
          File emlFile=new File(storageRoot,module.getName() + EclipseXml.IDEA_SETTINGS_POSTFIX);
          if (!FileUtil.createIfDoesntExist(emlFile)) {
            continue;
          }
          EclipseJDOMUtil.output(ideaSpecific,emlFile,project);
        }
      }
 catch (      Exception e1) {
        LOG.error(e1);
      }
    }
  }
  try {
    EclipseUserLibrariesHelper.appendProjectLibraries(project,dialog.getUserLibrariesFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
  }
  project.save();
}
