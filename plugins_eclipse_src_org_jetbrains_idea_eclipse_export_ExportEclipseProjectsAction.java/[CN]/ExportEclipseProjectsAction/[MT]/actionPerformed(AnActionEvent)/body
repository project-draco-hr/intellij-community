{
  Project project=e.getData(CommonDataKeys.PROJECT);
  if (project == null) {
    return;
  }
  project.save();
  List<Module> modules=new SmartList<Module>();
  List<Module> incompatibleModules=new SmartList<Module>();
  for (  Module module : ModuleManager.getInstance(project).getModules()) {
    if (!JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID.equals(ClassPathStorageUtil.getStorageType(module))) {
      try {
        ClasspathStorageProvider provider=ClasspathStorage.getProvider(JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID);
        if (provider != null) {
          provider.assertCompatible(ModuleRootManager.getInstance(module));
        }
        modules.add(module);
      }
 catch (      ConfigurationException ignored) {
        incompatibleModules.add(module);
      }
    }
  }
  if (incompatibleModules.isEmpty()) {
    if (modules.isEmpty()) {
      Messages.showInfoMessage(project,EclipseBundle.message("eclipse.export.nothing.to.do"),EclipseBundle.message("eclipse.export.dialog.title"));
      return;
    }
  }
 else   if (Messages.showOkCancelDialog(project,"<html><body>Eclipse incompatible modules found:<ul><br><li>" + StringUtil.join(incompatibleModules,new Function<Module,String>(){
    @Override public String fun(    Module module){
      return module.getName();
    }
  }
,"<br><li>") + "</ul><br>Would you like to proceed and possibly lose your configurations?</body></html>",EclipseBundle.message("eclipse.export.dialog.title"),Messages.getWarningIcon()) != Messages.OK) {
    return;
  }
  modules.addAll(incompatibleModules);
  ExportEclipseProjectsDialog dialog=new ExportEclipseProjectsDialog(project,modules);
  if (!dialog.showAndGet()) {
    return;
  }
  if (dialog.isLink()) {
    for (    Module module : dialog.getSelectedModules()) {
      ClasspathStorage.setStorageType(ModuleRootManager.getInstance(module),JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID);
    }
  }
 else {
    for (    Module module : dialog.getSelectedModules()) {
      final ModuleRootModel model=ModuleRootManager.getInstance(module);
      final VirtualFile[] contentRoots=model.getContentRoots();
      final String storageRoot=contentRoots.length == 1 ? contentRoots[0].getPath() : ClasspathStorage.getStorageRootFromOptions(module);
      try {
        Element classpathElement=new Element(EclipseXml.CLASSPATH_TAG);
        final EclipseClasspathWriter classpathWriter=new EclipseClasspathWriter(model);
        classpathWriter.writeClasspath(classpathElement,null);
        final File classpathFile=new File(storageRoot,EclipseXml.CLASSPATH_FILE);
        if (!FileUtil.createIfDoesntExist(classpathFile))         continue;
        EclipseJDOMUtil.output(new Document(classpathElement),classpathFile,project);
        final Element ideaSpecific=new Element(IdeaXml.COMPONENT_TAG);
        if (IdeaSpecificSettings.writeIDEASpecificClasspath(ideaSpecific,model)) {
          final File emlFile=new File(storageRoot,module.getName() + EclipseXml.IDEA_SETTINGS_POSTFIX);
          if (!FileUtil.createIfDoesntExist(emlFile))           continue;
          EclipseJDOMUtil.output(new Document(ideaSpecific),emlFile,project);
        }
        DotProjectFileHelper.saveDotProjectFile(module,storageRoot);
      }
 catch (      ConversionException e1) {
        LOG.error(e1);
      }
catch (      IOException e1) {
        LOG.error(e1);
      }
catch (      WriteExternalException e1) {
        LOG.error(e1);
      }
    }
  }
  try {
    EclipseUserLibrariesHelper.appendProjectLibraries(project,dialog.getUserLibrariesFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
  }
  project.save();
}
