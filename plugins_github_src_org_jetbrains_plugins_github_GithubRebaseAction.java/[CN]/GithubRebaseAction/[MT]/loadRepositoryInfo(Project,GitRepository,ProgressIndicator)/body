{
  final String remoteUrl=GithubUtil.findGithubRemoteUrl(gitRepository);
  if (remoteUrl == null) {
    GithubNotifications.showError(project,CANNOT_PERFORM_GITHUB_REBASE,"Can't find github remote");
    return null;
  }
  final String userAndRepo=GithubUtil.getUserAndRepositoryFromRemoteUrl(remoteUrl);
  if (userAndRepo == null) {
    GithubNotifications.showError(project,CANNOT_PERFORM_GITHUB_REBASE,"Can't process remote: " + remoteUrl);
    return null;
  }
  int index=userAndRepo.indexOf('/');
  if (index == -1) {
    GithubNotifications.showError(project,CANNOT_PERFORM_GITHUB_REBASE,"Can't process remote: " + remoteUrl);
    return null;
  }
  final String user=userAndRepo.substring(0,index);
  final String repositoryName=userAndRepo.substring(index + 1);
  RepositoryInfo repositoryInfo=null;
  try {
    repositoryInfo=GithubUtil.runWithValidAuth(project,indicator,new ThrowableConvertor<GithubAuthData,RepositoryInfo,IOException>(){
      @Override public RepositoryInfo convert(      GithubAuthData authData) throws IOException {
        return GithubUtil.getDetailedRepoInfo(authData,user,repositoryName);
      }
    }
);
  }
 catch (  IOException e) {
    GithubNotifications.showError(project,CANNOT_PERFORM_GITHUB_REBASE,"Can't load repository info: " + e.getMessage());
    return null;
  }
  if (repositoryInfo == null) {
    GithubNotifications.showError(project,CANNOT_PERFORM_GITHUB_REBASE,"Can't load repository info");
    return null;
  }
  return repositoryInfo;
}
