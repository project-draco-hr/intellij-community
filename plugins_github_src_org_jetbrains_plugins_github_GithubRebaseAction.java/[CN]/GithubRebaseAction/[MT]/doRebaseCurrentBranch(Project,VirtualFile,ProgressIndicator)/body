{
  final GitRepositoryManager repositoryManager=GitUtil.getRepositoryManager(project);
  final GitRebaser rebaser=new GitRebaser(project,ServiceManager.getService(Git.class),indicator);
  final GitLineHandler handler=new GitLineHandler(project,root,GitCommand.REBASE);
  handler.setStdoutSuppressed(false);
  handler.addParameters("upstream/master");
  final GitRebaseProblemDetector rebaseConflictDetector=new GitRebaseProblemDetector();
  handler.addLineListener(rebaseConflictDetector);
  final GitUntrackedFilesOverwrittenByOperationDetector untrackedFilesDetector=new GitUntrackedFilesOverwrittenByOperationDetector(root);
  final GitLocalChangesWouldBeOverwrittenDetector localChangesDetector=new GitLocalChangesWouldBeOverwrittenDetector(root,CHECKOUT);
  handler.addLineListener(untrackedFilesDetector);
  handler.addLineListener(localChangesDetector);
  GitTask pullTask=new GitTask(project,handler,"Rebasing from upstream/master");
  pullTask.setProgressIndicator(indicator);
  pullTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  pullTask.execute(true,false,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      root.refresh(false,true);
      repositoryManager.updateRepository(root);
      GithubNotifications.showInfo(project,"Success","Successfully rebased GitHub fork");
    }
    @Override protected void onFailure(){
      GitUpdateResult result=rebaser.handleRebaseFailure(handler,root,rebaseConflictDetector,untrackedFilesDetector,localChangesDetector);
      repositoryManager.updateRepository(root);
      if (result == GitUpdateResult.NOTHING_TO_UPDATE || result == GitUpdateResult.SUCCESS || result == GitUpdateResult.SUCCESS_WITH_RESOLVED_CONFLICTS) {
        GithubNotifications.showInfo(project,"Success","Successfully rebased GitHub fork");
      }
    }
  }
);
}
