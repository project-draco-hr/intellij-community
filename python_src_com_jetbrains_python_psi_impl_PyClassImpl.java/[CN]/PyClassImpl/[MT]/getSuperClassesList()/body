{
  if (PyNames.FAKE_OLD_BASE.equals(getName())) {
    return Collections.emptyList();
  }
  List<PyClassRef> result=resolveSuperClassesFromStub();
  if (result == null) {
    result=new ArrayList<PyClassRef>();
    final TypeEvalContext context=TypeEvalContext.fastStubOnly(null);
    final PyExpression[] superClassExpressions=getSuperClassExpressions();
    for (    PyExpression expression : superClassExpressions) {
      final PsiElement element=classElementFromExpression(expression);
      if (element != null) {
        result.add(new PyClassRef(element));
      }
 else {
        final PyType type=context.getType(expression);
        if (type instanceof PyClassType) {
          result.add(new PyClassRef((PyClassType)type));
        }
 else {
          result.add(new PyClassRef((PsiElement)null));
        }
      }
    }
  }
  if (result.size() == 0 && isValid() && !PyBuiltinCache.getInstance(this).hasInBuiltins(this)) {
    String implicitSuperclassName=LanguageLevel.forElement(this).isPy3K() ? PyNames.OBJECT : PyNames.FAKE_OLD_BASE;
    PyClass implicitSuperclass=PyBuiltinCache.getInstance(this).getClass(implicitSuperclassName);
    if (implicitSuperclass != null) {
      result.add(new PyClassRef(implicitSuperclass));
    }
  }
  return result;
}
