{
  ExitCode exitCode=ExitCode.NOTHING_DONE;
  final boolean hasSourcesToCompile=!files.isEmpty();
  if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) {
    return exitCode;
  }
  final ProjectDescriptor pd=context.getProjectDescriptor();
  JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(),context,BUILDER_NAME);
  final Collection<File> classpath=ProjectPaths.getCompilationClasspath(chunk,false);
  final Collection<File> platformCp=ProjectPaths.getPlatformCompilationClasspath(chunk,false);
  final Mappings delta=pd.dataManager.getMappings().createDelta();
  final Callbacks.Backend mappingsCallback=delta.getCallback();
  final OutputFilesSink outputSink=new OutputFilesSink(context,outputConsumer,mappingsCallback,chunk.getName());
  try {
    if (hasSourcesToCompile) {
      final AtomicReference<String> ref=COMPILER_VERSION_INFO.get(context);
      final String versionInfo=ref.getAndSet(null);
      if (versionInfo != null) {
        LOG.info(versionInfo);
        context.processMessage(new CompilerMessage("",BuildMessage.Kind.INFO,versionInfo));
      }
      exitCode=ExitCode.OK;
      final Set<File> srcPath=new HashSet<File>();
      Set<File> tempRoots=null;
      final BuildRootIndex index=pd.getBuildRootIndex();
      for (      ModuleBuildTarget target : chunk.getTargets()) {
        for (        JavaSourceRootDescriptor rd : index.getTargetRoots(target,context)) {
          srcPath.add(rd.root);
          if (rd.isTemp) {
            if (tempRoots == null) {
              tempRoots=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
            }
            tempRoots.add(rd.root);
          }
        }
      }
      final DiagnosticSink diagnosticSink=new DiagnosticSink(context,tempRoots == null ? Collections.<File>emptySet() : tempRoots);
      final String chunkName=chunk.getName();
      context.processMessage(new ProgressMessage("Parsing java... [" + chunkName + "]"));
      final int filesCount=files.size();
      boolean compiledOk=true;
      int tempRootsErrorCount=0;
      int tempRootsWarningCount=0;
      if (filesCount > 0) {
        LOG.info("Compiling " + filesCount + " java files; module: "+ chunkName+ (chunk.containsTests() ? " (tests)" : ""));
        if (LOG.isDebugEnabled()) {
          for (          File file : files) {
            LOG.debug("Compiling " + file.getPath());
          }
          LOG.debug(" classpath for " + chunkName + ":");
          for (          File file : classpath) {
            LOG.debug("  " + file.getAbsolutePath());
          }
          LOG.debug(" platform classpath for " + chunkName + ":");
          for (          File file : platformCp) {
            LOG.debug("  " + file.getAbsolutePath());
          }
        }
        try {
          compiledOk=compileJava(context,chunk,files,classpath,platformCp,srcPath,diagnosticSink,outputSink);
          if (compiledOk) {
            final Collection<File> loadedTempFiles=diagnosticSink.getLoadedTempSources();
            if (!loadedTempFiles.isEmpty()) {
              final DiagnosticSink tempRootsSink=new DiagnosticSink(context,Collections.<File>emptySet());
              compiledOk=compileJava(context,chunk,loadedTempFiles,classpath,platformCp,tempRoots,tempRootsSink,outputSink);
              tempRootsErrorCount=tempRootsSink.getErrorCount();
              tempRootsWarningCount=tempRootsSink.getWarningCount();
            }
          }
        }
  finally {
          for (          File file : diagnosticSink.getFilesWithErrors()) {
            if (!file.exists()) {
              FSOperations.markDeleted(context,file);
            }
          }
        }
      }
      context.checkCanceled();
      if (!compiledOk && (diagnosticSink.getErrorCount() + tempRootsErrorCount) == 0) {
        diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR,"Compilation failed: internal java compiler error"));
      }
      final int totalErrorCount=diagnosticSink.getErrorCount() + tempRootsErrorCount;
      if (!Utils.PROCEED_ON_ERROR_KEY.get(context,Boolean.FALSE) && totalErrorCount > 0) {
        if (!compiledOk) {
          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER,"Errors occurred while compiling module '" + chunkName + "'"));
        }
        throw new StopBuildException("Compilation failed: errors: " + totalErrorCount + "; warnings: "+ (diagnosticSink.getWarningCount() + tempRootsWarningCount));
      }
    }
  }
  finally {
    if (JavaBuilderUtil.updateMappings(context,delta,dirtyFilesHolder,chunk,files,outputSink.getSuccessfullyCompiled())) {
      exitCode=ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
  }
  return exitCode;
}
