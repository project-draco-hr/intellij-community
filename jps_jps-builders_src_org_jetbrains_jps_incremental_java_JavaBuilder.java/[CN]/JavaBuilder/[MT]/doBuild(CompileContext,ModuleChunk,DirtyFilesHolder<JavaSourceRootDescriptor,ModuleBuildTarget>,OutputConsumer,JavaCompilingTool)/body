{
  try {
    final Set<File> filesToCompile=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget>(){
      @Override public boolean apply(      ModuleBuildTarget target,      File file,      JavaSourceRootDescriptor descriptor) throws IOException {
        if (JAVA_SOURCES_FILTER.accept(file) && ourCompilableModuleTypes.contains(target.getModule().getModuleType())) {
          filesToCompile.add(file);
        }
        return true;
      }
    }
);
    if (!filesToCompile.isEmpty() || dirtyFilesHolder.hasRemovedFiles()) {
      JavaModuleIndex index=getJavaModuleIndex(context);
      for (      JpsModule module : chunk.getModules()) {
        ContainerUtil.addIfNotNull(filesToCompile,index.getModuleInfoFile(module));
      }
    }
    if (JavaBuilderUtil.isCompileJavaIncrementally(context)) {
      final ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
      if (logger.isEnabled()) {
        if (!filesToCompile.isEmpty()) {
          logger.logCompiledFiles(filesToCompile,BUILDER_NAME,"Compiling files:");
        }
      }
    }
    return compile(context,chunk,dirtyFilesHolder,filesToCompile,outputConsumer,compilingTool);
  }
 catch (  BuildDataCorruptedException e) {
    throw e;
  }
catch (  ProjectBuildException e) {
    throw e;
  }
catch (  PersistentEnumeratorBase.CorruptedException e) {
    throw e;
  }
catch (  Exception e) {
    LOG.info(e);
    String message=e.getMessage();
    if (message == null) {
      final ByteArrayOutputStream out=new ByteArrayOutputStream();
      final PrintStream stream=new PrintStream(out);
      try {
        e.printStackTrace(stream);
      }
  finally {
        stream.close();
      }
      message="Internal error: \n" + out;
    }
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,message));
    throw new StopBuildException();
  }
}
