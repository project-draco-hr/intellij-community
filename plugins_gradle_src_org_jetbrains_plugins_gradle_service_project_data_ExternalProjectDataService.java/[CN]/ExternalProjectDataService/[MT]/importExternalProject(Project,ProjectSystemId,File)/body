{
  final Boolean result=UIUtil.invokeAndWaitIfNeeded(new Computable<Boolean>(){
    @Override public Boolean compute(){
      final Ref<Boolean> result=new Ref<Boolean>(false);
      if (project.isDisposed())       return false;
      final String linkedProjectPath=FileUtil.toCanonicalPath(projectRootDir.getPath());
      final ExternalProjectSettings projectSettings=ExternalSystemApiUtil.getSettings(project,projectSystemId).getLinkedProjectSettings(linkedProjectPath);
      if (projectSettings == null) {
        LOG.warn("Unable to get project settings for project path: " + linkedProjectPath);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Available projects paths: " + ContainerUtil.map(ExternalSystemApiUtil.getSettings(project,projectSystemId).getLinkedProjectsSettings(),new Function<ExternalProjectSettings,String>(){
            @Override public String fun(            ExternalProjectSettings settings){
              return settings.getExternalProjectPath();
            }
          }
));
        }
        return false;
      }
      final File projectFile=new File(linkedProjectPath);
      final String projectName;
      if (projectFile.isFile()) {
        projectName=projectFile.getParentFile().getName();
      }
 else {
        projectName=projectFile.getName();
      }
      if (!projectSettings.isUseAutoImport()) {
        String message=String.format("Project '%s' require synchronization with %s configuration. \nImport the project?",projectName,projectSystemId.getReadableName());
        int returnValue=Messages.showOkCancelDialog(message,"Import Project",CommonBundle.getOkButtonText(),CommonBundle.getCancelButtonText(),Messages.getQuestionIcon());
        if (returnValue != Messages.OK)         return false;
      }
      final String title=ExternalSystemBundle.message("progress.import.text",linkedProjectPath,projectSystemId.getReadableName());
      new Task.Modal(project,title,false){
        @Override public void run(        @NotNull ProgressIndicator indicator){
          if (project.isDisposed())           return;
          ExternalSystemNotificationManager.getInstance(project).clearNotifications(null,NotificationSource.PROJECT_SYNC,projectSystemId);
          ExternalSystemResolveProjectTask task=new ExternalSystemResolveProjectTask(projectSystemId,project,linkedProjectPath,false);
          task.execute(indicator,ExternalSystemTaskNotificationListener.EP_NAME.getExtensions());
          if (project.isDisposed())           return;
          final Throwable error=task.getError();
          if (error != null) {
            ExternalSystemNotificationManager.getInstance(project).processExternalProjectRefreshError(error,projectName,projectSystemId);
            return;
          }
          final DataNode<ProjectData> projectDataDataNode=task.getExternalProject();
          if (projectDataDataNode == null)           return;
          final Collection<DataNode<ExternalProject>> nodes=ExternalSystemApiUtil.findAll(projectDataDataNode,KEY);
          if (nodes.size() != 1) {
            throw new IllegalArgumentException(String.format("Expected to get a single external project but got %d: %s",nodes.size(),nodes));
          }
          ProjectRootManagerEx.getInstanceEx(myProject).mergeRootsChangesDuring(new Runnable(){
            @Override public void run(){
              myProjectDataManager.importData(KEY,nodes,project,true);
            }
          }
);
          result.set(true);
        }
      }
.queue();
      return result.get();
    }
  }
);
  return result ? getRootExternalProject(projectSystemId,projectRootDir) : null;
}
