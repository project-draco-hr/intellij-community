{
  final List<PsiNewExpression> newExpressionsToCheckDiamonds=new SmartList<PsiNewExpression>();
  final TypeMigrationLabeler.MigrationProducer producer=labeler.createMigratorFor(usages);
  List<UsageInfo> nonCodeUsages=new ArrayList<UsageInfo>();
  for (  UsageInfo usage : usages) {
    if (((TypeMigrationUsageInfo)usage).isExcluded())     continue;
    final PsiElement element=usage.getElement();
    if (element instanceof PsiVariable || element instanceof PsiMember || element instanceof PsiExpression|| element instanceof PsiReferenceParameterList) {
      producer.change((TypeMigrationUsageInfo)usage,new Consumer<PsiNewExpression>(){
        @Override public void consume(        @NotNull PsiNewExpression expression){
          newExpressionsToCheckDiamonds.add(expression);
        }
      }
);
    }
 else {
      nonCodeUsages.add(usage);
    }
  }
  for (  PsiNewExpression newExpression : newExpressionsToCheckDiamonds) {
    labeler.postProcessNewExpression(newExpression);
  }
  for (  UsageInfo usageInfo : nonCodeUsages) {
    final PsiElement element=usageInfo.getElement();
    if (element != null) {
      final PsiReference reference=element.getReference();
      if (reference != null) {
        final Object target=producer.getConversion(usageInfo);
        if (target instanceof PsiMember) {
          try {
            reference.bindToElement((PsiElement)target);
          }
 catch (          IncorrectOperationException ignored) {
          }
        }
      }
    }
  }
}
