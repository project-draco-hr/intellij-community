{
  myApplication.assertWriteAccessAllowed();
synchronized (myLock) {
    if (myReleased)     return;
    if (myBulkUpdate || myAnathemaThrown || BaseLoadState.LOADED != myBaseLoaded)     return;
    try {
      int upToDateFirstLine;
      int upToDateLastLine;
      int linesAfterChange=myDocument.getLineNumber(e.getOffset() + e.getNewLength()) - myDocument.getLineNumber(e.getOffset());
      int linesShift=linesAfterChange - myLinesBeforeChange;
      List<Range> rangesBeforeChange=new ArrayList<Range>();
      List<Range> rangesAfterChange=new ArrayList<Range>();
      List<Range> changedRanges=new ArrayList<Range>();
      sortRanges(myRanges,myFirstChangedLine,myLastChangedLine,rangesBeforeChange,changedRanges,rangesAfterChange);
      Range firstChangedRange=ContainerUtil.getFirstItem(changedRanges);
      Range lastChangedRange=ContainerUtil.getLastItem(changedRanges);
      Range lastRangeBefore=ContainerUtil.getLastItem(rangesBeforeChange);
      if (firstChangedRange != null && firstChangedRange.getOffset1() < myFirstChangedLine) {
        myFirstChangedLine=firstChangedRange.getOffset1();
      }
      if (lastChangedRange != null && lastChangedRange.getOffset2() > myLastChangedLine) {
        myLastChangedLine=lastChangedRange.getOffset2();
      }
      upToDateFirstLine=getUpToDateLine(lastRangeBefore,myFirstChangedLine);
      if (lastChangedRange == null) {
        upToDateLastLine=getUpToDateLine(lastRangeBefore,myLastChangedLine);
      }
 else {
        upToDateLastLine=getUpToDateLine(lastChangedRange,myLastChangedLine);
      }
      myLastChangedLine+=linesShift;
      List<Range> newChangedRanges=getNewChangedRanges(upToDateFirstLine,upToDateLastLine);
      shiftRanges(rangesAfterChange,linesShift);
      if (!changedRanges.equals(newChangedRanges)) {
        replaceRanges(changedRanges,newChangedRanges);
        myRanges=new ArrayList<Range>();
        myRanges.addAll(rangesBeforeChange);
        myRanges.addAll(newChangedRanges);
        myRanges.addAll(rangesAfterChange);
        myRanges=mergeRanges(myRanges);
        for (        Range range : myRanges) {
          if (!range.hasHighlighter())           range.setHighlighter(createHighlighter(range));
        }
        if (myRanges.isEmpty() && myVirtualFile != null) {
          SwingUtilities.invokeLater(new Runnable(){
            @Override public void run(){
              FileDocumentManager.getInstance().saveDocument(e.getDocument());
              boolean[] stillEmpty=new boolean[1];
synchronized (myLock) {
                stillEmpty[0]=myRanges.isEmpty();
              }
              if (stillEmpty[0]) {
                myVcsDirtyScopeManager.fileDirty(myVirtualFile);
              }
            }
          }
);
        }
      }
    }
 catch (    ProcessCanceledException ignore) {
    }
catch (    FilesTooBigForDiffException e1) {
      installAnathema();
      removeHighlightersFromMarkupModel();
    }
  }
}
