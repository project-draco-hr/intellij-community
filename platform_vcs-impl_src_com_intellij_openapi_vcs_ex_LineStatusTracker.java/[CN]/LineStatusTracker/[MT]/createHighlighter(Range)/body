{
  LOG.assertTrue(!myReleased,"Already released");
  TextRange textRange=getCurrentTextRange(range);
  final RangeHighlighter highlighter=DocumentMarkupModel.forDocument(myDocument,myProject,true).addRangeHighlighter(textRange.getStartOffset(),textRange.getEndOffset(),HighlighterLayer.FIRST - 1,null,HighlighterTargetArea.LINES_IN_RANGE);
  final TextAttributes attr=LineStatusTrackerDrawing.getAttributesFor(range);
  highlighter.setErrorStripeMarkColor(attr.getErrorStripeColor());
  highlighter.setThinErrorStripeMark(true);
  highlighter.setGreedyToLeft(true);
  highlighter.setGreedyToRight(true);
  highlighter.setLineMarkerRenderer(LineStatusTrackerDrawing.createRenderer(range,this));
  highlighter.setEditorFilter(MarkupEditorFilterFactory.createIsNotDiffFilter());
  final String tooltip;
  if (range.getOffset1() == range.getOffset2()) {
    if (range.getUOffset1() + 1 == range.getUOffset2()) {
      tooltip=VcsBundle.message("tooltip.text.line.before.deleted",range.getOffset1() + 1);
    }
 else {
      tooltip=VcsBundle.message("tooltip.text.lines.before.deleted",range.getOffset1() + 1,range.getUOffset2() - range.getUOffset1());
    }
  }
 else   if (range.getOffset1() + 1 == range.getOffset2()) {
    tooltip=VcsBundle.message("tooltip.text.line.changed",range.getOffset1() + 1);
  }
 else {
    tooltip=VcsBundle.message("tooltip.text.lines.changed",range.getOffset1() + 1,range.getOffset2());
  }
  highlighter.setErrorStripeTooltip(tooltip);
  return highlighter;
}
