{
  if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) {
    CommonRefactoringUtil.showErrorHint(project,editor,PyBundle.message("refactoring.extract.method.error.local.variable.modifications.and.returns"),RefactoringBundle.message("error.title"),"refactoring.extractMethod");
    return;
  }
  final PyFunction function=PsiTreeUtil.getParentOfType(statement1,PyFunction.class);
  final PyUtil.MethodFlags flags=function == null ? null : PyUtil.MethodFlags.of(function);
  final boolean isClassMethod=flags != null && flags.isClassMethod();
  final boolean isStaticMethod=flags != null && flags.isStaticMethod();
  final List<PsiElement> elementsRange=PyPsiUtils.collectElements(statement1,statement2);
  if (elementsRange.isEmpty()) {
    CommonRefactoringUtil.showErrorHint(project,editor,PyBundle.message("refactoring.extract.method.error.empty.fragment"),RefactoringBundle.message("extract.method.title"),"refactoring.extractMethod");
    return;
  }
  final Pair<String,AbstractVariableData[]> data=getNameAndVariableData(project,fragment,statement1,isClassMethod,isStaticMethod);
  if (data.first == null || data.second == null) {
    return;
  }
  final String methodName=data.first;
  final AbstractVariableData[] variableData=data.second;
  final SimpleDuplicatesFinder finder=new SimpleDuplicatesFinder(statement1,statement2,variableData,fragment.getOutputVariables());
  CommandProcessor.getInstance().executeCommand(project,new Runnable(){
    public void run(){
      ApplicationManager.getApplication().runWriteAction(new Runnable(){
        public void run(){
          final RefactoringEventData beforeData=new RefactoringEventData();
          beforeData.addElements(new PsiElement[]{statement1,statement2});
          project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(getRefactoringId(),beforeData);
          final StringBuilder builder=new StringBuilder();
          final boolean isAsync=fragment.isAsync();
          if (isAsync) {
            builder.append("async ");
          }
          builder.append("def f():\n    ");
          final List<PsiElement> newMethodElements=new ArrayList<PsiElement>(elementsRange);
          final boolean hasOutputVariables=!fragment.getOutputVariables().isEmpty();
          final PyElementGenerator generator=PyElementGenerator.getInstance(project);
          final LanguageLevel languageLevel=LanguageLevel.forElement(statement1);
          if (hasOutputVariables) {
            final String outputVariables=StringUtil.join(fragment.getOutputVariables(),", ");
            String newMethodText=builder + "return " + outputVariables;
            builder.append(outputVariables);
            final PyFunction function=generator.createFromText(languageLevel,PyFunction.class,newMethodText);
            final PsiElement returnStatement=function.getStatementList().getStatements()[0];
            newMethodElements.add(returnStatement);
          }
          PyFunction generatedMethod=generateMethodFromElements(project,methodName,variableData,newMethodElements,flags,isAsync);
          generatedMethod=insertGeneratedMethod(statement1,generatedMethod);
          final PsiElement firstElement=elementsRange.get(0);
          final boolean isMethod=PyPsiUtils.isMethodContext(firstElement);
          processParameters(project,generatedMethod,variableData,isMethod,isClassMethod,isStaticMethod);
          processGlobalWrites(generatedMethod,fragment);
          processNonlocalWrites(generatedMethod,fragment);
          if (hasOutputVariables) {
            builder.append(" = ");
          }
 else           if (fragment.isReturnInstructionInside()) {
            builder.append("return ");
          }
          if (isAsync) {
            builder.append("await ");
          }
 else           if (fragment.isYieldInside()) {
            builder.append("yield from ");
          }
          if (isMethod) {
            appendSelf(firstElement,builder,isStaticMethod);
          }
          builder.append(methodName).append("(");
          builder.append(createCallArgsString(variableData)).append(")");
          final PyFunction function=generator.createFromText(languageLevel,PyFunction.class,builder.toString());
          PsiElement callElement=function.getStatementList().getStatements()[0];
          callElement=replaceElements(elementsRange,callElement);
          callElement=CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement);
          if (callElement != null) {
            processDuplicates(callElement,generatedMethod,finder,editor);
          }
          setSelectionAndCaret(editor,callElement);
          final RefactoringEventData afterData=new RefactoringEventData();
          afterData.addElement(generatedMethod);
          project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(getRefactoringId(),afterData);
        }
      }
);
    }
  }
,PyBundle.message("refactoring.extract.method"),null);
}
