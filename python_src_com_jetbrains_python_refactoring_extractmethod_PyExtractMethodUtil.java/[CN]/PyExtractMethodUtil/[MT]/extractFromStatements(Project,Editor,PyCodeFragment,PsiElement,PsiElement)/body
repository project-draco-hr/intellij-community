{
  if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) {
    CommonRefactoringUtil.showErrorHint(project,editor,PyBundle.message("refactoring.extract.method.error.cannot.perform.refactoring.with.local"),RefactoringBundle.message("error.title"),"refactoring.extractMethod");
    return;
  }
  final PyFunction function=PsiTreeUtil.getParentOfType(statement1,PyFunction.class);
  final PyUtil.MethodFlags flags=function == null ? null : PyUtil.MethodFlags.of(function);
  final boolean isClassMethod=flags != null && flags.isClassMethod();
  final boolean isStaticMethod=flags != null && flags.isStaticMethod();
  final List<PsiElement> elementsRange=PyPsiUtils.collectElements(statement1,statement2);
  if (elementsRange.isEmpty()) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Cannot perform refactoring from empty code fragment",RefactoringBundle.message("extract.method.title"),"refactoring.extractMethod");
    return;
  }
  final Pair<String,AbstractVariableData[]> data=getNameAndVariableData(project,fragment,statement1,isClassMethod,isStaticMethod);
  if (data.first == null || data.second == null) {
    return;
  }
  final String methodName=data.first;
  final AbstractVariableData[] variableData=data.second;
  final PyDuplicatesFinder finder=new PyDuplicatesFinder(statement1,statement2);
  if (fragment.getOutputVariables().isEmpty()) {
    CommandProcessor.getInstance().executeCommand(project,new Runnable(){
      public void run(){
        ApplicationManager.getApplication().runWriteAction(new Runnable(){
          public void run(){
            PyFunction generatedMethod=generateMethodFromElements(project,methodName,variableData,elementsRange,flags);
            generatedMethod=insertGeneratedMethod(statement1,generatedMethod);
            final PsiElement firstElement=elementsRange.get(0);
            final boolean isMethod=PyPsiUtils.isMethodContext(firstElement);
            processParameters(project,generatedMethod,variableData,isMethod,isClassMethod,isStaticMethod);
            processGlobalWrites(generatedMethod,fragment);
            processNonlocalWrites(generatedMethod,fragment);
            final StringBuilder builder=new StringBuilder();
            if (fragment.isReturnInstructionInside()) {
              builder.append("return ");
            }
            if (fragment.isYieldInside()) {
              builder.append("yield from ");
            }
            if (isMethod) {
              appendSelf(firstElement,builder,isStaticMethod);
            }
            builder.append(methodName);
            builder.append("(").append(createCallArgsString(variableData)).append(")");
            PsiElement callElement=PyElementGenerator.getInstance(project).createFromText(LanguageLevel.getDefault(),PyCallExpression.class,builder.toString());
            callElement=replaceElements(elementsRange,callElement);
            callElement=CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement);
            processDuplicates(callElement,generatedMethod,finder,editor);
            setSelectionAndCaret(editor,callElement);
          }
        }
);
      }
    }
,"Extract method",null);
  }
 else {
    CommandProcessor.getInstance().executeCommand(project,new Runnable(){
      public void run(){
        ApplicationManager.getApplication().runWriteAction(new Runnable(){
          public void run(){
            final StringBuilder builder=new StringBuilder();
            for (            String s : fragment.getOutputVariables()) {
              if (builder.length() != 0) {
                builder.append(", ");
              }
              builder.append(s);
            }
            final List<PsiElement> newMethodElements=new ArrayList<PsiElement>(elementsRange);
            final PsiElement returnStatement=PyElementGenerator.getInstance(project).createFromText(LanguageLevel.getDefault(),PyElement.class,"return " + builder.toString());
            newMethodElements.add(returnStatement);
            PyFunction generatedMethod=generateMethodFromElements(project,methodName,variableData,newMethodElements,flags);
            generatedMethod=(PyFunction)CodeStyleManager.getInstance(project).reformat(generatedMethod);
            generatedMethod=insertGeneratedMethod(statement1,generatedMethod);
            final boolean isMethod=PyPsiUtils.isMethodContext(elementsRange.get(0));
            processParameters(project,generatedMethod,variableData,isMethod,isClassMethod,isStaticMethod);
            processGlobalWrites(generatedMethod,fragment);
            processNonlocalWrites(generatedMethod,fragment);
            builder.append(" = ");
            if (fragment.isYieldInside()) {
              builder.append("yield from ");
            }
            if (isMethod) {
              appendSelf(elementsRange.get(0),builder,isStaticMethod);
            }
            builder.append(methodName).append("(");
            builder.append(createCallArgsString(variableData)).append(")");
            PsiElement callElement=PyElementGenerator.getInstance(project).createFromText(LanguageLevel.getDefault(),PyElement.class,builder.toString());
            callElement=replaceElements(elementsRange,callElement);
            callElement=CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement);
            processDuplicates(callElement,generatedMethod,finder,editor);
            setSelectionAndCaret(editor,callElement);
          }
        }
);
      }
    }
,"Extract method",null);
  }
}
