{
  if (!fragment.getOutputVariables().isEmpty()) {
    CommonRefactoringUtil.showErrorHint(project,editor,PyBundle.message("refactoring.extract.method.error.local.variable.modifications"),RefactoringBundle.message("error.title"),"refactoring.extractMethod");
    return;
  }
  if (fragment.isReturnInstructionInside()) {
    CommonRefactoringUtil.showErrorHint(project,editor,PyBundle.message("refactoring.extract.method.error.returns"),RefactoringBundle.message("error.title"),"refactoring.extractMethod");
    return;
  }
  final PyFunction function=PsiTreeUtil.getParentOfType(expression,PyFunction.class);
  final PyUtil.MethodFlags flags=function == null ? null : PyUtil.MethodFlags.of(function);
  final boolean isClassMethod=flags != null && flags.isClassMethod();
  final boolean isStaticMethod=flags != null && flags.isClassMethod();
  final Pair<String,AbstractVariableData[]> data=getNameAndVariableData(project,fragment,expression,isClassMethod,isStaticMethod);
  if (data.first == null || data.second == null) {
    return;
  }
  final String methodName=data.first;
  final AbstractVariableData[] variableData=data.second;
  final SimpleDuplicatesFinder finder=new SimpleDuplicatesFinder(expression,expression,variableData,fragment.getOutputVariables());
  if (fragment.getOutputVariables().isEmpty()) {
    CommandProcessor.getInstance().executeCommand(project,new Runnable(){
      @Override public void run(){
        ApplicationManager.getApplication().runWriteAction(new Runnable(){
          @Override public void run(){
            final boolean isAsync=fragment.isAsync();
            PyFunction generatedMethod=generateMethodFromExpression(project,methodName,variableData,expression,flags,isAsync);
            generatedMethod=insertGeneratedMethod(expression,generatedMethod);
            final boolean isMethod=PyPsiUtils.isMethodContext(expression);
            processParameters(project,generatedMethod,variableData,isMethod,isClassMethod,isStaticMethod);
            final StringBuilder builder=new StringBuilder();
            if (isAsync) {
              builder.append("async ");
            }
            builder.append("def f():\n    ");
            if (isAsync) {
              builder.append("await ");
            }
 else             if (fragment.isYieldInside()) {
              builder.append("yield from ");
            }
 else {
              builder.append("return ");
            }
            if (isMethod) {
              appendSelf(expression,builder,isStaticMethod);
            }
            builder.append(methodName);
            builder.append("(").append(createCallArgsString(variableData)).append(")");
            final PyElementGenerator generator=PyElementGenerator.getInstance(project);
            final PyFunction function=generator.createFromText(LanguageLevel.forElement(expression),PyFunction.class,builder.toString());
            final PyElement generated=function.getStatementList().getStatements()[0];
            PsiElement callElement=null;
            if (generated instanceof PyReturnStatement) {
              callElement=((PyReturnStatement)generated).getExpression();
            }
 else             if (generated instanceof PyExpressionStatement) {
              callElement=((PyExpressionStatement)generated).getExpression();
            }
            if (callElement != null) {
              callElement=PyReplaceExpressionUtil.replaceExpression(expression,callElement);
            }
            if (callElement != null) {
              processDuplicates(callElement,generatedMethod,finder,editor);
            }
            setSelectionAndCaret(editor,callElement);
          }
        }
);
      }
    }
,PyBundle.message("refactoring.extract.method"),null);
  }
}
