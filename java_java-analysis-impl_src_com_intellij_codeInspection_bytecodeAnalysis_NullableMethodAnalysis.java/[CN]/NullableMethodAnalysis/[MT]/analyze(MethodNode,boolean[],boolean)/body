{
  InsnList insns=methodNode.instructions;
  Constraint[] data=new Constraint[insns.size()];
  NullableMethodInterpreter interpreter=new NullableMethodInterpreter(insns,origins);
  Frame<BasicValue>[] frames=jsr ? new AnalyzerExt<BasicValue,Constraint,NullableMethodInterpreter>(interpreter,data,Constraint.EMPTY).analyze("this",methodNode) : new LiteAnalyzerExt<BasicValue,Constraint,NullableMethodInterpreter>(interpreter,data,Constraint.EMPTY).analyze("this",methodNode);
  BasicValue result=BasicValue.REFERENCE_VALUE;
  for (int i=0; i < frames.length; i++) {
    Frame<BasicValue> frame=frames[i];
    if (frame != null && insns.get(i).getOpcode() == Opcodes.ARETURN) {
      BasicValue stackTop=frame.pop();
      result=combine(result,stackTop,data[i]);
    }
  }
  if (result instanceof LabeledNull) {
    return FinalNull;
  }
  if (result instanceof Calls) {
    Calls calls=((Calls)result);
    Set<Product<Key,Value>> sum=new HashSet<Product<Key,Value>>(calls.keys.size());
    for (    Key key : calls.keys) {
      sum.add(new Product<Key,Value>(Value.Null,new SingletonSet<Key>(key)));
    }
    return new Pending<Key,Value>(sum);
  }
  return FinalBot;
}
