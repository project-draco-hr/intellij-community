{
  InsnList insns=methodNode.instructions;
  Constraint[] data=new Constraint[insns.size()];
  int[] originsMapping=mapOrigins(origins);
  NullableMethodInterpreter interpreter=new NullableMethodInterpreter(insns,origins,originsMapping);
  Frame<BasicValue>[] frames=jsr ? new AnalyzerExt<>(interpreter,data,Constraint.EMPTY).analyze("this",methodNode) : new LiteAnalyzerExt<>(interpreter,data,Constraint.EMPTY).analyze("this",methodNode);
  BasicValue result=BasicValue.REFERENCE_VALUE;
  for (int i=0; i < frames.length; i++) {
    Frame<BasicValue> frame=frames[i];
    if (frame != null && insns.get(i).getOpcode() == Opcodes.ARETURN) {
      BasicValue stackTop=frame.pop();
      result=combine(result,stackTop,data[i]);
    }
  }
  if (result instanceof LabeledNull) {
    return FinalNull;
  }
  if (result instanceof Calls) {
    Calls calls=((Calls)result);
    int mergedMappedLabels=calls.mergedLabels;
    if (mergedMappedLabels != 0) {
      Set<Product> sum=new HashSet<>();
      Key[] createdKeys=interpreter.keys;
      for (int origin=0; origin < originsMapping.length; origin++) {
        int mappedOrigin=originsMapping[origin];
        Key createdKey=createdKeys[origin];
        if (createdKey != null && (mergedMappedLabels & (1 << mappedOrigin)) != 0) {
          sum.add(new Product(Value.Null,Collections.singleton(createdKey)));
        }
      }
      if (!sum.isEmpty()) {
        return new Pending(sum);
      }
    }
  }
  return FinalBot;
}
