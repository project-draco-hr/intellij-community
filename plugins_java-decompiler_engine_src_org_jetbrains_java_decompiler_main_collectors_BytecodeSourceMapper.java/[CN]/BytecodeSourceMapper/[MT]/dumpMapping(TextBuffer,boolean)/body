{
  if (mapping.isEmpty() && linesMapping.isEmpty()) {
    return;
  }
  String lineSeparator=DecompilerContext.getNewLineSeparator();
  for (  Entry<String,Map<String,Map<Integer,Integer>>> class_entry : mapping.entrySet()) {
    Map<String,Map<Integer,Integer>> class_mapping=class_entry.getValue();
    buffer.append("class '" + class_entry.getKey() + "' {"+ lineSeparator);
    boolean is_first_method=true;
    for (    Entry<String,Map<Integer,Integer>> method_entry : class_mapping.entrySet()) {
      Map<Integer,Integer> method_mapping=method_entry.getValue();
      if (!is_first_method) {
        buffer.appendLineSeparator();
      }
      buffer.appendIndent(1).append("method '" + method_entry.getKey() + "' {"+ lineSeparator);
      List<Integer> lstBytecodeOffsets=new ArrayList<Integer>(method_mapping.keySet());
      Collections.sort(lstBytecodeOffsets);
      for (      Integer offset : lstBytecodeOffsets) {
        Integer line=method_mapping.get(offset);
        String strOffset=offsetsToHex ? Integer.toHexString(offset) : line.toString();
        buffer.appendIndent(2).append(strOffset).appendIndent(2).append((line + offset_total) + lineSeparator);
      }
      buffer.appendIndent(1).append("}").appendLineSeparator();
      is_first_method=false;
    }
    buffer.append("}").appendLineSeparator().appendLineSeparator();
  }
  buffer.append("Lines mapping:").appendLineSeparator();
  Map<Integer,Integer> sorted=new TreeMap<Integer,Integer>(linesMapping);
  for (  Entry<Integer,Integer> entry : sorted.entrySet()) {
    buffer.append(entry.getKey()).append(" <-> ").append(entry.getValue() + offset_total + 1).appendLineSeparator();
  }
  if (!unmappedLines.isEmpty()) {
    buffer.append("Not mapped:").appendLineSeparator();
    for (    Integer line : unmappedLines) {
      if (!linesMapping.containsKey(line)) {
        buffer.append(line).appendLineSeparator();
      }
    }
  }
}
