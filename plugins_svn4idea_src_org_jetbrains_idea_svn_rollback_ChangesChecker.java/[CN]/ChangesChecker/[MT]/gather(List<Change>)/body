{
  final TreeMap<String,File> renames=new TreeMap<String,File>();
  final Set<String> alsoReverted=new HashSet<String>();
  final Map<String,FilePath> files=new HashMap<String,FilePath>();
  for (  Change change : changes) {
    final ContentRevision beforeRevision=change.getBeforeRevision();
    final ContentRevision afterRevision=change.getAfterRevision();
    final String key=afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile());
    if (SvnRollbackEnvironment.isMoveRenameReplace(change)) {
      final File beforeFile=beforeRevision.getFile().getIOFile();
      renames.put(key,beforeFile);
      files.put(key,afterRevision.getFile());
      myCollector.markRename(beforeFile,afterRevision.getFile().getIOFile());
    }
 else     if (afterRevision != null) {
      alsoReverted.add(key);
    }
  }
  if (!renames.isEmpty()) {
    final ArrayList<String> paths=new ArrayList<String>(renames.keySet());
    if (paths.size() > 1) {
      FilterFilePathStrings.getInstance().doFilter(paths);
    }
    myCollector.setRenamesMap(renames);
    myCollector.setAlsoReverted(alsoReverted);
    for (    String path : paths) {
      try {
        myChangeProvider.getChanges(files.get(path),true,myCollector);
      }
 catch (      SVNException e) {
        myExceptions.add(new VcsException(e));
      }
catch (      SvnBindException e) {
        myExceptions.add(e);
      }
    }
  }
  for (  Change change : changes) {
    final ContentRevision afterRevision=change.getAfterRevision();
    boolean checked=myForAdds.accept(change);
    checked|=myForDeletes.accept(change);
    if (!checked) {
      myForEdits.add(afterRevision.getFile().getIOFile());
    }
  }
}
