{
  ParserUtils.getToken(builder,mAT);
  if (ParserUtils.getToken(builder,mIDENT) || ParserUtils.getToken(builder,mSTRING_LITERAL) || ParserUtils.getToken(builder,mGSTRING_LITERAL)) {
    return REFERENCE_EXPRESSION;
  }
  final IElementType tokenType=builder.getTokenType();
  if (tokenType == mGSTRING_BEGIN) {
    final boolean result=CompoundStringExpression.parse(builder,parser,true,mGSTRING_BEGIN,mGSTRING_CONTENT,mGSTRING_END,null,GSTRING,GroovyBundle.message("string.end.expected"));
    return result ? PATH_PROPERTY_REFERENCE : REFERENCE_EXPRESSION;
  }
  if (tokenType == mREGEX_BEGIN) {
    final boolean result=CompoundStringExpression.parse(builder,parser,true,mREGEX_BEGIN,mREGEX_CONTENT,mREGEX_END,mREGEX_LITERAL,REGEX,GroovyBundle.message("regex.end.expected"));
    return result ? PATH_PROPERTY_REFERENCE : REFERENCE_EXPRESSION;
  }
  if (tokenType == mDOLLAR_SLASH_REGEX_BEGIN) {
    final boolean result=CompoundStringExpression.parse(builder,parser,true,mDOLLAR_SLASH_REGEX_BEGIN,mDOLLAR_SLASH_REGEX_CONTENT,mDOLLAR_SLASH_REGEX_END,mDOLLAR_SLASH_REGEX_LITERAL,REGEX,GroovyBundle.message("dollar.slash.end.expected"));
    return result ? PATH_PROPERTY_REFERENCE : REFERENCE_EXPRESSION;
  }
  if (tokenType == mLCURLY) {
    OpenOrClosableBlock.parseOpenBlock(builder,parser);
    return PATH_PROPERTY_REFERENCE;
  }
  if (tokenType == mLPAREN) {
    PrimaryExpression.parenthesizedExprParse(builder,parser);
    return PATH_PROPERTY_REFERENCE;
  }
  if (TokenSets.KEYWORDS.contains(builder.getTokenType())) {
    builder.advanceLexer();
    return REFERENCE_EXPRESSION;
  }
  return WRONGWAY;
}
