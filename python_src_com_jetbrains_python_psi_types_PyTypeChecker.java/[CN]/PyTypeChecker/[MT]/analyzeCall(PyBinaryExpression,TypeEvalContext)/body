{
  final PsiPolyVariantReference ref=expr.getReference(PyResolveContext.noImplicits().withTypeEvalContext(context));
  final ResolveResult[] resolveResult=ref.multiResolve(false);
  AnalyzeCallResults firstResults=null;
  for (  ResolveResult result : resolveResult) {
    final PsiElement resolved=result.getElement();
    if (resolved instanceof PyTypedElement) {
      final PyTypedElement typedElement=(PyTypedElement)resolved;
      final PyType type=context.getType(typedElement);
      if (!(type instanceof PyFunctionType)) {
        return null;
      }
      final Callable callable=((PyFunctionType)type).getCallable();
      final boolean isRight=PyNames.isRightOperatorName(typedElement.getName());
      final PyExpression arg=isRight ? expr.getLeftExpression() : expr.getRightExpression();
      final PyExpression receiver=isRight ? expr.getRightExpression() : expr.getLeftExpression();
      final PyParameter[] parameters=callable.getParameterList().getParameters();
      if (parameters.length >= 2) {
        final PyNamedParameter param=parameters[1].getAsNamed();
        if (arg != null && param != null) {
          final Map<PyExpression,PyNamedParameter> arguments=new LinkedHashMap<PyExpression,PyNamedParameter>();
          arguments.put(arg,param);
          final AnalyzeCallResults results=new AnalyzeCallResults(callable,receiver,arguments);
          if (firstResults == null) {
            firstResults=results;
          }
          if (match(context.getType(param),context.getType(arg),context)) {
            return results;
          }
        }
      }
    }
  }
  if (firstResults != null) {
    return firstResults;
  }
  return null;
}
