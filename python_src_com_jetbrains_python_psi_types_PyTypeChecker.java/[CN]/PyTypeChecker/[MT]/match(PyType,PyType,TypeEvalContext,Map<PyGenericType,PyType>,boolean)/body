{
  if (expected instanceof PyGenericType && substitutions != null) {
    final PyGenericType generic=(PyGenericType)expected;
    final PyType subst=substitutions.get(generic);
    final PyType bound=generic.getBound();
    if (!match(bound,actual,context,substitutions,recursive)) {
      return false;
    }
 else     if (subst != null) {
      if (expected.equals(actual)) {
        return true;
      }
 else       if (recursive) {
        return match(subst,actual,context,substitutions,false);
      }
 else {
        return false;
      }
    }
 else     if (actual != null && !(actual instanceof PyReturnTypeReference)) {
      substitutions.put(generic,actual);
    }
 else     if (bound != null) {
      substitutions.put(generic,bound);
    }
    return true;
  }
  if (expected == null || actual == null) {
    return true;
  }
  if (expected instanceof PyClassType) {
    final PyClass c=((PyClassType)expected).getPyClass();
    if (c != null && "object".equals(c.getName())) {
      return true;
    }
  }
  if ((expected instanceof PyTypeReference || actual instanceof PyTypeReference) && !recursive) {
    return true;
  }
  if (expected instanceof PyTypeReference) {
    return match(((PyTypeReference)expected).resolve(null,context),actual,context,substitutions,recursive);
  }
  if (actual instanceof PyTypeReference) {
    return match(expected,((PyTypeReference)actual).resolve(null,context),context,substitutions,false);
  }
  if (isUnknown(actual)) {
    return true;
  }
  if (actual instanceof PyUnionType) {
    for (    PyType m : ((PyUnionType)actual).getMembers()) {
      if (match(expected,m,context,substitutions,recursive)) {
        return true;
      }
    }
    return false;
  }
  if (expected instanceof PyUnionType) {
    for (    PyType t : ((PyUnionType)expected).getMembers()) {
      if (match(t,actual,context,substitutions,recursive)) {
        return true;
      }
    }
    return false;
  }
  if (expected instanceof PyClassType && actual instanceof PyClassType) {
    final PyClass superClass=((PyClassType)expected).getPyClass();
    final PyClass subClass=((PyClassType)actual).getPyClass();
    if (expected instanceof PyCollectionType && actual instanceof PyCollectionType) {
      if (!matchClasses(superClass,subClass,context)) {
        return false;
      }
      final PyType superElementType=((PyCollectionType)expected).getElementType(context);
      final PyType subElementType=((PyCollectionType)actual).getElementType(context);
      return match(superElementType,subElementType,context,substitutions,recursive);
    }
 else     if (expected instanceof PyTupleType && actual instanceof PyTupleType) {
      final PyTupleType superTupleType=(PyTupleType)expected;
      final PyTupleType subTupleType=(PyTupleType)actual;
      if (superTupleType.getElementCount() != subTupleType.getElementCount()) {
        return false;
      }
 else {
        for (int i=0; i < superTupleType.getElementCount(); i++) {
          if (!match(superTupleType.getElementType(i),subTupleType.getElementType(i),context,substitutions,recursive)) {
            return false;
          }
        }
        return true;
      }
    }
 else     if (matchClasses(superClass,subClass,context)) {
      return true;
    }
 else     if (((PyClassType)actual).isDefinition() && PyNames.CALLABLE.equals(expected.getName())) {
      return true;
    }
    if (expected.equals(actual)) {
      return true;
    }
  }
  if (actual instanceof PyFunctionType && expected instanceof PyClassType) {
    final PyClass superClass=((PyClassType)expected).getPyClass();
    if (superClass != null && PyNames.CALLABLE.equals(superClass.getName())) {
      return true;
    }
  }
  final String superName=expected.getName();
  final String subName=actual.getName();
  final boolean subIsBool="bool".equals(subName);
  final boolean subIsInt="int".equals(subName);
  final boolean subIsLong="long".equals(subName);
  final boolean subIsFloat="float".equals(subName);
  final boolean subIsComplex="complex".equals(subName);
  if (superName == null || subName == null || superName.equals(subName) || ("int".equals(superName) && subIsBool) || (("long".equals(superName) || "Integral".equals(superName)) && (subIsBool || subIsInt)) || (("float".equals(superName) || "Real".equals(superName)) && (subIsBool || subIsInt || subIsLong)) || (("complex".equals(superName) || "Complex".equals(superName)) && (subIsBool || subIsInt || subIsLong|| subIsFloat)) || ("Number".equals(superName) && (subIsBool || subIsInt || subIsLong|| subIsFloat|| subIsComplex))) {
    return true;
  }
  return false;
}
