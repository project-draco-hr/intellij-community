{
  final StringWriter out=new StringWriter();
  final StringWriter err=new StringWriter();
  final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
  try {
    final Process process=myCommandLine.createProcess();
    final OSProcessHandler processHandler=new OSProcessHandler(process,myCommandLine.toString(),myCommandLine.getCharset());
    processHandler.addProcessListener(new ProcessListener(){
      public void startNotified(      final ProcessEvent event){
      }
      public void processTerminated(      final ProcessEvent event){
        myExitCode=event.getExitCode();
      }
      @Override public void processWillTerminate(      ProcessEvent event,      boolean willBeDestroyed){
      }
      @Override public void onTextAvailable(      ProcessEvent event,      Key outputType){
        Iterator<String> lines=LineHandlerHelper.splitText(event.getText()).iterator();
        if (ProcessOutputTypes.STDOUT == outputType) {
          while (lines.hasNext()) {
            String line=lines.next();
            if (indicator != null && showTextOnIndicator) {
              indicator.setText2(line);
            }
            out.write(line);
          }
        }
 else         if (ProcessOutputTypes.STDERR == outputType) {
          while (lines.hasNext()) {
            err.write(lines.next());
          }
        }
      }
    }
);
    processHandler.startNotify();
    while (!processHandler.waitFor(300)) {
      if (indicator != null && indicator.isCanceled()) {
        processHandler.destroyProcess();
        myExitCode=255;
        break;
      }
    }
    return new HgCommandResult(out,err,myExitCode);
  }
 catch (  ExecutionException e) {
    throw new ShellCommandException(e);
  }
}
