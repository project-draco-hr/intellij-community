{
switch (frame.getCommand()) {
case AbstractCommand.CREATE_THREAD:
{
      final PyThreadInfo thread=parseThreadEvent(frame);
      if (!thread.isPydevThread()) {
        myThreads.put(thread.getId(),thread);
      }
      break;
    }
case AbstractCommand.SUSPEND_THREAD:
{
    final PyThreadInfo event=parseThreadEvent(frame);
    PyThreadInfo thread=myThreads.get(event.getId());
    if (thread == null) {
      LOG.error("Trying to stop on non-existent thread: " + event.getId() + ", "+ event.getStopReason()+ ", "+ event.getMessage());
      myThreads.put(event.getId(),event);
      thread=event;
    }
    thread.updateState(PyThreadInfo.State.SUSPENDED,event.getFrames());
    thread.setStopReason(event.getStopReason());
    thread.setMessage(event.getMessage());
    myDebugProcess.threadSuspended(thread);
    break;
  }
case AbstractCommand.RESUME_THREAD:
{
  final String id=ProtocolParser.getThreadId(frame.getPayload());
  final PyThreadInfo thread=myThreads.get(id);
  if (thread != null) {
    thread.updateState(PyThreadInfo.State.RUNNING,null);
    myDebugProcess.threadResumed(thread);
  }
  break;
}
case AbstractCommand.KILL_THREAD:
{
final String id=frame.getPayload();
final PyThreadInfo thread=myThreads.get(id);
if (thread != null) {
  thread.updateState(PyThreadInfo.State.KILLED,null);
  myThreads.remove(id);
}
for (PyThreadInfo threadInfo : myThreads.values()) {
  if ((threadInfo != null) && (threadInfo.getState() == PyThreadInfo.State.SUSPENDED)) {
    myDebugProcess.threadResumed(threadInfo);
    myDebugProcess.threadSuspended(threadInfo);
  }
}
break;
}
case AbstractCommand.SHOW_CONSOLE:
{
final PyThreadInfo event=parseThreadEvent(frame);
PyThreadInfo thread=myThreads.get(event.getId());
if (thread == null) {
myThreads.put(event.getId(),event);
thread=event;
}
thread.updateState(PyThreadInfo.State.SUSPENDED,event.getFrames());
thread.setStopReason(event.getStopReason());
thread.setMessage(event.getMessage());
myDebugProcess.showConsole(thread);
break;
}
}
}
