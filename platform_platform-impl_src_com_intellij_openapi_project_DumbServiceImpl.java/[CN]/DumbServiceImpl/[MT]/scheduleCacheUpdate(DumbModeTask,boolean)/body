{
  if (ApplicationManager.getApplication().isInternal())   LOG.info("schedule " + task);
  final Application application=ApplicationManager.getApplication();
  if (application.isUnitTestMode() || application.isHeadlessEnvironment() || !forceDumbMode && !myDumb && application.isReadAccessAllowed()) {
    final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
    if (indicator != null) {
      indicator.pushState();
    }
    try {
      HeavyProcessLatch.INSTANCE.processStarted();
      task.performInDumbMode(indicator != null ? indicator : new EmptyProgressIndicator());
    }
  finally {
      HeavyProcessLatch.INSTANCE.processFinished();
      if (indicator != null) {
        indicator.popState();
      }
      Disposer.dispose(task);
    }
    return;
  }
  UIUtil.invokeLaterIfNeeded(new DumbAwareRunnable(){
    @Override public void run(){
      if (myProject.isDisposed()) {
        return;
      }
      myUpdatesQueue.addLast(task);
      myProgresses.put(task,new ProgressIndicatorBase());
      Disposer.register(task,new Disposable(){
        @Override public void dispose(){
          application.assertIsDispatchThread();
          myProgresses.remove(task);
        }
      }
);
      if (!myDumb) {
        boolean startSuccess=application.runWriteAction(new Computable<Boolean>(){
          @Override public Boolean compute(){
            myDumb=true;
            try {
              myPublisher.enteredDumbMode();
            }
 catch (            Throwable e) {
              LOG.error(e);
            }
            try {
              startBackgroundProcess();
            }
 catch (            Throwable e) {
              LOG.error("Failed to start background index update task",e);
              return false;
            }
            return true;
          }
        }
);
        if (!startSuccess) {
          updateFinished();
        }
      }
    }
  }
);
}
