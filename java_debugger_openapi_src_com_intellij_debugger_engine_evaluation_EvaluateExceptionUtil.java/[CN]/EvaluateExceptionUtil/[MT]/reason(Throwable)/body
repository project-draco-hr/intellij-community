{
  if (th instanceof InvalidTypeException) {
    final String originalReason=th.getMessage();
    return DebuggerBundle.message("evaluation.error.type.mismatch") + (originalReason != null ? " " + originalReason : "");
  }
 else   if (th instanceof AbsentInformationException) {
    return DebuggerBundle.message("evaluation.error.debug.info.unavailable");
  }
 else   if (th instanceof ClassNotLoadedException) {
    return DebuggerBundle.message("evaluation.error.class.not.loaded",((ClassNotLoadedException)th).className());
  }
 else   if (th instanceof ClassNotPreparedException) {
    return th.getMessage();
  }
 else   if (th instanceof IncompatibleThreadStateException) {
    return DebuggerBundle.message("evaluation.error.thread.not.at.breakpoint");
  }
 else   if (th instanceof InconsistentDebugInfoException) {
    return DebuggerBundle.message("evaluation.error.inconsistent.debug.info");
  }
 else   if (th instanceof ObjectCollectedException) {
    return DebuggerBundle.message("evaluation.error.object.collected");
  }
 else   if (th instanceof InvocationException) {
    InvocationException invocationException=(InvocationException)th;
    return DebuggerBundle.message("evaluation.error.method.exception",invocationException.exception().referenceType().name());
  }
 else   if (th instanceof EvaluateException) {
    return th.getMessage();
  }
 else {
    StringBuilder res=new StringBuilder(th.getClass().getName());
    String message=th.getMessage();
    if (!StringUtil.isEmpty(message)) {
      res.append(" : ").append(message);
    }
    return res.toString();
  }
}
