{
  PsiElement refNameElement=ref.getReferenceNameElement();
  if (refNameElement == null)   return null;
  boolean inStaticContext=PsiUtil.isCompileStatic(ref) || isPropertyAccessInStaticMethod(ref);
  GroovyResolveResult resolveResult=getBestResolveResult(ref);
  if (resolveResult.getElement() != null) {
    if (!isInspectionEnabled(ref.getContainingFile(),ref.getProject()))     return null;
    if (isStaticOk(resolveResult))     return null;
    String message=GroovyBundle.message("cannot.reference.non.static",ref.getReferenceName());
    return createAnnotationForRef(ref,inStaticContext,message);
  }
  if (ResolveUtil.isKeyOfMap(ref) || isClassReference(ref)) {
    return null;
  }
  if (!inStaticContext) {
    GrUnresolvedAccessInspection inspection=getInstance(ref.getContainingFile(),ref.getProject());
    if (inspection == null)     return null;
    if (!inspection.myHighlightIfGroovyObjectOverridden && areGroovyObjectMethodsOverridden(ref))     return null;
    if (!inspection.myHighlightIfMissingMethodsDeclared && areMissingMethodsDeclared(ref))     return null;
    if (GroovySuppressableInspectionTool.isElementToolSuppressedIn(ref,SHORT_NAME))     return null;
  }
  if (inStaticContext || shouldHighlightAsUnresolved(ref)) {
    HighlightInfo info=createAnnotationForRef(ref,inStaticContext,GroovyBundle.message("cannot.resolve",ref.getReferenceName()));
    if (info == null)     return null;
    HighlightDisplayKey displayKey=HighlightDisplayKey.find(SHORT_NAME);
    if (ref.getParent() instanceof GrMethodCall) {
      registerStaticImportFix(ref,info,displayKey);
    }
 else {
      registerCreateClassByTypeFix(ref,info,displayKey);
      registerAddImportFixes(ref,info,displayKey);
    }
    registerReferenceFixes(ref,info,inStaticContext,displayKey);
    UnresolvedReferenceQuickFixProvider.registerReferenceFixes(ref,new QuickFixActionRegistrarAdapter(info,displayKey));
    OrderEntryFix.registerFixes(new QuickFixActionRegistrarAdapter(info,displayKey),ref);
    return info;
  }
  return null;
}
