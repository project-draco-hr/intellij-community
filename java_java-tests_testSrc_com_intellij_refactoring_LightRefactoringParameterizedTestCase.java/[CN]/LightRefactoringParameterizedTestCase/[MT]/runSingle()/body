{
  final Throwable[] throwables=new Throwable[1];
  final Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        final String filePath=getRelativeBasePath() + getBeforeFile(myFileSuffix);
        configureByFile(filePath);
        final File testDir=new File(filePath).getParentFile();
        final String afterName=getAfterFile(myFileSuffix);
        final boolean conflictShouldBeFound=!new File(getTestDataPath() + "/" + testDir,afterName).exists();
        try {
          perform();
          if (conflictShouldBeFound) {
            fail("Conflict expected.");
          }
        }
 catch (        BaseRefactoringProcessor.ConflictsInTestsException exception) {
          if (!conflictShouldBeFound) {
            fail("Conflict not expected");
          }
 else {
            final File conflicts=new File(getTestDataPath() + "/" + testDir,FileUtilRt.getNameWithoutExtension(myFileSuffix) + CONFLICTS_SUFFIX);
            if (!conflicts.exists()) {
              fail("Conflict file " + conflicts.getPath() + " not found");
            }
            final VirtualFile conflictsFile=VfsUtil.findFileByIoFile(conflicts,false);
            assertNotNull(conflictsFile);
            assertEquals(LoadTextUtil.loadText(conflictsFile).toString(),exception.getMessage());
          }
        }
        if (!conflictShouldBeFound) {
          checkResultByFile(getRelativeBasePath() + getAfterFile(myFileSuffix));
        }
      }
 catch (      Throwable e) {
        throwables[0]=e;
      }
    }
  }
;
  invokeTestRunnable(new Runnable(){
    @Override public void run(){
      CommandProcessor.getInstance().executeCommand(getProject(),new Runnable(){
        @Override public void run(){
          runnable.run();
        }
      }
,"",null);
    }
  }
);
  if (throwables[0] != null) {
    throw throwables[0];
  }
}
