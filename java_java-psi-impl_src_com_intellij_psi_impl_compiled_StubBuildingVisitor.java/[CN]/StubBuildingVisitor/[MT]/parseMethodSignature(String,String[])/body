{
  MethodInfo result=new MethodInfo();
  CharacterIterator iterator=new StringCharacterIterator(signature);
  result.typeParameters=SignatureParsing.parseTypeParametersDeclaration(iterator,myMapping);
  if (iterator.current() != '(')   throw new ClsFormatException();
  iterator.next();
  if (iterator.current() == ')') {
    result.argTypes=ContainerUtil.emptyList();
  }
 else {
    result.argTypes=ContainerUtil.newSmartList();
    while (iterator.current() != ')' && iterator.current() != CharacterIterator.DONE) {
      result.argTypes.add(SignatureParsing.parseTypeString(iterator,myMapping));
    }
    if (iterator.current() != ')')     throw new ClsFormatException();
  }
  iterator.next();
  result.returnType=SignatureParsing.parseTypeString(iterator,myMapping);
  result.throwTypes=null;
  while (iterator.current() == '^') {
    iterator.next();
    if (result.throwTypes == null)     result.throwTypes=ContainerUtil.newSmartList();
    result.throwTypes.add(SignatureParsing.parseTypeString(iterator,myMapping));
  }
  if (exceptions != null && (result.throwTypes == null || exceptions.length > result.throwTypes.size())) {
    result.throwTypes=ContainerUtil.map(exceptions,new Function<String,String>(){
      @Override public String fun(      String name){
        return myMapping.fun(name);
      }
    }
);
  }
  return result;
}
