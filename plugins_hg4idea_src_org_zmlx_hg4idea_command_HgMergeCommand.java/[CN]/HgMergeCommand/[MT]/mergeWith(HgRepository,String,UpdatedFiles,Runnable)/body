{
  final Project project=repository.getProject();
  final VirtualFile repositoryRoot=repository.getRoot();
  final HgMergeCommand hgMergeCommand=new HgMergeCommand(project,repository);
  hgMergeCommand.setRevision(branchName);
  new Task.Backgroundable(project,"Merging changes..."){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      try {
        HgCommandResult result=hgMergeCommand.merge();
        if (HgErrorUtil.isAncestorMergeError(result)) {
          VcsNotifier.getInstance(project).notifyMinorWarning("Merging is skipped for " + repositoryRoot.getPresentableName(),"Merging with a working directory ancestor has no effect");
          return;
        }
        new HgConflictResolver(project,updatedFiles).resolve(repositoryRoot);
        if (HgConflictResolver.findConflicts(project,repositoryRoot).isEmpty() && onSuccessHandler != null) {
          onSuccessHandler.run();
        }
      }
 catch (      VcsException exception) {
        if (exception.isWarning()) {
          VcsNotifier.getInstance(project).notifyWarning("Warning during merge",exception.getMessage());
        }
 else {
          VcsNotifier.getInstance(project).notifyError("Exception during merge",exception.getMessage());
        }
      }
    }
  }
.queue();
}
