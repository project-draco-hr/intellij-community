{
  ApplicationManager.getApplication().assertIsDispatchThread();
  if (myProject.isDisposed()) {
    return;
  }
  EditorEx editor=myEditor;
  if (editor == null) {
    return;
  }
  if (clear) {
    final DocumentEx document;
synchronized (LOCK) {
      myTokens.clear();
      editor.getMarkupModel().removeAllHighlighters();
      document=editor.getDocument();
      myFoldingAlarm.cancelAllRequests();
      cancelHeavyAlarm();
    }
    final int documentTextLength=document.getTextLength();
    if (documentTextLength > 0) {
      CommandProcessor.getInstance().executeCommand(myProject,new Runnable(){
        @Override public void run(){
          document.setInBulkUpdate(true);
          try {
            myInDocumentUpdate=true;
            myDocumentClearing=true;
            document.deleteString(0,documentTextLength);
          }
  finally {
            document.setInBulkUpdate(false);
            myDocumentClearing=false;
            myInDocumentUpdate=false;
          }
        }
      }
,null,DocCommandGroupId.noneGroupId(document));
    }
  }
  final String addedText;
  final Collection<ConsoleViewContentType> contentTypes;
  int deferredTokensSize;
synchronized (LOCK) {
    if (myOutputPaused)     return;
    if (myBuffer.isEmpty())     return;
    addedText=myBuffer.getText();
    contentTypes=Collections.unmodifiableCollection(new HashSet<ConsoleViewContentType>(myBuffer.getDeferredTokenTypes()));
    List<TokenInfo> deferredTokens=myBuffer.getDeferredTokens();
    for (    TokenInfo deferredToken : deferredTokens) {
      addToken(deferredToken.getLength(),deferredToken.getHyperlinkInfo(),deferredToken.contentType);
    }
    deferredTokensSize=deferredTokens.size();
    myBuffer.clear(false);
    cancelHeavyAlarm();
  }
  final Document document=myEditor.getDocument();
  RangeMarker oldEndMarker=document.createRangeMarker(document.getTextLength(),document.getTextLength());
  final boolean isAtEndOfDocument=myEditor.getCaretModel().getOffset() == document.getTextLength();
  CommandProcessor.getInstance().executeCommand(myProject,new Runnable(){
    @Override public void run(){
      int offset=myEditor.getCaretModel().getOffset();
      boolean preserveCurrentVisualArea=offset < document.getTextLength();
      if (preserveCurrentVisualArea) {
        myEditor.getScrollingModel().accumulateViewportChanges();
      }
      try {
        myInDocumentUpdate=true;
        String[] strings=addedText.split("\\r");
        for (int i=0; i < strings.length - 1; i++) {
          document.insertString(document.getTextLength(),strings[i]);
          int lastLine=document.getLineCount() - 1;
          if (lastLine >= 0) {
            ConsoleUtil.updateTokensOnTextRemoval(myTokens,document.getTextLength(),document.getTextLength() + 1);
            document.deleteString(document.getLineStartOffset(lastLine),document.getTextLength());
          }
        }
        if (strings.length > 0) {
          document.insertString(document.getTextLength(),strings[strings.length - 1]);
          myContentSize-=strings.length - 1;
        }
      }
  finally {
        myInDocumentUpdate=false;
        if (preserveCurrentVisualArea) {
          myEditor.getScrollingModel().flushViewportChanges();
        }
      }
      if (!contentTypes.isEmpty()) {
        for (        ChangeListener each : myListeners) {
          each.contentAdded(contentTypes);
        }
      }
    }
  }
,null,DocCommandGroupId.noneGroupId(document));
synchronized (LOCK) {
    for (int i=myTokens.size() - 1; i >= 0 && deferredTokensSize > 0; i--, deferredTokensSize--) {
      TokenInfo token=myTokens.get(i);
      final HyperlinkInfo info=token.getHyperlinkInfo();
      if (info != null) {
        myHyperlinks.addHyperlink(token.startOffset,token.endOffset,null,info);
      }
    }
  }
  myPsiDisposedCheck.performCheck();
  myLastAddedTextLength=addedText.length();
  if (!myTooMuchOfOutput) {
    if (isTheAmountOfTextTooBig(myLastAddedTextLength)) {
      final int lastProcessedOffset=Math.max(0,myEditor.getDocument().getTextLength() - addedText.length() - 1);
      final RangeMarker lastProcessedOutput=document.createRangeMarker(lastProcessedOffset,lastProcessedOffset);
      myTooMuchOfOutput=true;
      final EditorNotificationPanel comp=new EditorNotificationPanel().text("Too much output to process").icon(AllIcons.General.ExclMark);
      add(comp,BorderLayout.NORTH);
      performWhenNoDeferredOutput(new Runnable(){
        @Override public void run(){
          if (!isTheAmountOfTextTooBig(myLastAddedTextLength)) {
            try {
              final int startLine=lastProcessedOutput.isValid() ? myEditor.getDocument().getLineNumber(lastProcessedOutput.getEndOffset()) : 0;
              highlightHyperlinksAndFoldings(startLine,myEditor.getDocument().getLineCount() - 1);
            }
  finally {
              myTooMuchOfOutput=false;
              remove(comp);
            }
          }
 else {
            myLastAddedTextLength=0;
            performLaterWhenNoDeferredOutput(this);
          }
        }
      }
);
    }
 else {
      final int newLastLine=document.getLineCount() - 1;
      if (!oldEndMarker.isValid()) {
        highlightHyperlinksAndFoldings(0,newLastLine);
      }
 else {
        int oldLastLine=document.getLineNumber(oldEndMarker.getEndOffset());
        if (oldLastLine < newLastLine) {
          highlightHyperlinksAndFoldings(oldLastLine + 1,newLastLine);
        }
      }
    }
  }
  if (isAtEndOfDocument) {
    EditorUtil.scrollToTheEnd(myEditor);
  }
}
