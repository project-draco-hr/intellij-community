{
  final Set<HgChange> hgChanges=new HashSet<HgChange>();
  for (  Map.Entry<VirtualFile,Collection<FilePath>> entry : HgUtil.groupFilePathsByHgRoots(myProject,files).entrySet()) {
    VirtualFile repo=entry.getKey();
    final HgRevisionNumber workingRevision=new HgWorkingCopyRevisionsCommand(myProject).identify(repo).getFirst();
    final HgRevisionNumber parentRevision=new HgWorkingCopyRevisionsCommand(myProject).firstParent(repo);
    final Map<HgFile,HgResolveStatusEnum> list=new HgResolveCommand(myProject).getListSynchronously(repo);
    hgChanges.addAll(new HgStatusCommand.Builder(true).build(myProject).executeInCurrentThread(repo,entry.getValue()));
    final HgRepository hgRepo=HgUtil.getRepositoryForFile(myProject,repo);
    if (hgRepo != null && hgRepo.hasSubrepos()) {
      hgChanges.addAll(ContainerUtil.mapNotNull(hgRepo.getSubrepos(),new Function<HgNameWithHashInfo,HgChange>(){
        @Override public HgChange fun(        HgNameWithHashInfo info){
          return findChange(hgRepo,info);
        }
      }
));
    }
    sendChanges(builder,hgChanges,list,workingRevision,parentRevision);
  }
  return hgChanges;
}
