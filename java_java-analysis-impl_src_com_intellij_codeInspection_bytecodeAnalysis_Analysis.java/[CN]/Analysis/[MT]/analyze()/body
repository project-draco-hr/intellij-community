{
  pending.push(new ProceedState<Res>(createStartState()));
  int steps=0;
  while (!pending.isEmpty() && earlyResult == null) {
    steps++;
    if (steps >= STEPS_LIMIT) {
      throw new AnalyzerException(null,"limit is reached, steps: " + steps + " in method "+ method);
    }
    PendingAction<Res> action=pending.pop();
    if (action instanceof MakeResult) {
      MakeResult<Res> makeResult=(MakeResult<Res>)action;
      ArrayList<Res> subResults=new ArrayList<Res>();
      for (      int index : makeResult.indices) {
        subResults.add(results.get(index));
      }
      Res result=combineResults(makeResult.subResult,subResults);
      if (isEarlyResult(result)) {
        earlyResult=result;
      }
 else {
        State state=makeResult.state;
        int insnIndex=state.conf.insnIndex;
        results.put(state.index,result);
        List<State> thisComputed=computed.get(insnIndex);
        if (thisComputed == null) {
          thisComputed=new ArrayList<State>();
          computed.put(insnIndex,thisComputed);
        }
        thisComputed.add(state);
      }
    }
 else     if (action instanceof ProceedState) {
      ProceedState<Res> proceedState=(ProceedState<Res>)action;
      State state=proceedState.state;
      int insnIndex=state.conf.insnIndex;
      Conf conf=state.conf;
      List<Conf> history=state.history;
      boolean fold=false;
      if (dfsTree.loopEnters[insnIndex]) {
        for (        Conf prev : history) {
          if (AbstractValues.isInstance(conf,prev)) {
            fold=true;
          }
        }
      }
      if (fold) {
        results.put(state.index,myIdentity);
        List<State> thisComputed=computed.get(insnIndex);
        if (thisComputed == null) {
          thisComputed=new ArrayList<State>();
          computed.put(insnIndex,thisComputed);
        }
        thisComputed.add(state);
      }
 else {
        State baseState=null;
        List<State> thisComputed=computed.get(insnIndex);
        if (thisComputed != null) {
          for (          State prevState : thisComputed) {
            if (stateEquiv(state,prevState)) {
              baseState=prevState;
              break;
            }
          }
        }
        if (baseState != null) {
          results.put(state.index,results.get(baseState.index));
        }
 else {
          processState(state);
        }
      }
    }
  }
  if (earlyResult != null) {
    return mkEquation(earlyResult);
  }
 else {
    return mkEquation(results.get(0));
  }
}
