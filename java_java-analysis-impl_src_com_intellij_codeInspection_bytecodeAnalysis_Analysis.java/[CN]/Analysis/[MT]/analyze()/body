{
  pendingPush(new ProceedState<Res>(createStartState()));
  int steps=0;
  while (pendingTop > 0 && earlyResult == null) {
    steps++;
    if (steps >= STEPS_LIMIT) {
      throw new AnalyzerException(null,"limit is reached, steps: " + steps + " in method "+ method);
    }
    PendingAction<Res> action=pending[--pendingTop];
    if (action instanceof MakeResult) {
      MakeResult<Res> makeResult=(MakeResult<Res>)action;
      Res result=combineResults(makeResult.subResult,makeResult.indices);
      if (isEarlyResult(result)) {
        earlyResult=result;
      }
 else {
        State state=makeResult.state;
        int insnIndex=state.conf.insnIndex;
        results[state.index]=result;
        addComputed(insnIndex,state);
      }
    }
 else     if (action instanceof ProceedState) {
      ProceedState<Res> proceedState=(ProceedState<Res>)action;
      State state=proceedState.state;
      int insnIndex=state.conf.insnIndex;
      Conf conf=state.conf;
      List<Conf> history=state.history;
      boolean fold=false;
      if (dfsTree.loopEnters[insnIndex]) {
        for (        Conf prev : history) {
          if (AbstractValues.isInstance(conf,prev)) {
            fold=true;
            break;
          }
        }
      }
      if (fold) {
        results[state.index]=myIdentity;
        addComputed(insnIndex,state);
      }
 else {
        State baseState=null;
        List<State> thisComputed=computed[insnIndex];
        if (thisComputed != null) {
          for (          State prevState : thisComputed) {
            if (stateEquiv(state,prevState)) {
              baseState=prevState;
              break;
            }
          }
        }
        if (baseState != null) {
          results[state.index]=results[baseState.index];
        }
 else {
          processState(state);
        }
      }
    }
  }
  if (earlyResult != null) {
    return mkEquation(earlyResult);
  }
 else {
    return mkEquation(results[0]);
  }
}
