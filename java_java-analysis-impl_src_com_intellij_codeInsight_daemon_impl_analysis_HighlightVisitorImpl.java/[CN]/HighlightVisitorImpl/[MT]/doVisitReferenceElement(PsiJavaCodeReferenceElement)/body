{
  JavaResolveResult result;
  try {
    result=resolveOptimised(ref);
  }
 catch (  IndexNotReadyException e) {
    return null;
  }
  PsiElement resolved=result.getElement();
  PsiElement parent=ref.getParent();
  if (myRefCountHolder != null) {
    myRefCountHolder.registerReference(ref,result);
  }
  myHolder.add(HighlightUtil.checkReference(ref,result,myFile,myLanguageLevel));
  if (parent instanceof PsiJavaCodeReferenceElement || ref.isQualified()) {
    if (!myHolder.hasErrorResults() && resolved instanceof PsiTypeParameter) {
      boolean cannotSelectFromTypeParameter=!myJavaSdkVersion.isAtLeast(JavaSdkVersion.JDK_1_7);
      if (!cannotSelectFromTypeParameter) {
        final PsiClass containingClass=PsiTreeUtil.getParentOfType(ref,PsiClass.class);
        if (containingClass != null) {
          if (PsiTreeUtil.isAncestor(containingClass.getExtendsList(),ref,false) || PsiTreeUtil.isAncestor(containingClass.getImplementsList(),ref,false)) {
            cannotSelectFromTypeParameter=true;
          }
        }
      }
      if (cannotSelectFromTypeParameter) {
        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).descriptionAndTooltip("Cannot select from a type parameter").range(ref).create());
      }
    }
  }
  if (!myHolder.hasErrorResults())   myHolder.add(HighlightClassUtil.checkAbstractInstantiation(ref));
  if (!myHolder.hasErrorResults())   myHolder.add(HighlightClassUtil.checkExtendsDuplicate(ref,resolved,myFile));
  if (!myHolder.hasErrorResults())   myHolder.add(HighlightClassUtil.checkClassExtendsForeignInnerClass(ref,resolved));
  if (!myHolder.hasErrorResults())   myHolder.add(GenericsHighlightUtil.checkSelectStaticClassFromParameterizedType(resolved,ref));
  if (!myHolder.hasErrorResults())   myHolder.add(GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(resolved,ref,result.getSubstitutor(),myJavaSdkVersion));
  if (!myHolder.hasErrorResults())   myHolder.add(GenericsHighlightUtil.checkCannotPassInner(ref));
  if (resolved != null && parent instanceof PsiReferenceList) {
    if (!myHolder.hasErrorResults()) {
      PsiReferenceList referenceList=(PsiReferenceList)parent;
      myHolder.add(HighlightUtil.checkElementInReferenceList(ref,referenceList,result,myLanguageLevel));
    }
  }
  if (parent instanceof PsiAnonymousClass && ref.equals(((PsiAnonymousClass)parent).getBaseClassReference())) {
    PsiClass aClass=(PsiClass)parent;
    myHolder.addAll(GenericsHighlightUtil.checkOverrideEquivalentMethods(aClass));
  }
  if (resolved instanceof PsiVariable) {
    PsiVariable variable=(PsiVariable)resolved;
    final PsiElement containingClass=PsiTreeUtil.getNonStrictParentOfType(ref,PsiClass.class,PsiLambdaExpression.class);
    if ((containingClass instanceof PsiAnonymousClass || containingClass instanceof PsiLambdaExpression) && !PsiTreeUtil.isAncestor(containingClass,variable,false) && !(variable instanceof PsiField)) {
      if (containingClass instanceof PsiLambdaExpression || !PsiTreeUtil.isAncestor(((PsiAnonymousClass)containingClass).getArgumentList(),ref,false)) {
        myHolder.add(HighlightInfo.newHighlightInfo(JavaHighlightInfoTypes.IMPLICIT_ANONYMOUS_CLASS_PARAMETER).range(ref).create());
      }
    }
    if (variable instanceof PsiParameter && ref instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)ref)) {
      myReassignedParameters.put((PsiParameter)variable,2);
    }
    final TextAttributesScheme colorsScheme=myHolder.getColorsScheme();
    if (!variable.hasModifierProperty(PsiModifier.FINAL) && isReassigned(variable)) {
      myHolder.add(HighlightNamesUtil.highlightReassignedVariable(variable,ref));
    }
 else {
      myHolder.add(HighlightNamesUtil.highlightVariableName(variable,ref.getReferenceNameElement(),colorsScheme));
    }
    myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(ref,colorsScheme));
  }
 else {
    highlightReferencedMethodOrClassName(ref,resolved);
  }
  if (parent instanceof PsiNewExpression && !(resolved instanceof PsiClass) && resolved instanceof PsiNamedElement&& ((PsiNewExpression)parent).getClassOrAnonymousClassReference() == ref) {
    myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(ref).descriptionAndTooltip("Cannot find symbol " + ((PsiNamedElement)resolved).getName()).create());
  }
  if (!myHolder.hasErrorResults() && resolved instanceof PsiClass) {
    final PsiClass aClass=((PsiClass)resolved).getContainingClass();
    if (aClass != null) {
      final PsiElement qualifier=ref.getQualifier();
      final PsiElement place;
      if (qualifier instanceof PsiJavaCodeReferenceElement) {
        place=((PsiJavaCodeReferenceElement)qualifier).resolve();
      }
 else {
        if (parent instanceof PsiNewExpression) {
          final PsiExpression newQualifier=((PsiNewExpression)parent).getQualifier();
          place=newQualifier == null ? ref : PsiUtil.resolveClassInType(newQualifier.getType());
        }
 else {
          place=ref;
        }
      }
      if (place != null && PsiTreeUtil.isAncestor(aClass,place,false) && aClass.hasTypeParameters()) {
        myHolder.add(HighlightClassUtil.checkCreateInnerClassFromStaticContext(ref,place,(PsiClass)resolved));
      }
    }
 else     if (resolved instanceof PsiTypeParameter) {
      final PsiTypeParameterListOwner owner=((PsiTypeParameter)resolved).getOwner();
      if (owner instanceof PsiClass) {
        final PsiClass outerClass=(PsiClass)owner;
        if (!InheritanceUtil.hasEnclosingInstanceInScope(outerClass,ref,false,false)) {
          myHolder.add(HighlightClassUtil.reportIllegalEnclosingUsage(ref,null,(PsiClass)owner,ref));
        }
      }
    }
  }
  if (!myHolder.hasErrorResults())   myHolder.add(HighlightUtil.checkPackageAndClassConflict(ref,myFile));
  return result;
}
