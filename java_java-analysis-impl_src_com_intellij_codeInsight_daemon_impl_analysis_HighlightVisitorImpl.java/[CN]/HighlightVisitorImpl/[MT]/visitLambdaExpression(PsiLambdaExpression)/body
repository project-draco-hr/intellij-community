{
  myHolder.add(checkFeature(expression,Feature.LAMBDA_EXPRESSIONS));
  if (!myHolder.hasErrorResults()) {
    if (LambdaUtil.isValidLambdaContext(expression.getParent())) {
      final PsiType functionalInterfaceType=expression.getFunctionalInterfaceType();
      if (functionalInterfaceType != null) {
        final String notFunctionalMessage=LambdaHighlightingUtil.checkInterfaceFunctional(functionalInterfaceType);
        if (notFunctionalMessage != null) {
          HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(notFunctionalMessage).create();
          myHolder.add(result);
        }
 else {
          if (!LambdaUtil.isLambdaFullyInferred(expression,functionalInterfaceType) && !expression.hasFormalParameterTypes()) {
            HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Cyclic inference").create();
            myHolder.add(result);
          }
 else {
            final String incompatibleReturnTypesMessage=LambdaUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
            if (incompatibleReturnTypesMessage != null) {
              final List<PsiExpression> returnExpressions=LambdaUtil.getReturnExpressions(expression);
              final PsiElement returnStatementToHighlight=returnExpressions.size() == 1 ? returnExpressions.get(0) : expression.getBody();
              HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(returnStatementToHighlight != null ? returnStatementToHighlight : expression).descriptionAndTooltip(incompatibleReturnTypesMessage).create();
              myHolder.add(result);
            }
 else {
              final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
              final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
              if (interfaceMethod != null) {
                final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
                PsiElement incompatibleElt=LambdaHighlightingUtil.checkParametersCompatible(expression,parameters,LambdaUtil.getSubstitutor(interfaceMethod,resolveResult));
                if (incompatibleElt != null) {
                  final String incompatibleTypesMessage="Incompatible parameter types in lambda expression";
                  HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(incompatibleElt).descriptionAndTooltip(incompatibleTypesMessage).create();
                  myHolder.add(result);
                }
 else {
                  final PsiClass samClass=resolveResult.getElement();
                  if (!PsiUtil.isAccessible(myFile.getProject(),samClass,expression,null)) {
                    myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(HighlightUtil.buildProblemWithAccessDescription(expression,resolveResult)).create());
                  }
                }
              }
            }
          }
        }
      }
 else       if (LambdaUtil.getFunctionalInterfaceType(expression,true) != null) {
        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Cannot infer functional interface type").create());
      }
    }
 else {
      HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Lambda expression not expected here").create();
      myHolder.add(result);
    }
    if (!myHolder.hasErrorResults()) {
      final PsiElement body=expression.getBody();
      if (body instanceof PsiCodeBlock) {
        myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement((PsiCodeBlock)body));
      }
    }
  }
}
