{
  myHolder.add(checkFeature(expression,Feature.LAMBDA_EXPRESSIONS));
  final PsiElement parent=PsiUtil.skipParenthesizedExprUp(expression.getParent());
  if (parent instanceof PsiExpressionStatement)   return;
  if (!myHolder.hasErrorResults() && !LambdaUtil.isValidLambdaContext(parent)) {
    myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Lambda expression not expected here").create());
  }
  PsiType functionalInterfaceType=null;
  if (!myHolder.hasErrorResults()) {
    functionalInterfaceType=expression.getFunctionalInterfaceType();
    if (functionalInterfaceType != null) {
      final String notFunctionalMessage=LambdaHighlightingUtil.checkInterfaceFunctional(functionalInterfaceType);
      if (notFunctionalMessage != null) {
        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(notFunctionalMessage).create());
      }
 else {
        checkFunctionalInterfaceTypeAccessible(expression,functionalInterfaceType);
      }
    }
 else     if (LambdaUtil.getFunctionalInterfaceType(expression,true) != null) {
      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Cannot infer functional interface type").create());
    }
  }
  if (!myHolder.hasErrorResults() && functionalInterfaceType != null) {
    String parentInferenceErrorMessage=null;
    final PsiCallExpression callExpression=parent instanceof PsiExpressionList && parent.getParent() instanceof PsiCallExpression ? (PsiCallExpression)parent.getParent() : null;
    final JavaResolveResult containingCallResolveResult=callExpression != null ? callExpression.resolveMethodGenerics() : null;
    if (containingCallResolveResult instanceof MethodCandidateInfo) {
      parentInferenceErrorMessage=((MethodCandidateInfo)containingCallResolveResult).getParentInferenceErrorMessage((PsiExpressionList)parent);
    }
    final Map<PsiElement,String> returnErrors=LambdaUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
    if (parentInferenceErrorMessage != null && (returnErrors == null || !returnErrors.containsValue(parentInferenceErrorMessage))) {
      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(parentInferenceErrorMessage).create());
    }
 else     if (returnErrors != null) {
      for (      Map.Entry<PsiElement,String> entry : returnErrors.entrySet()) {
        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(entry.getKey()).descriptionAndTooltip(entry.getValue()).create());
      }
    }
  }
  if (!myHolder.hasErrorResults() && functionalInterfaceType != null) {
    final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
    final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
    if (interfaceMethod != null) {
      final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
      myHolder.add(LambdaHighlightingUtil.checkParametersCompatible(expression,parameters,LambdaUtil.getSubstitutor(interfaceMethod,resolveResult)));
    }
  }
  if (!myHolder.hasErrorResults()) {
    final PsiElement body=expression.getBody();
    if (body instanceof PsiCodeBlock) {
      myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement((PsiCodeBlock)body));
    }
  }
}
