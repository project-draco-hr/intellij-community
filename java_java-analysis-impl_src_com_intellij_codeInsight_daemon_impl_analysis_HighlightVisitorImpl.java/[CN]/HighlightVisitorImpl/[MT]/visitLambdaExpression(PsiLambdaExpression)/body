{
  myHolder.add(checkFeature(expression,Feature.LAMBDA_EXPRESSIONS));
  final PsiElement parent=PsiUtil.skipParenthesizedExprUp(expression.getParent());
  if (parent instanceof PsiExpressionStatement)   return;
  if (!myHolder.hasErrorResults()) {
    if (LambdaUtil.isValidLambdaContext(parent)) {
      final PsiType functionalInterfaceType=expression.getFunctionalInterfaceType();
      if (functionalInterfaceType != null) {
        final String notFunctionalMessage=LambdaHighlightingUtil.checkInterfaceFunctional(functionalInterfaceType);
        if (notFunctionalMessage != null) {
          HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(notFunctionalMessage).create();
          myHolder.add(result);
        }
 else {
          final PsiCallExpression callExpression=parent instanceof PsiExpressionList && parent.getParent() instanceof PsiCallExpression ? (PsiCallExpression)parent.getParent() : null;
          final JavaResolveResult containingCallResolveResult=callExpression != null ? callExpression.resolveMethodGenerics() : null;
          final String errorMessage;
          if (containingCallResolveResult instanceof MethodCandidateInfo) {
            errorMessage=((MethodCandidateInfo)containingCallResolveResult).getParentInferenceErrorMessage((PsiExpressionList)parent);
          }
 else {
            errorMessage=null;
          }
          if (errorMessage != null) {
            HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(errorMessage).create();
            myHolder.add(result);
          }
 else {
            final Map<PsiElement,String> returnErrors=LambdaUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
            if (returnErrors != null) {
              for (              Map.Entry<PsiElement,String> entry : returnErrors.entrySet()) {
                myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(entry.getKey()).descriptionAndTooltip(entry.getValue()).create());
              }
            }
 else {
              final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
              final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
              if (interfaceMethod != null) {
                final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
                HighlightInfo result=LambdaHighlightingUtil.checkParametersCompatible(expression,parameters,LambdaUtil.getSubstitutor(interfaceMethod,resolveResult));
                if (result != null) {
                  myHolder.add(result);
                }
 else {
                  checkFunctionalInterfaceTypeAccessible(expression,functionalInterfaceType);
                }
              }
            }
          }
        }
      }
 else       if (LambdaUtil.getFunctionalInterfaceType(expression,true) != null) {
        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Cannot infer functional interface type").create());
      }
    }
 else {
      HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Lambda expression not expected here").create();
      myHolder.add(result);
    }
    if (!myHolder.hasErrorResults()) {
      final PsiElement body=expression.getBody();
      if (body instanceof PsiCodeBlock) {
        myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement((PsiCodeBlock)body));
      }
    }
  }
}
