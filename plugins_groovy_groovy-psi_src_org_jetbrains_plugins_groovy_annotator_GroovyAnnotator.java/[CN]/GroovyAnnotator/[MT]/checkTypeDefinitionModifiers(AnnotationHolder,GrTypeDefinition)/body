{
  GrModifierList modifiersList=typeDefinition.getModifierList();
  if (modifiersList == null)   return;
  checkAccessModifiers(holder,modifiersList,typeDefinition);
  checkDuplicateModifiers(holder,modifiersList,typeDefinition);
  PsiClassType[] extendsListTypes=typeDefinition.getExtendsListTypes();
  for (  PsiClassType classType : extendsListTypes) {
    PsiClass psiClass=classType.resolve();
    if (psiClass != null && psiClass.hasModifierProperty(PsiModifier.FINAL)) {
      final Annotation annotation=holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(),GroovyBundle.message("final.class.cannot.be.extended"));
      registerFix(annotation,new GrModifierFix(typeDefinition,PsiModifier.FINAL,false,false,GrModifierFix.MODIFIER_LIST_OWNER),typeDefinition);
    }
  }
  if (!typeDefinition.isEnum()) {
    checkForAbstractAndFinalCombination(holder,typeDefinition,modifiersList);
  }
  checkModifierIsNotAllowed(modifiersList,PsiModifier.TRANSIENT,GroovyBundle.message("modifier.transient.not.allowed.here"),holder);
  checkModifierIsNotAllowed(modifiersList,PsiModifier.VOLATILE,GroovyBundle.message("modifier.volatile.not.allowed.here"),holder);
  if (typeDefinition.isInterface()) {
    checkModifierIsNotAllowed(modifiersList,PsiModifier.FINAL,GroovyBundle.message("intarface.cannot.have.modifier.final"),holder);
  }
  if (GroovyConfigUtils.getInstance().isVersionAtLeast(typeDefinition,GroovyConfigUtils.GROOVY1_8)) {
    if (typeDefinition.getContainingClass() == null && !(typeDefinition instanceof GrTraitTypeDefinition)) {
      checkModifierIsNotAllowed(modifiersList,PsiModifier.STATIC,holder);
    }
  }
}
