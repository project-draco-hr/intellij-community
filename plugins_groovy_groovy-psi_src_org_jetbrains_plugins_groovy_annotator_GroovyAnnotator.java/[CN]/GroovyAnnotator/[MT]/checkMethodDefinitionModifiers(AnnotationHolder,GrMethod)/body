{
  final GrModifierList modifiersList=method.getModifierList();
  checkAccessModifiers(holder,modifiersList,method);
  checkDuplicateModifiers(holder,modifiersList,method);
  checkOverrideAnnotation(holder,modifiersList,method);
  checkModifierIsNotAllowed(modifiersList,PsiModifier.VOLATILE,GroovyBundle.message("method.has.incorrect.modifier.volatile"),holder);
  checkForAbstractAndFinalCombination(holder,method,modifiersList);
  boolean isMethodAbstract=modifiersList.hasExplicitModifier(PsiModifier.ABSTRACT);
  if (method.getParent() instanceof GroovyFileBase) {
    if (isMethodAbstract) {
      final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,PsiModifier.ABSTRACT),GroovyBundle.message("script.method.cannot.have.modifier.abstract"));
      registerMakeAbstractMethodNotAbstractFix(annotation,method,false);
    }
    checkModifierIsNotAllowed(modifiersList,PsiModifier.NATIVE,GroovyBundle.message("script.cannot.have.modifier.native"),holder);
  }
 else   if (method.getParent() != null && method.getParent().getParent() instanceof GrTypeDefinition) {
    GrTypeDefinition containingTypeDef=((GrTypeDefinition)method.getParent().getParent());
    if (containingTypeDef.isTrait()) {
      checkModifierIsNotAllowed(modifiersList,PsiModifier.PROTECTED,GroovyBundle.message("trait.method.cannot.be.protected"),holder);
    }
 else     if (containingTypeDef.isInterface()) {
      checkModifierIsNotAllowed(modifiersList,PsiModifier.STATIC,GroovyBundle.message("interface.must.have.no.static.method"),holder);
      checkModifierIsNotAllowed(modifiersList,PsiModifier.PRIVATE,GroovyBundle.message("interface.members.are.not.allowed.to.be",PsiModifier.PRIVATE),holder);
      checkModifierIsNotAllowed(modifiersList,PsiModifier.PROTECTED,GroovyBundle.message("interface.members.are.not.allowed.to.be",PsiModifier.PROTECTED),holder);
    }
 else     if (containingTypeDef.isAnonymous()) {
      if (isMethodAbstract) {
        final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,PsiModifier.ABSTRACT),GroovyBundle.message("anonymous.class.cannot.have.abstract.method"));
        registerMakeAbstractMethodNotAbstractFix(annotation,method,false);
      }
    }
 else {
      PsiModifierList typeDefModifiersList=containingTypeDef.getModifierList();
      LOG.assertTrue(typeDefModifiersList != null,"modifiers list must be not null");
      if (!typeDefModifiersList.hasModifierProperty(PsiModifier.ABSTRACT) && isMethodAbstract) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("only.abstract.class.can.have.abstract.method"));
        registerMakeAbstractMethodNotAbstractFix(annotation,method,true);
      }
    }
    if (method.isConstructor()) {
      checkModifierIsNotAllowed(modifiersList,PsiModifier.STATIC,GroovyBundle.message("constructor.cannot.have.static.modifier"),holder);
    }
  }
  if (method.hasModifierProperty(PsiModifier.NATIVE) && method.getBlock() != null) {
    final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,PsiModifier.NATIVE),GroovyBundle.message("native.methods.cannot.have.body"));
    registerFix(annotation,new GrModifierFix((PsiMember)modifiersList.getParent(),PsiModifier.NATIVE,true,false,GrModifierFix.MODIFIER_LIST),modifiersList);
    annotation.registerFix(QuickFixFactory.getInstance().createDeleteMethodBodyFix(method));
  }
}
