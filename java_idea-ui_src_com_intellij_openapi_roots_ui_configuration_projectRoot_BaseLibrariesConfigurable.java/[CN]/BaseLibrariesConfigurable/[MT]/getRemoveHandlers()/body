{
  return Collections.singletonList(new RemoveConfigurableHandler<Library>(LibraryConfigurable.class){
    @Override public boolean remove(    @NotNull Collection<Library> libraries){
      List<Pair<LibraryProjectStructureElement,Collection<ProjectStructureElementUsage>>> toRemove=new ArrayList<>();
      String firstLibraryUsageDescription=null;
      String firstLibraryWithUsageName=null;
      int librariesWithUsages=0;
      for (      Library library : libraries) {
        final LibraryTable table=library.getTable();
        if (table == null)         continue;
        final LibraryProjectStructureElement libraryElement=new LibraryProjectStructureElement(myContext,library);
        final Collection<ProjectStructureElementUsage> usages=new ArrayList<>(myContext.getDaemonAnalyzer().getUsages(libraryElement));
        if (usages.size() > 0) {
          if (librariesWithUsages == 0) {
            final MultiMap<String,ProjectStructureElementUsage> containerType2Usage=new MultiMap<>();
            for (            final ProjectStructureElementUsage usage : usages) {
              containerType2Usage.putValue(usage.getContainingElement().getTypeName(),usage);
            }
            List<String> types=new ArrayList<>(containerType2Usage.keySet());
            Collections.sort(types);
            final StringBuilder sb=new StringBuilder("Library '");
            Library libraryModel=myContext.getLibraryModel(library);
            sb.append(libraryModel != null ? libraryModel.getName() : library.getName()).append("' is used in ");
            for (int i=0; i < types.size(); i++) {
              if (i > 0 && i == types.size() - 1) {
                sb.append(" and in ");
              }
 else               if (i > 0) {
                sb.append(", in ");
              }
              String type=types.get(i);
              Collection<ProjectStructureElementUsage> usagesOfType=containerType2Usage.get(type);
              if (usagesOfType.size() > 1) {
                sb.append(usagesOfType.size()).append(" ").append(StringUtil.decapitalize(StringUtil.pluralize(type)));
              }
 else {
                sb.append(StringUtil.decapitalize(usagesOfType.iterator().next().getContainingElement().getPresentableText()));
              }
            }
            firstLibraryWithUsageName=library.getName();
            firstLibraryUsageDescription=sb.toString();
          }
          librariesWithUsages++;
        }
        toRemove.add(Pair.create(libraryElement,usages));
      }
      if (librariesWithUsages > 0) {
        String message;
        if (librariesWithUsages == 1) {
          message=firstLibraryUsageDescription + ".\nAre you sure you want to delete this library?";
        }
 else {
          message=ProjectBundle.message("libraries.remove.confirmation.text",firstLibraryWithUsageName,librariesWithUsages - 1);
        }
        if (Messages.OK != Messages.showOkCancelDialog(myProject,message,ProjectBundle.message("libraries.remove.confirmation.title",librariesWithUsages),Messages.getQuestionIcon())) {
          return false;
        }
      }
      for (      Pair<LibraryProjectStructureElement,Collection<ProjectStructureElementUsage>> pair : toRemove) {
        for (        ProjectStructureElementUsage usage : pair.getSecond()) {
          usage.removeSourceElement();
        }
        getModelProvider().getModifiableModel().removeLibrary(pair.getFirst().getLibrary());
        myContext.getDaemonAnalyzer().removeElement(pair.getFirst());
      }
      return true;
    }
    @Override public boolean canBeRemoved(    @NotNull Collection<Library> libraries){
      for (      Library library : libraries) {
        LibraryTable table=library.getTable();
        if (table != null && !table.isEditable()) {
          return false;
        }
      }
      return true;
    }
  }
);
}
