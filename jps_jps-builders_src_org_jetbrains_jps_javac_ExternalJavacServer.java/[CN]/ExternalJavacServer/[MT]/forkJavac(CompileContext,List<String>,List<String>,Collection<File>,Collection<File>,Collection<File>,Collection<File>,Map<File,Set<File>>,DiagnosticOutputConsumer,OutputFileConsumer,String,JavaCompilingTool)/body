{
  final ExternalJavacMessageHandler rh=new ExternalJavacMessageHandler(diagnosticSink,outputSink,getEncodingName(options));
  final JavacRemoteProto.Message.Request request=JavacProtoUtil.createCompilationRequest(options,files,classpath,platformCp,sourcePath,outs);
  final UUID uuid=UUID.randomUUID();
  final JavacProcessDescriptor processDescriptor=new JavacProcessDescriptor(uuid,rh,request);
synchronized (myMessageHandlers) {
    myMessageHandlers.put(uuid,processDescriptor);
  }
  try {
    final JavacServerBootstrap.ExternalJavacProcessHandler processHandler=JavacServerBootstrap.launchExternalJavacProcess(uuid,javaHome,getExternalJavacHeapSize(context),myListenPort,Utils.getSystemRoot(),vmOptions,compilingTool);
    while (!processDescriptor.waitFor(300L)) {
      if (processHandler.isProcessTerminated() && processDescriptor.channel == null && processHandler.getExitCode() != 0) {
        processDescriptor.setDone();
        break;
      }
      if (context.getCancelStatus().isCanceled()) {
        processDescriptor.cancelBuild();
      }
    }
    return rh.isTerminatedSuccessfully();
  }
 catch (  Throwable e) {
    LOG.info(e);
    diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR,e.getMessage()));
  }
 finally {
    unregisterMessageHandler(uuid);
  }
  return false;
}
