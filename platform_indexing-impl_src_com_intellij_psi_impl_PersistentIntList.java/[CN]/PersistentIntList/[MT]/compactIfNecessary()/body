{
  if (gap < data.length() / 2)   return;
  index.withStorageLock(new Runnable(){
    @Override public void run(){
      persistsVarsTo(data,true);
      index.doFlush();
      data.sync();
      try {
        final RandomAccessDataFile newData=new RandomAccessDataFile(new File(data.getFile().getParentFile(),"newData"));
        persistsVarsTo(newData,true);
        final TIntIntHashMap map=new TIntIntHashMap();
        index.processMappings(new IntToIntBtree.KeyValueProcessor(){
          @Override public boolean process(          int key,          int value) throws IOException {
            map.put(key,value);
            return true;
          }
        }
);
        map.forEachEntry(new TIntIntProcedure(){
          @Override public boolean execute(          int key,          int value){
            int[] ids=get(key);
            int pointer=(int)newData.length();
            byte[] bytes=toBytes(ids);
            storeArray(newData,pointer,ids.length,(int)(ids.length * 1.3),bytes);
            index.put(key,pointer);
            return true;
          }
        }
);
        data.dispose();
        data=newData;
        gap=0;
        flush();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
}
