{
  TIntHashSet visited=new TIntHashSet();
  final Queue<BackLink> toVisit=new Queue<BackLink>(1000000);
  for (  Object startRoot : startRoots) {
    toVisit.addLast(new BackLink(startRoot,null,null));
  }
  while (true) {
    if (toVisit.isEmpty())     return;
    final BackLink backLink=toVisit.pullFirst();
    Object root=backLink.value;
    if (!visited.add(System.identityHashCode(root)))     continue;
    DebugReflectionUtil.processStronglyReferencedValues(root,new PairProcessor<Object,Field>(){
      @Override public boolean process(      Object value,      Field field){
        Class<?> valueClass=value.getClass();
        if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) {
          leakProcessor.process(new BackLink(value,field,backLink));
        }
 else {
          toVisit.addLast(new BackLink(value,field,backLink));
        }
        return true;
      }
    }
);
  }
}
