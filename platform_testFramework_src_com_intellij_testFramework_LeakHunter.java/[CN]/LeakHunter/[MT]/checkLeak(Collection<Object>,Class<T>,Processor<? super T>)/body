{
  if (SwingUtilities.isEventDispatchThread()) {
    UIUtil.dispatchAllInvocationEvents();
  }
 else {
    UIUtil.pump();
  }
  PersistentEnumeratorBase.clearCacheForTests();
  walkObjects(suspectClass,roots,new Processor<BackLink>(){
    @SuppressWarnings("UseOfSystemOutOrSystemErr") @Override public boolean process(    BackLink backLink){
      T leaked=(T)backLink.value;
      if (markLeaked(leaked) && (isReallyLeak == null || isReallyLeak.process(leaked))) {
        String place=leaked instanceof Project ? PlatformTestCase.getCreationPlace((Project)leaked) : "";
        System.out.println("Leaked object found:" + leaked + "; hash: "+ System.identityHashCode(leaked)+ "; place: "+ place);
        while (backLink != null) {
          String valueStr;
          try {
            valueStr=backLink.value instanceof FList ? "FList" : backLink.value instanceof Collection ? "Collection" : String.valueOf(backLink.value);
          }
 catch (          Throwable e) {
            valueStr="(" + e.getMessage() + " while computing .toString())";
          }
          System.out.println("-->" + backLink.field + "; Value: "+ valueStr+ "; "+ backLink.value.getClass());
          backLink=backLink.backLink;
        }
        System.out.println(";-----");
        throw new AssertionError();
      }
      return true;
    }
    private boolean markLeaked(    T leaked){
      return !(leaked instanceof UserDataHolderEx) || ((UserDataHolderEx)leaked).replace(REPORTED_LEAKED,null,Boolean.TRUE);
    }
  }
);
}
