{
  DebuggerManagerThreadImpl.assertIsManagerThread();
  if (modifiedClasses == null || modifiedClasses.size() == 0) {
    myProgress.addMessage(myDebuggerSession,MessageCategory.INFORMATION,DebuggerBundle.message("status.hotswap.loaded.classes.up.to.date"));
    return;
  }
  final DebugProcessImpl debugProcess=getDebugProcess();
  final VirtualMachineProxyImpl virtualMachineProxy=debugProcess.getVirtualMachineProxy();
  if (virtualMachineProxy == null) {
    return;
  }
  final Project project=debugProcess.getProject();
  final BreakpointManager breakpointManager=(DebuggerManagerEx.getInstanceEx(project)).getBreakpointManager();
  breakpointManager.disableBreakpoints(debugProcess);
  try {
    RedefineProcessor redefineProcessor=new RedefineProcessor(virtualMachineProxy);
    int processedEntriesCount=0;
    for (    final Map.Entry<String,HotSwapFile> entry : modifiedClasses.entrySet()) {
      if (debugProcess.isDetached() || debugProcess.isDetaching()) {
        break;
      }
      if (redefineProcessor.getProcessedClassesCount() == 0 && myProgress.isCancelled()) {
        break;
      }
      processedEntriesCount++;
      final String qualifiedName=entry.getKey();
      if (qualifiedName != null) {
        myProgress.setText(qualifiedName);
        myProgress.setFraction(processedEntriesCount / (double)modifiedClasses.size());
      }
      try {
        redefineProcessor.processClass(qualifiedName,entry.getValue().file);
      }
 catch (      IOException e) {
        reportProblem(qualifiedName,e);
      }
    }
    if (redefineProcessor.getProcessedClassesCount() == 0 && myProgress.isCancelled()) {
      return;
    }
    redefineProcessor.processPending();
    myProgress.setFraction(1);
    final int partiallyRedefinedClassesCount=redefineProcessor.getPartiallyRedefinedClassesCount();
    if (partiallyRedefinedClassesCount == 0) {
      myProgress.addMessage(myDebuggerSession,MessageCategory.INFORMATION,DebuggerBundle.message("status.classes.reloaded",redefineProcessor.getProcessedClassesCount()));
    }
 else {
      final String message=DebuggerBundle.message("status.classes.not.all.versions.reloaded",partiallyRedefinedClassesCount,redefineProcessor.getProcessedClassesCount());
      myProgress.addMessage(myDebuggerSession,MessageCategory.WARNING,message);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("classes reloaded");
    }
  }
 catch (  Throwable e) {
    processException(e);
  }
  DebuggerContextImpl context=myDebuggerSession.getContextManager().getContext();
  SuspendContextImpl suspendContext=context.getSuspendContext();
  if (suspendContext != null) {
    XExecutionStack stack=suspendContext.getActiveExecutionStack();
    if (stack instanceof JavaExecutionStack) {
      ((JavaExecutionStack)stack).initTopFrame();
    }
  }
  final Semaphore waitSemaphore=new Semaphore();
  waitSemaphore.down();
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      try {
        if (!project.isDisposed()) {
          final BreakpointManager breakpointManager=(DebuggerManagerEx.getInstanceEx(project)).getBreakpointManager();
          breakpointManager.reloadBreakpoints();
          debugProcess.getRequestsManager().clearWarnings();
          if (LOG.isDebugEnabled()) {
            LOG.debug("requests updated");
            LOG.debug("time stamp set");
          }
          myDebuggerSession.refresh(false);
          XDebugSession session=myDebuggerSession.getXDebugSession();
          if (session != null) {
            session.rebuildViews();
          }
        }
      }
 catch (      Throwable e) {
        LOG.error(e);
      }
 finally {
        waitSemaphore.up();
      }
    }
  }
);
  waitSemaphore.waitFor();
  if (!project.isDisposed()) {
    try {
      breakpointManager.enableBreakpoints(debugProcess);
    }
 catch (    Exception e) {
      processException(e);
    }
  }
}
