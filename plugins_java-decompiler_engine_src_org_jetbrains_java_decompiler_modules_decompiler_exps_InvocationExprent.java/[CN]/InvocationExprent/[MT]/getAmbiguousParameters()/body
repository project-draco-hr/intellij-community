{
  StructClass cl=DecompilerContext.getStructContext().getClass(classname);
  if (cl == null)   return EMPTY_BIT_SET;
  List<MethodDescriptor> matches=new ArrayList<>();
  nextMethod:   for (  StructMethod mt : cl.getMethods()) {
    if (name.equals(mt.getName())) {
      MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
      if (md.params.length == descriptor.params.length) {
        for (int i=0; i < md.params.length; i++) {
          if (md.params[i].typeFamily != descriptor.params[i].typeFamily) {
            continue nextMethod;
          }
        }
        matches.add(md);
      }
    }
  }
  if (matches.size() == 1)   return EMPTY_BIT_SET;
  StructMethod mt=cl.getMethod(InterpreterUtil.makeUniqueKey(name,stringDescriptor));
  if (mt != null) {
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    if (md.params.length == lstParameters.size()) {
      boolean exact=true;
      for (int i=0; i < md.params.length; i++) {
        if (!md.params[i].equals(lstParameters.get(i).getExprType())) {
          exact=false;
          break;
        }
      }
      if (exact)       return EMPTY_BIT_SET;
    }
  }
  BitSet ambiguous=new BitSet(descriptor.params.length);
  for (int i=0; i < descriptor.params.length; i++) {
    VarType paramType=descriptor.params[i];
    for (    MethodDescriptor md : matches) {
      if (!paramType.equals(md.params[i])) {
        ambiguous.set(i);
        break;
      }
    }
  }
  return ambiguous;
}
