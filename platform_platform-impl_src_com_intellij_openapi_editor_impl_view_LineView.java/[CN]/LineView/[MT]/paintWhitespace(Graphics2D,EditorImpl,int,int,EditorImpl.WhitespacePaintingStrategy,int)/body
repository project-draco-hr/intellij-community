{
  g.setColor(editor.getColorsScheme().getColor(EditorColors.WHITESPACES_COLOR));
  CharSequence text=editor.getDocument().getImmutableCharSequence();
  for (int i=startOffset; i < endOffset; i++) {
    char c=text.charAt(i);
    if (" \t\u3000".indexOf(c) >= 0 && whitespacePaintingStrategy.showWhitespaceAtOffset(i)) {
      Point start=new Point();
      myLayout.hitToPoint(TextHitInfo.leading(i - startOffset),start);
      Point end=new Point();
      myLayout.hitToPoint(TextHitInfo.trailing(i - startOffset),end);
      int y=editor.getAscent();
      if (c == ' ') {
        g.fillRect((start.x + end.x) / 2,y,1,1);
      }
 else       if (c == '\t') {
        int startX=Math.min(start.x,end.x);
        int stopX=Math.max(start.x,end.x);
        stopX-=plainSpaceWidth / 4;
        int height=editor.getCharHeight();
        int halfHeight=height / 2;
        int mid=y - halfHeight;
        int top=y - height;
        UIUtil.drawLine(g,startX,mid,stopX,mid);
        UIUtil.drawLine(g,stopX,y,stopX,top);
        g.fillPolygon(new int[]{stopX - halfHeight,stopX - halfHeight,stopX},new int[]{y,y - height,y - halfHeight},3);
      }
 else       if (c == '\u3000') {
        final int charHeight=editor.getCharHeight();
        g.drawRect(Math.min(start.x,end.x) + 2,y - charHeight,Math.abs(start.x - end.x) - 4,charHeight);
      }
    }
  }
}
