{
  LinkedHashSet<String> files=null;
  final File toDir=toBaseDir(rootDir);
  boolean checkWarnings=true;
  while (checkWarnings) {
    files=Utils.collectRelativePaths(toDir,true);
    checkWarnings=false;
    for (    String file : files) {
      String warning=myWarnings.get(file);
      if (warning != null) {
        if (!ui.showWarning(warning)) {
          throw new OperationCancelledException();
        }
        checkWarnings=true;
        break;
      }
    }
  }
  final List<ValidationResult> result=new ArrayList<>();
  if (myIsStrict) {
    for (    PatchAction action : myActions) {
      files.remove(action.getPath());
    }
    for (    String file : files) {
      myActions.add(0,new DeleteAction(this,file,Digester.INVALID));
    }
  }
  List<String> deleteElements=new ArrayList<>();
  Runner.logger.info("Validating installation...");
  forEach(myActions,"Validating installation...",ui,true,new ActionsProcessor(){
    @Override public void forEach(    PatchAction each) throws IOException {
      String action=each.toString().toLowerCase();
      ValidationResult validationResult=each.validate(toDir);
      if (action.startsWith("delete")) {
        deleteElements.add(each.getPath().toLowerCase());
      }
 else       if (action.startsWith("create") && (validationResult != null && validationResult.message.equals(ValidationResult.ALREADY_EXISTS_MESSAGE))) {
        for (        String deleteElement : deleteElements) {
          if (each.getPath().toLowerCase().equals(deleteElement)) {
            validationResult=null;
          }
        }
      }
      if (validationResult != null)       result.add(validationResult);
    }
  }
);
  return result;
}
