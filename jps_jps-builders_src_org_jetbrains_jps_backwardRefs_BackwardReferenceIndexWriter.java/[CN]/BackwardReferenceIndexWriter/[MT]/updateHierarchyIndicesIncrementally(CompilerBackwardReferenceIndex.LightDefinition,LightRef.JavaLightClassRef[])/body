{
  final Collection<LightRef> rawOldSupers=myIndex.getHierarchyMap().get(classId);
  Set<LightRef> oldSuperClasses;
  if (rawOldSupers == null) {
    oldSuperClasses=null;
  }
 else {
    if (superIds.length == rawOldSupers.size()) {
      boolean needUpdate=false;
      for (      LightRef.JavaLightClassRef id : superIds) {
        if (!rawOldSupers.contains(id)) {
          needUpdate=true;
          break;
        }
      }
      if (!needUpdate)       return;
    }
    oldSuperClasses=new THashSet<LightRef>(rawOldSupers);
  }
  for (  LightRef.JavaLightClassRef superId : superIds) {
    if (oldSuperClasses == null || !oldSuperClasses.remove(superId)) {
      myIndex.getBackwardHierarchyMap().put(superId,classId);
      myIndex.getHierarchyMap().put(classId,superId);
    }
  }
  if (oldSuperClasses != null && !oldSuperClasses.isEmpty()) {
    myIndex.getHierarchyMap().removeAll(classId,oldSuperClasses);
    for (    LightRef anOldClass : oldSuperClasses) {
      myIndex.getBackwardHierarchyMap().put(anOldClass,classId);
    }
  }
}
