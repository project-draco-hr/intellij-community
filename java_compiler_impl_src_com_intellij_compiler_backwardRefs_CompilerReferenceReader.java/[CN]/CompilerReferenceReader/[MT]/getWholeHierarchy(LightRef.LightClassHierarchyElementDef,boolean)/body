{
  Set<LightRef.NamedLightRef> result=new THashSet<>();
  Queue<LightRef.NamedLightRef> q=new Queue<>(10);
  q.addLast(hierarchyElement);
  while (!q.isEmpty()) {
    LightRef.NamedLightRef curClass=q.pullFirst();
    if (result.add(curClass)) {
      if (checkBaseClassAmbiguity || curClass != hierarchyElement) {
        final Collection<Integer> definitionFiles=myIndex.getBackwardClassDefinitionMap().get(curClass);
        if (definitionFiles.size() != 1) {
          return null;
        }
      }
      final Collection<CompilerBackwardReferenceIndex.LightDefinition> subClassDefs=myIndex.getBackwardHierarchyMap().get(curClass);
      if (subClassDefs != null) {
        for (        CompilerBackwardReferenceIndex.LightDefinition subclass : subClassDefs) {
          final LightRef ref=subclass.getRef();
          if (ref instanceof LightRef.LightClassHierarchyElementDef) {
            q.addLast((LightRef.LightClassHierarchyElementDef)ref);
          }
        }
      }
    }
  }
  return result.toArray(new LightRef.NamedLightRef[result.size()]);
}
