{
  final Set<PsiModifierListOwner> owners=new HashSet<PsiModifierListOwner>();
  for (  PsiElement element : elements) {
    if (element instanceof PsiParameter)     continue;
    if (element instanceof PsiModifierListOwner) {
      final PsiModifierListOwner modifierListOwner=(PsiModifierListOwner)element;
      final ExternalAnnotationsManager annotationsManager=ExternalAnnotationsManager.getInstance(modifierListOwner.getProject());
      PsiAnnotation[] externalAnnotations=annotationsManager.findExternalAnnotations(modifierListOwner);
      if (externalAnnotations != null && externalAnnotations.length > 0) {
        owners.add((PsiModifierListOwner)element);
      }
 else       if (element instanceof PsiMethod) {
        final PsiParameter[] parameters=((PsiMethod)element).getParameterList().getParameters();
        for (        PsiParameter parameter : parameters) {
          externalAnnotations=annotationsManager.findExternalAnnotations(parameter);
          if (externalAnnotations != null && externalAnnotations.length > 0) {
            owners.add((PsiMethod)element);
            break;
          }
        }
      }
    }
  }
  for (  PsiModifierListOwner modifierListOwner : owners) {
    final Function<PsiModifierListOwner,String> annotationsCollector=new Function<PsiModifierListOwner,String>(){
      @Override public String fun(      PsiModifierListOwner owner){
        return XmlStringUtil.wrapInHtml(JavaDocInfoGenerator.generateSignature(owner));
      }
    }
;
    result.add(new LineMarkerInfo<PsiModifierListOwner>(modifierListOwner,modifierListOwner.getTextOffset(),AllIcons.Nodes.Annotationtype,Pass.UPDATE_OVERRIDEN_MARKERS,annotationsCollector,new MyIconGutterHandler(),GutterIconRenderer.Alignment.LEFT));
  }
}
