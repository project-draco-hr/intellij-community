{
  List<ThreadState> result=new ArrayList<ThreadState>();
  StringBuilder lastThreadStack=new StringBuilder();
  ThreadState lastThreadState=null;
  boolean expectingThreadState=false;
  boolean haveNonEmptyStackTrace=false;
  for (  @NonNls String line : StringUtil.tokenize(threadDump,"\r\n")) {
    if (line.startsWith("============") || line.contains("Java-level deadlock")) {
      break;
    }
    ThreadState state=tryParseThreadStart(line);
    if (state != null) {
      if (lastThreadState != null) {
        lastThreadState.setStackTrace(lastThreadStack.toString(),!haveNonEmptyStackTrace);
      }
      lastThreadState=state;
      result.add(lastThreadState);
      lastThreadStack.setLength(0);
      haveNonEmptyStackTrace=false;
      lastThreadStack.append(line).append("\n");
      expectingThreadState=true;
    }
 else {
      boolean parsedThreadState=false;
      if (expectingThreadState) {
        expectingThreadState=false;
        parsedThreadState=tryParseThreadState(line,lastThreadState);
      }
      lastThreadStack.append(line).append("\n");
      if (!parsedThreadState && line.trim().startsWith("at")) {
        haveNonEmptyStackTrace=true;
      }
    }
  }
  if (lastThreadState != null) {
    lastThreadState.setStackTrace(lastThreadStack.toString(),!haveNonEmptyStackTrace);
  }
  for (  ThreadState threadState : result) {
    inferThreadStateDetail(threadState);
    String lockId=findWaitingForLock(threadState.getStackTrace());
    ThreadState lockOwner=findLockOwner(result,lockId,true);
    if (lockOwner == null) {
      lockOwner=findLockOwner(result,lockId,false);
    }
    if (lockOwner != null) {
      if (threadState.isAwaitedBy(lockOwner)) {
        threadState.addDeadlockedThread(lockOwner);
        lockOwner.addDeadlockedThread(threadState);
      }
      lockOwner.addWaitingThread(threadState);
    }
  }
  sortThreads(result);
  return result;
}
