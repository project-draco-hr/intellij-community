{
  if (node.type == ClassNode.CLASS_LAMBDA) {
    return;
  }
  for (  MethodWrapper meth : node.wrapper.getMethods()) {
    if (meth.root != null) {
      boolean replaced=false;
      DirectGraph graph=meth.getOrBuildGraph();
      HashSet<DirectNode> setVisited=new HashSet<DirectNode>();
      LinkedList<DirectNode> stack=new LinkedList<DirectNode>();
      stack.add(graph.first);
      while (!stack.isEmpty()) {
        DirectNode nd=stack.removeFirst();
        if (setVisited.contains(nd)) {
          continue;
        }
        setVisited.add(nd);
        for (int i=0; i < nd.exprents.size(); i++) {
          Exprent exprent=nd.exprents.get(i);
          replaced|=replaceInvocations(node,meth,exprent);
          if (exprent.type == Exprent.EXPRENT_INVOCATION) {
            Exprent ret=replaceAccessExprent(node,meth,(InvocationExprent)exprent);
            if (ret != null) {
              nd.exprents.set(i,ret);
              replaced=true;
            }
          }
        }
        for (        DirectNode ndx : nd.succs) {
          stack.add(ndx);
        }
      }
      if (replaced) {
        computeMethodType(node,meth);
      }
    }
  }
  for (  ClassNode child : node.nested) {
    eliminateStaticAccess(child);
  }
}
