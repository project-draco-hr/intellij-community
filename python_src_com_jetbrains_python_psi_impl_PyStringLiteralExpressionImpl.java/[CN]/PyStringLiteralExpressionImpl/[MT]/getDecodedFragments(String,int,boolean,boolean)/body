{
  final List<Pair<TextRange,String>> result=new ArrayList<Pair<TextRange,String>>();
  final Matcher escMatcher=PATTERN_ESCAPE.matcher(encoded);
  int index=0;
  while (escMatcher.find(index)) {
    if (index < escMatcher.start()) {
      final TextRange range=TextRange.create(index,escMatcher.start());
      final TextRange offsetRange=range.shiftRight(offset);
      result.add(Pair.create(offsetRange,range.substring(encoded)));
    }
    final String octal=escapeRegexGroup(escMatcher,EscapeRegexGroup.OCTAL);
    final String hex=escapeRegexGroup(escMatcher,EscapeRegexGroup.HEXADECIMAL);
    final String unicode16=escapeRegexGroup(escMatcher,EscapeRegexGroup.UNICODE_16BIT);
    final String unicode32=escapeRegexGroup(escMatcher,EscapeRegexGroup.UNICODE_32BIT);
    final String wholeMatch=escapeRegexGroup(escMatcher,EscapeRegexGroup.WHOLE_MATCH);
    final boolean escapedUnicode=raw && unicode || !raw;
    final String str;
    if (!raw && octal != null) {
      str=new String(new char[]{(char)Integer.parseInt(octal,8)});
    }
 else     if (!raw && hex != null) {
      str=new String(new char[]{(char)Integer.parseInt(hex,16)});
    }
 else     if (escapedUnicode && unicode16 != null) {
      str=unicode ? new String(new char[]{(char)Integer.parseInt(unicode16,16)}) : wholeMatch;
    }
 else     if (escapedUnicode && unicode32 != null) {
      String s=wholeMatch;
      if (unicode) {
        try {
          s=new String(Character.toChars((int)Long.parseLong(unicode32,16)));
        }
 catch (        IllegalArgumentException ignored) {
        }
      }
      str=s;
    }
 else     if (raw) {
      str=wholeMatch;
    }
 else {
      final String toReplace=escapeRegexGroup(escMatcher,EscapeRegexGroup.ESCAPED_SUBSTRING);
      str=escapeMap.get(toReplace);
    }
    if (str != null) {
      final TextRange wholeMatchRange=TextRange.create(escMatcher.start(),escMatcher.end());
      result.add(Pair.create(wholeMatchRange.shiftRight(offset),str));
    }
    index=escMatcher.end();
  }
  final TextRange range=TextRange.create(index,encoded.length());
  final TextRange offRange=range.shiftRight(offset);
  result.add(Pair.create(offRange,range.substring(encoded)));
  return result;
}
