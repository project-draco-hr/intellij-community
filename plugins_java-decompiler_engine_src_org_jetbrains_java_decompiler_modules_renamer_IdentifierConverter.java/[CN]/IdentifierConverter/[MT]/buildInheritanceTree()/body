{
  Map<String,ClassWrapperNode> nodes=new HashMap<String,ClassWrapperNode>();
  Map<String,StructClass> classes=context.getClasses();
  List<ClassWrapperNode> rootClasses=new ArrayList<ClassWrapperNode>();
  List<ClassWrapperNode> rootInterfaces=new ArrayList<ClassWrapperNode>();
  for (  StructClass cl : classes.values()) {
    if (!cl.isOwn()) {
      continue;
    }
    LinkedList<StructClass> stack=new LinkedList<StructClass>();
    LinkedList<ClassWrapperNode> stackSubNodes=new LinkedList<ClassWrapperNode>();
    stack.add(cl);
    stackSubNodes.add(null);
    while (!stack.isEmpty()) {
      StructClass clStr=stack.removeFirst();
      ClassWrapperNode child=stackSubNodes.removeFirst();
      ClassWrapperNode node=nodes.get(clStr.qualifiedName);
      boolean isNewNode=(node == null);
      if (isNewNode) {
        nodes.put(clStr.qualifiedName,node=new ClassWrapperNode(clStr));
      }
      if (child != null) {
        node.addSubclass(child);
      }
      if (!isNewNode) {
        break;
      }
 else {
        boolean isInterface=clStr.hasModifier(CodeConstants.ACC_INTERFACE);
        boolean found_parent=false;
        if (isInterface) {
          for (          String ifName : clStr.getInterfaceNames()) {
            StructClass clParent=classes.get(ifName);
            if (clParent != null) {
              stack.add(clParent);
              stackSubNodes.add(node);
              found_parent=true;
            }
          }
        }
 else         if (clStr.superClass != null) {
          StructClass clParent=classes.get(clStr.superClass.getString());
          if (clParent != null) {
            stack.add(clParent);
            stackSubNodes.add(node);
            found_parent=true;
          }
        }
        if (!found_parent) {
          (isInterface ? rootInterfaces : rootClasses).add(node);
        }
      }
    }
  }
  this.rootClasses=rootClasses;
  this.rootInterfaces=rootInterfaces;
}
