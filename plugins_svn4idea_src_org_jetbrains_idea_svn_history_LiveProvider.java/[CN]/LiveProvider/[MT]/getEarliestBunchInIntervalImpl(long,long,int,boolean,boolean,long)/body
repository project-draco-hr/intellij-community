{
  if ((myEarliestRevisionWasAccessed) || ((oldestRevision == myYoungestRevision) && ((!includeYoungest) || (!includeOldest)))) {
    return null;
  }
  final SVNRevision youngRevision=(earliestRevision == -1) ? SVNRevision.HEAD : SVNRevision.create(earliestRevision);
  final Ref<List<CommittedChangeList>> refToList=new Ref<List<CommittedChangeList>>();
  final Ref<VcsException> exceptionRef=new Ref<VcsException>();
  final Runnable loader=new Runnable(){
    public void run(){
      try {
        refToList.set(myLoader.loadInterval(youngRevision,SVNRevision.create(oldestRevision),desirableSize,includeYoungest,includeOldest));
      }
 catch (      VcsException e) {
        exceptionRef.set(e);
      }
    }
  }
;
  final Application application=ApplicationManager.getApplication();
  if (application.isUnitTestMode() || !application.isDispatchThread()) {
    loader.run();
  }
 else {
    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
      public void run(){
        final ProgressIndicator ind=ProgressManager.getInstance().getProgressIndicator();
        if (ind != null) {
          ind.setText(SvnBundle.message("progress.live.provider.loading.revisions.details.text"));
        }
        loader.run();
      }
    }
,SvnBundle.message("progress.live.provider.loading.revisions.text"),false,myVcs.getProject());
  }
  if (!exceptionRef.isNull()) {
    final VcsException e=exceptionRef.get();
    if (isElementNotFound(e)) {
      final LatestExistentSearcher searcher=new LatestExistentSearcher(oldestRevision,myYoungestRevision,(oldestRevision != 0),myVcs,myLocation.toSvnUrl());
      final long existent=searcher.getLatestExistent();
      if ((existent == -1) || (existent == earliestRevision)) {
        myEarliestRevisionWasAccessed=true;
        return null;
      }
      return getEarliestBunchInIntervalImpl(existent,oldestRevision,includeYoungest ? desirableSize : (desirableSize + 1),true,includeOldest,Math.min(existent,earliestRevision));
    }
    throw e;
  }
  final List<CommittedChangeList> list=refToList.get();
  if (list.isEmpty()) {
    myEarliestRevisionWasAccessed=(oldestRevision == 0);
    return null;
  }
  if (earliestToTake > 0) {
    for (Iterator<CommittedChangeList> iterator=list.iterator(); iterator.hasNext(); ) {
      final CommittedChangeList changeList=iterator.next();
      if (changeList.getNumber() > earliestToTake)       iterator.remove();
    }
  }
  myEarliestRevisionWasAccessed=(oldestRevision == 0) && ((list.size() + ((!includeOldest) ? 1 : 0) + ((!includeYoungest) ? 1 : 0)) < desirableSize);
  return new Fragment(Origin.LIVE,list,true,true,null);
}
