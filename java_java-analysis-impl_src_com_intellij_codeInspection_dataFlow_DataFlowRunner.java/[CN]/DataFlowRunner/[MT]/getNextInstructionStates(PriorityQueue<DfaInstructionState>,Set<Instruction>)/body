{
  DfaInstructionState state=queue.poll();
  Instruction instruction=state.getInstruction();
  DfaInstructionState next=queue.peek();
  if (next == null || next.compareTo(state) != 0)   return Collections.singletonList(state);
  List<DfaInstructionState> sameInstructionStates=ContainerUtil.newArrayList();
  sameInstructionStates.add(state);
  while (!queue.isEmpty() && queue.peek().compareTo(state) == 0) {
    sameInstructionStates.add(queue.poll());
  }
  if (!joinInstructions.contains(instruction)) {
    return sameInstructionStates;
  }
  findMergeable:   while (true) {
    for (int i=0; i < sameInstructionStates.size(); i++) {
      DfaInstructionState state1=sameInstructionStates.get(i);
      for (int j=i + 1; j < sameInstructionStates.size(); j++) {
        ProgressManager.checkCanceled();
        DfaInstructionState state2=sameInstructionStates.get(j);
        DfaMemoryState merged=state1.getMemoryState().mergeWith(state2.getMemoryState());
        if (merged != null) {
          sameInstructionStates.set(i,new DfaInstructionState(instruction,merged));
          sameInstructionStates.remove(j);
          continue findMergeable;
        }
      }
    }
    break;
  }
  return sameInstructionStates;
}
