{
  DfaInstructionState state=queue.poll();
  final Instruction instruction=state.getInstruction();
  DfaInstructionState next=queue.peek();
  if (next == null || next.compareTo(state) != 0)   return Collections.singletonList(state);
  Set<DfaMemoryStateImpl> memoryStates=ContainerUtil.newHashSet();
  memoryStates.add((DfaMemoryStateImpl)state.getMemoryState());
  while (!queue.isEmpty() && queue.peek().compareTo(state) == 0) {
    memoryStates.add((DfaMemoryStateImpl)queue.poll().getMemoryState());
  }
  if (joinInstructions.contains(instruction)) {
    while (true) {
      Set<DfaMemoryStateImpl> nextStates=new StateMerger(memoryStates).merge();
      if (nextStates == null)       break;
      memoryStates=nextStates;
    }
  }
  return ContainerUtil.map(memoryStates,new Function<DfaMemoryStateImpl,DfaInstructionState>(){
    @Override public DfaInstructionState fun(    DfaMemoryStateImpl state){
      return new DfaInstructionState(instruction,state);
    }
  }
);
}
