{
  try {
    ControlFlowAnalyzer analyzer=createControlFlowAnalyzer();
    final ControlFlow flow=analyzer.buildControlFlow(psiBlock,ignoreAssertions);
    if (flow == null)     return RunnerResult.NOT_APPLICABLE;
    int[] loopNumber=LoopAnalyzer.calcInLoop(flow);
    int endOffset=flow.getInstructionCount();
    myInstructions=flow.getInstructions();
    myNestedClosures.clear();
    Set<Instruction> joinInstructions=ContainerUtil.newHashSet();
    for (int index=0; index < myInstructions.length; index++) {
      Instruction instruction=myInstructions[index];
      if (instruction instanceof GotoInstruction) {
        joinInstructions.add(myInstructions[((GotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof ConditionalGotoInstruction) {
        joinInstructions.add(myInstructions[((ConditionalGotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof MethodCallInstruction && !((MethodCallInstruction)instruction).getContracts().isEmpty()) {
        joinInstructions.add(myInstructions[index + 1]);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Analyzing code block: " + psiBlock.getText());
      for (int i=0; i < myInstructions.length; i++) {
        LOG.debug(i + ": " + myInstructions[i].toString());
      }
    }
    Integer tooExpensiveHash=psiBlock.getUserData(TOO_EXPENSIVE_HASH);
    if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {
      LOG.debug("Too complex because hasn't changed since being too complex already");
      return RunnerResult.TOO_COMPLEX;
    }
    final StateQueue queue=new StateQueue();
    for (    final DfaMemoryState initialState : initialStates) {
      queue.offer(new DfaInstructionState(myInstructions[0],initialState));
    }
    MultiMap<BranchingInstruction,DfaMemoryState> processedStates=MultiMap.createSet();
    MultiMap<BranchingInstruction,DfaMemoryState> incomingStates=MultiMap.createSet();
    long msLimit=shouldCheckTimeLimit() ? Registry.intValue("ide.dfa.time.limit.online") : Registry.intValue("ide.dfa.time.limit.offline");
    WorkingTimeMeasurer measurer=new WorkingTimeMeasurer(msLimit * 1000 * 1000);
    int count=0;
    while (!queue.isEmpty()) {
      List<DfaInstructionState> states=queue.getNextInstructionStates(joinInstructions);
      for (      DfaInstructionState instructionState : states) {
        if (count++ % 1024 == 0 && measurer.isTimeOver()) {
          LOG.debug("Too complex because the analysis took too long");
          psiBlock.putUserData(TOO_EXPENSIVE_HASH,psiBlock.getText().hashCode());
          return RunnerResult.TOO_COMPLEX;
        }
        ProgressManager.checkCanceled();
        if (LOG.isDebugEnabled()) {
          LOG.debug(instructionState.toString());
        }
        Instruction instruction=instructionState.getInstruction();
        if (instruction instanceof BranchingInstruction) {
          BranchingInstruction branching=(BranchingInstruction)instruction;
          Collection<DfaMemoryState> processed=processedStates.get(branching);
          if (processed.contains(instructionState.getMemoryState())) {
            continue;
          }
          if (processed.size() > MAX_STATES_PER_BRANCH) {
            LOG.debug("Too complex because too many different possible states");
            return RunnerResult.TOO_COMPLEX;
          }
          if (loopNumber[branching.getIndex()] != 0) {
            processedStates.putValue(branching,instructionState.getMemoryState().createCopy());
          }
        }
        DfaInstructionState[] after=acceptInstruction(visitor,instructionState);
        for (        DfaInstructionState state : after) {
          Instruction nextInstruction=state.getInstruction();
          if (nextInstruction.getIndex() >= endOffset) {
            continue;
          }
          handleStepOutOfLoop(instruction,nextInstruction,loopNumber,processedStates,incomingStates,states,after,queue);
          if (nextInstruction instanceof BranchingInstruction) {
            BranchingInstruction branching=(BranchingInstruction)nextInstruction;
            if (processedStates.get(branching).contains(state.getMemoryState()) || incomingStates.get(branching).contains(state.getMemoryState())) {
              continue;
            }
            if (loopNumber[branching.getIndex()] != 0) {
              incomingStates.putValue(branching,state.getMemoryState().createCopy());
            }
          }
          queue.offer(state);
        }
      }
    }
    psiBlock.putUserData(TOO_EXPENSIVE_HASH,null);
    LOG.debug("Analysis ok");
    return RunnerResult.OK;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    LOG.error(psiBlock.getText(),e);
    return RunnerResult.ABORTED;
  }
catch (  EmptyStackException e) {
    LOG.error(psiBlock.getText(),e);
    return RunnerResult.ABORTED;
  }
}
