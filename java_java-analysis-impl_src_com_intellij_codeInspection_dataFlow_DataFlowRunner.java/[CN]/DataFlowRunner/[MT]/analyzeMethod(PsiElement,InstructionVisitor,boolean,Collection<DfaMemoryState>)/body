{
  try {
    prepareAnalysis(psiBlock,initialStates);
    final ControlFlow flow=createControlFlowAnalyzer().buildControlFlow(psiBlock,ignoreAssertions);
    if (flow == null)     return RunnerResult.NOT_APPLICABLE;
    int endOffset=flow.getInstructionCount();
    myInstructions=flow.getInstructions();
    myFields=flow.getFields();
    myNestedClosures.clear();
    Set<Instruction> joinInstructions=ContainerUtil.newHashSet();
    for (    Instruction instruction : myInstructions) {
      if (instruction instanceof GotoInstruction) {
        joinInstructions.add(myInstructions[((GotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof ConditionalGotoInstruction) {
        joinInstructions.add(myInstructions[((ConditionalGotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof GosubInstruction) {
        joinInstructions.add(myInstructions[((GosubInstruction)instruction).getSubprogramOffset()]);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Analyzing code block: " + psiBlock.getText());
      for (int i=0; i < myInstructions.length; i++) {
        Instruction instruction=myInstructions[i];
        LOG.debug(i + ": " + instruction.toString());
      }
    }
    Integer tooExpensiveHash=psiBlock.getUserData(TOO_EXPENSIVE_HASH);
    if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {
      LOG.debug("Too complex because hasn't changed since being too complex already");
      return RunnerResult.TOO_COMPLEX;
    }
    final PriorityQueue<DfaInstructionState> queue=new PriorityQueue<DfaInstructionState>();
    for (    final DfaMemoryState initialState : initialStates) {
      queue.add(new DfaInstructionState(myInstructions[0],initialState));
    }
    WorkingTimeMeasurer measurer=new WorkingTimeMeasurer(shouldCheckTimeLimit() ? ourTimeLimit : ourTimeLimit * 42);
    int count=0;
    while (!queue.isEmpty()) {
      for (      DfaInstructionState instructionState : getNextInstructionStates(queue,joinInstructions)) {
        if (count++ % 1024 == 0 && measurer.isTimeOver()) {
          LOG.debug("Too complex because the analysis took too long");
          psiBlock.putUserData(TOO_EXPENSIVE_HASH,psiBlock.getText().hashCode());
          return RunnerResult.TOO_COMPLEX;
        }
        ProgressManager.checkCanceled();
        if (LOG.isDebugEnabled()) {
          LOG.debug(instructionState.toString());
        }
        Instruction instruction=instructionState.getInstruction();
        if (instruction instanceof BranchingInstruction) {
          BranchingInstruction branching=(BranchingInstruction)instruction;
          if (branching.isMemoryStateProcessed(instructionState.getMemoryState())) {
            continue;
          }
          if (!branching.setMemoryStateProcessed(instructionState.getMemoryState().createCopy())) {
            LOG.debug("Too complex because too many different possible states");
            return RunnerResult.TOO_COMPLEX;
          }
        }
        DfaInstructionState[] after=acceptInstruction(visitor,instructionState);
        for (        DfaInstructionState state : after) {
          if (instruction.getIndex() < endOffset) {
            queue.add(state);
          }
        }
      }
    }
    psiBlock.putUserData(TOO_EXPENSIVE_HASH,null);
    LOG.debug("Analysis ok");
    return RunnerResult.OK;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    LOG.error(psiBlock.getText(),e);
    return RunnerResult.ABORTED;
  }
catch (  EmptyStackException e) {
    if (LOG.isDebugEnabled()) {
      LOG.error(e);
    }
    return RunnerResult.ABORTED;
  }
}
