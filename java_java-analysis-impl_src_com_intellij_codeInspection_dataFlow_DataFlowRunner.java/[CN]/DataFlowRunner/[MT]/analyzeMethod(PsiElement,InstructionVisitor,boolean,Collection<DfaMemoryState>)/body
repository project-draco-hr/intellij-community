{
  try {
    prepareAnalysis(psiBlock,initialStates);
    final ControlFlow flow=createControlFlowAnalyzer().buildControlFlow(psiBlock,ignoreAssertions);
    if (flow == null)     return RunnerResult.NOT_APPLICABLE;
    int endOffset=flow.getInstructionCount();
    myInstructions=flow.getInstructions();
    myFields=flow.getFields();
    myNestedClosures.clear();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Analyzing code block: " + psiBlock.getText());
      for (int i=0; i < myInstructions.length; i++) {
        Instruction instruction=myInstructions[i];
        LOG.debug(i + ": " + instruction.toString());
      }
    }
    Integer tooExpensiveHash=psiBlock.getUserData(TOO_EXPENSIVE_HASH);
    if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {
      LOG.debug("Too complex because hasn't changed since being too complex already");
      return RunnerResult.TOO_COMPLEX;
    }
    final ArrayList<DfaInstructionState> queue=new ArrayList<DfaInstructionState>();
    for (    final DfaMemoryState initialState : initialStates) {
      queue.add(new DfaInstructionState(myInstructions[0],initialState));
    }
    WorkingTimeMeasurer measurer=new WorkingTimeMeasurer(shouldCheckTimeLimit() ? ourTimeLimit : ourTimeLimit * 42);
    int count=0;
    while (!queue.isEmpty()) {
      if (count % 64 == 0 && measurer.isTimeOver()) {
        LOG.debug("Too complex because the analysis took too long");
        psiBlock.putUserData(TOO_EXPENSIVE_HASH,psiBlock.getText().hashCode());
        return RunnerResult.TOO_COMPLEX;
      }
      ProgressManager.checkCanceled();
      DfaInstructionState instructionState=queue.remove(0);
      if (LOG.isDebugEnabled()) {
        LOG.debug(instructionState.toString());
      }
      Instruction instruction=instructionState.getInstruction();
      long distance=instructionState.getDistanceFromStart();
      if (instruction instanceof BranchingInstruction) {
        if (!instruction.setMemoryStateProcessed(instructionState.getMemoryState().createCopy())) {
          LOG.debug("Too complex because too many different possible states");
          return RunnerResult.TOO_COMPLEX;
        }
      }
      DfaInstructionState[] after=acceptInstruction(visitor,instructionState);
      for (      DfaInstructionState state : after) {
        Instruction nextInstruction=state.getInstruction();
        if ((!(nextInstruction instanceof BranchingInstruction) || !nextInstruction.isMemoryStateProcessed(state.getMemoryState())) && instruction.getIndex() < endOffset) {
          state.setDistanceFromStart(distance + 1);
          queue.add(state);
        }
      }
      count++;
    }
    psiBlock.putUserData(TOO_EXPENSIVE_HASH,null);
    LOG.debug("Analysis ok");
    return RunnerResult.OK;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    LOG.error(psiBlock.getText(),e);
    return RunnerResult.ABORTED;
  }
catch (  EmptyStackException e) {
    if (LOG.isDebugEnabled()) {
      LOG.error(e);
    }
    return RunnerResult.ABORTED;
  }
}
