{
  final XDebuggerEvaluator.XEvaluationCallback computeChildrenCallback=new XDebuggerEvaluator.XEvaluationCallback(){
    @Override public void evaluated(    @NotNull final XValue result){
      final String name=((PyDebugValue)result).getName();
      DebuggerUIUtil.invokeLater(new Runnable(){
        @Override public void run(){
          XValueNodeImpl node=new XValueNodeImpl(myValueProvider.getTree(),null,name,result);
          node.startComputingChildren();
        }
      }
);
    }
    @Override public void errorOccurred(    @NotNull String errorMessage){
      if (!errorMessage.contains("Timeout waiting for response on")) {
        myValueProvider.showError(errorMessage);
      }
    }
  }
;
  XDebuggerTreeListener treeListener=new XDebuggerTreeListener(){
    @Override public void nodeLoaded(    @NotNull RestorableStateNode node,    String name){
    }
    @Override public void childrenLoaded(    @NotNull XDebuggerTreeNode node,    @NotNull List<XValueContainerNode<?>> children,    boolean last){
      String fullName=((XValueNodeImpl)node).getName();
      if (!fullName.contains(getPresentation())) {
        return;
      }
      int row=-1;
      if (isOneRow()) {
        row=0;
      }
 else {
        if (fullName != null && fullName.contains("[")) {
          fullName=fullName.substring(0,fullName.lastIndexOf(","));
        }
        if (fullName != null && fullName.contains("[")) {
          row=Integer.parseInt(fullName.substring(fullName.lastIndexOf('[') + 1,fullName.length()));
        }
 else         if (fullName != null && !fullName.contains("[")) {
          row=0;
        }
      }
      if (row > rows) {
        throw new IllegalStateException("Row " + row + " is out of range for "+ getPresentation()+ ".");
      }
      if (row != -1 && myData[row][0] == null) {
        for (int i=0; i < node.getChildCount() - 1; i++) {
          myData[row][i]=((XValueNodeImpl)node.getChildAt(i + 1)).getRawValue();
        }
        myFilledRows+=1;
        if (myFilledRows == rows) {
          node.getTree().removeTreeListener(this);
          callback.run();
        }
 else {
          nextRow+=1;
          startEvalNextRow(computeChildrenCallback);
        }
      }
    }
  }
;
  myData=new Object[rows][columns];
  myValueProvider.getTree().addTreeListener(treeListener);
  nextRow=0;
  myFilledRows=0;
  startEvalNextRow(computeChildrenCallback);
}
