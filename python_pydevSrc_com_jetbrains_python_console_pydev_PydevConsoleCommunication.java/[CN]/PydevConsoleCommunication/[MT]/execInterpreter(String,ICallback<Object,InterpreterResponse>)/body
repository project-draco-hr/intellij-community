{
  nextResponse=null;
  if (waitingForInput) {
    inputReceived=command;
    waitingForInput=false;
  }
 else {
    new Task.Backgroundable(myProject,"REPL Communication",true){
      @Override public void run(      @NotNull ProgressIndicator indicator){
        boolean needInput=false;
        try {
          Pair<String,Boolean> executed=null;
          int commAttempts=0;
          while (true) {
            if (indicator.isCanceled()) {
              return;
            }
            executed=exec(command);
            String refusedConnPattern="Failed to read servers response";
            if (executed.first != null && executed.first.indexOf(refusedConnPattern) != -1) {
              if (firstCommWorked) {
                break;
              }
 else {
                if (commAttempts < MAX_ATTEMPTS) {
                  commAttempts+=1;
                  Thread.sleep(250);
                  executed=new Pair<String,Boolean>(stdErrReader.getAndClearContents(),executed.second);
                  continue;
                }
 else {
                  break;
                }
              }
            }
 else {
              break;
            }
          }
          firstCommWorked=true;
          String errorContents=executed.first;
          boolean more=executed.second;
          if (errorContents == null) {
            errorContents=stdErrReader.getAndClearContents();
          }
          nextResponse=new InterpreterResponse(stdOutReader.getAndClearContents(),errorContents,more,needInput);
        }
 catch (        Exception e) {
          nextResponse=new InterpreterResponse("","Exception while pushing line to console:" + e.getMessage(),false,needInput);
        }
      }
    }
.queue();
    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
      @Override public void run(){
        final ProgressManager progressManager=ProgressManager.getInstance();
        if (progressManager.hasProgressIndicator()) {
          progressManager.getProgressIndicator().setText("Waiting for REPL response with " + (int)(TIMEOUT / 10e8) + "s timeout");
        }
        final long startTime=System.nanoTime();
        while (nextResponse == null) {
          try {
            ProgressManager.checkCanceled();
          }
 catch (          ProcessCanceledException e) {
            LOG.debug("Canceled");
            nextResponse=new InterpreterResponse("","Canceled",false,false);
          }
          final long time=System.nanoTime() - startTime;
          if (progressManager.hasProgressIndicator()) {
            progressManager.getProgressIndicator().setFraction(((double)time) / TIMEOUT);
          }
          if (time > TIMEOUT) {
            LOG.debug("Timeout exceeded");
            nextResponse=new InterpreterResponse("","Timeout exceeded",false,false);
          }
synchronized (lock2) {
            try {
              lock2.wait(20);
            }
 catch (            InterruptedException e) {
              LOG.error(e);
            }
          }
        }
        onResponseReceived.call(nextResponse);
      }
    }
,"Waiting for REPL response",true,myProject);
  }
}
