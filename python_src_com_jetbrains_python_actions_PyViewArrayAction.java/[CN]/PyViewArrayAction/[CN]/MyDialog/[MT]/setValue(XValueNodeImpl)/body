{
  final ArrayValueProvider valueProvider;
  if (node.getValuePresentation() != null && node.getValuePresentation().getType() != null && node.getValuePresentation().getType().equals("ndarray")) {
    valueProvider=new NumpyArrayValueProvider();
    XDebuggerTreeTableListener tableUpdater=new XDebuggerTreeTableListener(){
      XValueNodeImpl baseNode;
      XValueContainerNode innerNdarray;
      XValueContainerNode innerItems;
      int[] shape;
      int depth=0;
      int loadedRows=0;
      HashSet<String> unloadedRowNumbers=new HashSet<String>();
      boolean baseChildrenLoaded=false;
      boolean numeric=false;
      boolean dataLoaded=false;
      Object[][] data;
      @Override public void nodeLoaded(      @NotNull RestorableStateNode node,      String name){
        System.out.printf(name + " node loaded\n");
        if (!baseChildrenLoaded && (shape == null || name.equals("dtype")) && ((XValueNodeImpl)node.getParent()).getName().equals(baseNode.getName())) {
          if (name.equals("shape")) {
            String rawValue=node.getRawValue();
            String[] shapes=rawValue.substring(1,rawValue.length() - 1).split(",");
            shape=new int[shapes.length];
            for (int i=0; i < shapes.length; i++) {
              shape[i]=Integer.parseInt(shapes[i].trim());
            }
            depth=Math.max(shape.length - 2,0);
          }
          if (name.equals("dtype")) {
            String rawValue=node.getRawValue();
            if ("biufc".contains(rawValue.substring(0,1))) {
              numeric=true;
            }
          }
        }
      }
      @Override public void childrenLoaded(      @NotNull XDebuggerTreeNode node,      @NotNull List<XValueContainerNode<?>> children,      boolean last){
        System.out.printf(children + "children loaded\n");
        if (dataLoaded) {
          return;
        }
        if (!baseChildrenLoaded && node.equals(baseNode)) {
          baseChildrenLoaded=true;
          innerNdarray=(XValueContainerNode)node;
          if (shape != null) {
            if (shape.length >= 2) {
              data=new Object[shape[shape.length - 2]][shape[shape.length - 1]];
            }
 else {
              data=new Object[1][shape[0]];
            }
          }
        }
        if (depth > 0) {
          if (innerNdarray != null && innerNdarray.equals(node)) {
            innerNdarray=null;
            innerItems=findItems(node);
            innerItems.startComputingChildren();
          }
          if (innerItems != null && innerItems.equals(node)) {
            innerNdarray=(XValueContainerNode)node.getChildAt(1);
            innerItems=null;
            innerNdarray.startComputingChildren();
            depth-=1;
          }
          return;
        }
        if (depth == 0) {
          innerItems=findItems(node);
          innerItems.startComputingChildren();
          depth-=1;
          return;
        }
        if (depth == -1 && node.equals(innerItems)) {
          if (shape != null && shape.length == 1) {
            for (int i=0; i < node.getChildCount() - 1; i++) {
              data[0][i]=fixValue(((XValueNodeImpl)node.getChildAt(i + 1)).getRawValue());
            }
            loadData();
            loadedRows=1;
          }
 else {
            for (int i=0; i < node.getChildCount() - 1; i++) {
              ((XValueNodeImpl)node.getChildAt(i + 1)).startComputingChildren();
              unloadedRowNumbers.add(((XValueNodeImpl)node.getChildAt(i + 1)).getName());
            }
            depth-=1;
          }
          return;
        }
        if (depth == -2) {
          String name=((XValueNodeImpl)node).getName();
          if (unloadedRowNumbers.contains(name)) {
            unloadedRowNumbers.remove(name);
            findItems(node).startComputingChildren();
            return;
          }
          if (name.startsWith("[")) {
            int row=parseName(((XValueNodeImpl)node.getParent()).getName());
            if (data[row][0] == null) {
              for (int i=0; i < node.getChildCount() - 1; i++) {
                data[row][i]=fixValue(((XValueNodeImpl)node.getChildAt(i + 1)).getRawValue());
              }
              loadedRows+=1;
            }
          }
        }
        if (loadedRows == shape[shape.length - 2]) {
          loadData();
        }
      }
      private String fixValue(      String value){
        if (!numeric) {
          return "\'" + value + "\'";
        }
        return value;
      }
      public void setBaseNode(      XValueNodeImpl baseNode){
        this.baseNode=baseNode;
      }
      private int parseName(      String name){
        int open=name.indexOf('(');
        return Integer.parseInt(name.substring(1,open - 2));
      }
      XValueContainerNode findItems(      @NotNull XDebuggerTreeNode node){
        for (int i=0; i < node.getChildCount(); i++) {
          if (node.getChildAt(i).toString().startsWith("[")) {
            return (XValueContainerNode)node.getChildAt(i);
          }
        }
        return null;
      }
      private void loadData(){
        DefaultTableModel model=new DefaultTableModel(data,range(0,data[0].length - 1));
        myTable.setModel(model);
        myTable.setDefaultEditor(myTable.getColumnClass(0),new MyTableCellEditor(myProject));
        if (numeric) {
          double min=Double.MAX_VALUE;
          double max=Double.MIN_VALUE;
          if (data.length > 0) {
            try {
              for (int i=0; i < data.length; i++) {
                for (int j=0; j < data[0].length; j++) {
                  double d=Double.parseDouble(data[i][j].toString());
                  min=min > d ? d : min;
                  max=max < d ? d : max;
                }
              }
            }
 catch (            NumberFormatException e) {
              min=0;
              max=0;
            }
          }
 else {
            min=0;
            max=0;
          }
          myTable.setDefaultRenderer(myTable.getColumnClass(0),new MyTableCellRenderer(min,max));
        }
 else {
          myComponent.getColored().setSelected(false);
          myComponent.getColored().setVisible(false);
        }
        myComponent.getTextField().setText(getDefaultSliceRepresentation());
        dataLoaded=true;
        innerItems=null;
        innerNdarray=null;
      }
      public String getDefaultSliceRepresentation(){
        String representation="";
        if (baseNode != null) {
          representation+=baseNode.getName();
          if (shape != null && shape.length > 0) {
            for (int i=0; i < shape.length - 2; i++) {
              representation+="[0]";
            }
            if (shape.length == 1) {
              representation+="[0:" + shape[0] + "]";
            }
 else {
              representation+="[0:" + shape[shape.length - 2] + "][0:"+ shape[shape.length - 1]+ "]";
            }
          }
        }
        return representation;
      }
    }
;
    tableUpdater.setBaseNode(node);
    node.getTree().addTreeListener(tableUpdater);
    node.startComputingChildren();
  }
}
