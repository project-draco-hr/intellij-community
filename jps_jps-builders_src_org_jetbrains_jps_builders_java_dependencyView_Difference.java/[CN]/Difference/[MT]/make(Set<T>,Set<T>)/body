{
  if (past == null) {
    final Collection<T> _now=Collections.unmodifiableCollection(now);
    return new Specifier<T,D>(){
      public Collection<T> added(){
        return _now;
      }
      public Collection<T> removed(){
        return Collections.emptyList();
      }
      public Collection<Pair<T,D>> changed(){
        return Collections.emptyList();
      }
      public boolean unchanged(){
        return false;
      }
    }
;
  }
  final Set<T> added=new HashSet<T>(now);
  added.removeAll(past);
  final Set<T> removed=new HashSet<T>(past);
  removed.removeAll(now);
  final Set<Pair<T,D>> changed;
  if (canContainChangedElements(past,now)) {
    changed=new HashSet<Pair<T,D>>();
    final Set<T> intersect=new HashSet<T>(past);
    final Map<T,T> nowMap=new HashMap<T,T>();
    for (    T s : now) {
      if (intersect.contains(s)) {
        nowMap.put(s,s);
      }
    }
    intersect.retainAll(now);
    for (    T x : intersect) {
      final Proto px=(Proto)x;
      final Proto py=(Proto)nowMap.get(x);
      final D diff=(D)py.difference(px);
      if (!diff.no()) {
        changed.add(Pair.create(x,diff));
      }
    }
  }
 else {
    changed=Collections.emptySet();
  }
  return new Specifier<T,D>(){
    public Collection<T> added(){
      return added;
    }
    public Collection<T> removed(){
      return removed;
    }
    public Collection<Pair<T,D>> changed(){
      return changed;
    }
    public boolean unchanged(){
      return changed.isEmpty() && added.isEmpty() && removed.isEmpty();
    }
  }
;
}
