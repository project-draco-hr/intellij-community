{
  final Gson gson=new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();
  JsonObject taskFileObject=json.getAsJsonObject();
  JsonArray placeholders=taskFileObject.getAsJsonArray(PLACEHOLDERS);
  for (  JsonElement placeholder : placeholders) {
    JsonObject placeholderObject=placeholder.getAsJsonObject();
    int line=placeholderObject.getAsJsonPrimitive(LINE).getAsInt();
    int start=placeholderObject.getAsJsonPrimitive(START).getAsInt();
    if (line == -1) {
      placeholderObject.addProperty(OFFSET,start);
    }
 else {
      Document document=EditorFactory.getInstance().createDocument(taskFileObject.getAsJsonPrimitive(TEXT).getAsString());
      placeholderObject.addProperty(OFFSET,document.getLineStartOffset(line) + start);
    }
    final String hintString=placeholderObject.getAsJsonPrimitive(HINT).getAsString();
    final JsonArray hintsArray=new JsonArray();
    try {
      final Type listType=new TypeToken<List<String>>(){
      }
.getType();
      final List<String> hints=gson.fromJson(hintString,listType);
      if (hints != null && !hints.isEmpty()) {
        for (int i=0; i < hints.size(); i++) {
          if (i == 0) {
            placeholderObject.addProperty(HINT,hints.get(0));
            continue;
          }
          hintsArray.add(hints.get(i));
        }
        placeholderObject.add(ADDITIONAL_HINTS,hintsArray);
      }
 else {
        placeholderObject.addProperty(HINT,"");
      }
    }
 catch (    JsonParseException e) {
      hintsArray.add(hintString);
    }
  }
  return gson.fromJson(json,TaskFile.class);
}
