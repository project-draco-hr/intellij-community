{
  List<MethodContract> contracts;
  try {
    contracts=MethodContract.parseContract(text);
  }
 catch (  MethodContract.ParseException e) {
    return e.getMessage();
  }
  int paramCount=method.getParameterList().getParametersCount();
  for (int i=0; i < contracts.size(); i++) {
    MethodContract contract=contracts.get(i);
    if (contract.arguments.length != paramCount) {
      return "Method takes " + paramCount + " parameters, while contract clause number "+ (i + 1)+ " expects "+ contract.arguments.length;
    }
    PsiType returnType=method.getReturnType();
    if (returnType != null && !InferenceFromSourceUtil.isReturnTypeCompatible(returnType,contract.returnValue)) {
      return "Method returns " + returnType.getPresentableText() + " but the contract specifies "+ contract.returnValue;
    }
    if (method.isConstructor() && contract.returnValue != MethodContract.ValueConstraint.THROW_EXCEPTION) {
      return "Invalid contract return value for a constructor: " + contract.returnValue;
    }
  }
  return null;
}
