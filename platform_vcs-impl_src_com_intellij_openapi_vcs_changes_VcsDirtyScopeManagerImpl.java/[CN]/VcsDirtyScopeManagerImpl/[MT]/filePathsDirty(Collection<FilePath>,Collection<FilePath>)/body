{
  try {
    final Collection<FilePathUnderVcs> filesConverted=convertPaths(filesDirty);
    final Collection<FilePathUnderVcs> dirsConverted=convertPaths(dirsRecursivelyDirty);
    if (filesConverted.isEmpty() && dirsConverted.isEmpty())     return;
    if (LOG.isDebugEnabled()) {
      LOG.debug("paths dirty: " + filesConverted + "; "+ dirsConverted+ "; "+ ReflectionUtil.findCallerClass(3));
    }
    final Ref<Boolean> hasSomethingDirty=Ref.create(true);
    boolean done=myLife.doIfAlive(new Runnable(){
      public void run(){
        for (        final FilePathUnderVcs root : filesConverted) {
          myDirtBuilder.addDirtyFile(root);
        }
        for (        final FilePathUnderVcs root : dirsConverted) {
          myDirtBuilder.addDirtyDirRecursively(root);
        }
        hasSomethingDirty.set(!myDirtBuilder.isEmpty());
      }
    }
);
    if (done && hasSomethingDirty.get()) {
      myChangeListManager.scheduleUpdate();
    }
  }
 catch (  ProcessCanceledException ignore) {
  }
}
