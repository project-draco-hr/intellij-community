{
  return new DataIndexer<String,Collection<IndexHolder>,FileContent>(){
    @NotNull @Override public Map<String,Collection<IndexHolder>> map(    @NotNull FileContent inputData){
      final CharSequence contentAsText=inputData.getContentAsText();
      if (!StringUtil.contains(contentAsText,"::") && !StringUtil.contains(contentAsText,"->")) {
        return Collections.emptyMap();
      }
      final PsiFile file=((FileContentImpl)inputData).getPsiFileForPsiDependentIndex();
      if (!(file instanceof PsiJavaFile) || !JavaStubElementTypes.JAVA_FILE.shouldBuildStubFor(inputData.getFile())) {
        return Collections.emptyMap();
      }
      final HashMap<String,Collection<IndexHolder>> methodsMap=ContainerUtil.newHashMap();
      for (      PsiFunctionalExpression expression : SyntaxTraverser.psiTraverser().withRoot(file).filter(PsiFunctionalExpression.class)) {
        final PsiExpressionList expressionList=PsiTreeUtil.getParentOfType(expression,PsiExpressionList.class,true,PsiStatement.class,PsiModifierListOwner.class);
        if (expressionList != null) {
          final PsiElement parent=expressionList.getParent();
          String methodName=null;
          if (parent instanceof PsiMethodCallExpression) {
            methodName=((PsiMethodCallExpression)parent).getMethodExpression().getReferenceName();
            if (methodName != null) {
              final boolean thisRef=methodName.equals(THIS_REF_NAME);
              if (thisRef || methodName.equals(SUPER_REF_NAME)) {
                methodName=null;
                final PsiClass containingClass=PsiTreeUtil.getParentOfType(parent,PsiClass.class);
                if (containingClass != null) {
                  if (thisRef) {
                    methodName=containingClass.getName();
                  }
 else {
                    final PsiReferenceList extendsList=containingClass.getExtendsList();
                    if (extendsList != null) {
                      final PsiJavaCodeReferenceElement[] referenceElements=extendsList.getReferenceElements();
                      if (referenceElements.length > 0) {
                        methodName=referenceElements[0].getReferenceName();
                      }
                    }
                  }
                }
              }
            }
          }
 else           if (parent instanceof PsiNewExpression) {
            final PsiJavaCodeReferenceElement classReference=((PsiNewExpression)parent).getClassOrAnonymousClassReference();
            if (classReference != null) {
              methodName=classReference.getReferenceName();
            }
          }
 else           if (parent instanceof PsiEnumConstant) {
            final PsiClass containingClass=((PsiEnumConstant)parent).getContainingClass();
            if (containingClass != null) {
              final String shortEnumName=containingClass.getName();
              if (shortEnumName != null) {
                methodName=shortEnumName;
              }
            }
          }
          if (methodName != null) {
            Collection<IndexHolder> holders=methodsMap.get(methodName);
            if (holders == null) {
              holders=new HashSet<IndexHolder>();
              methodsMap.put(methodName,holders);
            }
            holders.add(new IndexHolder(expression instanceof PsiLambdaExpression ? ((PsiLambdaExpression)expression).getParameterList().getParametersCount() : -1,expressionList.getExpressions().length,LambdaUtil.getLambdaIdx(expressionList,expression)));
          }
        }
      }
      return methodsMap;
    }
  }
;
}
