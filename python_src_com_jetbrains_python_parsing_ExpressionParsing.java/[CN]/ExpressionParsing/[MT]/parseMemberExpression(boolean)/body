{
  boolean recast_first_identifier=false;
  boolean recast_qualifier=false;
  do {
    boolean first_identifier_is_target=isTargetExpression && !recast_first_identifier;
    PsiBuilder.Marker expr=myBuilder.mark();
    if (!parsePrimaryExpression(first_identifier_is_target)) {
      expr.drop();
      return false;
    }
    while (true) {
      final IElementType tokenType=myBuilder.getTokenType();
      if (tokenType == PyTokenTypes.DOT) {
        if (first_identifier_is_target) {
          recast_first_identifier=true;
          expr.rollbackTo();
          break;
        }
 else         recast_first_identifier=false;
        myBuilder.advanceLexer();
        checkMatches(PyTokenTypes.IDENTIFIER,message("PARSE.expected.name"));
        if (isTargetExpression && !recast_qualifier && !atAnyOfTokens(PyTokenTypes.DOT,PyTokenTypes.LPAR,PyTokenTypes.LBRACKET)) {
          expr.done(PyElementTypes.TARGET_EXPRESSION);
        }
 else {
          expr.done(getReferenceType());
        }
        expr=expr.precede();
      }
 else       if (tokenType == PyTokenTypes.LPAR) {
        parseArgumentList();
        expr.done(PyElementTypes.CALL_EXPRESSION);
        expr=expr.precede();
      }
 else       if (tokenType == PyTokenTypes.LBRACKET) {
        myBuilder.advanceLexer();
        PsiBuilder.Marker sliceOrTupleStart=myBuilder.mark();
        PsiBuilder.Marker sliceItemStart=myBuilder.mark();
        if (atToken(PyTokenTypes.COLON)) {
          sliceOrTupleStart.drop();
          PsiBuilder.Marker sliceMarker=myBuilder.mark();
          sliceMarker.done(PyElementTypes.EMPTY_EXPRESSION);
          parseSliceEnd(expr,sliceItemStart);
        }
 else {
          parseSingleExpression(false);
          if (atToken(PyTokenTypes.COLON)) {
            sliceOrTupleStart.drop();
            parseSliceEnd(expr,sliceItemStart);
          }
 else           if (atToken(PyTokenTypes.COMMA)) {
            sliceItemStart.done(PyElementTypes.SLICE_ITEM);
            if (!parseSliceListTail(expr,sliceOrTupleStart)) {
              sliceOrTupleStart.rollbackTo();
              if (!parseTupleExpression(false,false,false)) {
                myBuilder.error("tuple expression expected");
              }
              checkMatches(PyTokenTypes.RBRACKET,message("PARSE.expected.rbracket"));
              expr.done(PyElementTypes.SUBSCRIPTION_EXPRESSION);
            }
          }
 else {
            sliceOrTupleStart.drop();
            sliceItemStart.drop();
            checkMatches(PyTokenTypes.RBRACKET,message("PARSE.expected.rbracket"));
            expr.done(PyElementTypes.SUBSCRIPTION_EXPRESSION);
            if (isTargetExpression && !recast_qualifier) {
              recast_first_identifier=true;
              recast_qualifier=true;
              expr.rollbackTo();
              break;
            }
          }
        }
        expr=expr.precede();
      }
 else {
        expr.drop();
        break;
      }
      recast_first_identifier=false;
    }
  }
 while (recast_first_identifier);
  return true;
}
