{
  boolean recast_first_identifier=false;
  boolean recast_qualifier=false;
  do {
    boolean first_identifier_is_target=isTargetExpression && !recast_first_identifier;
    PsiBuilder.Marker expr=myBuilder.mark();
    if (!parsePrimaryExpression(first_identifier_is_target)) {
      expr.drop();
      return false;
    }
    while (true) {
      final IElementType tokenType=myBuilder.getTokenType();
      if (tokenType == PyTokenTypes.DOT) {
        if (first_identifier_is_target) {
          recast_first_identifier=true;
          expr.rollbackTo();
          break;
        }
 else         recast_first_identifier=false;
        myBuilder.advanceLexer();
        checkMatches(PyTokenTypes.IDENTIFIER,message("PARSE.expected.name"));
        if (isTargetExpression && !recast_qualifier && myBuilder.getTokenType() != PyTokenTypes.DOT) {
          expr.done(PyElementTypes.TARGET_EXPRESSION);
        }
 else {
          expr.done(PyElementTypes.REFERENCE_EXPRESSION);
        }
        expr=expr.precede();
      }
 else       if (tokenType == PyTokenTypes.LPAR) {
        parseArgumentList();
        expr.done(PyElementTypes.CALL_EXPRESSION);
        expr=expr.precede();
      }
 else       if (tokenType == PyTokenTypes.LBRACKET) {
        myBuilder.advanceLexer();
        PsiBuilder.Marker sliceItemStart=myBuilder.mark();
        if (atToken(PyTokenTypes.COLON)) {
          PsiBuilder.Marker sliceMarker=myBuilder.mark();
          sliceMarker.done(PyElementTypes.EMPTY_EXPRESSION);
          parseSliceEnd(expr,sliceItemStart);
        }
 else {
          parseExpressionOptional();
          if (myBuilder.getTokenType() == PyTokenTypes.COLON) {
            parseSliceEnd(expr,sliceItemStart);
          }
 else {
            sliceItemStart.drop();
            checkMatches(PyTokenTypes.RBRACKET,message("PARSE.expected.rbracket"));
            expr.done(PyElementTypes.SUBSCRIPTION_EXPRESSION);
            if (isTargetExpression && !recast_qualifier) {
              recast_first_identifier=true;
              recast_qualifier=true;
              expr.rollbackTo();
              break;
            }
          }
        }
        expr=expr.precede();
      }
 else {
        expr.drop();
        break;
      }
      recast_first_identifier=false;
    }
  }
 while (recast_first_identifier);
  return true;
}
