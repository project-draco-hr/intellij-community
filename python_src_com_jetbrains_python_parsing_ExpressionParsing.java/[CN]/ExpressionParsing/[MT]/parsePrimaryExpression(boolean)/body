{
  final IElementType firstToken=myBuilder.getTokenType();
  if (firstToken == PyTokenTypes.IDENTIFIER) {
    if (isTargetExpression) {
      buildTokenElement(PyElementTypes.TARGET_EXPRESSION,myBuilder);
    }
 else {
      buildTokenElement(PyElementTypes.REFERENCE_EXPRESSION,myBuilder);
    }
    return true;
  }
 else   if (firstToken == PyTokenTypes.INTEGER_LITERAL) {
    buildTokenElement(PyElementTypes.INTEGER_LITERAL_EXPRESSION,myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.FLOAT_LITERAL) {
    buildTokenElement(PyElementTypes.FLOAT_LITERAL_EXPRESSION,myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.IMAGINARY_LITERAL) {
    buildTokenElement(PyElementTypes.IMAGINARY_LITERAL_EXPRESSION,myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.NONE_KEYWORD) {
    buildTokenElement(PyElementTypes.NONE_LITERAL_EXPRESSION,myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.TRUE_KEYWORD || firstToken == PyTokenTypes.FALSE_KEYWORD) {
    buildTokenElement(PyElementTypes.BOOL_LITERAL_EXPRESSION,myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.STRING_LITERAL) {
    final PsiBuilder.Marker marker=myBuilder.mark();
    while (myBuilder.getTokenType() == PyTokenTypes.STRING_LITERAL) {
      myBuilder.advanceLexer();
    }
    marker.done(PyElementTypes.STRING_LITERAL_EXPRESSION);
    return true;
  }
 else   if (firstToken == PyTokenTypes.LPAR) {
    parseParenthesizedExpression(isTargetExpression);
    return true;
  }
 else   if (firstToken == PyTokenTypes.LBRACKET) {
    parseListLiteralExpression(myBuilder,isTargetExpression);
    return true;
  }
 else   if (firstToken == PyTokenTypes.LBRACE) {
    parseDictOrSetDisplay();
    return true;
  }
 else   if (firstToken == PyTokenTypes.TICK) {
    parseReprExpression(myBuilder);
    return true;
  }
 else   if (firstToken == PyTokenTypes.DOT) {
    final PsiBuilder.Marker maybeEllipsis=myBuilder.mark();
    myBuilder.advanceLexer();
    if (matchToken(PyTokenTypes.DOT) && matchToken(PyTokenTypes.DOT)) {
      maybeEllipsis.done(PyElementTypes.NONE_LITERAL_EXPRESSION);
      return true;
    }
    maybeEllipsis.rollbackTo();
  }
  return false;
}
