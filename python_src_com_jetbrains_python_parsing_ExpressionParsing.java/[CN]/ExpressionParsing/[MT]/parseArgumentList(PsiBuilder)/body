{
  LOG.assertTrue(builder.getTokenType() == PyTokenTypes.LPAR);
  final PsiBuilder.Marker arglist=builder.mark();
  final PsiBuilder.Marker genexpr=builder.mark();
  builder.advanceLexer();
  int argNumber=0;
  boolean needBracket=true;
  while (builder.getTokenType() != PyTokenTypes.RPAR) {
    argNumber++;
    if (argNumber > 1) {
      if (argNumber == 2 && builder.getTokenType() == PyTokenTypes.FOR_KEYWORD) {
        parseListCompExpression(genexpr,PyTokenTypes.RPAR,PyElementTypes.GENERATOR_EXPRESSION);
        needBracket=false;
        break;
      }
 else       if (builder.getTokenType() == PyTokenTypes.COMMA) {
        builder.advanceLexer();
        if (builder.getTokenType() == PyTokenTypes.RPAR) {
          break;
        }
      }
 else {
        builder.error(", or ) expected");
        break;
      }
    }
    if (builder.getTokenType() == PyTokenTypes.MULT || builder.getTokenType() == PyTokenTypes.EXP) {
      final PsiBuilder.Marker starArgMarker=builder.mark();
      builder.advanceLexer();
      if (!parseSingleExpression(false)) {
        builder.error("expression expected");
      }
      starArgMarker.done(PyElementTypes.STAR_ARGUMENT_EXPRESSION);
    }
 else {
      if (builder.getTokenType() == PyTokenTypes.IDENTIFIER) {
        final PsiBuilder.Marker keywordArgMarker=builder.mark();
        builder.advanceLexer();
        if (builder.getTokenType() == PyTokenTypes.EQ) {
          builder.advanceLexer();
          if (!parseSingleExpression(false)) {
            builder.error("expression expected");
          }
          keywordArgMarker.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
          continue;
        }
        keywordArgMarker.rollbackTo();
      }
      if (!parseSingleExpression(false)) {
        builder.error("expression expected");
      }
    }
  }
  if (needBracket) {
    genexpr.drop();
    checkMatches(PyTokenTypes.RPAR,") expected");
  }
  arglist.done(PyElementTypes.ARGUMENT_LIST);
}
