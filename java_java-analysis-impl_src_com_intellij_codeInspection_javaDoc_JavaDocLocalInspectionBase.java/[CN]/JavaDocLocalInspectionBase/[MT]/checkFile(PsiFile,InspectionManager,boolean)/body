{
  if (!PsiPackage.PACKAGE_INFO_FILE.equals(file.getName()) || !(file instanceof PsiJavaFile)) {
    return null;
  }
  final PsiDocComment docComment=PsiTreeUtil.getChildOfType(file,PsiDocComment.class);
  final JavaDirectoryService directoryService=JavaDirectoryService.getInstance();
  final PsiDirectory directory=file.getContainingDirectory();
  final PsiPackage aPackage=directoryService.getPackage(directory);
  if (IGNORE_DEPRECATED && aPackage != null) {
    final PsiModifierList modifierList=aPackage.getModifierList();
    if (modifierList != null && modifierList.findAnnotation("java.lang.Deprecated") != null) {
      return null;
    }
  }
  final PsiJavaFile javaFile=(PsiJavaFile)file;
  final PsiPackageStatement packageStatement=javaFile.getPackageStatement();
  final PsiElement elementToHighlight=packageStatement != null ? packageStatement : file;
  final boolean required=aPackage != null && isJavaDocRequired(aPackage);
  if (docComment != null) {
    if (IGNORE_DEPRECATED && docComment.findTagByName("deprecated") != null) {
      return null;
    }
  }
 else {
    return required ? new ProblemDescriptor[]{createRequiredJavadocAbsentDescription(elementToHighlight,manager,isOnTheFly)} : null;
  }
  final PsiDocTag[] tags=docComment.getTags();
  final List<ProblemDescriptor> problems=getRequiredTagProblems(aPackage,docComment.getFirstChild(),tags,manager,isOnTheFly,required);
  final List<ProblemDescriptor> tagProblems=getTagValuesProblems(aPackage,tags,manager,isOnTheFly);
  if (tagProblems != null) {
    problems.addAll(tagProblems);
  }
  checkInlineTags(manager,problems,docComment.getDescriptionElements(),JavadocManager.SERVICE.getInstance(docComment.getProject()),isOnTheFly);
  checkForPeriodInDoc(aPackage,docComment,problems,manager,isOnTheFly);
  checkForBadCharacters(docComment,problems,manager,isOnTheFly);
  return problems.isEmpty() ? null : problems.toArray(new ProblemDescriptor[problems.size()]);
}
