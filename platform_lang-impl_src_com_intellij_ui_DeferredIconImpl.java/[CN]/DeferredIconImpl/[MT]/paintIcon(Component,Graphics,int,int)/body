{
  if (!(myDelegateIcon instanceof DeferredIconImpl && ((DeferredIconImpl)myDelegateIcon).myDelegateIcon instanceof DeferredIconImpl)) {
    myDelegateIcon.paintIcon(c,g,x,y);
  }
  if (isDone() || myIsScheduled || PowerSaveMode.isEnabled()) {
    return;
  }
  myIsScheduled=true;
  final Component target=getTarget(c);
  final Component paintingParent=SwingUtilities.getAncestorOfClass(PaintingParent.class,c);
  final Rectangle paintingParentRec=paintingParent == null ? null : ((PaintingParent)paintingParent).getChildRec(c);
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      int oldWidth=myDelegateIcon.getIconWidth();
      final Icon[] evaluated=new Icon[1];
      final Runnable evalRunnable=new Runnable(){
        @Override public void run(){
          try {
            evaluated[0]=nonNull(myEvaluator.fun(myParam));
          }
 catch (          ProcessCanceledException e) {
            evaluated[0]=EMPTY_ICON;
          }
catch (          IndexNotReadyException e) {
            evaluated[0]=EMPTY_ICON;
          }
        }
      }
;
      final long startTime=System.currentTimeMillis();
      if (myNeedReadAction) {
        final ProgressIndicatorBase progress=new ProgressIndicatorBase();
        final ApplicationAdapter listener=new ApplicationAdapter(){
          @Override public void beforeWriteActionStart(          Object action){
            progress.cancel();
          }
        }
;
        ApplicationManager.getApplication().invokeAndWait(new Runnable(){
          @Override public void run(){
            ApplicationManager.getApplication().addApplicationListener(listener);
          }
        }
,ModalityState.any());
        try {
          final Ref<Boolean> cancelled=new Ref<Boolean>();
          ProgressManager.getInstance().runProcess(new Runnable(){
            @Override public void run(){
              if (!ApplicationManagerEx.getApplicationEx().tryRunReadAction(new Runnable(){
                @Override public void run(){
                  IconDeferrerImpl.evaluateDeferred(evalRunnable);
                  if (myAutoUpdatable) {
                    myLastCalcTime=System.currentTimeMillis();
                    myLastTimeSpent=myLastCalcTime - startTime;
                  }
                }
              }
)) {
                myIsScheduled=false;
                cancelled.set(Boolean.TRUE);
              }
            }
          }
,progress);
          if (cancelled.get() == Boolean.TRUE)           return;
        }
 catch (        ProcessCanceledException e) {
        }
 finally {
          ApplicationManager.getApplication().removeApplicationListener(listener);
        }
      }
 else {
        IconDeferrerImpl.evaluateDeferred(evalRunnable);
        if (myAutoUpdatable) {
          myLastCalcTime=System.currentTimeMillis();
          myLastTimeSpent=myLastCalcTime - startTime;
        }
      }
      final Icon result=evaluated[0];
      myDelegateIcon=result;
      final boolean shouldRevalidate=Registry.is("ide.tree.deferred.icon.invalidates.cache") && myDelegateIcon.getIconWidth() != oldWidth;
      ourLaterInvocator.offer(new Runnable(){
        @Override public void run(){
          setDone(result);
          Component actualTarget=target;
          if (actualTarget != null && SwingUtilities.getWindowAncestor(actualTarget) == null) {
            actualTarget=paintingParent;
            if (actualTarget == null || SwingUtilities.getWindowAncestor(actualTarget) == null) {
              actualTarget=null;
            }
          }
          if (actualTarget == null)           return;
          if (shouldRevalidate) {
            if (actualTarget instanceof JTree) {
              final TreeUI ui=((JTree)actualTarget).getUI();
              if (ui instanceof BasicTreeUI) {
                ((BasicTreeUI)ui).setLeftChildIndent(UIUtil.getTreeLeftChildIndent());
              }
            }
          }
          if (c == actualTarget) {
            c.repaint(x,y,getIconWidth(),getIconHeight());
          }
 else {
            ourRepaintScheduler.pushDirtyComponent(actualTarget,paintingParentRec);
          }
        }
      }
);
    }
  }
);
}
