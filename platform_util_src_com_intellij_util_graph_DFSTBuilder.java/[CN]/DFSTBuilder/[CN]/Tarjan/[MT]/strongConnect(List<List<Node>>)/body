{
  int successor=-1;
  nextNode:   while (!frames.isEmpty()) {
    Frame pair=frames.peek();
    int i=pair.nodeI;
    if (index[i] == -1) {
      index[i]=dfsIndex;
      lowLink[i]=dfsIndex;
      dfsIndex++;
      nodesOnStack.push(i);
      isOnStack[i]=true;
    }
    if (ArrayUtil.indexOf(pair.out,successor) != -1) {
      lowLink[i]=Math.min(lowLink[i],lowLink[successor]);
    }
    successor=i;
    while (pair.nextUnexploredIndex < pair.out.length) {
      int nextI=pair.out[pair.nextUnexploredIndex++];
      if (index[nextI] == -1) {
        frames.push(new Frame(nextI));
        continue nextNode;
      }
      if (isOnStack[nextI]) {
        lowLink[i]=Math.min(lowLink[i],index[nextI]);
        if (myBackEdge == null) {
          myBackEdge=Couple.of(myAllNodes[nextI],myAllNodes[i]);
        }
      }
    }
    frames.pop();
    topo.add(i);
    if (lowLink[i] == index[i]) {
      List<Node> scc=new ArrayList<Node>();
      int pushedI;
      do {
        pushedI=nodesOnStack.pop();
        Node pushed=myAllNodes[pushedI];
        isOnStack[pushedI]=false;
        scc.add(pushed);
      }
 while (pushedI != i);
      sccs.add(scc);
    }
  }
}
