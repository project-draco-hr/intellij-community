{
  List<Task> issues=null;
  for (  final TaskRepository repository : getAllRepositories()) {
    if (!repository.isConfigured() || (!forceRequest && myBadRepositories.contains(repository))) {
      continue;
    }
    try {
      long start=System.currentTimeMillis();
      Task[] tasks=repository.getIssues(request,offset,limit,withClosed,cancelled);
      long timeSpent=System.currentTimeMillis() - start;
      LOG.debug(String.format("Total %s ms to download %d issues from '%s'",timeSpent,tasks.length,repository.getUrl()));
      myBadRepositories.remove(repository);
      if (issues == null)       issues=new ArrayList<Task>(tasks.length);
      if (!repository.isSupported(TaskRepository.NATIVE_SEARCH) && request != null) {
        List<Task> filteredTasks=TaskSearchSupport.filterTasks(request,ContainerUtil.list(tasks));
        ContainerUtil.addAll(issues,filteredTasks);
      }
 else {
        ContainerUtil.addAll(issues,tasks);
      }
    }
 catch (    ProcessCanceledException ignored) {
    }
catch (    Exception e) {
      String reason="";
      if (e.getClass() == Exception.class) {
        reason=e.getMessage();
      }
      if (e instanceof SocketTimeoutException) {
        LOG.warn("Socket timeout from " + repository);
      }
 else {
        LOG.warn("Cannot connect to " + repository,e);
      }
      myBadRepositories.add(repository);
      if (forceRequest) {
        notifyAboutConnectionFailure(repository,reason);
      }
    }
  }
  return issues;
}
