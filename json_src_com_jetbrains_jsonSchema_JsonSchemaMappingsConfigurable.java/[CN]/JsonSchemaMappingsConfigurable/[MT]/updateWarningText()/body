{
  final MultiMap<String,JsonSchemaMappingsConfigurationBase.Item> patternsMap=new MultiMap<>();
  final StringBuilder sb=new StringBuilder();
  final List<JsonSchemaMappingsConfigurationBase.SchemaInfo> list;
  try {
    list=getUiList(false);
  }
 catch (  ConfigurationException e) {
    return;
  }
  for (  JsonSchemaMappingsConfigurationBase.SchemaInfo info : list) {
    final JsonSchemaPatternComparator comparator=new JsonSchemaPatternComparator(myProject);
    final List<JsonSchemaMappingsConfigurationBase.Item> patterns=info.getPatterns();
    for (    JsonSchemaMappingsConfigurationBase.Item pattern : patterns) {
      for (      Map.Entry<String,Collection<JsonSchemaMappingsConfigurationBase.Item>> entry : patternsMap.entrySet()) {
        for (        JsonSchemaMappingsConfigurationBase.Item item : entry.getValue()) {
          final ThreeState similar=comparator.isSimilar(pattern,item);
          if (ThreeState.NO.equals(similar))           continue;
          if (sb.length() > 0)           sb.append('\n');
          sb.append("'").append(pattern.getPresentation()).append("' for schema '").append(info.getName()).append("' and '").append(item.getPresentation()).append("' for schema '").append(entry.getKey()).append("'");
        }
      }
    }
    patternsMap.put(info.getName(),patterns);
  }
  if (sb.length() > 0) {
    myError="Conflicting mappings:\n" + sb.toString();
  }
 else {
    myError=null;
  }
  final Enumeration children=myRoot.children();
  while (children.hasMoreElements()) {
    Object o=children.nextElement();
    if (o instanceof MyNode && ((MyNode)o).getConfigurable() instanceof JsonSchemaConfigurable) {
      ((JsonSchemaConfigurable)((MyNode)o).getConfigurable()).setError(myError);
    }
  }
}
