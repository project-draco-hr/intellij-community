{
  if (!Registry.is("editor.richcopy.enable")) {
    return null;
  }
  try {
    for (    TextWithMarkupBuilder builder : myBuilders) {
      builder.reset();
    }
    RichCopySettings settings=RichCopySettings.getInstance();
    Document document=editor.getDocument();
    final int indentSymbolsToStrip;
    final int firstLineStartOffset;
    if (settings.isStripIndents() && startOffsets.length == 1) {
      Pair<Integer,Integer> p=calcIndentSymbolsToStrip(document,startOffsets[0],endOffsets[0]);
      firstLineStartOffset=p.first;
      indentSymbolsToStrip=p.second;
    }
 else {
      firstLineStartOffset=startOffsets[0];
      indentSymbolsToStrip=0;
    }
    logInitial(document,startOffsets,endOffsets,indentSymbolsToStrip,firstLineStartOffset);
    CharSequence text=document.getCharsSequence();
    EditorColorsScheme schemeToUse=settings.getColorsScheme(editor.getColorsScheme());
    EditorHighlighter highlighter=HighlighterFactory.createHighlighter(file.getVirtualFile(),schemeToUse,file.getProject());
    highlighter.setText(text);
    MarkupModel markupModel=DocumentMarkupModel.forDocument(document,file.getProject(),false);
    Context context=new Context(text,schemeToUse,indentSymbolsToStrip);
    for (int i=0; i < startOffsets.length; i++) {
      int startOffsetToUse;
      if (i == 0) {
        startOffsetToUse=firstLineStartOffset;
      }
 else {
        startOffsetToUse=startOffsets[i];
        context.outputInfos.add(new Text('\n'));
      }
      int endOffsetToUse=endOffsets[i];
      context.reset();
      if (endOffsetToUse <= startOffsetToUse) {
        continue;
      }
      DisposableIterator<SegmentInfo> it=aggregateSyntaxInfo(schemeToUse,wrap(highlighter,text,schemeToUse,startOffsetToUse,endOffsetToUse),wrap(markupModel,text,schemeToUse,startOffsetToUse,endOffsetToUse));
      try {
        while (it.hasNext()) {
          SegmentInfo info=it.next();
          if (info.startOffset >= endOffsetToUse) {
            break;
          }
          context.onNewData(info);
        }
      }
  finally {
        it.dispose();
      }
      context.onIterationEnd(endOffsetToUse);
    }
    SyntaxInfo syntaxInfo=context.finish();
    logSyntaxInfo(syntaxInfo);
    for (    TextWithMarkupBuilder builder : myBuilders) {
      builder.build(text,syntaxInfo);
    }
  }
 catch (  Exception e) {
    LOG.error(e);
  }
  return null;
}
