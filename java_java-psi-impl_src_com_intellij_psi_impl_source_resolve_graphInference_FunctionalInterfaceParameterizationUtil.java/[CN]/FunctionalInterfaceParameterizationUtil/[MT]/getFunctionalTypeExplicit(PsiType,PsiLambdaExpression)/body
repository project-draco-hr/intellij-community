{
  final PsiParameter[] lambdaParams=expr.getParameterList().getParameters();
  if (psiClassType instanceof PsiIntersectionType) {
    for (    PsiType psiType : ((PsiIntersectionType)psiClassType).getConjuncts()) {
      final PsiType functionalType=getFunctionalTypeExplicit(psiType,expr);
      if (functionalType != null)       return functionalType;
    }
    return null;
  }
  LOG.assertTrue(psiClassType instanceof PsiClassType,"Unexpected type: " + psiClassType);
  final PsiType[] parameters=((PsiClassType)psiClassType).getParameters();
  final PsiClassType.ClassResolveResult resolveResult=((PsiClassType)psiClassType).resolveGenerics();
  PsiClass psiClass=resolveResult.getElement();
  if (psiClass != null) {
    final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
    if (interfaceMethod == null)     return null;
    PsiTypeParameter[] typeParameters=psiClass.getTypeParameters();
    if (typeParameters.length != parameters.length) {
      return null;
    }
    final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(psiClass.getProject());
    final PsiParameter[] targetMethodParams=interfaceMethod.getParameterList().getParameters();
    if (targetMethodParams.length != lambdaParams.length) {
      return null;
    }
    final InferenceSession session=new InferenceSession(typeParameters,PsiSubstitutor.EMPTY,expr.getManager(),expr);
    for (int i=0; i < targetMethodParams.length; i++) {
      session.addConstraint(new TypeEqualityConstraint(lambdaParams[i].getType(),targetMethodParams[i].getType()));
    }
    if (!session.repeatInferencePhases(false)) {
      return null;
    }
    final PsiSubstitutor substitutor=session.resolveDependencies(session.getInferenceVariables());
    final PsiType[] newTypeParameters=new PsiType[parameters.length];
    for (int i=0; i < typeParameters.length; i++) {
      PsiTypeParameter typeParameter=typeParameters[i];
      if (substitutor.getSubstitutionMap().containsKey(typeParameter)) {
        newTypeParameters[i]=substitutor.substitute(typeParameter);
      }
 else {
        newTypeParameters[i]=parameters[i];
      }
    }
    final PsiClassType parameterization=elementFactory.createType(psiClass,newTypeParameters);
    if (!isWellFormed(psiClass,typeParameters,newTypeParameters)) {
      return null;
    }
    if (!TypeConversionUtil.containsWildcards(parameterization)) {
      return parameterization;
    }
    if (!parameterization.isAssignableFrom(psiClassType)) {
      return null;
    }
    return getNonWildcardParameterization(parameterization);
  }
  return null;
}
