{
  if (StringUtil.isEmptyOrSpaces(line))   return null;
  if (line.startsWith(MERGING) || line.startsWith(RECORDING_MERGE_INFO)) {
    return null;
  }
 else   if (line.startsWith(UPDATING)) {
    myCurrentFile=parseForPath(line);
    return new ProgressEvent(myCurrentFile,-1,null,null,SVNEventAction.UPDATE_NONE,null,null);
  }
 else   if (line.startsWith(RESTORED)) {
    myCurrentFile=parseForPath(line);
    return new ProgressEvent(myCurrentFile,-1,null,null,SVNEventAction.RESTORE,null,null);
  }
 else   if (line.startsWith(SKIPPED)) {
    myCurrentFile=parseForPath(line);
    final String comment=parseComment(line);
    return new ProgressEvent(myCurrentFile,-1,null,null,SVNEventAction.SKIP,comment == null ? null : SVNErrorMessage.create(SVNErrorCode.WC_OBSTRUCTED_UPDATE,comment),null);
  }
 else   if (line.startsWith(FETCHING_EXTERNAL)) {
    myCurrentFile=parseForPath(line);
    return new ProgressEvent(myCurrentFile,-1,null,null,SVNEventAction.UPDATE_EXTERNAL,null,null);
  }
  for (int i=0; i < ourCompletePatterns.length; i++) {
    final Pattern pattern=ourCompletePatterns[i];
    final long revision=matchAndGetRevision(pattern,line);
    if (revision != -1) {
      return new ProgressEvent(myCurrentFile,revision,null,null,SVNEventAction.UPDATE_COMPLETED,null,null);
    }
  }
  return parseNormalString(line);
}
