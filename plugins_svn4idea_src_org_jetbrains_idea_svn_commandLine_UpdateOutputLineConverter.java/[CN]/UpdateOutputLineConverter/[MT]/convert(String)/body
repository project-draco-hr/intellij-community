{
  if (StringUtil.isEmptyOrSpaces(line))   return null;
  if (line.startsWith(MERGING) || line.startsWith(RECORDING_MERGE_INFO)) {
    return null;
  }
 else   if (line.startsWith(UPDATING)) {
    myRootsUnderProcessing.push(parseForPath(line));
    return new ProgressEvent(myRootsUnderProcessing.peek(),-1,null,null,EventAction.UPDATE_NONE,null,null);
  }
 else   if (line.startsWith(RESTORED)) {
    return new ProgressEvent(parseForPath(line),-1,null,null,EventAction.RESTORE,null,null);
  }
 else   if (line.startsWith(SKIPPED)) {
    final String comment=parseComment(line);
    return new ProgressEvent(parseForPath(line),-1,null,null,EventAction.SKIP,comment == null ? null : SVNErrorMessage.create(SVNErrorCode.WC_OBSTRUCTED_UPDATE,comment),null);
  }
 else   if (line.startsWith(FETCHING_EXTERNAL)) {
    myRootsUnderProcessing.push(parseForPath(line));
    return new ProgressEvent(myRootsUnderProcessing.peek(),-1,null,null,EventAction.UPDATE_EXTERNAL,null,null);
  }
  for (int i=0; i < ourCompletePatterns.length; i++) {
    final Pattern pattern=ourCompletePatterns[i];
    final long revision=matchAndGetRevision(pattern,line);
    if (revision != -1) {
      File currentRoot=myRootsUnderProcessing.size() > 0 ? myRootsUnderProcessing.pop() : myBase;
      return new ProgressEvent(currentRoot,revision,null,null,EventAction.UPDATE_COMPLETED,null,null);
    }
  }
  return parseNormalString(line);
}
