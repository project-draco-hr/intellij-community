{
  if (!method.hasModifierProperty(PsiModifier.PUBLIC))   return null;
  if (method.hasModifierProperty(PsiModifier.STATIC))   return null;
  final PsiClass containingClass=method.getContainingClass();
  boolean hasSubClass=containingClass != null && !containingClass.isInterface() && subClassCache.get(containingClass) != null;
  if (!hasSubClass) {
    return null;
  }
  if (CommonClassNames.JAVA_LANG_OBJECT.equals(containingClass.getQualifiedName())) {
    return null;
  }
  final Collection<PsiAnchor> checkedInterfaces=new THashSet<PsiAnchor>();
  checkedInterfaces.add(PsiAnchor.create(containingClass));
  final Ref<Pair<PsiMethod,PsiClass>> result=Ref.create();
  ClassInheritorsSearch.search(containingClass,containingClass.getUseScope(),true,true,false).forEach(new Processor<PsiClass>(){
    @Override public boolean process(    PsiClass inheritor){
      ProgressManager.checkCanceled();
      for (      PsiClassType interfaceType : inheritor.getImplementsListTypes()) {
        ProgressManager.checkCanceled();
        PsiClassType.ClassResolveResult resolved=interfaceType.resolveGenerics();
        PsiClass anInterface=resolved.getElement();
        if (anInterface == null || !checkedInterfaces.add(PsiAnchor.create(anInterface)))         continue;
        for (        PsiMethod superMethod : anInterface.findMethodsByName(method.getName(),true)) {
          PsiElement navigationElement=superMethod.getNavigationElement();
          if (!(navigationElement instanceof PsiMethod))           continue;
          superMethod=(PsiMethod)navigationElement;
          ProgressManager.checkCanceled();
          PsiClass superInterface=superMethod.getContainingClass();
          if (superInterface == null) {
            continue;
          }
          if (containingClass.isInheritor(superInterface,true)) {
            continue;
          }
          PsiSubstitutor substitutor=TypeConversionUtil.getSuperClassSubstitutor(containingClass,inheritor,PsiSubstitutor.EMPTY);
          substitutor=TypeConversionUtil.getSuperClassSubstitutor(superInterface,inheritor,substitutor);
          final MethodSignature superSignature=superMethod.getSignature(substitutor);
          final MethodSignature derivedSignature=method.getSignature(PsiSubstitutor.EMPTY);
          boolean isOverridden=MethodSignatureUtil.isSubsignature(superSignature,derivedSignature);
          if (!isOverridden) {
            continue;
          }
          result.set(Pair.create(superMethod,inheritor));
          return false;
        }
      }
      return true;
    }
  }
);
  return result.get();
}
