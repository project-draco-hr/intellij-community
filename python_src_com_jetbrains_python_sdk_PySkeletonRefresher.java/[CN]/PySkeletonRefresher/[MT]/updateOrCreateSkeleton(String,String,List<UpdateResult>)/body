{
  final File skeleton=getSkeleton(moduleName,getSkeletonsPath());
  final File binary=new File(moduleLibName);
  Matcher matcher=getParseHeader(skeleton);
  boolean must_rebuild=true;
  if (matcher != null && matcher.matches()) {
    int file_version=fromVersionString(matcher.group(2));
    int required_version=myVersionChecker.getRequiredVersion(moduleName);
    must_rebuild=file_version < required_version;
  }
  final long lib_file_timestamp=binary.lastModified();
  if (!must_rebuild) {
    must_rebuild=(binary.exists() && skeleton.exists() && lib_file_timestamp > skeleton.lastModified());
  }
  if (myBlacklist != null) {
    Pair<Integer,Long> version_info=myBlacklist.get(moduleLibName);
    if (version_info != null) {
      int failed_generator_version=version_info.getFirst();
      long failed_timestamp=version_info.getSecond();
      must_rebuild&=failed_generator_version < myGeneratorVersion || failed_timestamp < lib_file_timestamp;
      if (!must_rebuild) {
        error_list.add(new UpdateResult(moduleName,moduleLibName,lib_file_timestamp,false));
      }
    }
  }
  if (must_rebuild) {
    indicateMinor(moduleName);
    if (myPregeneratedSkeletons != null && copyPregeneratedSkeleton(moduleName)) {
      return true;
    }
    LOG.info("Skeleton for " + moduleName);
    if (!generateSkeleton(moduleName,moduleLibName,null)) {
      error_list.add(new UpdateResult(moduleName,moduleLibName,lib_file_timestamp,true));
    }
  }
  return false;
}
