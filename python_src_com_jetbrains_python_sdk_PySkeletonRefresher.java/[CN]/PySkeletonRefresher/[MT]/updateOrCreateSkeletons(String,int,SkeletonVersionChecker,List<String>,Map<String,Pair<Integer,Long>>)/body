{
  final List<UpdateResult> error_list=new SmartList<UpdateResult>();
  final Iterator<String> bin_iter=binaries.iterator();
  bin_iter.next();
  final int count=Math.max(0,binaries.size() - 1);
  int i=0;
  while (bin_iter.hasNext()) {
    checkCanceled();
    if (myIndicator != null) {
      myIndicator.setFraction((double)i / count);
    }
    final String line=bin_iter.next();
    int cutpos=line.indexOf(' ');
    if (cutpos < 0)     LOG.error("Bad binaries line: '" + line + "', SDK "+ binaryPath);
 else {
      String moduleName=line.substring(0,cutpos);
      String module_lib_name=line.substring(cutpos + 1);
      final String modulePath=moduleName.replace('.','/');
      String skeletonPath=getSkeletonPath();
      File skeleton_file=new File(skeletonPath,modulePath + ".py");
      if (!skeleton_file.exists()) {
        skeleton_file=new File(new File(skeletonPath,modulePath),PyNames.INIT_DOT_PY);
      }
      File lib_file=new File(module_lib_name);
      Matcher matcher=getParseHeader(skeleton_file);
      boolean must_rebuild=true;
      if (matcher != null && matcher.matches()) {
        int file_version=SkeletonVersionChecker.fromVersionString(matcher.group(2));
        int required_version=checker.getRequiredVersion(moduleName);
        must_rebuild=file_version < required_version;
      }
      final long lib_file_timestamp=lib_file.lastModified();
      if (!must_rebuild) {
        must_rebuild=(lib_file.exists() && skeleton_file.exists() && lib_file_timestamp > skeleton_file.lastModified());
      }
      if (blacklist != null) {
        Pair<Integer,Long> version_info=blacklist.get(module_lib_name);
        if (version_info != null) {
          int failed_generator_version=version_info.getFirst();
          long failed_timestamp=version_info.getSecond();
          must_rebuild&=failed_generator_version < generator_version || failed_timestamp < lib_file_timestamp;
          if (!must_rebuild) {
            error_list.add(new UpdateResult(moduleName,module_lib_name,lib_file_timestamp,false));
          }
        }
      }
      if (must_rebuild) {
        indicateMinor(moduleName);
        if (myPregeneratedSkeletons != null && copyPregeneratedSkeleton(moduleName)) {
          continue;
        }
        LOG.info("Skeleton for " + moduleName);
        if (!generateSkeleton(moduleName,module_lib_name,null)) {
          error_list.add(new UpdateResult(moduleName,module_lib_name,lib_file_timestamp,true));
        }
      }
    }
    i++;
  }
  return error_list;
}
