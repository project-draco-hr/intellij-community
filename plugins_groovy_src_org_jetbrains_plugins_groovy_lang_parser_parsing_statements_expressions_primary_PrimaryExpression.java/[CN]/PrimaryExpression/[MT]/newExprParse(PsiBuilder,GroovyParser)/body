{
  ParserUtils.getToken(builder,GroovyTokenTypes.kNEW);
  ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
  PsiBuilder.Marker rb=builder.mark();
  TypeArguments.parseTypeArguments(builder,false);
  if (!TokenSets.BUILT_IN_TYPES.contains(builder.getTokenType()) && GroovyTokenTypes.mIDENT != builder.getTokenType()) {
    rb.rollbackTo();
  }
 else {
    rb.drop();
  }
  PsiBuilder.Marker anonymousMarker=builder.mark();
  String name;
  if (TokenSets.BUILT_IN_TYPES.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,GroovyElementTypes.BUILT_IN_TYPE);
    name=null;
  }
 else   if (TokenSets.CODE_REFERENCE_ELEMENT_NAME_TOKENS.contains(builder.getTokenType())) {
    name=builder.getTokenText();
    ReferenceElement.parse(builder,false,true,false,true,true);
  }
 else {
    builder.error(GroovyBundle.message("type.specification.expected"));
    anonymousMarker.drop();
    return GroovyElementTypes.NEW_EXPRESSION;
  }
  if (builder.getTokenType() == GroovyTokenTypes.mLPAREN || ParserUtils.lookAhead(builder,GroovyTokenTypes.mNLS,GroovyTokenTypes.mLPAREN)) {
    ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    methodCallArgsParse(builder,parser);
    if (builder.getTokenType() == GroovyTokenTypes.mLCURLY || ParserUtils.lookAhead(builder,GroovyTokenTypes.mNLS,GroovyTokenTypes.mLCURLY)) {
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
      TypeDefinition.parseBody(builder,name,parser,false);
      anonymousMarker.done(GroovyElementTypes.ANONYMOUS_CLASS_DEFINITION);
      return GroovyElementTypes.NEW_EXPRESSION;
    }
  }
 else   if (builder.getTokenType() == GroovyTokenTypes.mLBRACK) {
    PsiBuilder.Marker forArray=builder.mark();
    ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    ParserUtils.getToken(builder,GroovyTokenTypes.mLBRACK);
    if (!AssignmentExpression.parse(builder,parser)) {
      builder.error(GroovyBundle.message("expression.expected"));
    }
    ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
    ParserUtils.getToken(builder,GroovyTokenTypes.mRBRACK,GroovyBundle.message("rbrack.expected"));
    while (ParserUtils.getToken(builder,GroovyTokenTypes.mLBRACK)) {
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
      AssignmentExpression.parse(builder,parser);
      ParserUtils.getToken(builder,GroovyTokenTypes.mNLS);
      ParserUtils.getToken(builder,GroovyTokenTypes.mRBRACK,GroovyBundle.message("rbrack.expected"));
    }
    forArray.done(GroovyElementTypes.ARRAY_DECLARATOR);
  }
 else {
    builder.error(GroovyBundle.message("lparen.expected"));
  }
  anonymousMarker.drop();
  return GroovyElementTypes.NEW_EXPRESSION;
}
