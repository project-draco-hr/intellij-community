{
  if (myT instanceof PsiWildcardType && myS instanceof PsiWildcardType) {
    final PsiType tBound=((PsiWildcardType)myT).getBound();
    final PsiType sBound=((PsiWildcardType)myS).getBound();
    if (tBound == null && sBound == null)     return true;
    if (sBound == null && ((PsiWildcardType)myT).isExtends()) {
      constraints.add(new TypeEqualityConstraint(((PsiWildcardType)myS).getExtendsBound(),tBound));
      return true;
    }
    if (tBound == null && ((PsiWildcardType)myS).isExtends()) {
      constraints.add(new TypeEqualityConstraint(((PsiWildcardType)myT).getExtendsBound(),sBound));
      return true;
    }
    if (((PsiWildcardType)myT).isExtends() && ((PsiWildcardType)myS).isExtends() || ((PsiWildcardType)myT).isSuper() && ((PsiWildcardType)myS).isSuper()) {
      LOG.assertTrue(tBound != null);
      LOG.assertTrue(sBound != null);
      constraints.add(new TypeEqualityConstraint(tBound,sBound));
      return true;
    }
  }
  if (myT instanceof PsiWildcardType || myS instanceof PsiWildcardType) {
    session.registerIncompatibleErrorMessage("Incompatible equality constraint: " + session.getPresentableText(myT) + " and "+ session.getPresentableText(myS));
    return false;
  }
  if (session.isProperType(myT) && session.isProperType(myS)) {
    final boolean equal=Comparing.equal(myT,myS);
    if (!equal) {
      session.registerIncompatibleErrorMessage("Incompatible equality constraint: " + session.getPresentableText(myT) + " and "+ session.getPresentableText(myS));
    }
    return equal;
  }
  if (myT == null || myT == PsiType.NULL)   return false;
  if (myS == null || myS == PsiType.NULL)   return false;
  InferenceVariable inferenceVariable=session.getInferenceVariable(myS);
  if (inferenceVariable != null && !(myT instanceof PsiPrimitiveType)) {
    inferenceVariable.addBound(myT,InferenceBound.EQ,session.myIncorporationPhase);
    return true;
  }
  inferenceVariable=session.getInferenceVariable(myT);
  if (inferenceVariable != null && !(myS instanceof PsiPrimitiveType)) {
    inferenceVariable.addBound(myS,InferenceBound.EQ,session.myIncorporationPhase);
    return true;
  }
  if (myT instanceof PsiClassType && myS instanceof PsiClassType) {
    final PsiClassType.ClassResolveResult tResult=((PsiClassType)myT).resolveGenerics();
    final PsiClassType.ClassResolveResult sResult=((PsiClassType)myS).resolveGenerics();
    final PsiClass tClass=tResult.getElement();
    if (tClass != null && tClass.getManager().areElementsEquivalent(tClass,sResult.getElement())) {
      final PsiSubstitutor tSubstitutor=tResult.getSubstitutor();
      final PsiSubstitutor sSubstitutor=sResult.getSubstitutor();
      for (      PsiTypeParameter typeParameter : tClass.getTypeParameters()) {
        final PsiType tSubstituted=tSubstitutor.substitute(typeParameter);
        final PsiType sSubstituted=sSubstitutor.substitute(typeParameter);
        if (tSubstituted != null && sSubstituted != null) {
          constraints.add(new TypeEqualityConstraint(tSubstituted,sSubstituted));
        }
        if (tSubstituted == null ^ sSubstituted == null) {
          session.registerIncompatibleErrorMessage("Incompatible equality constraint: " + session.getPresentableText(myT) + " and "+ session.getPresentableText(myS));
          return false;
        }
      }
      return true;
    }
  }
  if (myT instanceof PsiArrayType && myS instanceof PsiArrayType) {
    constraints.add(new TypeEqualityConstraint(((PsiArrayType)myT).getComponentType(),((PsiArrayType)myS).getComponentType()));
    return true;
  }
  session.registerIncompatibleErrorMessage(session.getInferenceVariables(),session.getPresentableText(myS) + " conforms to " + session.getPresentableText(myT));
  return false;
}
