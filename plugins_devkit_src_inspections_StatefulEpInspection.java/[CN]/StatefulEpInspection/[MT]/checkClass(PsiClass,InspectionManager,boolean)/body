{
  PsiField[] fields=psiClass.getFields();
  if (fields.length == 0)   return super.checkClass(psiClass,manager,isOnTheFly);
  final boolean isQuickFix=InheritanceUtil.isInheritor(psiClass,LocalQuickFix.class.getCanonicalName());
  final boolean isProjectComponent=InheritanceUtil.isInheritor(psiClass,ProjectComponent.class.getCanonicalName());
  if (isQuickFix || ExtensionPointLocator.isImplementedEp(psiClass)) {
    List<ProblemDescriptor> result=ContainerUtil.newArrayList();
    for (    final PsiField field : fields) {
      for (      Class c : new Class[]{PsiElement.class,PsiReference.class,Project.class}) {
        if (c == Project.class && (field.hasModifierProperty(PsiModifier.FINAL) || isProjectComponent))         continue;
        String message=c == PsiElement.class ? "Potential memory leak: don't hold PsiElement, use SmartPsiElementPointer instead" + (isQuickFix ? "; also see LocalQuickFixOnPsiElement" : "") : "Don't use " + c.getSimpleName() + " as a field in extension";
        if (InheritanceUtil.isInheritor(field.getType(),c.getCanonicalName())) {
          result.add(manager.createProblemDescriptor(field,message,true,ProblemHighlightType.GENERIC_ERROR_OR_WARNING,isOnTheFly));
        }
      }
    }
    return result.toArray(new ProblemDescriptor[result.size()]);
  }
  return super.checkClass(psiClass,manager,isOnTheFly);
}
