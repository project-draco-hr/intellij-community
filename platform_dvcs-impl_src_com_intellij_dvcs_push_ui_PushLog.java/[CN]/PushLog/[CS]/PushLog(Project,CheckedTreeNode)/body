{
  DefaultTreeModel treeModel=new DefaultTreeModel(root);
  treeModel.nodeStructureChanged(root);
  myTreeCellRenderer=new MyTreeCellRenderer();
  myTree=new CheckboxTree(myTreeCellRenderer,root){
    public boolean isPathEditable(    TreePath path){
      return isEditable() && path.getLastPathComponent() instanceof DefaultMutableTreeNode;
    }
    @Override protected void onNodeStateChanged(    CheckedTreeNode node){
      if (node instanceof EditableTreeNode) {
        ((EditableTreeNode)node).fireOnSelectionChange(node.isChecked());
      }
    }
    @Override public String getToolTipText(    MouseEvent event){
      final TreePath path=myTree.getPathForLocation(event.getX(),event.getY());
      if (path == null) {
        return "";
      }
      Object node=path.getLastPathComponent();
      if (node == null || (!(node instanceof DefaultMutableTreeNode))) {
        return "";
      }
      if (node instanceof TooltipNode) {
        return ((TooltipNode)node).getTooltip();
      }
      return "";
    }
    @Override public boolean stopEditing(){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node instanceof EditableTreeNode) {
        JComponent editedComponent=(JComponent)node.getUserObject();
        InputVerifier verifier=editedComponent.getInputVerifier();
        if (verifier != null && !verifier.verify(editedComponent))         return false;
      }
      boolean result=super.stopEditing();
      if (myShouldRepaint) {
        refreshNode(root);
      }
      return result;
    }
    @Override public void cancelEditing(){
      super.cancelEditing();
      if (myShouldRepaint) {
        refreshNode(root);
      }
    }
  }
;
  myTree.setEditable(true);
  MyTreeCellEditor treeCellEditor=new MyTreeCellEditor();
  myTree.setCellEditor(treeCellEditor);
  treeCellEditor.addCellEditorListener(new CellEditorListener(){
    @Override public void editingStopped(    ChangeEvent e){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node != null && node instanceof EditableTreeNode) {
        ((EditableTreeNode)node).fireOnChange();
      }
    }
    @Override public void editingCanceled(    ChangeEvent e){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node != null && node instanceof EditableTreeNode) {
        ((EditableTreeNode)node).fireOnCancel();
      }
    }
  }
);
  myTree.setRootVisible(false);
  TreeUtil.collapseAll(myTree,1);
  final VcsBranchEditorListener linkMouseListener=new VcsBranchEditorListener(myTreeCellRenderer);
  linkMouseListener.installOn(myTree);
  myTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
  myTree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      updateChangesView();
    }
  }
);
  myTree.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),START_EDITING);
  myTree.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),"");
  myTree.setRowHeight(0);
  ToolTipManager.sharedInstance().registerComponent(myTree);
  myChangesBrowser=new ChangesBrowser(project,null,Collections.<Change>emptyList(),null,false,true,null,ChangesBrowser.MyUseCase.LOCAL_CHANGES,null);
  myChangesBrowser.getDiffAction().registerCustomShortcutSet(CommonShortcuts.getDiff(),myTree);
  setDefaultEmptyText();
  Splitter splitter=new Splitter(false,0.7f);
  splitter.setFirstComponent(ScrollPaneFactory.createScrollPane(myTree));
  splitter.setSecondComponent(myChangesBrowser);
  setLayout(new BorderLayout());
  add(splitter);
}
