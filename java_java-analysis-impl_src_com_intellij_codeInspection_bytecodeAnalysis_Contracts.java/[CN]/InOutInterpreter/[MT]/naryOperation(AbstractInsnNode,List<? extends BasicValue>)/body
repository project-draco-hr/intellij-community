{
  boolean propagate=resultOrigins[insns.indexOf(insn)];
  int opCode=insn.getOpcode();
  int shift=opCode == INVOKESTATIC ? 0 : 1;
switch (opCode) {
case INVOKESPECIAL:
case INVOKEINTERFACE:
case INVOKEVIRTUAL:
    if (nullAnalysis && values.get(0) instanceof ParamValue) {
      deReferenced=true;
      return super.naryOperation(insn,values);
    }
}
if (propagate) {
switch (opCode) {
case INVOKESTATIC:
case INVOKESPECIAL:
case INVOKEVIRTUAL:
case INVOKEINTERFACE:
    boolean stable=opCode == INVOKESTATIC || opCode == INVOKESPECIAL;
  MethodInsnNode mNode=(MethodInsnNode)insn;
Method method=new Method(mNode.owner,mNode.name,mNode.desc);
Type retType=Type.getReturnType(mNode.desc);
boolean isRefRetType=retType.getSort() == Type.OBJECT || retType.getSort() == Type.ARRAY;
if (!Type.VOID_TYPE.equals(retType)) {
if (direction instanceof InOut) {
InOut inOut=(InOut)direction;
HashSet<Key> keys=new HashSet<>();
for (int i=shift; i < values.size(); i++) {
if (values.get(i) instanceof ParamValue) {
  keys.add(new Key(method,new InOut(i - shift,inOut.inValue),stable));
}
}
if (isRefRetType) {
keys.add(new Key(method,Out,stable));
}
if (!keys.isEmpty()) {
return new CallResultValue(retType,keys);
}
}
 else if (isRefRetType) {
HashSet<Key> keys=new HashSet<>();
keys.add(new Key(method,Out,stable));
return new CallResultValue(retType,keys);
}
}
break;
case MULTIANEWARRAY:
return new NotNullValue(super.naryOperation(insn,values).getType());
default :
}
}
return super.naryOperation(insn,values);
}
