{
  boolean propagate=resultOrigins.contains(insns.indexOf(insn));
  int opCode=insn.getOpcode();
  int shift=opCode == INVOKESTATIC ? 0 : 1;
  if (propagate) {
switch (opCode) {
case INVOKESTATIC:
case INVOKESPECIAL:
case INVOKEVIRTUAL:
case INVOKEINTERFACE:
      boolean stable=opCode == INVOKESTATIC || opCode == INVOKESPECIAL;
    MethodInsnNode mNode=(MethodInsnNode)insn;
  Method method=new Method(mNode.owner,mNode.name,mNode.desc);
Type retType=Type.getReturnType(mNode.desc);
boolean isRefRetType=retType.getSort() == Type.OBJECT || retType.getSort() == Type.ARRAY;
if (!Type.VOID_TYPE.equals(retType)) {
if (direction instanceof InOut) {
InOut inOut=(InOut)direction;
HashSet<Key> keys=new HashSet<Key>();
for (int i=shift; i < values.size(); i++) {
  if (values.get(i) instanceof ParamValue) {
    keys.add(new Key(method,new InOut(i - shift,inOut.inValue),stable));
  }
}
if (isRefRetType) {
  keys.add(new Key(method,new Out(),stable));
}
if (!keys.isEmpty()) {
  return new CallResultValue(retType,keys);
}
}
 else if (isRefRetType) {
HashSet<Key> keys=new HashSet<Key>();
keys.add(new Key(method,new Out(),stable));
return new CallResultValue(retType,keys);
}
}
break;
case MULTIANEWARRAY:
return new NotNullValue(super.naryOperation(insn,values).getType());
default :
}
}
return super.naryOperation(insn,values);
}
