{
  Conf preConf=state.conf;
  int insnIndex=preConf.insnIndex;
  boolean loopEnter=dfsTree.loopEnters[insnIndex];
  Conf conf=loopEnter ? generalize(preConf) : preConf;
  List<Conf> history=state.history;
  boolean taken=state.taken;
  Frame<BasicValue> frame=conf.frame;
  AbstractInsnNode insnNode=methodNode.instructions.get(insnIndex);
  List<Conf> nextHistory=loopEnter ? append(history,conf) : history;
  Frame<BasicValue> nextFrame=execute(frame,insnNode);
  addComputed(insnIndex,state);
  if (interpreter.deReferenced) {
    return;
  }
  int opcode=insnNode.getOpcode();
switch (opcode) {
case ARETURN:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case RETURN:
    BasicValue stackTop=popValue(frame);
  Result subResult;
if (FalseValue == stackTop) {
  subResult=new Final(Value.False);
}
 else if (TrueValue == stackTop) {
  subResult=new Final(Value.True);
}
 else if (NullValue == stackTop) {
  subResult=new Final(Value.Null);
}
 else if (stackTop instanceof NotNullValue) {
  subResult=new Final(Value.NotNull);
}
 else if (stackTop instanceof ParamValue) {
  subResult=new Final(inValue);
}
 else if (stackTop instanceof CallResultValue) {
  Set<Key> keys=((CallResultValue)stackTop).inters;
  subResult=new Pending(Collections.singleton(new Product(Value.Top,keys)));
}
 else {
  earlyResult=new Final(Value.Top);
  return;
}
internalResult=resultUtil.join(internalResult,subResult);
if (internalResult instanceof Final && ((Final)internalResult).value == Value.Top) {
earlyResult=internalResult;
}
return;
case ATHROW:
return;
default :
}
if (opcode == IFNONNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=inValue == Value.Null ? insnIndex + 1 : methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false);
pendingPush(nextState);
return;
}
if (opcode == IFNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=inValue == Value.NotNull ? insnIndex + 1 : methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false);
pendingPush(nextState);
return;
}
if (opcode == IFEQ && popValue(frame) == InstanceOfCheckValue && inValue == Value.Null) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false);
pendingPush(nextState);
return;
}
if (opcode == IFNE && popValue(frame) == InstanceOfCheckValue && inValue == Value.Null) {
int nextInsnIndex=insnIndex + 1;
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false);
pendingPush(nextState);
return;
}
for (int nextInsnIndex : controlFlow.transitions[insnIndex]) {
Frame<BasicValue> nextFrame1=nextFrame;
if (controlFlow.errors[nextInsnIndex] && controlFlow.errorTransitions.contains(new Edge(insnIndex,nextInsnIndex))) {
nextFrame1=new Frame<BasicValue>(frame);
nextFrame1.clearStack();
nextFrame1.push(ASMUtils.THROWABLE_VALUE);
}
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame1),nextHistory,taken,false));
}
}
