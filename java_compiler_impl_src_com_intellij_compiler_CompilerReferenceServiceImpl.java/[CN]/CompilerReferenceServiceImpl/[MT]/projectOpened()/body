{
  if (isEnabled()) {
    myDirtyModulesHolder.markAsDirty(ModuleManager.getInstance(myProject).getModules());
    myProject.getMessageBus().connect(myProject).subscribe(BuildManagerListener.TOPIC,new BuildManagerListener(){
      @Override public void buildStarted(      Project project,      UUID sessionId,      boolean isAutomake){
        myDirtyModulesHolder.compilationPhaseStarted();
        closeReaderIfNeed();
      }
    }
);
    CompilerManager.getInstance(myProject).addCompilationStatusListener(new CompilationStatusListener(){
      @Override public void compilationFinished(      boolean aborted,      int errors,      int warnings,      CompileContext compileContext){
        compilationFinished(errors,compileContext);
      }
      @Override public void automakeCompilationFinished(      int errors,      int warnings,      CompileContext compileContext){
        compilationFinished(errors,compileContext);
      }
      private void compilationFinished(      int errors,      CompileContext context){
        final Module[] compilationModules=context.getCompileScope().getAffectedModules();
        if (errors != 0) {
          final Set<Module> modulesWithErrors=new THashSet<>();
          boolean unknownErrorLocation=false;
          for (          CompilerMessage message : context.getMessages(CompilerMessageCategory.ERROR)) {
            VirtualFile file=message.getVirtualFile();
            if (file == null) {
              unknownErrorLocation=true;
              break;
            }
            Module module=myProjectFileIndex.getModuleForFile(file);
            if (module == null) {
              unknownErrorLocation=true;
              break;
            }
            modulesWithErrors.add(module);
          }
          if (unknownErrorLocation) {
            myDirtyModulesHolder.compilationPhaseFinishedWithUnknownErrorLocation(compilationModules);
          }
 else {
            myDirtyModulesHolder.compilationPhaseFinished(compilationModules,modulesWithErrors.toArray(Module.EMPTY_ARRAY));
          }
        }
 else {
          myDirtyModulesHolder.compilationPhaseFinished(compilationModules,Module.EMPTY_ARRAY);
        }
        myCompilationCount.increment();
        openReaderIfNeed();
      }
    }
);
    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter(){
      @Override public void fileCreated(      @NotNull VirtualFileEvent event){
        processChange(event.getFile());
      }
      @Override public void fileCopied(      @NotNull VirtualFileCopyEvent event){
        processChange(event.getFile());
      }
      @Override public void fileMoved(      @NotNull VirtualFileMoveEvent event){
        processChange(event.getFile());
      }
      @Override public void beforePropertyChange(      @NotNull VirtualFilePropertyEvent event){
        if (VirtualFile.PROP_NAME.equals(event.getPropertyName()) || VirtualFile.PROP_SYMLINK_TARGET.equals(event.getPropertyName())) {
          processChange(event.getFile());
        }
      }
      @Override public void beforeContentsChange(      @NotNull VirtualFileEvent event){
        processChange(event.getFile());
      }
      @Override public void beforeFileDeletion(      @NotNull VirtualFileEvent event){
        processChange(event.getFile());
      }
      @Override public void beforeFileMovement(      @NotNull VirtualFileMoveEvent event){
        processChange(event.getFile());
      }
      private void processChange(      VirtualFile file){
        myDirtyModulesHolder.fileChanged(file);
      }
    }
,myProject);
  }
}
