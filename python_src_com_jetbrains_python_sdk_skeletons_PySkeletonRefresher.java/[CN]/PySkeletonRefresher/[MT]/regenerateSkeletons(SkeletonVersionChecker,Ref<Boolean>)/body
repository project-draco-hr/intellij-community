{
  final List<String> errorList=new SmartList<String>();
  final String homePath=mySdk.getHomePath();
  final String skeletonsPath=getSkeletonsPath();
  final File skeletonsDir=new File(skeletonsPath);
  if (!skeletonsDir.exists()) {
    skeletonsDir.mkdirs();
  }
  final String readablePath=FileUtil.getLocationRelativeToUserHome(homePath);
  mySkeletonsGenerator.prepare();
  myBlacklist=loadBlacklist();
  indicate(PyBundle.message("sdk.gen.querying.$0",readablePath));
  final PySkeletonGenerator.ListBinariesResult binaries=mySkeletonsGenerator.listBinaries(mySdk,calculateExtraSysPath(mySdk,getSkeletonsPath()));
  myGeneratorVersion=binaries.generatorVersion;
  myPregeneratedSkeletons=findPregeneratedSkeletons();
  indicate(PyBundle.message("sdk.gen.reading.versions.file"));
  if (cachedChecker != null) {
    myVersionChecker=cachedChecker.withDefaultVersionIfUnknown(myGeneratorVersion);
  }
 else {
    myVersionChecker=new SkeletonVersionChecker(myGeneratorVersion);
  }
  final String builtinsFileName=PythonSdkType.getBuiltinsFileName(mySdk);
  final File builtinsFile=new File(skeletonsPath,builtinsFileName);
  final SkeletonHeader oldHeader=readSkeletonHeader(builtinsFile);
  final boolean oldOrNonExisting=oldHeader == null || oldHeader.getVersion() == 0;
  if (migrationFlag != null && !migrationFlag.get() && oldOrNonExisting) {
    migrationFlag.set(true);
    Notifications.Bus.notify(new Notification(PythonSdkType.SKELETONS_TOPIC,PyBundle.message("sdk.gen.notify.converting.old.skels"),PyBundle.message("sdk.gen.notify.converting.text"),NotificationType.INFORMATION));
  }
  if (myPregeneratedSkeletons != null && oldOrNonExisting) {
    indicate("Unpacking pregenerated skeletons...");
    try {
      final VirtualFile jar=JarFileSystem.getInstance().getVirtualFileForJar(myPregeneratedSkeletons);
      if (jar != null) {
        ZipUtil.extract(new File(jar.getPath()),new File(getSkeletonsPath()),null);
      }
    }
 catch (    IOException e) {
      LOG.info("Error unpacking pregenerated skeletons",e);
    }
  }
  if (oldOrNonExisting) {
    final Sdk base=PythonSdkType.getInstance().getVirtualEnvBaseSdk(mySdk);
    if (base != null) {
      indicate("Copying base SDK skeletons for virtualenv...");
      final String baseSkeletonsPath=PythonSdkType.getSkeletonsPath(PathManager.getSystemPath(),base.getHomePath());
      final PySkeletonGenerator.ListBinariesResult baseBinaries=mySkeletonsGenerator.listBinaries(base,calculateExtraSysPath(base,baseSkeletonsPath));
      for (      Map.Entry<String,PyBinaryItem> entry : binaries.modules.entrySet()) {
        final String module=entry.getKey();
        final PyBinaryItem binary=entry.getValue();
        final PyBinaryItem baseBinary=baseBinaries.modules.get(module);
        final File fromFile=getSkeleton(module,baseSkeletonsPath);
        if (baseBinaries.modules.containsKey(module) && fromFile.exists() && binary.length() == baseBinary.length()) {
          final File toFile=fromFile.isDirectory() ? getPackageSkeleton(module,skeletonsPath) : getModuleSkeleton(module,skeletonsPath);
          try {
            FileUtil.copy(fromFile,toFile);
          }
 catch (          IOException e) {
            LOG.info("Error copying base virtualenv SDK skeleton for " + module,e);
          }
        }
      }
    }
  }
  final SkeletonHeader newHeader=readSkeletonHeader(builtinsFile);
  final boolean mustUpdateBuiltins=myPregeneratedSkeletons == null && (newHeader == null || newHeader.getVersion() < myVersionChecker.getBuiltinVersion());
  if (mustUpdateBuiltins) {
    indicate(PyBundle.message("sdk.gen.updating.builtins.$0",readablePath));
    mySkeletonsGenerator.generateBuiltinSkeletons(mySdk);
    if (myProject != null) {
      PythonSdkPathCache.getInstance(myProject,mySdk).clearBuiltins();
    }
  }
  if (!binaries.modules.isEmpty()) {
    indicate(PyBundle.message("sdk.gen.updating.$0",readablePath));
    List<UpdateResult> updateErrors=updateOrCreateSkeletons(binaries.modules);
    if (updateErrors.size() > 0) {
      indicateMinor(BLACKLIST_FILE_NAME);
      for (      UpdateResult error : updateErrors) {
        if (error.isFresh())         errorList.add(error.getName());
        myBlacklist.put(error.getPath(),new Pair<Integer,Long>(myGeneratorVersion,error.getTimestamp()));
      }
      storeBlacklist(skeletonsDir,myBlacklist);
    }
 else {
      removeBlacklist(skeletonsDir);
    }
  }
  indicate(PyBundle.message("sdk.gen.reloading"));
  mySkeletonsGenerator.refreshGeneratedSkeletons();
  if (!oldOrNonExisting) {
    indicate(PyBundle.message("sdk.gen.cleaning.$0",readablePath));
    cleanUpSkeletons(skeletonsDir);
  }
  if (PySdkUtil.isRemote(mySdk)) {
    try {
      ((PyPackageManagerImpl)PyPackageManager.getInstance(mySdk)).loadPackages();
    }
 catch (    PyExternalProcessException e) {
    }
  }
  if ((mustUpdateBuiltins || PySdkUtil.isRemote(mySdk)) && myProject != null) {
    ApplicationManager.getApplication().invokeLater(new Runnable(){
      @Override public void run(){
        DaemonCodeAnalyzer.getInstance(myProject).restart();
      }
    }
,myProject.getDisposed());
  }
  return errorList;
}
