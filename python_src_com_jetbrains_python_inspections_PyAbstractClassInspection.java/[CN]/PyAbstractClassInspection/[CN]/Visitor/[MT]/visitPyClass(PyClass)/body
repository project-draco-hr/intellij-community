{
  Set<PyFunction> toBeImplemented=new HashSet<PyFunction>();
  final Collection<PyFunction> functions=PyOverrideImplementUtil.getAllSuperFunctions(node);
  for (  PyFunction method : functions) {
    final PyDecoratorList list=method.getDecoratorList();
    if (list != null && node.findMethodByName(method.getName(),false) == null) {
      for (      PyDecorator decorator : list.getDecorators()) {
        final PyQualifiedName qualifiedName=decorator.getQualifiedName();
        if (qualifiedName != null && (PyNames.ABSTRACTMETHOD.equals(qualifiedName.getLastComponent()) || PyNames.ABSTRACTPROPERTY.equals(qualifiedName.getLastComponent()))) {
          toBeImplemented.add(method);
        }
      }
    }
  }
  final ASTNode nameNode=node.getNameNode();
  if (!toBeImplemented.isEmpty() && nameNode != null) {
    registerProblem(nameNode.getPsi(),PyBundle.message("INSP.NAME.abstract.class.$0.must.implement",node.getName()),ProblemHighlightType.INFO,null,new PyImplementMethodsQuickFix(node,toBeImplemented));
  }
}
