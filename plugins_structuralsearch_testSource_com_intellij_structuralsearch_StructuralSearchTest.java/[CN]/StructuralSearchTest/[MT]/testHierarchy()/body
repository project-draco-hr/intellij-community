{
  final String s105="class B {} class A extends B { }";
  final String s106="class '_ extends '_:[ref('T)] {}";
  assertEquals("extends match",findMatchesCount(s105,s106),1);
  final String s107="interface IA {} interface IB extends IA { } interface IC extends IB {} interface ID extends IC {}" + "class A implements IA {} class B extends A { } class C extends B implements IC {} class D extends C {}";
  final String s108="class '_ extends 'Type:+A {}";
  final String s108_2="class '_ implements 'Type:+IA {}";
  assertEquals("extends navigation match",findMatchesCount(s107,s108),2);
  assertEquals("implements navigation match",3,findMatchesCount(s107,s108_2));
  final String s109="interface I {} interface I2 extends I {} class A implements I2 {} class B extends A { } class C extends B {} class D { void e() { C c; B b; A a;} }";
  final String s110="'_:*A '_;";
  final String s110_2="'_:*I '_;";
  final String s110_3="'_:*[regex( I ) && ref('T)] '_;";
  final String s110_4="'_:*[regex( I ) && ref2('T)] '_;";
  assertEquals("extends navigation match in definition",findMatchesCount(s109,s110),3);
  assertEquals("implements navigation match in definition 2",findMatchesCount(s109,s110_2),3);
  assertEquals("implements navigation match in definition 2 with nested conditions",findMatchesCount(s109,s110_3),3);
  try {
    findMatchesCount(s109,s110_4);
    assertFalse("implements navigation match in definition 2 with nested conditions - incorrect cond",false);
  }
 catch (  UnsupportedPatternException ex) {
  }
  final String s111="interface E {} class A implements E {} class B extends A { int f = 0; } class C extends B {} class D { void e() { C c; B b; A a;} }";
  final String s112="'_";
  assertEquals("symbol match",findMatchesCount(s111,s112),17);
  final String s113="class B {int c; void d() {} } int a; B b; a = 1; b.d(); ++a; int c=a; System.out.println(a); " + "b.c = 1; System.out.println(b.c); b.c++;";
  final String s114="'_:[read]";
  final String s114_2="'_:[write]";
  assertEquals("read symbol match",findMatchesCount(s113,s114),11);
  assertEquals("write symbol match",findMatchesCount(s113,s114_2),5);
  final String s115="class B {} public class C {}";
  final String s116="public class '_ {}";
  assertEquals("public modifier for class",findMatchesCount(s115,s116),1);
  final String s117="class A { int b; void c() { int e; b=1; this.b=1; e=5; " + "System.out.println(e); " + "System.out.println(b); System.out.println(this.b);} }";
  final String s118="this.'Field";
  final String s118_2="this.'Field:[read]";
  final String s118_3="this.'Field:[write]";
  assertEquals("fields of class",4,findMatchesCount(s117,s118));
  assertEquals("fields of class read",findMatchesCount(s117,s118_2),2);
  assertEquals("fields of class written",findMatchesCount(s117,s118_3),2);
  final String s119="try { a.b(); } catch(IOException e) { c(); } catch(Exception ex) { d(); }";
  final String s120="try { '_; } catch('_ '_) { '_; }";
  final String s120_2="try { '_; } catch(Throwable '_) { '_; }";
  assertEquals("catches loose matching",findMatchesCount(s119,s120),1);
  assertEquals("catches loose matching 2",findMatchesCount(s119,s120_2),0);
  final String s121="class A { private int a; class Inner {} } " + "class B extends A { private int a; class Inner2 {} }";
  final String s122="class '_ { int '_:* ; }";
  final String s122_2="class '_ { int '_:+hashCode (); }";
  final String s122_3="class '_ { class '_:* {} }";
  assertEquals("hierarchical matching",findMatchesCount(s121,s122),2);
  assertEquals("hierarchical matching 2",findMatchesCount(s121,s122_2),4);
  assertEquals("hierarchical matching 3",findMatchesCount(s121,s122_3),2);
}
