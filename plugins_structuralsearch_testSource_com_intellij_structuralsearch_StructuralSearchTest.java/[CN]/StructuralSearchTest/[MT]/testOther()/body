{
  assertEquals("optional init match in definition",findMatchesCount(s73,s74),4);
  assertEquals("null match",findMatchesCount(s77,s78),0);
  assertEquals("body of method by block search",findMatchesCount(s79,s80),2);
  assertEquals("first matches, next not",findMatchesCount(s95,s96),2);
  final String s97="class A { int c; void b() { C d; } } class C { C() { A a; a.b(); a.c=1; } }";
  final String s98="'_.'_:[ref('T)] ()";
  final String s98_2="'_.'_:[ref('T)]";
  final String s98_3="'_:[ref('T)].'_ ();";
  final String s98_4="'_:[ref('T)] '_;";
  assertEquals("method predicate match",findMatchesCount(s97,s98),1);
  assertEquals("field predicate match",findMatchesCount(s97,s98_2),1);
  assertEquals("dcl predicate match",findMatchesCount(s97,s98_3),1);
  final String s99=" char s = '\\u1111';  char s1 = '\\n'; ";
  final String s100=" char 'var = '\\u1111'; ";
  final String s100_2=" char 'var = '\\n'; ";
  assertEquals("char constants in pattern",findMatchesCount(s99,s100),1);
  assertEquals("char constants in pattern 2",findMatchesCount(s99,s100_2),1);
  assertEquals("class predicate match (from definition)",findMatchesCount(s97,s98_4),3);
  final String s125="a=1;";
  final String s126="'t:[regex(a)]";
  try {
    findMatchesCount(s125,s126);
    assertFalse("spaces around reg exp check",false);
  }
 catch (  MalformedPatternException ex) {
  }
  options.setDistinct(true);
  final String s101="class A { void b() { String d; String e; String[] f; f.length=1; f.length=1; } }";
  final String s102="'_:[ref('T)] '_;";
  assertEquals("distinct match",findMatchesCount(s101,s102),1);
  options.setDistinct(false);
  final String s103=" a=1; ";
  final String s104="'T:{ ;";
  try {
    findMatchesCount(s103,s104);
    assertFalse("incorrect reg exp",false);
  }
 catch (  MalformedPatternException ex) {
  }
  final String s106="$_ReturnType$ $MethodName$($_ParameterType$ $_Parameter$);";
  final String s105=" aaa; ";
  try {
    findMatchesCount(s105,s106);
    assertFalse("incorrect reg exp 2",false);
  }
 catch (  UnsupportedPatternException ex) {
  }
  String s107="class A {\n" + "  /* */\n" + "  void a() {\n"+ "  }"+ "  /* */\n"+ "  int b = 1;\n"+ "  /*"+ "   *"+ "   */\n"+ "   class C {}"+ "}";
  String s108="  /*" + "   *" + "   */";
  assertEquals("finding comments without typed var",1,findMatchesCount(s107,s108));
  String s109="class A { void b(); int b(int c); char d(char e); }\n" + "A a; a.b(1); a.b(2); a.b(); a.d('e'); a.d('f'); a.d('g');";
  String s110="'_a.'_b:[exprtype( int ) ]('_c*);";
  assertEquals("caring about method return type",2,findMatchesCount(s109,s110));
  String s111="class A { void getManager() { getManager(); } };\n" + "class B { void getManager() { getManager(); getManager(); } };";
  String s112="'Instance?:[exprtype( B )].getManager();";
  assertEquals("caring about missing qualifier type",2,findMatchesCount(s111,s112));
  String s113="class A { static void a() { a(); }}\n" + "class B { static void a() { a(); a(); }}\n";
  String s114="'_Q?:[regex( B )].a()";
  assertEquals("should care about implicit class qualifier",2,findMatchesCount(s113,s114));
  String s114a="B.a()";
  assertEquals("simple implicit class qualifier query",2,findMatchesCount(s113,s114a));
}
