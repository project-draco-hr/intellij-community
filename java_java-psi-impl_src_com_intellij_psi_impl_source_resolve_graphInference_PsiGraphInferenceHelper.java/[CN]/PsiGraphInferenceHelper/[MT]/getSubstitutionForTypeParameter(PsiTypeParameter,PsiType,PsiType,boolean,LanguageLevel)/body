{
  if (arg == PsiType.VOID || param == PsiType.VOID)   return PsiType.NULL;
  if (param instanceof PsiArrayType && arg instanceof PsiArrayType) {
    return getSubstitutionForTypeParameter(typeParam,((PsiArrayType)param).getComponentType(),((PsiArrayType)arg).getComponentType(),isContraVariantPosition,languageLevel);
  }
  if (!(param instanceof PsiClassType))   return PsiType.NULL;
  if (arg == null) {
    return PsiType.NULL;
  }
  final PsiType[] leftTypes;
  final PsiType[] rightTypes;
  if (isContraVariantPosition) {
    leftTypes=new PsiType[]{param};
    rightTypes=new PsiType[]{arg};
  }
 else {
    leftTypes=new PsiType[]{arg};
    rightTypes=new PsiType[]{param};
  }
  final InferenceSession inferenceSession=new InferenceSession(new PsiTypeParameter[]{typeParam},leftTypes,rightTypes,PsiSubstitutor.EMPTY,myManager,null);
  if (inferenceSession.isProperType(param) && inferenceSession.isProperType(arg)) {
    boolean proceed=false;
    for (    PsiClassType classType : typeParam.getExtendsListTypes()) {
      if (!inferenceSession.isProperType(classType)) {
        proceed=true;
        break;
      }
    }
    if (!proceed) {
      return PsiType.NULL;
    }
  }
  final PsiSubstitutor substitutor=inferenceSession.infer();
  return substitutor.substitute(typeParam);
}
