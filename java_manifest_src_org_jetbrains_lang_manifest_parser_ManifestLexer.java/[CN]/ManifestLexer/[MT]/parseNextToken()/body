{
  if (myTokenStart >= myEndOffset) {
    myTokenType=null;
    myTokenEnd=myTokenStart;
    return;
  }
  boolean atLineStart=myTokenStart == 0 || myBuffer.charAt(myTokenStart - 1) == '\n';
  char c=myBuffer.charAt(myTokenStart);
  if (atLineStart) {
    myDefaultState=true;
    if (c == ' ') {
      myTokenType=ManifestTokenType.SIGNIFICANT_SPACE;
      myTokenEnd=myTokenStart + 1;
    }
 else     if (c == '\n') {
      myTokenType=ManifestTokenType.SECTION_END;
      myTokenEnd=myTokenStart + 1;
    }
 else {
      int headerEnd=myTokenStart + 1;
      while (headerEnd < myEndOffset) {
        c=myBuffer.charAt(headerEnd);
        if (c == ':') {
          myDefaultState=false;
          break;
        }
 else         if (c == '\n') {
          break;
        }
        ++headerEnd;
      }
      myTokenType=ManifestTokenType.HEADER_NAME;
      myTokenEnd=headerEnd;
    }
  }
 else   if (!myDefaultState && c == ':') {
    myTokenType=ManifestTokenType.COLON;
    myTokenEnd=myTokenStart + 1;
  }
 else   if (!myDefaultState && c == ' ') {
    myTokenType=ManifestTokenType.SIGNIFICANT_SPACE;
    myTokenEnd=myTokenStart + 1;
    myDefaultState=true;
  }
 else {
    myDefaultState=true;
    IElementType special;
    if (c == '\n') {
      myTokenType=ManifestTokenType.NEWLINE;
      myTokenEnd=myTokenStart + 1;
    }
 else     if ((special=SPECIAL_CHARACTERS_TOKEN_MAPPING.get(c)) != null) {
      myTokenType=special;
      myTokenEnd=myTokenStart + 1;
    }
 else {
      int valueEnd=myTokenStart + 1;
      while (valueEnd < myEndOffset) {
        c=myBuffer.charAt(valueEnd);
        if (c == '\n' || SPECIAL_CHARACTERS_TOKEN_MAPPING.containsKey(c)) {
          break;
        }
        ++valueEnd;
      }
      myTokenType=ManifestTokenType.HEADER_VALUE_PART;
      myTokenEnd=valueEnd;
    }
  }
}
