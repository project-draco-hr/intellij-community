{
  if (myDefinition.isInterface())   return Collections.emptyList();
  GrImplementsClause clause=myDefinition.getImplementsClause();
  if (clause == null)   return Collections.emptyList();
  PsiClassType[] types=clause.getReferencedTypes();
  List<PsiClassType.ClassResolveResult> traits=getSuperTraits(types);
  if (traits.isEmpty())   return Collections.emptyList();
  Set<MethodSignature> existingSignatures=newHashSet(map(codeMethods,new Function<PsiMethod,MethodSignature>(){
    @Override public MethodSignature fun(    PsiMethod method){
      return method.getSignature(PsiSubstitutor.EMPTY);
    }
  }
));
  List<PsiMethod> result=newArrayList();
  for (  PsiClassType.ClassResolveResult resolveResult : traits) {
    GrTypeDefinition trait=(GrTypeDefinition)resolveResult.getElement();
    LOG.assertTrue(trait != null);
    List<CandidateInfo> concreteTraitMethods=new TraitProcessor(trait,resolveResult.getSubstitutor()).getResult();
    for (    CandidateInfo candidateInfo : concreteTraitMethods) {
      List<GrMethod> methodsToAdd=getExpandingMethods(candidateInfo);
      for (      GrMethod impl : methodsToAdd) {
        if (existingSignatures.add(impl.getSignature(PsiSubstitutor.EMPTY))) {
          result.add(impl);
        }
      }
    }
  }
  return result;
}
