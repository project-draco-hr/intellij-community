{
  boolean hasPrivate=modifierList.hasExplicitModifier(PRIVATE);
  boolean hasPublic=modifierList.hasExplicitModifier(PUBLIC);
  boolean hasProtected=modifierList.hasExplicitModifier(PROTECTED);
  if (hasPrivate && hasPublic || hasPrivate && hasProtected || hasPublic && hasProtected) {
    final Annotation annotation=holder.createErrorAnnotation(modifierList,GroovyBundle.message("illegal.combination.of.modifiers"));
    if (hasPrivate) {
      registerFix(annotation,new GrModifierFix(member,PRIVATE,false,false,GrModifierFix.MODIFIER_LIST),modifierList);
    }
    if (hasProtected) {
      registerFix(annotation,new GrModifierFix(member,PROTECTED,false,false,GrModifierFix.MODIFIER_LIST),modifierList);
    }
    if (hasPublic) {
      registerFix(annotation,new GrModifierFix(member,PUBLIC,false,false,GrModifierFix.MODIFIER_LIST),modifierList);
    }
  }
 else   if (member instanceof PsiMethod && member.getContainingClass() instanceof GrInterfaceDefinition && hasPublic&& !GroovyConfigUtils.getInstance().isVersionAtLeast(member,"1.8.4")) {
    final PsiElement publicModifier=ObjectUtils.assertNotNull(PsiUtil.findModifierInList(modifierList,PUBLIC));
    final Annotation annotation=holder.createErrorAnnotation(publicModifier,GroovyBundle.message("public.modifier.is.not.allowed.in.interfaces"));
    registerFix(annotation,new GrModifierFix(member,PUBLIC,false,false,GrModifierFix.MODIFIER_LIST),modifierList);
  }
 else   if (member instanceof PsiClass && member.getContainingClass() == null && GroovyConfigUtils.getInstance().isVersionAtLeast(member,GroovyConfigUtils.GROOVY2_0)) {
    checkModifierIsNotAllowed(modifierList,PRIVATE,GroovyBundle.message("top.level.class.maynot.have.private.modifier"),holder);
    checkModifierIsNotAllowed(modifierList,PROTECTED,GroovyBundle.message("top.level.class.maynot.have.protected.modifier"),holder);
  }
}
