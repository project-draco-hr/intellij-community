{
  checkMethodWithTypeParamsShouldHaveReturnType(myHolder,method);
  checkInnerMethod(myHolder,method);
  checkOptionalParametersInAbstractMethod(myHolder,method);
  checkConstructorOfImmutableClass(myHolder,method);
  checkGetterOfImmutable(myHolder,method);
  final PsiElement nameIdentifier=method.getNameIdentifierGroovy();
  if (nameIdentifier.getNode().getElementType() == GroovyTokenTypes.mSTRING_LITERAL) {
    checkStringLiteral(nameIdentifier);
  }
  GrOpenBlock block=method.getBlock();
  if (block != null && TypeInferenceHelper.isTooComplexTooAnalyze(block)) {
    myHolder.createWeakWarningAnnotation(nameIdentifier,GroovyBundle.message("method.0.is.too.complex.too.analyze",method.getName()));
  }
  final PsiClass containingClass=method.getContainingClass();
  if (method.isConstructor()) {
    if (containingClass instanceof GrAnonymousClassDefinition) {
      myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("constructors.are.not.allowed.in.anonymous.class"));
    }
 else     if (containingClass != null && containingClass.isInterface()) {
      myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("constructors.are.not.allowed.in.interface"));
    }
  }
  if (method.getBlock() == null && !isAbstractOrNative(method)) {
    final Annotation annotation=myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("not.abstract.method.should.have.body"));
  }
  checkOverridingMethod(myHolder,method);
}
