{
  GrModifierList modifiersList=typeDefinition.getModifierList();
  if (modifiersList == null)   return;
  checkAccessModifiers(holder,modifiersList,typeDefinition);
  checkDuplicateModifiers(holder,modifiersList,typeDefinition);
  PsiClassType[] extendsListTypes=typeDefinition.getExtendsListTypes();
  for (  PsiClassType classType : extendsListTypes) {
    PsiClass psiClass=classType.resolve();
    if (psiClass != null && psiClass.hasModifierProperty(FINAL)) {
      final Annotation annotation=holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(),GroovyBundle.message("final.class.cannot.be.extended"));
      registerFix(annotation,new GrModifierFix(typeDefinition,FINAL,false,false,GrModifierFix.MODIFIER_LIST_OWNER),typeDefinition);
    }
  }
  if (!typeDefinition.isEnum() && modifiersList.hasModifierProperty(ABSTRACT) && modifiersList.hasModifierProperty(FINAL)) {
    final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("illegal.combination.of.modifiers.abstract.and.final"));
    registerFix(annotation,new GrModifierFix(typeDefinition,FINAL,false,false,GrModifierFix.MODIFIER_LIST),modifiersList);
    registerFix(annotation,new GrModifierFix(typeDefinition,ABSTRACT,false,false,GrModifierFix.MODIFIER_LIST),modifiersList);
  }
  checkModifierIsNotAllowed(modifiersList,TRANSIENT,GroovyBundle.message("modifier.transient.not.allowed.here"),holder);
  checkModifierIsNotAllowed(modifiersList,VOLATILE,GroovyBundle.message("modifier.volatile.not.allowed.here"),holder);
  if (typeDefinition.isInterface()) {
    checkModifierIsNotAllowed(modifiersList,FINAL,GroovyBundle.message("intarface.cannot.have.modifier.final"),holder);
  }
}
