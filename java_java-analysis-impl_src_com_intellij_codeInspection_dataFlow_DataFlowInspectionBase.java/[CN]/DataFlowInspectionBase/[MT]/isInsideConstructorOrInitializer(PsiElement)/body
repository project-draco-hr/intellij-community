{
  while (element != null) {
    element=PsiTreeUtil.getParentOfType(element,PsiMethod.class,PsiClassInitializer.class);
    if (element instanceof PsiClassInitializer)     return true;
    if (element instanceof PsiMethod) {
      if (((PsiMethod)element).isConstructor())       return true;
      final PsiClass containingClass=((PsiMethod)element).getContainingClass();
      return !InheritanceUtil.processSupers(containingClass,true,new Processor<PsiClass>(){
        @Override public boolean process(        PsiClass psiClass){
          return !canCallMethodsInConstructors(psiClass,psiClass != containingClass);
        }
      }
);
    }
  }
  return false;
}
