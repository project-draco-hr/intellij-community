{
  if (DumbService.isDumb(aClass.getProject())) {
    DumbService.getInstance(aClass.getProject()).showDumbModeNotification("Navigation to overriding methods is not possible during index update");
    return;
  }
  final PsiElementProcessor.CollectElementsWithLimit<PsiClass> collectProcessor=new PsiElementProcessor.CollectElementsWithLimit<PsiClass>(2,new THashSet<PsiClass>());
  final PsiElementProcessor.CollectElementsWithLimit<PsiFunctionalExpression> collectExprProcessor=new PsiElementProcessor.CollectElementsWithLimit<PsiFunctionalExpression>(2,new THashSet<PsiFunctionalExpression>());
  if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
    @Override public void run(){
      ClassInheritorsSearch.search(aClass).forEach(new PsiElementProcessorAdapter<PsiClass>(collectProcessor));
      if (collectProcessor.getCollection().size() < 2) {
        FunctionalExpressionSearch.search(aClass).forEach(new PsiElementProcessorAdapter<PsiFunctionalExpression>(collectExprProcessor));
      }
    }
  }
,SEARCHING_FOR_OVERRIDDEN_METHODS,true,aClass.getProject(),(JComponent)e.getComponent())) {
    return;
  }
  final List<NavigatablePsiElement> inheritors=new ArrayList<NavigatablePsiElement>();
  inheritors.addAll(collectProcessor.getCollection());
  inheritors.addAll(collectExprProcessor.getCollection());
  if (inheritors.isEmpty())   return;
  final PsiClassOrFunctionalExpressionListCellRenderer renderer=new PsiClassOrFunctionalExpressionListCellRenderer();
  final SubclassUpdater subclassUpdater=new SubclassUpdater(aClass,renderer);
  Collections.sort(inheritors,renderer.getComparator());
  PsiElementListNavigator.openTargets(e,inheritors.toArray(new NavigatablePsiElement[inheritors.size()]),subclassUpdater.getCaption(inheritors.size()),CodeInsightBundle.message("goto.implementation.findUsages.title",aClass.getName()),renderer,subclassUpdater);
}
