{
  PsiElementProcessor.CollectElementsWithLimit<PsiMethod> processor=new PsiElementProcessor.CollectElementsWithLimit<PsiMethod>(5);
  OverridingMethodsSearch.search(method).forEach(new PsiElementProcessorAdapter<PsiMethod>(processor));
  boolean isAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
  if (processor.isOverflow()) {
    return isAbstract ? DaemonBundle.message("method.is.implemented.too.many") : DaemonBundle.message("method.is.overridden.too.many");
  }
  PsiMethod[] overridings=processor.toArray(PsiMethod.EMPTY_ARRAY);
  if (overridings.length == 0) {
    final PsiClass aClass=method.getContainingClass();
    if (aClass != null && FunctionalExpressionSearch.search(aClass).findFirst() != null) {
      return "Has functional implementations";
    }
    return null;
  }
  Comparator<PsiMethod> comparator=new MethodCellRenderer(false).getComparator();
  Arrays.sort(overridings,comparator);
  String start=isAbstract ? DaemonBundle.message("method.is.implemented.header") : DaemonBundle.message("method.is.overriden.header");
  @NonNls String pattern="&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#javaClass/{1}\">{1}</a>";
  return composeText(overridings,start,pattern,IdeActions.ACTION_GOTO_IMPLEMENTATION);
}
