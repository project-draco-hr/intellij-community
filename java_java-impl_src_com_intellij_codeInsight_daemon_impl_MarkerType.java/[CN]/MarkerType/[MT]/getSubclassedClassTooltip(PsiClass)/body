{
  PsiElementProcessor.CollectElementsWithLimit<PsiClass> processor=new PsiElementProcessor.CollectElementsWithLimit<>(5,new THashSet<>());
  ClassInheritorsSearch.search(aClass).forEach(new PsiElementProcessorAdapter<>(processor));
  if (processor.isOverflow()) {
    return aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.too.many") : DaemonBundle.message("class.is.subclassed.too.many");
  }
  PsiClass[] subclasses=processor.toArray(PsiClass.EMPTY_ARRAY);
  if (subclasses.length == 0) {
    final PsiElementProcessor.CollectElementsWithLimit<PsiFunctionalExpression> functionalImplementations=new PsiElementProcessor.CollectElementsWithLimit<>(2,new THashSet<>());
    FunctionalExpressionSearch.search(aClass).forEach(new PsiElementProcessorAdapter<>(functionalImplementations));
    if (!functionalImplementations.getCollection().isEmpty()) {
      return "Has functional implementations";
    }
    return null;
  }
  Comparator<PsiClass> comparator=PsiClassListCellRenderer.INSTANCE.getComparator();
  Arrays.sort(subclasses,comparator);
  String start=aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.by.header") : DaemonBundle.message("class.is.subclassed.by.header");
  @NonNls String pattern="&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#javaClass/{0}\">{0}</a>";
  return composeText(subclasses,start,pattern,IdeActions.ACTION_GOTO_IMPLEMENTATION);
}
