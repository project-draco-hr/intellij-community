{
  PsiElementProcessor.CollectElementsWithLimit<PsiClass> processor=new PsiElementProcessor.CollectElementsWithLimit<PsiClass>(5,new THashSet<PsiClass>());
  ClassInheritorsSearch.search(aClass,true).forEach(new PsiElementProcessorAdapter<PsiClass>(processor));
  if (processor.isOverflow()) {
    return aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.too.many") : DaemonBundle.message("class.is.subclassed.too.many");
  }
  PsiClass[] subclasses=processor.toArray(PsiClass.EMPTY_ARRAY);
  if (subclasses.length == 0) {
    final PsiElementProcessor.CollectElementsWithLimit<PsiFunctionalExpression> functionalImplementations=new PsiElementProcessor.CollectElementsWithLimit<PsiFunctionalExpression>(2,new THashSet<PsiFunctionalExpression>());
    FunctionalExpressionSearch.search(aClass).forEach(new PsiElementProcessorAdapter<PsiFunctionalExpression>(functionalImplementations));
    if (!functionalImplementations.getCollection().isEmpty()) {
      return "Has functional implementations";
    }
    return null;
  }
  Comparator<PsiClass> comparator=new PsiClassListCellRenderer().getComparator();
  Arrays.sort(subclasses,comparator);
  String start=aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.by.header") : DaemonBundle.message("class.is.subclassed.by.header");
  @NonNls String pattern="&nbsp;&nbsp;&nbsp;&nbsp;{0}";
  return GutterIconTooltipHelper.composeText(subclasses,start,pattern);
}
