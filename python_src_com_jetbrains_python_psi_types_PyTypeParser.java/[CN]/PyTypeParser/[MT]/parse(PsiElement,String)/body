{
  if (anchor == null || !anchor.isValid()) {
    return EMPTY_RESULT;
  }
  final ForwardDeclaration<ParseResult,PyElementType> typeExpr=ForwardDeclaration.create();
  final FunctionalParser<ParseResult,PyElementType> simpleType=token(IDENTIFIER).then(many(op(".").skipThen(token(IDENTIFIER)))).map(new MakeSimpleType(anchor));
  final FunctionalParser<ParseResult,PyElementType> tupleType=op("(").skipThen(typeExpr).then(many(op(",").skipThen(typeExpr))).thenSkip(op(")")).map(new Function<Pair<ParseResult,List<ParseResult>>,ParseResult>(){
    @Override public ParseResult fun(    Pair<ParseResult,List<ParseResult>> value){
      final List<PyType> types=new ArrayList<PyType>();
      ParseResult result=value.getFirst();
      types.add(result.getType());
      for (      ParseResult r : value.getSecond()) {
        result=result.merge(r);
        types.add(r.getType());
      }
      return result.withType(PyTupleType.create(anchor,types.toArray(new PyType[types.size()])));
    }
  }
);
  final FunctionalParser<ParseResult,PyElementType> typeParameter=token(PARAMETER).map(new Function<Token<PyElementType>,ParseResult>(){
    @Override public ParseResult fun(    Token<PyElementType> token){
      return new ParseResult(new PyGenericType(token.getText().toString()),token.getRange());
    }
  }
);
  final FunctionalParser<ParseResult,PyElementType> simpleExpr=simpleType.or(tupleType).or(typeParameter).cached();
  final FunctionalParser<ParseResult,PyElementType> paramExpr=simpleExpr.thenSkip(op("of")).then(simpleExpr).map(new Function<Pair<ParseResult,ParseResult>,ParseResult>(){
    @Override public ParseResult fun(    Pair<ParseResult,ParseResult> value){
      final ParseResult firstResult=value.getFirst();
      final ParseResult secondResult=value.getSecond();
      final ParseResult result=firstResult.merge(secondResult);
      final PyType firstType=firstResult.getType();
      final PyType secondType=secondResult.getType();
      if (firstType != null) {
        if (firstType instanceof PyClassType && secondType != null) {
          return result.withType(new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(),false,secondType));
        }
        return result.withType(firstType);
      }
      return EMPTY_RESULT;
    }
  }
).or(simpleExpr.thenSkip(op("from")).then(simpleExpr).thenSkip(op("to")).then(simpleExpr).map(new Function<Pair<Pair<ParseResult,ParseResult>,ParseResult>,ParseResult>(){
    @Override public ParseResult fun(    Pair<Pair<ParseResult,ParseResult>,ParseResult> value){
      final Pair<ParseResult,ParseResult> firstPair=value.getFirst();
      final ParseResult first=firstPair.getFirst();
      final ParseResult second=firstPair.getSecond();
      final ParseResult third=value.getSecond();
      final PyType firstType=first.getType();
      if (firstType instanceof PyClassType) {
        final PyTupleType tupleType=PyTupleType.create(anchor,new PyType[]{second.getType(),third.getType()});
        final PyCollectionTypeImpl type=new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(),false,tupleType);
        return first.merge(second).merge(third).withType(type);
      }
      return EMPTY_RESULT;
    }
  }
)).or(simpleExpr);
  final FunctionalParser<ParseResult,PyElementType> unionExpr=paramExpr.then(many(op("or").skipThen(paramExpr))).map(new Function<Pair<ParseResult,List<ParseResult>>,ParseResult>(){
    @Override public ParseResult fun(    Pair<ParseResult,List<ParseResult>> value){
      final ParseResult first=value.getFirst();
      final List<ParseResult> rest=value.getSecond();
      if (rest.isEmpty()) {
        return first;
      }
      final List<PyType> types=new ArrayList<PyType>();
      types.add(first.getType());
      ParseResult result=first;
      for (      ParseResult r : rest) {
        types.add(r.getType());
        result=result.merge(r);
      }
      return result.withType(PyUnionType.union(types));
    }
  }
);
  typeExpr.define(unionExpr);
  final FunctionalParser<ParseResult,PyElementType> typeFile=typeExpr.endOfInput();
  try {
    return typeFile.parse(tokenize(type));
  }
 catch (  ParserException e) {
    return EMPTY_RESULT;
  }
}
