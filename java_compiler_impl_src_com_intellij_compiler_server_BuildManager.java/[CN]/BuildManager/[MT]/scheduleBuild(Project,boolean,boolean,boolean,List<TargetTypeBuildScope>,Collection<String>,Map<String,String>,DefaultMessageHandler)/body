{
  final String projectPath=getProjectPath(project);
  final boolean isAutomake=messageHandler instanceof AutoMakeMessageHandler;
  final BuilderMessageHandler handler=new NotifyingMessageHandler(project,messageHandler,isAutomake);
  try {
    ensureListening();
  }
 catch (  Exception e) {
    final UUID sessionId=UUID.randomUUID();
    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),null));
    handler.sessionTerminated(sessionId);
    return null;
  }
  final DelegateFuture<BuilderMessageHandler> _future=new DelegateFuture<BuilderMessageHandler>();
  runCommand(new Runnable(){
    @Override public void run(){
      final Pair<RequestFuture<PreloadedProcessMessageHandler>,OSProcessHandler> preloaded=takePreloadedProcess(projectPath);
      final RequestFuture<PreloadedProcessMessageHandler> preloadedFuture=preloaded != null ? preloaded.first : null;
      final boolean usingPreloadedProcess=preloadedFuture != null;
      final UUID sessionId;
      if (usingPreloadedProcess) {
        LOG.info("Using preloaded build process to compile " + projectPath);
        sessionId=preloadedFuture.getRequestID();
        preloadedFuture.getMessageHandler().setDelegateHandler(handler);
      }
 else {
        sessionId=UUID.randomUUID();
      }
      final RequestFuture<? extends BuilderMessageHandler> future=usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler,sessionId,new CancelBuildSessionAction<BuilderMessageHandler>());
      _future.setDelegate(future);
      if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) {
        handler.sessionTerminated(sessionId);
        ((BasicFuture)future).setDone();
        return;
      }
      final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals=CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build();
      CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges;
      final SequentialTaskExecutor projectTaskQueue;
      final boolean needRescan;
synchronized (myProjectDataMap) {
        final ProjectData data=getProjectData(projectPath);
        if (isRebuild) {
          data.dropChanges();
        }
        if (IS_UNIT_TEST_MODE) {
          LOG.info("Scheduling build for " + projectPath + "; CHANGED: "+ new HashSet<String>(convertToStringPaths(data.myChanged))+ "; DELETED: "+ new HashSet<String>(convertToStringPaths(data.myDeleted)));
        }
        needRescan=data.getAndResetRescanFlag();
        currentFSChanges=needRescan ? null : data.createNextEvent();
        projectTaskQueue=data.taskQueue;
      }
      final CmdlineRemoteProto.Message.ControllerMessage params;
      if (isRebuild) {
        params=CmdlineProtoUtil.createBuildRequest(projectPath,scopes,Collections.<String>emptyList(),userData,globals,null);
      }
 else       if (onlyCheckUpToDate) {
        params=CmdlineProtoUtil.createUpToDateCheckRequest(projectPath,scopes,paths,userData,globals,currentFSChanges);
      }
 else {
        params=CmdlineProtoUtil.createBuildRequest(projectPath,scopes,isMake ? Collections.<String>emptyList() : paths,userData,globals,currentFSChanges);
      }
      if (!usingPreloadedProcess) {
        myMessageDispatcher.registerBuildMessageHandler(future,params);
      }
      try {
        projectTaskQueue.submit(new Runnable(){
          @Override public void run(){
            Throwable execFailure=null;
            try {
              if (project.isDisposed()) {
                if (usingPreloadedProcess) {
                  future.cancel(false);
                }
 else {
                  return;
                }
              }
              myBuildsInProgress.put(projectPath,future);
              final OSProcessHandler processHandler;
              CharSequence errorsOnLaunch;
              if (usingPreloadedProcess) {
                final boolean paramsSent=myMessageDispatcher.sendBuildParameters(future.getRequestID(),params);
                if (!paramsSent) {
                  myMessageDispatcher.cancelSession(future.getRequestID());
                }
                processHandler=preloaded.second;
                errorsOnLaunch=STDERR_OUTPUT.get(processHandler);
              }
 else {
                if (isAutomake && needRescan) {
                  try {
                    SwingUtilities.invokeAndWait(new Runnable(){
                      public void run(){
                        project.save();
                      }
                    }
);
                  }
 catch (                  Throwable e) {
                    LOG.info(e);
                  }
                }
                processHandler=launchBuildProcess(project,myListenPort,sessionId,false);
                errorsOnLaunch=new StringBuffer();
                processHandler.addProcessListener(new StdOutputCollector((StringBuffer)errorsOnLaunch));
                processHandler.startNotify();
              }
              while (!processHandler.waitFor()) {
                LOG.info("processHandler.waitFor() returned false for session " + sessionId + ", continue waiting");
              }
              final int exitValue=processHandler.getProcess().exitValue();
              if (exitValue != 0) {
                final StringBuilder msg=new StringBuilder();
                msg.append("Abnormal build process termination: ");
                if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) {
                  msg.append("\n").append(errorsOnLaunch);
                }
 else {
                  msg.append("unknown error");
                }
                handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(msg.toString(),null));
              }
            }
 catch (            Throwable e) {
              execFailure=e;
            }
 finally {
              myBuildsInProgress.remove(projectPath);
              notifySessionTerminationIfNeeded(sessionId,execFailure);
              if (isProcessPreloadingEnabled() && !project.isDisposed()) {
                runCommand(new Runnable(){
                  public void run(){
                    if (!myPreloadedBuilds.containsKey(projectPath)) {
                      try {
                        final Future<Pair<RequestFuture<PreloadedProcessMessageHandler>,OSProcessHandler>> preloadResult=launchPreloadedBuildProcess(project,projectTaskQueue);
                        myPreloadedBuilds.put(projectPath,preloadResult);
                      }
 catch (                      Throwable e) {
                        LOG.info("Error pre-loading build process for project " + projectPath,e);
                      }
                    }
                  }
                }
);
              }
            }
          }
        }
);
      }
 catch (      Throwable e) {
        handleProcessExecutionFailure(sessionId,e);
      }
    }
  }
);
  return _future;
}
