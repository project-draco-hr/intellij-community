{
  final String projectPath=getProjectPath(project);
  final Pair<RequestFuture<PreloadedProcessMessageHandler>,OSProcessHandler> preloaded=myPreloadedBuilds.remove(projectPath);
  final RequestFuture<PreloadedProcessMessageHandler> preloadedFuture=preloaded != null ? preloaded.first : null;
  final boolean usingPreloadedProcess=preloadedFuture != null;
  final UUID sessionId;
  final BuilderMessageHandler handler=new NotifyingMessageHandler(project,messageHandler,messageHandler instanceof AutoMakeMessageHandler);
  if (usingPreloadedProcess) {
    LOG.info("Using preloaded build process to compile " + projectPath);
    sessionId=preloadedFuture.getRequestID();
    preloadedFuture.getMessageHandler().setDelegateHandler(handler);
  }
 else {
    sessionId=UUID.randomUUID();
  }
  try {
    ensureListening();
  }
 catch (  Exception e) {
    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),null));
    handler.sessionTerminated(sessionId);
    return null;
  }
  try {
    final RequestFuture<? extends BuilderMessageHandler> future=usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler,sessionId,new RequestFuture.CancelAction<BuilderMessageHandler>(){
      @Override public void cancel(      RequestFuture<BuilderMessageHandler> future) throws Exception {
        myMessageDispatcher.cancelSession(future.getRequestID());
      }
    }
);
    runCommand(new Runnable(){
      @Override public void run(){
        if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) {
          handler.sessionTerminated(sessionId);
          future.setDone();
          return;
        }
        final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals=CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build();
        CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges;
        final SequentialTaskExecutor projectTaskQueue;
synchronized (myProjectDataMap) {
          final ProjectData data=getProjectData(projectPath);
          if (isRebuild) {
            data.dropChanges();
          }
          if (IS_UNIT_TEST_MODE) {
            LOG.info("Scheduling build for " + projectPath + "; CHANGED: "+ new HashSet<String>(convertToStringPaths(data.myChanged))+ "; DELETED: "+ new HashSet<String>(convertToStringPaths(data.myDeleted)));
          }
          currentFSChanges=data.getAndResetRescanFlag() ? null : data.createNextEvent();
          projectTaskQueue=data.taskQueue;
        }
        final CmdlineRemoteProto.Message.ControllerMessage params;
        if (isRebuild) {
          params=CmdlineProtoUtil.createBuildRequest(projectPath,scopes,Collections.<String>emptyList(),userData,globals,null);
        }
 else         if (onlyCheckUpToDate) {
          params=CmdlineProtoUtil.createUpToDateCheckRequest(projectPath,scopes,paths,userData,globals,currentFSChanges);
        }
 else {
          params=CmdlineProtoUtil.createBuildRequest(projectPath,scopes,isMake ? Collections.<String>emptyList() : paths,userData,globals,currentFSChanges);
        }
        if (!usingPreloadedProcess) {
          myMessageDispatcher.registerBuildMessageHandler(future,params);
        }
        try {
          projectTaskQueue.submit(new Runnable(){
            @Override public void run(){
              Throwable execFailure=null;
              try {
                if (project.isDisposed()) {
                  if (usingPreloadedProcess) {
                    future.cancel(true);
                  }
 else {
                    return;
                  }
                }
                myBuildsInProgress.put(projectPath,future);
                final OSProcessHandler processHandler;
                final StringBuilder errorsOnLaunch=new StringBuilder();
                if (usingPreloadedProcess) {
                  final boolean paramsSent=myMessageDispatcher.sendBuildParameters(future.getRequestID(),params);
                  if (!paramsSent) {
                    myMessageDispatcher.cancelSession(future.getRequestID());
                  }
                  processHandler=preloaded.second;
                }
 else {
                  processHandler=launchBuildProcess(project,myListenPort,sessionId,false);
                  processHandler.addProcessListener(new ProcessAdapter(){
                    @Override public void onTextAvailable(                    ProcessEvent event,                    Key outputType){
                      if (ProcessOutputTypes.STDERR.equals(outputType)) {
                        if (errorsOnLaunch.length() < 1024) {
                          final String text=event.getText();
                          if (!StringUtil.isEmptyOrSpaces(text)) {
                            errorsOnLaunch.append(text);
                          }
                        }
                      }
                    }
                  }
);
                  processHandler.startNotify();
                }
                final boolean terminated=processHandler.waitFor();
                if (terminated) {
                  final int exitValue=processHandler.getProcess().exitValue();
                  if (exitValue != 0) {
                    final StringBuilder msg=new StringBuilder();
                    msg.append("Abnormal build process termination: ");
                    if (errorsOnLaunch.length() > 0) {
                      msg.append("\n").append(errorsOnLaunch);
                    }
 else {
                      msg.append("unknown error");
                    }
                    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(msg.toString(),null));
                  }
                }
 else {
                  handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure("Disconnected from build process",null));
                }
              }
 catch (              Throwable e) {
                execFailure=e;
              }
 finally {
                myBuildsInProgress.remove(projectPath);
                if (myMessageDispatcher.getAssociatedChannel(sessionId) == null) {
                  final BuilderMessageHandler unregistered=myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
                  if (unregistered != null) {
                    if (execFailure != null) {
                      unregistered.handleFailure(sessionId,CmdlineProtoUtil.createFailure(execFailure.getMessage(),execFailure));
                    }
                    unregistered.sessionTerminated(sessionId);
                  }
                }
                if (Registry.is("compiler.process.preload") && !project.isDisposed()) {
                  try {
                    final Pair<RequestFuture<PreloadedProcessMessageHandler>,OSProcessHandler> pair=launchPreloadedBuildProcess(project);
                    myPreloadedBuilds.put(projectPath,pair);
                  }
 catch (                  Exception e) {
                    LOG.info("Error pre-loading build process for project " + projectPath,e);
                  }
                }
              }
            }
          }
);
        }
 catch (        Throwable e) {
          final BuilderMessageHandler unregistered=myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
          if (unregistered != null) {
            unregistered.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),e));
            unregistered.sessionTerminated(sessionId);
          }
        }
      }
    }
);
    return future;
  }
 catch (  Throwable e) {
    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),e));
    handler.sessionTerminated(sessionId);
  }
  return null;
}
