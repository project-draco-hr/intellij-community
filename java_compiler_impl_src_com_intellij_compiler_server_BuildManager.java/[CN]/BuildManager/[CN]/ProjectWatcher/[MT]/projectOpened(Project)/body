{
  if (ApplicationManager.getApplication().isUnitTestMode())   return;
  final MessageBusConnection conn=project.getMessageBus().connect();
  myConnections.put(project,conn);
  conn.subscribe(ProjectTopics.PROJECT_ROOTS,new ModuleRootAdapter(){
    @Override public void rootsChanged(    final ModuleRootEvent event){
      final Object source=event.getSource();
      if (source instanceof Project) {
        clearState((Project)source);
      }
    }
  }
);
  conn.subscribe(ExecutionManager.EXECUTION_TOPIC,new ExecutionAdapter(){
    @Override public void processTerminated(    @NotNull RunProfile runProfile,    @NotNull ProcessHandler handler){
      scheduleAutoMake();
    }
  }
);
  conn.subscribe(CompilerTopics.COMPILATION_STATUS,new CompilationStatusListener(){
    private final Set<String> myRootsToRefresh=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
    @Override public void automakeCompilationFinished(    int errors,    int warnings,    CompileContext compileContext){
      if (!compileContext.getProgressIndicator().isCanceled()) {
        refreshSources(compileContext);
      }
    }
    @Override public void compilationFinished(    boolean aborted,    int errors,    int warnings,    CompileContext compileContext){
      refreshSources(compileContext);
    }
    private void refreshSources(    CompileContext compileContext){
      if (project.isDisposed()) {
        return;
      }
      final Set<String> candidates=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
synchronized (myRootsToRefresh) {
        candidates.addAll(myRootsToRefresh);
        myRootsToRefresh.clear();
      }
      if (compileContext.isAnnotationProcessorsEnabled()) {
        final CompilerConfiguration config=CompilerConfiguration.getInstance(project);
        for (        Module module : compileContext.getCompileScope().getAffectedModules()) {
          if (config.getAnnotationProcessingConfiguration(module).isEnabled()) {
            final String path=CompilerPaths.getAnnotationProcessorsGenerationPath(module);
            if (path != null) {
              candidates.add(path);
            }
          }
        }
      }
      if (!candidates.isEmpty()) {
        ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
          @Override public void run(){
            if (project.isDisposed()) {
              return;
            }
            final List<File> rootFiles=new ArrayList<File>(candidates.size());
            for (            String root : candidates) {
              rootFiles.add(new File(root));
            }
            CompilerUtil.refreshOutputDirectories(rootFiles,false);
            final LocalFileSystem lfs=LocalFileSystem.getInstance();
            final Set<VirtualFile> filesToRefresh=new HashSet<VirtualFile>();
            ApplicationManager.getApplication().runReadAction(new Runnable(){
              public void run(){
                if (project.isDisposed()) {
                  return;
                }
                final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(project).getFileIndex();
                for (                File root : rootFiles) {
                  final VirtualFile rootFile=lfs.findFileByIoFile(root);
                  if (rootFile != null && fileIndex.isInSourceContent(rootFile)) {
                    filesToRefresh.add(rootFile);
                  }
                }
                if (!filesToRefresh.isEmpty()) {
                  lfs.refreshFiles(filesToRefresh,true,true,null);
                }
              }
            }
);
          }
        }
);
      }
    }
    @Override public void fileGenerated(    String outputRoot,    String relativePath){
synchronized (myRootsToRefresh) {
        myRootsToRefresh.add(outputRoot);
      }
    }
  }
);
  final String projectPath=getProjectPath(project);
  Disposer.register(project,new Disposable(){
    @Override public void dispose(){
      cancelPreloadedBuilds(projectPath);
      myProjectDataMap.remove(projectPath);
    }
  }
);
  StartupManager.getInstance(project).registerPostStartupActivity(new Runnable(){
    @Override public void run(){
      runCommand(new Runnable(){
        @Override public void run(){
          final File projectSystemDir=getProjectSystemDirectory(project);
          if (projectSystemDir != null) {
            updateUsageFile(project,projectSystemDir);
          }
        }
      }
);
      scheduleAutoMake();
    }
  }
);
}
