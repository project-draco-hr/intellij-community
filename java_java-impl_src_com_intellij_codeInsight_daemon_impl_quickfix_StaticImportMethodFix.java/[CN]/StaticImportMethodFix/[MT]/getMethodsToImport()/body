{
  final Project project=myMethodCall.getProject();
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(project);
  final PsiMethodCallExpression element=myMethodCall.getElement();
  PsiReferenceExpression reference=element.getMethodExpression();
  final PsiExpressionList argumentList=element.getArgumentList();
  String name=reference.getReferenceName();
  final List<PsiMethod> list=new ArrayList<PsiMethod>();
  if (name == null)   return list;
  GlobalSearchScope scope=element.getResolveScope();
  final Map<PsiClass,Boolean> possibleClasses=new HashMap<PsiClass,Boolean>();
  final PsiType expectedType=getExpectedType();
  final List<PsiMethod> applicableList=new ArrayList<PsiMethod>();
  final PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(project).getResolveHelper();
  final MultiMap<PsiClass,PsiMethod> deprecated=new LinkedMultiMap<PsiClass,PsiMethod>();
  final MultiMap<PsiClass,PsiMethod> suggestions=new LinkedMultiMap<PsiClass,PsiMethod>();
class RegisterMethodsProcessor {
    private void registerMethod(    PsiClass containingClass,    Collection<PsiMethod> methods){
      final Boolean alreadyMentioned=possibleClasses.get(containingClass);
      if (alreadyMentioned == Boolean.TRUE)       return;
      if (alreadyMentioned == null) {
        if (!methods.isEmpty()) {
          list.add(methods.iterator().next());
        }
        possibleClasses.put(containingClass,false);
      }
      for (      PsiMethod method : methods) {
        if (!PsiUtil.isAccessible(project,method,element,containingClass)) {
          continue;
        }
        PsiSubstitutor substitutorForMethod=resolveHelper.inferTypeArguments(method.getTypeParameters(),method.getParameterList().getParameters(),argumentList.getExpressions(),PsiSubstitutor.EMPTY,element.getParent(),DefaultParameterTypeInferencePolicy.INSTANCE);
        if (PsiUtil.isApplicable(method,substitutorForMethod,argumentList)) {
          final PsiType returnType=substitutorForMethod.substitute(method.getReturnType());
          if (expectedType == null || returnType == null || TypeConversionUtil.isAssignable(expectedType,returnType)) {
            applicableList.add(method);
            possibleClasses.put(containingClass,true);
            break;
          }
        }
      }
    }
  }
  final RegisterMethodsProcessor registrar=new RegisterMethodsProcessor();
  cache.processMethodsWithName(name,scope,new Processor<PsiMethod>(){
    @Override public boolean process(    PsiMethod method){
      ProgressManager.checkCanceled();
      if (JavaCompletionUtil.isInExcludedPackage(method,false) || !method.hasModifierProperty(PsiModifier.STATIC))       return true;
      PsiFile file=method.getContainingFile();
      final PsiClass containingClass=method.getContainingClass();
      if (file instanceof PsiJavaFile && !((PsiJavaFile)file).getPackageName().isEmpty()) {
        if (isEffectivelyDeprecated(method)) {
          deprecated.putValue(containingClass,method);
          return processCondition();
        }
        suggestions.putValue(containingClass,method);
      }
      return processCondition();
    }
    private boolean isEffectivelyDeprecated(    PsiMethod method){
      if (method.isDeprecated()) {
        return true;
      }
      PsiClass aClass=method.getContainingClass();
      while (aClass != null) {
        if (aClass.isDeprecated()) {
          return true;
        }
        aClass=aClass.getContainingClass();
      }
      return false;
    }
    private boolean processCondition(){
      return suggestions.size() + deprecated.size() < 50;
    }
  }
);
  for (  Map.Entry<PsiClass,Collection<PsiMethod>> methodEntry : suggestions.entrySet()) {
    registrar.registerMethod(methodEntry.getKey(),methodEntry.getValue());
  }
  for (  Map.Entry<PsiClass,Collection<PsiMethod>> deprecatedMethod : deprecated.entrySet()) {
    registrar.registerMethod(deprecatedMethod.getKey(),deprecatedMethod.getValue());
  }
  List<PsiMethod> result=applicableList.isEmpty() ? list : applicableList;
  for (int i=result.size() - 1; i >= 0; i--) {
    ProgressManager.checkCanceled();
    PsiMethod method=result.get(i);
    if (isExcluded(method)) {
      result.remove(i);
    }
  }
  Collections.sort(result,new PsiProximityComparator(argumentList));
  return result;
}
