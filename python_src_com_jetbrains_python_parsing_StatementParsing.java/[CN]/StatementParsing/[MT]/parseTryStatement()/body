{
  assertCurrentToken(PyTokenTypes.TRY_KEYWORD);
  final PsiBuilder.Marker statement=myBuilder.mark();
  final PsiBuilder.Marker tryPart=myBuilder.mark();
  myBuilder.advanceLexer();
  checkMatches(PyTokenTypes.COLON,"colon expected");
  parseSuite();
  tryPart.done(PyElementTypes.TRY_PART);
  boolean haveExceptClause=false;
  if (myBuilder.getTokenType() == PyTokenTypes.EXCEPT_KEYWORD) {
    haveExceptClause=true;
    while (myBuilder.getTokenType() == PyTokenTypes.EXCEPT_KEYWORD) {
      final PsiBuilder.Marker exceptBlock=myBuilder.mark();
      myBuilder.advanceLexer();
      if (myBuilder.getTokenType() != PyTokenTypes.COLON) {
        if (!getExpressionParser().parseSingleExpression(false)) {
          myBuilder.error("expression expected");
        }
        myExpectAsKeyword=true;
        if (myBuilder.getTokenType() == PyTokenTypes.COMMA || myBuilder.getTokenType() == PyTokenTypes.AS_KEYWORD) {
          myBuilder.advanceLexer();
          if (!getExpressionParser().parseSingleExpression(true)) {
            myBuilder.error("expression expected");
          }
        }
      }
      checkMatches(PyTokenTypes.COLON,"colon expected");
      parseSuite();
      exceptBlock.done(PyElementTypes.EXCEPT_PART);
    }
    final PsiBuilder.Marker elsePart=myBuilder.mark();
    if (myBuilder.getTokenType() == PyTokenTypes.ELSE_KEYWORD) {
      myBuilder.advanceLexer();
      checkMatches(PyTokenTypes.COLON,"colon expected");
      parseSuite();
      elsePart.done(PyElementTypes.ELSE_PART);
    }
 else     elsePart.drop();
  }
  final PsiBuilder.Marker finallyPart=myBuilder.mark();
  if (myBuilder.getTokenType() == PyTokenTypes.FINALLY_KEYWORD) {
    myBuilder.advanceLexer();
    checkMatches(PyTokenTypes.COLON,"colon expected");
    parseSuite();
    finallyPart.done(PyElementTypes.FINALLY_PART);
  }
 else {
    finallyPart.drop();
    if (!haveExceptClause) {
      myBuilder.error("'except' or 'finally' expected");
    }
  }
  statement.done(PyElementTypes.TRY_EXCEPT_STATEMENT);
}
