{
  PsiBuilder builder=myContext.getBuilder();
  final IElementType firstToken=builder.getTokenType();
  if (firstToken == null) {
    return;
  }
  if (firstToken == PyTokenTypes.PRINT_KEYWORD && hasPrintStatement()) {
    parsePrintStatement(builder,scope);
    return;
  }
  if (firstToken == PyTokenTypes.ASSERT_KEYWORD) {
    parseAssertStatement(scope);
    return;
  }
  if (firstToken == PyTokenTypes.BREAK_KEYWORD) {
    parseKeywordStatement(builder,PyElementTypes.BREAK_STATEMENT,scope);
    return;
  }
  if (firstToken == PyTokenTypes.CONTINUE_KEYWORD) {
    parseKeywordStatement(builder,PyElementTypes.CONTINUE_STATEMENT,scope);
    return;
  }
  if (firstToken == PyTokenTypes.DEL_KEYWORD) {
    parseDelStatement(scope);
    return;
  }
  if (firstToken == PyTokenTypes.EXEC_KEYWORD) {
    parseExecStatement(scope);
    return;
  }
  if (firstToken == PyTokenTypes.GLOBAL_KEYWORD) {
    parseNameDefiningStatement(scope,PyElementTypes.GLOBAL_STATEMENT);
    return;
  }
  if (firstToken == PyTokenTypes.NONLOCAL_KEYWORD) {
    parseNameDefiningStatement(scope,PyElementTypes.NONLOCAL_STATEMENT);
    return;
  }
  if (firstToken == PyTokenTypes.IMPORT_KEYWORD) {
    parseImportStatement(scope,PyElementTypes.IMPORT_STATEMENT,PyElementTypes.IMPORT_ELEMENT);
    return;
  }
  if (firstToken == PyTokenTypes.FROM_KEYWORD) {
    parseFromImportStatement(scope);
    return;
  }
  if (firstToken == PyTokenTypes.PASS_KEYWORD) {
    parseKeywordStatement(builder,PyElementTypes.PASS_STATEMENT,scope);
    return;
  }
  if (firstToken == PyTokenTypes.RETURN_KEYWORD) {
    parseReturnStatement(builder,scope);
    return;
  }
  if (firstToken == PyTokenTypes.RAISE_KEYWORD) {
    parseRaiseStatement(scope);
    return;
  }
  PsiBuilder.Marker exprStatement=builder.mark();
  if (builder.getTokenType() == PyTokenTypes.YIELD_KEYWORD) {
    getExpressionParser().parseYieldOrTupleExpression(false);
    checkEndOfStatement(scope);
    exprStatement.done(PyElementTypes.EXPRESSION_STATEMENT);
    return;
  }
 else   if (getExpressionParser().parseExpressionOptional()) {
    IElementType statementType=PyElementTypes.EXPRESSION_STATEMENT;
    if (PyTokenTypes.AUG_ASSIGN_OPERATIONS.contains(builder.getTokenType())) {
      statementType=PyElementTypes.AUG_ASSIGNMENT_STATEMENT;
      builder.advanceLexer();
      if (!getExpressionParser().parseYieldOrTupleExpression(false)) {
        builder.error(EXPRESSION_EXPECTED);
      }
    }
 else     if (builder.getTokenType() == PyTokenTypes.EQ) {
      statementType=PyElementTypes.ASSIGNMENT_STATEMENT;
      exprStatement.rollbackTo();
      exprStatement=builder.mark();
      getExpressionParser().parseExpression(false,true);
      LOG.assertTrue(builder.getTokenType() == PyTokenTypes.EQ,builder.getTokenType());
      builder.advanceLexer();
      while (true) {
        PsiBuilder.Marker maybeExprMarker=builder.mark();
        if (!getExpressionParser().parseYieldOrTupleExpression(false)) {
          maybeExprMarker.drop();
          builder.error(EXPRESSION_EXPECTED);
          break;
        }
        if (builder.getTokenType() == PyTokenTypes.EQ) {
          maybeExprMarker.rollbackTo();
          final int rollbackOffset=builder.getCurrentOffset();
          getExpressionParser().parseExpression(false,true);
          final int offsetAfterExpr=builder.getCurrentOffset();
          if (builder.getTokenType() != PyTokenTypes.EQ) {
            LOG.error("'=' after rollback expected",builder.getTokenType() + "; " + builder.getOriginalText().subSequence(rollbackOffset,offsetAfterExpr).toString());
          }
          builder.advanceLexer();
        }
 else {
          maybeExprMarker.drop();
          break;
        }
      }
    }
    checkEndOfStatement(scope);
    exprStatement.done(statementType);
    return;
  }
 else {
    exprStatement.drop();
  }
  builder.advanceLexer();
  if (firstToken == PyTokenTypes.INCONSISTENT_DEDENT) {
    builder.error("Unindent does not match any outer indentation level");
  }
 else   if (firstToken == PyTokenTypes.INDENT) {
    builder.error("Unexpected indent");
  }
 else {
    builder.error("Statement expected, found " + firstToken.toString());
  }
}
