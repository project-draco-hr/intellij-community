{
  final int N=1000;
  final byte[] data="xxx".getBytes(CharsetToolkit.UTF8_CHARSET);
  LocalFileSystem fs=LocalFileSystem.getInstance();
  VirtualFile vTemp=fs.findFileByIoFile(temp);
  assertNotNull(vTemp);
  VirtualFile[] children=new VirtualFile[N];
  long[] timestamp=new long[N];
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    FileUtil.writeToFile(file,data);
    VirtualFile child=fs.refreshAndFindFileByIoFile(file);
    assertNotNull(child);
    children[i]=child;
    timestamp[i]=file.lastModified();
  }
  vTemp.refresh(false,true);
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    assertEquals(timestamp[i],file.lastModified());
    VirtualFile child=fs.findFileByIoFile(file);
    assertNotNull(child);
    IoTestUtil.assertTimestampsEqual(timestamp[i],child.getTimeStamp());
  }
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    FileUtil.writeToFile(file,data);
    assertTrue(file.setLastModified(timestamp[i] - 2000));
    long modified=file.lastModified();
    assertTrue("File:" + file.getPath() + "; time:"+ modified,timestamp[i] != modified);
    timestamp[i]=modified;
    IoTestUtil.assertTimestampsNotEqual(children[i].getTimeStamp(),modified);
  }
  final CountDownLatch latch=new CountDownLatch(N);
  for (  final VirtualFile child : children) {
    child.refresh(true,true,new Runnable(){
      @Override public void run(){
        latch.countDown();
      }
    }
);
    TimeoutUtil.sleep(10);
  }
  while (latch.getCount() > 0) {
    latch.await(100,TimeUnit.MILLISECONDS);
    UIUtil.pump();
  }
  for (int i=0; i < N; i++) {
    VirtualFile child=children[i];
    IoTestUtil.assertTimestampsEqual(timestamp[i],child.getTimeStamp());
  }
}
