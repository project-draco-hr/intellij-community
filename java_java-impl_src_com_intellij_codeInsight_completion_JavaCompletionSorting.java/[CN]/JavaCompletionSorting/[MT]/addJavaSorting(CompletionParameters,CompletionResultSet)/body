{
  final PsiElement position=parameters.getPosition();
  final ExpectedTypeInfo[] expectedTypes=PsiJavaPatterns.psiElement().beforeLeaf(PsiJavaPatterns.psiElement().withText(".")).accepts(position) ? ExpectedTypeInfo.EMPTY_ARRAY : JavaSmartCompletionContributor.getExpectedTypes(parameters);
  final CompletionType type=parameters.getCompletionType();
  final boolean smart=type == CompletionType.SMART;
  final boolean afterNew=JavaSmartCompletionContributor.AFTER_NEW.accepts(position);
  List<LookupElementWeigher> afterProximity=new ArrayList<LookupElementWeigher>();
  afterProximity.add(new PreferContainingSameWords(expectedTypes));
  afterProximity.add(new PreferShorter(expectedTypes));
  CompletionSorter sorter=CompletionSorter.defaultSorter(parameters,result.getPrefixMatcher());
  if (!smart && afterNew) {
    sorter=sorter.weighBefore("liftShorter",new PreferExpected(true,expectedTypes));
  }
 else   if (PsiTreeUtil.getParentOfType(position,PsiReferenceList.class) == null) {
    sorter=((CompletionSorterImpl)sorter).withClassifier("liftShorterClasses",true,new LiftShorterClasses(position));
  }
  if (smart) {
    sorter=sorter.weighAfter("priority",new PreferDefaultTypeWeigher(expectedTypes,parameters));
  }
  List<LookupElementWeigher> afterPrefix=ContainerUtil.newArrayList();
  afterPrefix.add(new PreferByKindWeigher(type,position));
  if (!smart) {
    ContainerUtil.addIfNotNull(afterPrefix,preferStatics(position,expectedTypes));
    if (!afterNew) {
      afterPrefix.add(new PreferExpected(false,expectedTypes));
    }
  }
  ContainerUtil.addIfNotNull(afterPrefix,recursion(parameters,expectedTypes));
  Collections.addAll(afterPrefix,new PreferSimilarlyEnding(expectedTypes),new PreferNonGeneric(),new PreferAccessible(position),new PreferSimple());
  sorter=sorter.weighAfter("prefix",afterPrefix.toArray(new LookupElementWeigher[afterPrefix.size()]));
  sorter=sorter.weighAfter("proximity",afterProximity.toArray(new LookupElementWeigher[afterProximity.size()]));
  return result.withRelevanceSorter(sorter);
}
