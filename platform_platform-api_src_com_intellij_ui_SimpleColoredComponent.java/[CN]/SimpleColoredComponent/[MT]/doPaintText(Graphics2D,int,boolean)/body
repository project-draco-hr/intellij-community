{
  if (offset == 0) {
    offset=myIpad.left;
  }
  int textStart=offset;
  if (myBorder != null) {
    offset+=myBorder.getBorderInsets(this).left;
  }
  final List<Object[]> searchMatches=new ArrayList<Object[]>();
  applyAdditionalHints(g);
  final Font baseFont=getBaseFont();
  g.setFont(baseFont);
  offset+=computeTextAlignShift(baseFont);
  int baseSize=baseFont.getSize();
  FontMetrics baseMetrics=g.getFontMetrics();
  Rectangle area=computePaintArea();
  final int textBaseline=area.y + getTextBaseLine(baseMetrics,area.height);
  boolean wasSmaller=false;
  for (int i=0; i < myFragments.size(); i++) {
    final SimpleTextAttributes attributes=myAttributes.get(i);
    Font font=g.getFont();
    boolean isSmaller=attributes.isSmaller();
    if (font.getStyle() != attributes.getFontStyle() || isSmaller != wasSmaller) {
      font=font.deriveFont(attributes.getFontStyle(),isSmaller ? UIUtil.getFontSize(UIUtil.FontSize.SMALL) : baseSize);
    }
    wasSmaller=isSmaller;
    g.setFont(font);
    final FontMetrics metrics=g.getFontMetrics(font);
    final int fragmentWidth=computeStringWidth(i,font);
    final int fragmentPadding=myFragmentPadding.get(i);
    final Color bgColor=attributes.isSearchMatch() ? null : attributes.getBgColor();
    if ((attributes.isOpaque() || isOpaque()) && bgColor != null) {
      g.setColor(bgColor);
      g.fillRect(offset,0,fragmentWidth,getHeight());
    }
    Color color=attributes.getFgColor();
    if (color == null) {
      color=getForeground();
    }
    if (!isEnabled()) {
      color=UIUtil.getInactiveTextColor();
    }
    g.setColor(color);
    final int fragmentAlignment=myFragmentAlignment.get(i);
    final int endOffset;
    if (fragmentPadding > 0 && fragmentPadding > fragmentWidth) {
      endOffset=fragmentPadding;
      if (fragmentAlignment == SwingConstants.RIGHT || fragmentAlignment == SwingConstants.TRAILING) {
        offset=fragmentPadding - fragmentWidth;
      }
    }
 else {
      endOffset=offset + fragmentWidth;
    }
    if (!attributes.isSearchMatch()) {
      if (shouldDrawMacShadow()) {
        g.setColor(SHADOW_COLOR);
        doDrawString(g,i,offset,textBaseline + 1);
      }
      if (shouldDrawDimmed()) {
        color=ColorUtil.dimmer(color);
      }
      g.setColor(color);
      doDrawString(g,i,offset,textBaseline);
    }
    g.setStroke(g.getStroke());
    if (attributes.isStrikeout() && !attributes.isSearchMatch()) {
      drawStrikeout(g,offset,offset + fragmentWidth,textBaseline);
    }
    if (attributes.isWaved()) {
      EffectPainter.WAVE_UNDERSCORE.paint(g,offset,textBaseline + 1,fragmentWidth,Math.max(2,metrics.getDescent()),attributes.getWaveColor());
    }
    if (attributes.isUnderline()) {
      final int underlineAt=textBaseline + 1;
      UIUtil.drawLine(g,offset,underlineAt,offset + fragmentWidth,underlineAt);
    }
    if (attributes.isBoldDottedLine()) {
      final int dottedAt=SystemInfo.isMac ? textBaseline : textBaseline + 1;
      final Color lineColor=attributes.getWaveColor();
      UIUtil.drawBoldDottedLine(g,offset,offset + fragmentWidth,dottedAt,bgColor,lineColor,isOpaque());
    }
    if (attributes.isSearchMatch()) {
      searchMatches.add(new Object[]{offset,offset + fragmentWidth,textBaseline,myFragments.get(i),g.getFont(),attributes});
    }
    offset=endOffset;
  }
  if (myPaintFocusBorder && myBorder != null) {
    if (focusAroundIcon) {
      myBorder.paintBorder(this,g,0,0,getWidth(),getHeight());
    }
 else {
      myBorder.paintBorder(this,g,textStart,0,getWidth() - textStart,getHeight());
    }
  }
  for (  final Object[] info : searchMatches) {
    Integer x1=(Integer)info[0];
    Integer x2=(Integer)info[1];
    UIUtil.drawSearchMatch(g,x1,x2,getHeight());
    g.setFont((Font)info[4]);
    Integer baseline=(Integer)info[2];
    String text=(String)info[3];
    if (shouldDrawMacShadow()) {
      g.setColor(SHADOW_COLOR);
      g.drawString(text,x1,baseline + 1);
    }
    g.setColor(new JBColor(Gray._50,Gray._0));
    g.drawString(text,x1,baseline);
    if (((SimpleTextAttributes)info[5]).isStrikeout()) {
      drawStrikeout(g,x1,x2,baseline);
    }
  }
  return offset;
}
