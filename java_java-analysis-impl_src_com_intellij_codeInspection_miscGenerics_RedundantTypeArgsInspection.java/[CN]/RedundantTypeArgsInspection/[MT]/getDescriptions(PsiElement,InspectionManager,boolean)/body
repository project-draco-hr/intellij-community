{
  final List<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>();
  place.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitMethodCallExpression(    PsiMethodCallExpression expression){
      super.visitMethodCallExpression(expression);
      final PsiType[] typeArguments=expression.getTypeArguments();
      if (typeArguments.length > 0) {
        checkCallExpression(expression.getMethodExpression(),typeArguments,expression,inspectionManager,problems);
      }
    }
    @Override public void visitNewExpression(    PsiNewExpression expression){
      super.visitNewExpression(expression);
      final PsiType[] typeArguments=expression.getTypeArguments();
      if (typeArguments.length > 0) {
        final PsiJavaCodeReferenceElement classReference=expression.getClassReference();
        if (classReference != null) {
          checkCallExpression(classReference,typeArguments,expression,inspectionManager,problems);
        }
      }
    }
    @Override public void visitMethodReferenceExpression(    PsiMethodReferenceExpression expression){
      super.visitMethodReferenceExpression(expression);
      checkMethodReference(expression,inspectionManager,problems);
    }
    private void checkCallExpression(    final PsiJavaCodeReferenceElement reference,    final PsiType[] typeArguments,    PsiCallExpression expression,    final InspectionManager inspectionManager,    final List<ProblemDescriptor> problems){
      PsiExpressionList argumentList=expression.getArgumentList();
      if (argumentList == null)       return;
      final JavaResolveResult resolveResult=reference.advancedResolve(false);
      final PsiElement element=resolveResult.getElement();
      if (element instanceof PsiMethod && resolveResult.isValidResult()) {
        PsiMethod method=(PsiMethod)element;
        final PsiTypeParameter[] typeParameters=method.getTypeParameters();
        if (typeParameters.length == typeArguments.length) {
          final PsiType typeByParent=PsiTypesUtil.getExpectedTypeByParent(expression);
          if (typeByParent != null) {
            final String arrayInitializer="new " + typeByParent.getCanonicalText() + "[]{0}";
            final PsiNewExpression newExpr=(PsiNewExpression)JavaPsiFacade.getInstance(expression.getProject()).getElementFactory().createExpressionFromText(arrayInitializer,expression);
            final PsiArrayInitializerExpression initializer=newExpr.getArrayInitializer();
            LOG.assertTrue(initializer != null);
            final PsiCallExpression copy=(PsiCallExpression)initializer.getInitializers()[0].replace(expression);
            if (!isInferenceEquivalent(typeArguments,method,typeParameters,copy)) {
              return;
            }
          }
 else {
            final PsiCall topLevelCall=InferenceSessionContainer.treeWalkUp(expression);
            if (topLevelCall != null) {
              final int offset=expression.getTextRange().getStartOffset() - topLevelCall.getTextRange().getStartOffset();
              final PsiCall topLevelCopy=(PsiCall)topLevelCall.copy();
              final PsiElement elementInCopy=topLevelCopy.getContainingFile().findElementAt(topLevelCopy.getTextRange().getStartOffset() + offset);
              if (!isInferenceEquivalent(typeArguments,method,typeParameters,elementInCopy)) {
                return;
              }
            }
 else {
              return;
            }
          }
          final ProblemDescriptor descriptor=inspectionManager.createProblemDescriptor(expression.getTypeArgumentList(),InspectionsBundle.message("inspection.redundant.type.problem.descriptor"),myQuickFixAction,ProblemHighlightType.LIKE_UNUSED_SYMBOL,false);
          problems.add(descriptor);
        }
      }
    }
    private boolean isInferenceEquivalent(    PsiType[] typeArguments,    PsiMethod method,    PsiTypeParameter[] typeParameters,    PsiElement elementInCopy){
      final PsiCallExpression exprCopy=PsiTreeUtil.getParentOfType(elementInCopy,PsiCallExpression.class,false);
      if (exprCopy != null) {
        try {
          final PsiMethodCallExpression expr=(PsiMethodCallExpression)JavaPsiFacade.getInstance(exprCopy.getProject()).getElementFactory().createExpressionFromText("foo()",null);
          exprCopy.getTypeArgumentList().replace(expr.getTypeArgumentList());
        }
 catch (        IncorrectOperationException e) {
          LOG.error(e);
          return false;
        }
        final JavaResolveResult copyResult=exprCopy.resolveMethodGenerics();
        if (method != copyResult.getElement())         return false;
        final PsiSubstitutor psiSubstitutor=copyResult.getSubstitutor();
        for (int i=0, length=typeParameters.length; i < length; i++) {
          PsiTypeParameter typeParameter=typeParameters[i];
          final PsiType inferredType=psiSubstitutor.getSubstitutionMap().get(typeParameter);
          if (!typeArguments[i].equals(inferredType)) {
            return false;
          }
          if (PsiUtil.resolveClassInType(method.getReturnType()) == typeParameter && PsiPrimitiveType.getUnboxedType(inferredType) != null) {
            return false;
          }
        }
      }
      return true;
    }
  }
);
  if (problems.isEmpty())   return null;
  return problems.toArray(new ProblemDescriptor[problems.size()]);
}
