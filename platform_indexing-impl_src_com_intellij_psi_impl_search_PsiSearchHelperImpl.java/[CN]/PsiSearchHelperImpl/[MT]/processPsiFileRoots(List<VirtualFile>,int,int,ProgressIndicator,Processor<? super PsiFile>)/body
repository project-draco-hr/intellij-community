{
  myManager.startBatchFilesProcessingMode();
  try {
    final AtomicInteger counter=new AtomicInteger(alreadyProcessedFiles);
    final AtomicBoolean canceled=new AtomicBoolean(false);
    final List<VirtualFile> failedFiles=Collections.synchronizedList(new SmartList<VirtualFile>());
    boolean completed=JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files,progress,false,false,new Processor<VirtualFile>(){
      @Override public boolean process(      final VirtualFile vfile){
        try {
          TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();
          processVirtualFile(vfile,progress,localProcessor,canceled,counter,totalSize);
        }
 catch (        ApplicationUtil.CannotRunReadActionException action) {
          failedFiles.add(vfile);
        }
        return !canceled.get();
      }
    }
);
    if (!failedFiles.isEmpty()) {
      for (      final VirtualFile vfile : failedFiles) {
        progress.checkCanceled();
        TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          @Override public void run(){
            processVirtualFile(vfile,progress,localProcessor,canceled,counter,totalSize);
          }
        }
);
      }
    }
    return completed;
  }
  finally {
    myManager.finishBatchFilesProcessingMode();
  }
}
