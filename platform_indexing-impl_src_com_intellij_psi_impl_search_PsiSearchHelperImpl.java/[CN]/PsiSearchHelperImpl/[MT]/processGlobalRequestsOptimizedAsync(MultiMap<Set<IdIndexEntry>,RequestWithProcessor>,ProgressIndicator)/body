{
  if (singles.isEmpty()) {
    return AsyncFutureFactory.wrap(true);
  }
  if (singles.size() == 1) {
    final Collection<RequestWithProcessor> requests=singles.get(singles.keySet().iterator().next());
    if (requests.size() == 1) {
      final RequestWithProcessor theOnly=requests.iterator().next();
      return processSingleRequestAsync(theOnly.request,theOnly.refProcessor);
    }
  }
  if (progress != null) {
    progress.pushState();
    progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  }
  final MultiMap<VirtualFile,RequestWithProcessor> candidateFiles=collectFiles(singles,progress);
  if (candidateFiles.isEmpty()) {
    return AsyncFutureFactory.wrap(true);
  }
  final Map<RequestWithProcessor,StringSearcher> searchers=new HashMap<RequestWithProcessor,StringSearcher>();
  final Set<String> allWords=new TreeSet<String>();
  for (  RequestWithProcessor singleRequest : candidateFiles.values()) {
    searchers.put(singleRequest,new StringSearcher(singleRequest.request.word,singleRequest.request.caseSensitive,true,false));
    allWords.add(singleRequest.request.word);
  }
  if (progress != null) {
    progress.setText(PsiBundle.message("psi.search.for.word.progress",getPresentableWordsDescription(allWords)));
  }
  final AsyncFuture<Boolean> result=processPsiFileRootsAsync(new ArrayList<VirtualFile>(candidateFiles.keySet()),new Processor<PsiElement>(){
    @Override public boolean process(    final PsiElement psiRoot){
      TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();
      final VirtualFile vfile=ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>(){
        public VirtualFile compute(){
          return psiRoot.getContainingFile().getVirtualFile();
        }
      }
);
      for (      final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {
        final StringSearcher searcher=searchers.get(singleRequest);
        final TextOccurenceProcessor adapted=adaptProcessor(singleRequest.request,singleRequest.refProcessor);
        if (!ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
          public Boolean compute(){
            return LowLevelSearchUtil.processElementsContainingWordInElement(adapted,psiRoot,searcher,true,progress);
          }
        }
)) {
          return false;
        }
      }
      return true;
    }
  }
,progress);
  return new FinallyFuture<Boolean>(result,new Runnable(){
    @Override public void run(){
      if (progress != null) {
        progress.popState();
      }
    }
  }
);
}
