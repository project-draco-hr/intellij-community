{
  if (Thread.holdsLock(PsiLock.LOCK)) {
    throw new AssertionError("You must not run search from within updating PSI activity. Please consider invokeLatering it instead.");
  }
  if (progress != null) {
    progress.pushState();
    progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  }
  String text=searcher.getPattern();
  List<VirtualFile> fileSet=new ArrayList<VirtualFile>();
  getFilesWithText(scope,searchContext,caseSensitively,text,progress,fileSet);
  if (progress != null) {
    progress.setText(PsiBundle.message("psi.search.for.word.progress",text));
  }
  final Processor<PsiElement> localProcessor=localProcessor(processor,progress,true,searcher);
  if (containerName != null) {
    List<VirtualFile> containerFiles=new ArrayList<VirtualFile>();
    getFilesWithText(scope,searchContext,caseSensitively,containerName,progress,containerFiles);
    if (!containerFiles.isEmpty()) {
      Comparator<VirtualFile> byId=new Comparator<VirtualFile>(){
        @Override public int compare(        VirtualFile o1,        VirtualFile o2){
          return ((VirtualFileWithId)o1).getId() - ((VirtualFileWithId)o2).getId();
        }
      }
;
      ContainerUtil.quickSort(fileSet,byId);
      ContainerUtil.quickSort(containerFiles,byId);
      List<VirtualFile> intersection=new ArrayList<VirtualFile>(fileSet.size());
      final List<VirtualFile> rest=new ArrayList<VirtualFile>();
      splitSortedLists(fileSet,containerFiles,byId,intersection,rest);
      if (!intersection.isEmpty()) {
        int totalSize=rest.size() + intersection.size();
        AsyncFuture<Boolean> intersectionResult=processPsiFileRootsAsync(intersection,totalSize,0,progress,localProcessor);
        AsyncFuture<Boolean> result;
        try {
          if (intersectionResult.get()) {
            AsyncFuture<Boolean> restResult=processPsiFileRootsAsync(rest,totalSize,intersection.size(),progress,localProcessor);
            result=bind(intersectionResult,restResult);
          }
 else {
            result=intersectionResult;
          }
        }
 catch (        ExecutionException e) {
          Throwable cause=e.getCause();
          if (cause instanceof RuntimeException)           throw (RuntimeException)cause;
          if (cause instanceof Error)           throw (Error)cause;
          result=AsyncFutureFactory.wrapException(cause);
        }
catch (        InterruptedException e) {
          result=AsyncFutureFactory.wrapException(e);
        }
        return popStateAfter(result,progress);
      }
    }
  }
  AsyncFuture<Boolean> result=processPsiFileRootsAsync(fileSet,fileSet.size(),0,progress,localProcessor);
  return popStateAfter(result,progress);
}
