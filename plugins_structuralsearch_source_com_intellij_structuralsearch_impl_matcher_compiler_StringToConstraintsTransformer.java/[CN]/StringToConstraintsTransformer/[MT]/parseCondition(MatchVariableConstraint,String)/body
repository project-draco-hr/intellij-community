{
  StringTokenizer tokenizer=new StringTokenizer(s,"&&");
  while (tokenizer.hasMoreElements()) {
    String token=tokenizer.nextToken().trim();
    boolean hasNot=false;
    boolean consumed=false;
    String option;
    if (StringUtil.startsWithChar(token,'!')) {
      token=token.substring(1);
      hasNot=true;
    }
    Matcher m=p.matcher(token);
    if (m.matches()) {
      option=m.group(1);
      if (option.equalsIgnoreCase("ref")) {
        String name=m.group(2);
        constraint.setReference(true);
        constraint.setInvertReference(hasNot);
        constraint.setNameOfReferenceVar(name);
        consumed=true;
      }
    }
 else {
      m=p2.matcher(token);
      if (m.matches()) {
        option=m.group(1);
        if (option.equalsIgnoreCase("read")) {
          constraint.setReadAccess(true);
          constraint.setInvertReadAccess(hasNot);
          consumed=true;
        }
 else         if (option.equalsIgnoreCase("write")) {
          constraint.setWriteAccess(true);
          constraint.setInvertWriteAccess(hasNot);
          consumed=true;
        }
      }
 else {
        m=p3.matcher(token);
        if (m.matches()) {
          option=m.group(1);
          if (option.equalsIgnoreCase("regex") || option.equalsIgnoreCase("regexw")) {
            String typePattern=getSingleParameter(m,"Reg exp should be delimited with spaces");
            if (StringUtil.startsWithChar(typePattern,'*')) {
              typePattern=typePattern.substring(1);
              constraint.setWithinHierarchy(true);
            }
            constraint.setRegExp(typePattern);
            constraint.setInvertRegExp(hasNot);
            consumed=true;
            if (option.equalsIgnoreCase("regexw")) {
              constraint.setWholeWordsOnly(true);
            }
          }
 else           if (option.equalsIgnoreCase("exprtype")) {
            String exprTypePattern=getSingleParameter(m,"Reg exp in expr type should be delimited with spaces");
            if (StringUtil.startsWithChar(exprTypePattern,'*')) {
              exprTypePattern=exprTypePattern.substring(1);
              constraint.setExprTypeWithinHierarchy(true);
            }
            constraint.setNameOfExprType(exprTypePattern);
            constraint.setInvertExprType(hasNot);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase("formal")) {
            String exprTypePattern=getSingleParameter(m,"Reg exp in formal arg type should be delimited with spaces");
            if (StringUtil.startsWithChar(exprTypePattern,'*')) {
              exprTypePattern=exprTypePattern.substring(1);
              constraint.setFormalArgTypeWithinHierarchy(true);
            }
            constraint.setNameOfFormalArgType(exprTypePattern);
            constraint.setInvertFormalType(hasNot);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase("script")) {
            String script=getSingleParameter(m,"Script should be delimited with spaces");
            constraint.setScriptCodeConstraint(script);
            consumed=true;
          }
        }
      }
    }
    if (!consumed) {
      throw new UnsupportedPatternException(token + " option is not recognized");
    }
  }
}
