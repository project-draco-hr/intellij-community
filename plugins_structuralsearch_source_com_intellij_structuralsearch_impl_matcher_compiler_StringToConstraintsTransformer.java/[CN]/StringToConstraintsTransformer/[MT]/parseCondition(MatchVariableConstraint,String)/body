{
  StringTokenizer tokenizer=new StringTokenizer(s,"&&");
  while (tokenizer.hasMoreElements()) {
    String token=tokenizer.nextToken().trim();
    boolean hasNot=false;
    boolean consumed=false;
    String option;
    if (StringUtil.startsWithChar(token,'!')) {
      token=token.substring(1);
      hasNot=true;
    }
    Matcher m=p.matcher(token);
    if (m.matches()) {
      option=m.group(1);
      if (option.equalsIgnoreCase(REF)) {
        String name=m.group(2);
        constraint.setReference(true);
        constraint.setInvertReference(hasNot);
        constraint.setNameOfReferenceVar(name);
        consumed=true;
      }
    }
 else {
      m=p2.matcher(token);
      if (m.matches()) {
        option=m.group(1);
        if (option.equalsIgnoreCase(READ)) {
          constraint.setReadAccess(true);
          constraint.setInvertReadAccess(hasNot);
          consumed=true;
        }
 else         if (option.equalsIgnoreCase(WRITE)) {
          constraint.setWriteAccess(true);
          constraint.setInvertWriteAccess(hasNot);
          consumed=true;
        }
      }
 else {
        m=p3.matcher(token);
        if (m.matches()) {
          option=m.group(1);
          if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) {
            String typePattern=getSingleParameter(m,SSRBundle.message("reg.exp.should.be.delimited.with.spaces.error.message"));
            if (StringUtil.startsWithChar(typePattern,'*')) {
              typePattern=typePattern.substring(1);
              constraint.setWithinHierarchy(true);
            }
            constraint.setRegExp(typePattern);
            constraint.setInvertRegExp(hasNot);
            consumed=true;
            if (option.equalsIgnoreCase(REGEXW)) {
              constraint.setWholeWordsOnly(true);
            }
          }
 else           if (option.equalsIgnoreCase(EXPRTYPE)) {
            String exprTypePattern=getSingleParameter(m,SSRBundle.message("reg.exp.in.expr.type.should.be.delimited.with.spaces.error.message"));
            if (StringUtil.startsWithChar(exprTypePattern,'*')) {
              exprTypePattern=exprTypePattern.substring(1);
              constraint.setExprTypeWithinHierarchy(true);
            }
            constraint.setNameOfExprType(exprTypePattern);
            constraint.setInvertExprType(hasNot);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase(FORMAL)) {
            String exprTypePattern=getSingleParameter(m,SSRBundle.message("reg.exp.in.formal.arg.type.should.be.delimited.with.spaces.error.message"));
            if (StringUtil.startsWithChar(exprTypePattern,'*')) {
              exprTypePattern=exprTypePattern.substring(1);
              constraint.setFormalArgTypeWithinHierarchy(true);
            }
            constraint.setNameOfFormalArgType(exprTypePattern);
            constraint.setInvertFormalType(hasNot);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase(SCRIPT)) {
            String script=getSingleParameter(m,SSRBundle.message("script.should.be.delimited.with.spaces.error.message"));
            constraint.setScriptCodeConstraint(script);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase(CONTAINS)) {
            if (hasNot)             constraint.setInvertContainsConstraint(true);
            String script=getSingleParameter(m,SSRBundle.message("script.should.be.delimited.with.spaces.error.message"));
            constraint.setContainsConstraint(script);
            consumed=true;
          }
 else           if (option.equalsIgnoreCase(WITHIN)) {
            if (hasNot)             constraint.setInvertWithinConstraint(true);
            String script=getSingleParameter(m,SSRBundle.message("script.should.be.delimited.with.spaces.error.message"));
            constraint.setWithinConstraint(script);
            consumed=true;
          }
        }
      }
    }
    if (!consumed) {
      throw new UnsupportedPatternException(SSRBundle.message("option.is.not.recognized.error.message",token));
    }
  }
}
