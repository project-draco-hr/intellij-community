{
  String content;
  if (kind == OccurenceKind.LITERAL) {
    content=pattern.substring(1,pattern.length() - 1);
  }
 else   if (kind == OccurenceKind.COMMENT) {
    content=pattern;
  }
 else {
    return null;
  }
  @NonNls StringBuilder buf=new StringBuilder(content.length());
  Matcher matcher=substitutionPattern.matcher(content);
  List<SubstitutionHandler> handlers=null;
  int start=0;
  String word;
  boolean hasLiteralContent=false;
  SubstitutionHandler handler=null;
  while (matcher.find()) {
    if (handlers == null)     handlers=new ArrayList<SubstitutionHandler>();
    handler=(SubstitutionHandler)getContext().getPattern().getHandler(matcher.group(1));
    if (handler != null)     handlers.add(handler);
    word=content.substring(start,matcher.start());
    if (word.length() > 0) {
      buf.append(StructuralSearchUtil.shieldSpecialChars(word));
      hasLiteralContent=true;
      processTokenizedName(word,false,kind);
    }
    RegExpPredicate predicate=MatchingHandler.getSimpleRegExpPredicate(handler);
    if (predicate == null || !predicate.isWholeWords()) {
      buf.append("(.*?)");
    }
 else {
      buf.append(".*?\\b(").append(predicate.getRegExp()).append(")\\b.*?");
    }
    if (isSuitablePredicate(predicate,handler)) {
      processTokenizedName(predicate.getRegExp(),false,kind);
    }
    start=matcher.end();
  }
  word=content.substring(start,content.length());
  if (word.length() > 0) {
    hasLiteralContent=true;
    buf.append(StructuralSearchUtil.shieldSpecialChars(word));
    processTokenizedName(word,false,kind);
  }
  if (hasLiteralContent) {
    if (kind == OccurenceKind.LITERAL) {
      buf.insert(0,"[\"']");
      buf.append("[\"']");
    }
    buf.append("$");
  }
  if (handlers != null) {
    return (hasLiteralContent) ? new LiteralWithSubstitutionHandler(buf.toString(),handlers) : handler;
  }
  return null;
}
