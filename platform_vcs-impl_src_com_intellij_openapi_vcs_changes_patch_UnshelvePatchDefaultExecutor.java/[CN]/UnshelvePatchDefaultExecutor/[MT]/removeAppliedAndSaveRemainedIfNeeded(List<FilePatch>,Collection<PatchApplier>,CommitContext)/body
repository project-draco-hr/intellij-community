{
  ShelveChangesManager shelveChangesManager=ShelveChangesManager.getInstance(myProject);
  if (!shelveChangesManager.isRemoveFilesFromShelf())   return;
  try {
    List<FilePatch> textPatches=ContainerUtil.newArrayList(remaining);
    List<FilePatch> remainingBinaries=ContainerUtil.<FilePatch>newArrayList(myBinaryShelvedPatches);
    for (    PatchApplier applier : appliers) {
      textPatches.addAll(applier.getRemainingPatches());
      remainingBinaries.removeAll(applier.getBinaryPatches());
    }
    if (textPatches.isEmpty() && remainingBinaries.isEmpty()) {
      shelveChangesManager.recycleChangeList(myCurrentShelveChangeList);
    }
 else {
      shelveChangesManager.saveRemainingPatches(myCurrentShelveChangeList,textPatches,ContainerUtil.mapNotNull(remainingBinaries,new Function<FilePatch,ShelvedBinaryFile>(){
        @Override public ShelvedBinaryFile fun(        FilePatch patch){
          return patch instanceof ShelvedBinaryFilePatch ? ((ShelvedBinaryFilePatch)patch).getShelvedBinaryFile() : null;
        }
      }
),commitContext);
    }
  }
 catch (  Exception e) {
    LOG.error("Couldn't update and store remaining patches",e);
  }
}
