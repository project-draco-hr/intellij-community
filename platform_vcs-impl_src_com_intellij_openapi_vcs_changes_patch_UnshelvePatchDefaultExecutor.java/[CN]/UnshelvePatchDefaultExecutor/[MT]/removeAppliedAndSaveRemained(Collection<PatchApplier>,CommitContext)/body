{
  ShelveChangesManager shelveChangesManager=ShelveChangesManager.getInstance(myProject);
  try {
    List<FilePatch> textPatches=ContainerUtil.<FilePatch>newArrayList(ShelveChangesManager.loadPatches(myProject,myCurrentShelveChangeList.PATH,commitContext));
    List<FilePatch> remainingBinaries=ContainerUtil.<FilePatch>newArrayList(myBinaryShelvedPatches);
    for (    PatchApplier applier : appliers) {
      textPatches.removeAll(applier.getPatches());
      textPatches.addAll(applier.getRemainingPatches());
      remainingBinaries.removeAll(applier.getBinariesPatches());
    }
    if (textPatches.isEmpty() && remainingBinaries.isEmpty()) {
      shelveChangesManager.recycleChangeList(myCurrentShelveChangeList);
    }
 else {
      shelveChangesManager.saveRemainingPatches(myCurrentShelveChangeList,textPatches,ContainerUtil.mapNotNull(remainingBinaries,new Function<FilePatch,ShelvedBinaryFile>(){
        @Override public ShelvedBinaryFile fun(        FilePatch patch){
          return patch instanceof ShelveChangesManager.ShelvedBinaryFilePatch ? ((ShelveChangesManager.ShelvedBinaryFilePatch)patch).getShelvedBinaryFile() : null;
        }
      }
),commitContext);
    }
  }
 catch (  Exception e) {
    LOG.error("Couldn't update and store remaining patches",e);
  }
}
