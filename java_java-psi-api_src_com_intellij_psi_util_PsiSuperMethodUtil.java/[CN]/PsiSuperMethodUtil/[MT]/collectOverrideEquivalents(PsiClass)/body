{
  final Map<MethodSignature,Set<PsiMethod>> overrideEquivalent=new THashMap<MethodSignature,Set<PsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  final GlobalSearchScope resolveScope=aClass.getResolveScope();
  PsiClass[] supers=aClass.getSupers();
  for (int i=0; i < supers.length; i++) {
    PsiClass superClass=supers[i];
    boolean subType=false;
    for (int j=0; j < supers.length; j++) {
      if (j == i)       continue;
      subType|=supers[j].isInheritor(supers[i],true);
    }
    if (subType)     continue;
    final PsiSubstitutor superClassSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(superClass,aClass,PsiSubstitutor.EMPTY);
    for (    HierarchicalMethodSignature hms : superClass.getVisibleSignatures()) {
      PsiMethod method=hms.getMethod();
      if (MethodSignatureUtil.findMethodBySignature(aClass,method.getSignature(superClassSubstitutor),false) != null)       continue;
      final PsiClass containingClass=mapClass(method.getContainingClass(),resolveScope);
      if (containingClass == null)       continue;
      method=containingClass.findMethodBySignature(method,false);
      if (method == null)       continue;
      final PsiSubstitutor containingClassSubstitutor=TypeConversionUtil.getClassSubstitutor(containingClass,aClass,PsiSubstitutor.EMPTY);
      if (containingClassSubstitutor == null)       continue;
      final PsiSubstitutor finalSubstitutor=obtainFinalSubstitutor(containingClass,containingClassSubstitutor,hms.getSubstitutor(),false);
      final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,finalSubstitutor,false);
      Set<PsiMethod> methods=overrideEquivalent.get(signature);
      if (methods == null) {
        methods=new LinkedHashSet<PsiMethod>();
        overrideEquivalent.put(signature,methods);
      }
      methods.add(method);
    }
  }
  return overrideEquivalent;
}
