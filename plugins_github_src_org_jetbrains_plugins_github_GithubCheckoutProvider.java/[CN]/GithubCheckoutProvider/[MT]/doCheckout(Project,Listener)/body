{
  if (!GithubUtil.testGitExecutable(project)) {
    return;
  }
  BasicAction.saveAll();
  final Ref<List<GithubRepo>> repositoryInfoRef=new Ref<List<GithubRepo>>();
  ProgressManager.getInstance().run(new Task.Modal(project,"Access to GitHub",true){
    public void run(    @NotNull ProgressIndicator indicator){
      try {
        GithubUtil.runAndGetValidAuth(project,indicator,new ThrowableConsumer<GithubAuthData,IOException>(){
          @Override public void consume(          GithubAuthData authData) throws IOException {
            repositoryInfoRef.set(GithubApiUtil.getAvailableRepos(authData));
          }
        }
);
      }
 catch (      IOException e) {
        GithubNotifications.showError(project,"Couldn't get the list of GitHub repositories",e);
      }
    }
  }
);
  final List<GithubRepo> availableRepos=repositoryInfoRef.get();
  if (availableRepos == null) {
    return;
  }
  Collections.sort(availableRepos,new Comparator<GithubRepo>(){
    @Override public int compare(    final GithubRepo r1,    final GithubRepo r2){
      final int comparedOwners=r1.getOwner().getLogin().compareTo(r2.getOwner().getLogin());
      return comparedOwners != 0 ? comparedOwners : r1.getName().compareTo(r2.getName());
    }
  }
);
  final GitCloneDialog dialog=new GitCloneDialog(project);
  for (int i=availableRepos.size() - 1; i >= 0; i--) {
    dialog.prependToHistory(availableRepos.get(i).getCloneUrl());
  }
  dialog.show();
  if (!dialog.isOK()) {
    return;
  }
  dialog.rememberSettings();
  final VirtualFile destinationParent=LocalFileSystem.getInstance().findFileByIoFile(new File(dialog.getParentDirectory()));
  if (destinationParent == null) {
    return;
  }
  final String sourceRepositoryURL=dialog.getSourceRepositoryURL();
  final String directoryName=dialog.getDirectoryName();
  final String parentDirectory=dialog.getParentDirectory();
  Git git=ServiceManager.getService(Git.class);
  GitCheckoutProvider.clone(project,git,listener,destinationParent,sourceRepositoryURL,directoryName,parentDirectory);
}
