{
  final PsiTypeParameter[] parameters=myClass.getTypeParameters();
  final Map<String,TypeParameterInfo> infos=new HashMap<>();
  for (  final TypeParameterInfo info : myTypeParameterInfos) {
    if (info instanceof TypeParameterInfo.New && !PsiNameHelper.getInstance(myClass.getProject()).isIdentifier(info.getName(parameters))) {
      return RefactoringBundle.message("error.wrong.name.input",info.getName(parameters));
    }
    final String newName=info.getName(parameters);
    TypeParameterInfo existing=infos.get(newName);
    if (existing != null) {
      return myClass.getName() + " already contains type parameter " + newName;
    }
    infos.put(newName,info);
  }
  LOG.assertTrue(myDefaultValueTypeCodeFragments.size() == myTypeParameterInfos.size());
  LOG.assertTrue(myBoundValueTypeCodeFragments.size() == myTypeParameterInfos.size());
  for (int i=0; i < myDefaultValueTypeCodeFragments.size(); i++) {
    TypeParameterInfo info=myTypeParameterInfos.get(i);
    if (info instanceof TypeParameterInfo.Existing)     continue;
    String message=updateInfo(myDefaultValueTypeCodeFragments.get(i),(TypeParameterInfo.New)info,InfoUpdater.DEFAULT_VALUE);
    if (message != null)     return message;
    message=updateInfo(myBoundValueTypeCodeFragments.get(i),(TypeParameterInfo.New)info,InfoUpdater.BOUND_VALUE);
    if (message != null)     return message;
  }
  return null;
}
