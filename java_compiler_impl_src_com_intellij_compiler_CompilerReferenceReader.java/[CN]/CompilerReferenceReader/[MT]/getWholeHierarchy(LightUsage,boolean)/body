{
  Set<LightUsage> result=new THashSet<>();
  Queue<LightUsage> q=new Queue<>(10);
  q.addLast(aClass);
  while (!q.isEmpty()) {
    LightUsage curClass=q.pullFirst();
    if (result.add(curClass)) {
      if (checkBaseClassAmbiguity || curClass != aClass) {
        final Collection<Integer> definitionFiles=myIndex.getBackwardClassDefinitionMap().get(curClass);
        if (definitionFiles.size() != 1) {
          return null;
        }
      }
      final Collection<CompilerBackwardReferenceIndex.LightDefinition> subClassDefs=myIndex.getBackwardHierarchyMap().get(curClass);
      if (subClassDefs != null) {
        for (        CompilerBackwardReferenceIndex.LightDefinition subclass : subClassDefs) {
          q.addLast(subclass.getUsage());
        }
      }
    }
  }
  return result.toArray(new LightUsage[result.size()]);
}
