{
  if (classMember != null && RefactoringHierarchyUtil.isMemberBetween(mySuperClass,mySubclass,classMember)) {
    if (classMember.hasModifierProperty(PsiModifier.STATIC) && !willBeMoved(classMember,myMovedMembers)) {
      final boolean isAccessible=mySuperClass != null ? PsiUtil.isAccessible(classMember,mySuperClass,null) : myTargetPackage != null ? PsiUtil.isAccessibleFromPackage(classMember,myTargetPackage) : classMember.hasModifierProperty(PsiModifier.PUBLIC);
      if (!isAccessible) {
        String message=RefactoringBundle.message("0.uses.1.which.is.not.accessible.from.the.superclass",RefactoringUIUtil.getDescription(myScope,false),RefactoringUIUtil.getDescription(classMember,true));
        message=CommonRefactoringUtil.capitalize(message);
        myConflictsList.putValue(classMember,message);
      }
      return;
    }
    if (!myAbstractMethods.contains(classMember) && !willBeMoved(classMember,myMovedMembers)) {
      if (!existsInSuperClass(classMember)) {
        String message=RefactoringBundle.message("0.uses.1.which.is.not.moved.to.the.superclass",RefactoringUIUtil.getDescription(myScope,false),RefactoringUIUtil.getDescription(classMember,true));
        message=CommonRefactoringUtil.capitalize(message);
        myConflictsList.putValue(classMember,message);
      }
    }
  }
}
