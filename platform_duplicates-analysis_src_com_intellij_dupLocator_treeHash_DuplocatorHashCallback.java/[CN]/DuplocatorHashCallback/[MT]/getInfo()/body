{
  final TObjectIntHashMap<PsiFragment[]> duplicateList=new TObjectIntHashMap<PsiFragment[]>();
  myDuplicates.forEachEntry(new TIntObjectProcedure<List<List<PsiFragment>>>(){
    public boolean execute(    final int hash,    final List<List<PsiFragment>> listList){
      for (      List<PsiFragment> list : listList) {
        final int len=list.size();
        if (len > 1) {
          PsiFragment[] filtered=new PsiFragment[len];
          int idx=0;
          for (          final PsiFragment fragment : list) {
            fragment.markDuplicate();
            filtered[idx++]=fragment;
          }
          duplicateList.put(filtered,hash);
        }
      }
      return true;
    }
  }
);
  myDuplicates=null;
  for (TObjectIntIterator<PsiFragment[]> dups=duplicateList.iterator(); dups.hasNext(); ) {
    dups.advance();
    PsiFragment[] fragments=dups.key();
    LOG.assertTrue(fragments.length > 1);
    boolean nested=false;
    for (    PsiFragment fragment : fragments) {
      if (fragment.isNested()) {
        nested=true;
        break;
      }
    }
    if (nested) {
      dups.remove();
    }
  }
  final Object[] duplicates=duplicateList.keys();
  Arrays.sort(duplicates,new Comparator<Object>(){
    public int compare(    Object x,    Object y){
      return ((PsiFragment[])y)[0].getCost() - ((PsiFragment[])x)[0].getCost();
    }
  }
);
  return new DupInfo(){
    private final TIntObjectHashMap<GroupNodeDescription> myPattern2Description=new TIntObjectHashMap<GroupNodeDescription>();
    public int getPatterns(){
      return duplicates.length;
    }
    public int getPatternCost(    int number){
      return ((PsiFragment[])duplicates[number])[0].getCost();
    }
    public int getPatternDensity(    int number){
      return ((PsiFragment[])duplicates[number]).length;
    }
    public PsiFragment[] getFragmentOccurences(    int pattern){
      return (PsiFragment[])duplicates[pattern];
    }
    public UsageInfo[] getUsageOccurences(    int pattern){
      PsiFragment[] occs=getFragmentOccurences(pattern);
      UsageInfo[] infos=new UsageInfo[occs.length];
      for (int i=0; i < infos.length; i++) {
        infos[i]=occs[i].getUsageInfo();
      }
      return infos;
    }
    public int getFileCount(    final int pattern){
      if (myPattern2Description.containsKey(pattern)) {
        return myPattern2Description.get(pattern).getFilesCount();
      }
      return cacheGroupNodeDescription(pattern).getFilesCount();
    }
    private GroupNodeDescription cacheGroupNodeDescription(    final int pattern){
      final Set<PsiFile> files=new HashSet<PsiFile>();
      final PsiFragment[] occurencies=getFragmentOccurences(pattern);
      for (      PsiFragment occurency : occurencies) {
        final PsiFile file=occurency.getFile();
        if (file != null) {
          files.add(file);
        }
      }
      final int fileCount=files.size();
      final PsiFile psiFile=occurencies[0].getFile();
      DuplicatesProfile profile=DuplicatesProfileCache.getProfile(this,pattern);
      String comment=profile != null ? profile.getComment(this,pattern) : "";
      final GroupNodeDescription description=new GroupNodeDescription(fileCount,psiFile != null ? psiFile.getName() : "unknown",comment);
      myPattern2Description.put(pattern,description);
      return description;
    }
    @Nullable public String getTitle(    int pattern){
      if (getFileCount(pattern) == 1) {
        if (myPattern2Description.containsKey(pattern)) {
          return myPattern2Description.get(pattern).getTitle();
        }
        return cacheGroupNodeDescription(pattern).getTitle();
      }
      return null;
    }
    @Nullable public String getComment(    int pattern){
      if (getFileCount(pattern) == 1) {
        if (myPattern2Description.containsKey(pattern)) {
          return myPattern2Description.get(pattern).getComment();
        }
        return cacheGroupNodeDescription(pattern).getComment();
      }
      return null;
    }
    public int getHash(    final int i){
      return duplicateList.get((PsiFragment[])duplicates[i]);
    }
  }
;
}
