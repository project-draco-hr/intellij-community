{
  if (frag == null) {
    myDuplicates.put(hash,new ArrayList<List<PsiFragment>>());
    return;
  }
  frag.setCost(cost);
  List<List<PsiFragment>> fragments=myDuplicates.get(hash);
  if (fragments == null) {
    if (!myReadOnly) {
      List<List<PsiFragment>> list=new ArrayList<List<PsiFragment>>();
      List<PsiFragment> listf=new ArrayList<PsiFragment>();
      listf.add(frag);
      list.add(listf);
      myDuplicates.put(hash,list);
    }
    return;
  }
  boolean found=false;
  final PsiElement[] elements=frag.getElements();
  int discardCost=0;
  if (myDiscardCost >= 0) {
    discardCost=myDiscardCost;
  }
 else {
    final DuplocatorState state=DuplocatorUtil.getDuplocatorState(frag);
    if (state != null) {
      discardCost=state.getDiscardCost();
    }
  }
  for (Iterator<List<PsiFragment>> i=fragments.iterator(); i.hasNext() && !found; ) {
    List<PsiFragment> fi=i.next();
    PsiFragment aFrag=fi.get(0);
    if (aFrag.isEqual(elements,discardCost)) {
      boolean skipNew=false;
      for (Iterator<PsiFragment> frags=fi.iterator(); frags.hasNext() && !skipNew; ) {
        final PsiFragment old=frags.next();
        if (frag.intersectsWith(old)) {
          if (old.getCost() < frag.getCost() || frag.contains(old)) {
            frags.remove();
          }
 else {
            skipNew=true;
          }
        }
      }
      if (!skipNew)       fi.add(frag);
      found=true;
    }
  }
  if (!found) {
    List<PsiFragment> newFrags=new ArrayList<PsiFragment>();
    newFrags.add(frag);
    fragments.add(newFrags);
  }
}
