{
  int x=myGraphLayout.getLayoutIndex(firstChild);
  int y=myGraphLayout.getLayoutIndex(secondChild);
  int k=1;
  PriorityQueue<GraphEdge> queue=new PriorityQueue<GraphEdge>(MAX_BLOCK_SIZE,new GraphEdgeComparator());
  queue.addAll(myWorkingGraph.getAdjacentEdges(secondChild,EdgeFilter.NORMAL_DOWN));
  Set<Integer> definitelyNotTails=ContainerUtil.newHashSet(MAX_BLOCK_SIZE);
  Set<Integer> tails=ContainerUtil.newHashSet(MAX_BLOCK_SIZE);
  boolean mergeWithOldCommit=false;
  while (!queue.isEmpty()) {
    GraphEdge nextEdge=queue.poll();
    Integer next=nextEdge.getDownNodeIndex();
    if (next == null)     return false;
    Integer upNodeIndex=nextEdge.getUpNodeIndex();
    if (next == firstChild) {
      tails.add(upNodeIndex);
      mergeWithOldCommit=true;
    }
 else     if (next < secondChild + k) {
    }
 else     if (next == secondChild + k) {
      k++;
      queue.addAll(myWorkingGraph.getAdjacentEdges(next,EdgeFilter.NORMAL_DOWN));
      definitelyNotTails.add(upNodeIndex);
    }
 else     if (next > secondChild + k && next < firstChild) {
      k=next - secondChild + 1;
      queue.addAll(myWorkingGraph.getAdjacentEdges(next,EdgeFilter.NORMAL_DOWN));
      definitelyNotTails.add(upNodeIndex);
    }
 else     if (next > firstChild) {
      int li=myGraphLayout.getLayoutIndex(next);
      if (li > y) {
        return false;
      }
      if (li < x && !(li >= headIndex && li < nextHeadIndex)) {
        return false;
      }
 else {
        if (!definitelyNotTails.contains(upNodeIndex)) {
          tails.add(upNodeIndex);
          if (li != y && (li >= x)) {
            myWorkingGraph.removeEdge(upNodeIndex,next);
          }
        }
      }
    }
    if (k >= MAX_BLOCK_SIZE) {
      return false;
    }
    if (Math.abs(myTimestampGetter.getTimestamp(secondChild) - myTimestampGetter.getTimestamp(secondChild + k - 1)) > MAX_DELTA_TIME) {
      return false;
    }
  }
  for (  Integer tail : tails) {
    if (!LinearGraphUtils.getDownNodes(myWorkingGraph,tail).contains(firstChild)) {
      myWorkingGraph.addEdge(tail,firstChild);
    }
 else     if (mergeWithOldCommit) {
      myWorkingGraph.removeEdge(tail,firstChild);
      myWorkingGraph.addEdge(tail,firstChild);
    }
  }
  if (!tails.isEmpty() || mergeWithOldCommit) {
    myWorkingGraph.removeEdge(parent,firstChild);
  }
  return true;
}
