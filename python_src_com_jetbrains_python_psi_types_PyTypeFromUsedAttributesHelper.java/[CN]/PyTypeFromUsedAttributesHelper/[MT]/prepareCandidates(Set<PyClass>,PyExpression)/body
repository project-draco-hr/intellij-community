{
  final PsiFile originalFile=expression.getContainingFile();
  final List<QualifiedName> importQualifiers=Lists.newArrayList();
  if (originalFile instanceof PyFile) {
    final PyFile originalModule=(PyFile)originalFile;
    for (    PyFromImportStatement fromImport : originalModule.getFromImports()) {
      if (fromImport.isFromFuture()) {
        continue;
      }
      final PsiFileSystemItem importedModule=PyUtil.as(fromImport.resolveImportSource(),PsiFileSystemItem.class);
      if (importedModule != null) {
        final QualifiedName qName=findShortestImportableQName(expression,importedModule.getVirtualFile());
        ContainerUtil.addIfNotNull(qName,importQualifiers);
      }
    }
    for (    PyImportElement normalImport : originalModule.getImportTargets()) {
      ContainerUtil.addIfNotNull(importQualifiers,normalImport.getImportedQName());
    }
  }
  final List<CandidateClass> prioritizedCandidates=Lists.newArrayList();
  for (  PyClass candidate : candidates) {
    final PsiFile candidateFile=candidate.getContainingFile();
    final Priority priority;
    if (PyBuiltinCache.getInstance(expression).isBuiltin(candidate)) {
      priority=Priority.BUILTIN;
    }
 else     if (candidateFile == originalFile) {
      priority=Priority.SAME_FILE;
    }
 else {
      final String qualifiedName=candidate.getQualifiedName();
      final boolean probablyImported=qualifiedName != null && ContainerUtil.exists(importQualifiers,new Condition<QualifiedName>(){
        @Override public boolean value(        QualifiedName qualifier){
          return QualifiedName.fromDottedString(qualifiedName).matchesPrefix(qualifier);
        }
      }
);
      if (probablyImported) {
        priority=Priority.IMPORTED;
      }
 else       if (ProjectRootManager.getInstance(expression.getProject()).getFileIndex().isInSource(candidateFile.getVirtualFile())) {
        priority=Priority.PROJECT;
      }
 else {
        priority=Priority.OTHER;
      }
    }
    prioritizedCandidates.add(new CandidateClass(candidate,priority));
  }
  Collections.sort(prioritizedCandidates);
  return prioritizedCandidates.subList(0,Math.min(prioritizedCandidates.size(),MAX_CANDIDATES));
}
