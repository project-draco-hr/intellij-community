{
  final Graph<PluginId> graph=createPluginIdGraph(idToDescriptorMap);
  final DFSTBuilder<PluginId> builder=new DFSTBuilder<PluginId>(graph);
  if (!builder.isAcyclic()) {
    final String cyclePresentation;
    if (ApplicationManager.getApplication().isInternal()) {
      final StringBuilder cycles=new StringBuilder();
      for (      Collection<PluginId> component : builder.getComponents()) {
        if (cycles.length() > 0)         cycles.append(';');
        for (        PluginId id : component) {
          idToDescriptorMap.get(id).setEnabled(false);
          cycles.append(id.getIdString()).append(' ');
        }
      }
      cyclePresentation=cycles.toString();
    }
 else {
      final Couple<PluginId> circularDependency=builder.getCircularDependency();
      final PluginId id=circularDependency.getFirst();
      final PluginId parentId=circularDependency.getSecond();
      cyclePresentation=id + "->" + parentId+ "->...->"+ id;
    }
    errors.add(IdeBundle.message("error.plugins.should.not.have.cyclic.dependencies") + " " + cyclePresentation);
  }
  final Comparator<PluginId> idComparator=builder.comparator();
  return new Comparator<IdeaPluginDescriptor>(){
    @Override public int compare(    @NotNull IdeaPluginDescriptor o1,    @NotNull IdeaPluginDescriptor o2){
      final PluginId pluginId1=o1.getPluginId();
      final PluginId pluginId2=o2.getPluginId();
      if (pluginId1.getIdString().equals(CORE_PLUGIN_ID))       return -1;
      if (pluginId2.getIdString().equals(CORE_PLUGIN_ID))       return 1;
      return idComparator.compare(pluginId1,pluginId2);
    }
  }
;
}
