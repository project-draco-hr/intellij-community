{
  final Graph<PluginId> graph=createPluginIdGraph(idToDescriptorMap);
  final DFSTBuilder<PluginId> builder=new DFSTBuilder<PluginId>(graph);
  if (!builder.isAcyclic()) {
    final List<String> cycles=new ArrayList<String>();
    builder.getSCCs().forEach(new TIntProcedure(){
      private int myTNumber;
      @Override public boolean execute(      int size){
        if (size > 1) {
          String cycle="";
          for (int j=0; j < size; j++) {
            PluginId id=builder.getNodeByTNumber(myTNumber + j);
            idToDescriptorMap.get(id).setEnabled(false);
            cycle+=id.getIdString() + " ";
          }
          cycles.add(cycle);
        }
        myTNumber+=size;
        return true;
      }
    }
);
    final String cyclePresentation;
    if (ApplicationManager.getApplication().isInternal()) {
      cyclePresentation=StringUtil.join(cycles,";");
    }
 else {
      final Couple<PluginId> circularDependency=builder.getCircularDependency();
      final PluginId id=circularDependency.getFirst();
      final PluginId parentId=circularDependency.getSecond();
      cyclePresentation=id + "->" + parentId+ "->...->"+ id;
    }
    errors.add(IdeBundle.message("error.plugins.should.not.have.cyclic.dependencies") + " " + cyclePresentation);
  }
  final Comparator<PluginId> idComparator=builder.comparator();
  return new Comparator<IdeaPluginDescriptor>(){
    @Override public int compare(    @NotNull IdeaPluginDescriptor o1,    @NotNull IdeaPluginDescriptor o2){
      final PluginId pluginId1=o1.getPluginId();
      final PluginId pluginId2=o2.getPluginId();
      if (pluginId1.getIdString().equals(CORE_PLUGIN_ID))       return -1;
      if (pluginId2.getIdString().equals(CORE_PLUGIN_ID))       return 1;
      return idComparator.compare(pluginId1,pluginId2);
    }
  }
;
}
