{
  GlobalSearchScope librariesScope=ProjectScope.getLibrariesScope(myProject);
  HashSet<HKey> queued=new HashSet<HKey>();
  Stack<HKey> queue=new Stack<HKey>();
  queue.push(key);
  queued.add(key);
  FileBasedIndex index=FileBasedIndex.getInstance();
  while (!queue.empty()) {
    if (queued.size() > EQUATIONS_LIMIT) {
      throw new EquationsLimitException();
    }
    ProgressManager.checkCanceled();
    HKey hKey=queue.pop();
    Bytes bytes=new Bytes(hKey.key);
    List<HEquations> hEquationss=cache.get(bytes);
    if (hEquationss == null) {
      hEquationss=index.getValues(BytecodeAnalysisIndex.NAME,bytes,librariesScope);
      cache.put(bytes,hEquationss);
    }
    for (    HEquations hEquations : hEquationss) {
      boolean stable=hEquations.stable;
      for (      DirectionResultPair pair : hEquations.results) {
        int dirKey=pair.directionKey;
        if (dirKey == hKey.dirKey) {
          Set<HEffectQuantum> effects=((HEffects)pair.hResult).effects;
          puritySolver.addEquation(new HKey(bytes.bytes,dirKey,stable,false),effects);
          for (          HEffectQuantum effect : effects) {
            if (effect instanceof HEffectQuantum.CallQuantum) {
              HKey depKey=((HEffectQuantum.CallQuantum)effect).key;
              if (!queued.contains(depKey)) {
                queue.push(depKey);
                queued.add(depKey);
              }
            }
          }
        }
      }
    }
  }
}
