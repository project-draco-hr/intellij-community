{
  MultiMap<PsiElement,String> conflictDescriptions=new MultiMap<PsiElement,String>();
  addMethodConflicts(conflictDescriptions);
  Set<UsageInfo> usagesSet=new HashSet<UsageInfo>(Arrays.asList(refUsages.get()));
  RenameUtil.removeConflictUsages(usagesSet);
  if (myChangeInfo.isVisibilityChanged()) {
    try {
      addInaccessibilityDescriptions(usagesSet,conflictDescriptions);
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
  }
  checkContract(conflictDescriptions,myChangeInfo.getMethod());
  for (  UsageInfo usageInfo : usagesSet) {
    final PsiElement element=usageInfo.getElement();
    if (usageInfo instanceof OverriderUsageInfo) {
      final PsiMethod method=((OverriderUsageInfo)usageInfo).getOverridingMethod();
      final PsiMethod baseMethod=((OverriderUsageInfo)usageInfo).getBaseMethod();
      final int delta=baseMethod.getParameterList().getParametersCount() - method.getParameterList().getParametersCount();
      if (delta > 0) {
        final boolean[] toRemove=myChangeInfo.toRemoveParm();
        if (toRemove[toRemove.length - 1]) {
          conflictDescriptions.putValue(baseMethod,"Implicit last parameter should not be deleted");
        }
      }
      checkContract(conflictDescriptions,method);
    }
 else     if (element instanceof PsiMethodReferenceExpression && MethodReferenceUsageInfo.needToExpand(myChangeInfo)) {
      conflictDescriptions.putValue(element,RefactoringBundle.message("expand.method.reference.warning"));
    }
  }
  return conflictDescriptions;
}
