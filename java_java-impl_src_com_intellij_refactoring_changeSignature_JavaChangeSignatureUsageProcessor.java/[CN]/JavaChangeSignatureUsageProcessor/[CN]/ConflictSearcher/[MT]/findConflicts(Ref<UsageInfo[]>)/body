{
  MultiMap<PsiElement,String> conflictDescriptions=new MultiMap<>();
  final PsiMethod prototype=addMethodConflicts(conflictDescriptions);
  Set<UsageInfo> usagesSet=new HashSet<>(Arrays.asList(refUsages.get()));
  RenameUtil.removeConflictUsages(usagesSet);
  if (myChangeInfo.isVisibilityChanged()) {
    try {
      addInaccessibilityDescriptions(usagesSet,conflictDescriptions);
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
  }
  final boolean[] toRemove=myChangeInfo.toRemoveParm();
  final boolean checkUnusedParameter=myChangeInfo.checkUnusedParameter();
  if (checkUnusedParameter) {
    checkParametersToDelete(myChangeInfo.getMethod(),toRemove,conflictDescriptions);
  }
  checkContract(conflictDescriptions,myChangeInfo.getMethod());
  for (  UsageInfo usageInfo : usagesSet) {
    final PsiElement element=usageInfo.getElement();
    if (usageInfo instanceof OverriderUsageInfo) {
      final PsiMethod method=((OverriderUsageInfo)usageInfo).getOverridingMethod();
      final PsiMethod baseMethod=((OverriderUsageInfo)usageInfo).getBaseMethod();
      final int delta=baseMethod.getParameterList().getParametersCount() - method.getParameterList().getParametersCount();
      if (delta > 0) {
        if (toRemove[toRemove.length - 1]) {
          conflictDescriptions.putValue(baseMethod,"Implicit last parameter should not be deleted");
        }
      }
 else       if (prototype != null && baseMethod == myChangeInfo.getMethod()) {
        ConflictsUtil.checkMethodConflicts(method.getContainingClass(),method,prototype,conflictDescriptions);
        if (checkUnusedParameter) {
          checkParametersToDelete(method,toRemove,conflictDescriptions);
        }
      }
      checkContract(conflictDescriptions,method);
    }
 else     if (element instanceof PsiMethodReferenceExpression && MethodReferenceUsageInfo.needToExpand(myChangeInfo)) {
      conflictDescriptions.putValue(element,RefactoringBundle.message("expand.method.reference.warning"));
    }
 else     if (element instanceof PsiJavaCodeReferenceElement) {
      final PsiElement parent=element.getParent();
      if (parent instanceof PsiCallExpression) {
        final PsiExpressionList argumentList=((PsiCallExpression)parent).getArgumentList();
        if (argumentList != null) {
          final PsiExpression[] args=argumentList.getExpressions();
          for (int i=0; i < toRemove.length; i++) {
            if (toRemove[i] && i < args.length) {
              if (RemoveUnusedVariableUtil.checkSideEffects(args[i],null,new ArrayList<>())) {
                conflictDescriptions.putValue(args[i],"Parameter '" + myChangeInfo.getOldParameterNames()[i] + "' has usage that is not safe to delete");
              }
            }
          }
        }
      }
    }
  }
  return conflictDescriptions;
}
