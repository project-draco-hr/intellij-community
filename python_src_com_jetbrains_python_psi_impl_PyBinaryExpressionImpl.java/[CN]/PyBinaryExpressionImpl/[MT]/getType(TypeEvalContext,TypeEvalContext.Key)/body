{
  if (isOperator("and") || isOperator("or")) {
    final PyExpression left=getLeftExpression();
    final PyType leftType=left != null ? context.getType(left) : null;
    final PyExpression right=getRightExpression();
    final PyType rightType=right != null ? context.getType(right) : null;
    if (leftType == null && rightType == null) {
      return null;
    }
    return PyUnionType.union(leftType,rightType);
  }
  final List<PyTypeChecker.AnalyzeCallResults> results=PyTypeChecker.analyzeCallSite(this,context);
  if (!results.isEmpty()) {
    final List<PyType> types=new ArrayList<PyType>();
    final List<PyType> matchedTypes=new ArrayList<PyType>();
    for (    PyTypeChecker.AnalyzeCallResults result : results) {
      boolean matched=true;
      for (      Map.Entry<PyExpression,PyNamedParameter> entry : result.getArguments().entrySet()) {
        final PyExpression argument=entry.getKey();
        final PyNamedParameter parameter=entry.getValue();
        if (parameter.isPositionalContainer() || parameter.isKeywordContainer()) {
          continue;
        }
        final Map<PyGenericType,PyType> substitutions=new HashMap<PyGenericType,PyType>();
        final PyType parameterType=context.getType(parameter);
        final PyType argumentType=context.getType(argument);
        if (!PyTypeChecker.match(parameterType,argumentType,context,substitutions)) {
          matched=false;
        }
      }
      final PyType type=result.getCallable().getCallType(context,this);
      if (!PyTypeChecker.isUnknown(type) && !(type instanceof PyNoneType)) {
        types.add(type);
        if (matched) {
          matchedTypes.add(type);
        }
      }
    }
    if (!matchedTypes.isEmpty()) {
      return PyUnionType.union(matchedTypes);
    }
    if (!types.isEmpty()) {
      return PyUnionType.union(types);
    }
  }
  if (PyNames.COMPARISON_OPERATORS.contains(getReferencedName())) {
    return PyBuiltinCache.getInstance(this).getBoolType();
  }
  return null;
}
