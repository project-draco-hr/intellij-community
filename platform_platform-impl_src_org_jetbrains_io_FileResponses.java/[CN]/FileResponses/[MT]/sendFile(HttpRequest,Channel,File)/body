{
  if (checkCache(request,channel,file.lastModified())) {
    return;
  }
  HttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
  response.headers().add(CONTENT_TYPE,getContentType(file.getPath()));
  addCommonHeaders(response);
  response.headers().set(HttpHeaders.Names.CACHE_CONTROL,"private, must-revalidate");
  response.headers().set(HttpHeaders.Names.LAST_MODIFIED,DATE_FORMAT.get().format(new Date(file.lastModified())));
  boolean keepAlive=addKeepAliveIfNeed(response,request);
  boolean fileWillBeClosed=false;
  RandomAccessFile raf;
  try {
    raf=new RandomAccessFile(file,"r");
  }
 catch (  FileNotFoundException ignored) {
    send(response(HttpResponseStatus.NOT_FOUND),channel,request);
    return;
  }
  try {
    long fileLength=raf.length();
    if (request.method() != HttpMethod.HEAD) {
      HttpHeaders.setContentLength(response,fileLength);
    }
    channel.write(response);
    if (request.method() != HttpMethod.HEAD) {
      if (channel.pipeline().get(SslHandler.class) == null) {
        channel.write(new DefaultFileRegion(raf.getChannel(),0,fileLength));
      }
 else {
        channel.write(new ChunkedFile(raf));
      }
    }
    fileWillBeClosed=true;
  }
  finally {
    if (!fileWillBeClosed) {
      raf.close();
    }
  }
  ChannelFuture future=channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
  if (!keepAlive) {
    future.addListener(ChannelFutureListener.CLOSE);
  }
}
