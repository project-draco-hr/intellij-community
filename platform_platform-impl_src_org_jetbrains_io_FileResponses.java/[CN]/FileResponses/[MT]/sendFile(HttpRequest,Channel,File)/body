{
  if (checkCache(request,channel,file.lastModified())) {
    return;
  }
  boolean fileWillBeClosed=false;
  RandomAccessFile raf=new RandomAccessFile(file,"r");
  try {
    long fileLength=raf.length();
    HttpResponse response=create(getContentType(file.getPath()));
    addCommonHeaders(response);
    response.headers().set(HttpHeaders.Names.CACHE_CONTROL,"private, must-revalidate");
    response.headers().set(HttpHeaders.Names.LAST_MODIFIED,Responses.DATE_FORMAT.get().format(new Date(file.lastModified())));
    boolean keepAlive=addKeepAliveIfNeed(response,request);
    if (request.getMethod() != HttpMethod.HEAD) {
      HttpHeaders.setContentLength(response,fileLength);
    }
    ChannelFuture future=channel.write(response);
    if (request.getMethod() != HttpMethod.HEAD) {
      if (channel.pipeline().get(SslHandler.class) == null) {
        future=channel.write(new DefaultFileRegion(raf.getChannel(),0,fileLength));
      }
 else {
        future=channel.write(new ChunkedFile(raf,0,fileLength,8192));
      }
    }
    if (!keepAlive) {
      future.addListener(ChannelFutureListener.CLOSE);
    }
    channel.flush();
    fileWillBeClosed=true;
  }
  finally {
    if (!fileWillBeClosed) {
      raf.close();
    }
  }
}
