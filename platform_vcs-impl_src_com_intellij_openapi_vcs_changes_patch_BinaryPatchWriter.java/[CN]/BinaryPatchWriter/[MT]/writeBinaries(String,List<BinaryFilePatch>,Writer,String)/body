{
  for (  FilePatch patch : patches) {
    BinaryFilePatch filePatch=(BinaryFilePatch)patch;
    writer.write(String.format(GIT_DIFF_HEADER,filePatch.getBeforeName(),filePatch.getAfterName()));
    writer.write(lineSeparator);
    File afterFile=new File(basePath,filePatch.getAfterName());
    if (filePatch.isDeletedFile()) {
      writer.write(getFileModeHeader(FileStatus.DELETED,REGULAR_FILE_MODE));
      writer.write(lineSeparator);
    }
 else     if (filePatch.isNewFile()) {
      writer.write(getFileModeHeader(FileStatus.ADDED,afterFile.canExecute() ? EXECUTABLE_FILE_MODE : REGULAR_FILE_MODE));
      writer.write(lineSeparator);
    }
    byte[] afterContent=filePatch.getAfterContent();
    writer.write(getIndexHeader(filePatch.isNewFile() ? NOT_COMMITTED_HASH : getSha1ForContent(filePatch.getBeforeContent()),filePatch.isDeletedFile() ? NOT_COMMITTED_HASH : getSha1ForContent(afterContent)));
    writer.write(lineSeparator);
    writer.write(GIT_BINARY_HEADER);
    writer.write(lineSeparator);
    writer.write(String.format(LITERAL_HEADER,afterContent == null ? 0 : afterContent.length));
    writer.write(lineSeparator);
    try {
      BinaryEncoder.encode(afterFile.exists() ? new FileInputStream(afterFile) : new ByteArrayInputStream(ArrayUtil.EMPTY_BYTE_ARRAY),writer);
    }
 catch (    BinaryEncoder.BinaryPatchException e) {
      LOG.error("Can't write patch for binary file: " + afterFile.getPath(),e);
    }
    writer.write(lineSeparator);
  }
}
