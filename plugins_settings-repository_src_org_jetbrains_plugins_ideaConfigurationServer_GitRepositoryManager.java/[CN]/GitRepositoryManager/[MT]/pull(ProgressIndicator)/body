{
  return execute(new ThrowableConsumer<ProgressIndicator,Exception>(){
    @Override public void consume(    @NotNull ProgressIndicator indicator) throws Exception {
      JGitProgressMonitor progressMonitor=new JGitProgressMonitor(indicator);
      FetchResult fetchResult=git.fetch().setRemoveDeletedRefs(true).setProgressMonitor(progressMonitor).setCredentialsProvider(getCredentialsProvider()).call();
      if (LOG.isDebugEnabled()) {
        String messages=fetchResult.getMessages();
        if (!StringUtil.isEmptyOrSpaces(messages)) {
          LOG.debug(messages);
        }
      }
      Iterator<TrackingRefUpdate> refUpdates=fetchResult.getTrackingRefUpdates().iterator();
      TrackingRefUpdate refUpdate=refUpdates.hasNext() ? refUpdates.next() : null;
      if (refUpdate == null || refUpdate.getResult() == RefUpdate.Result.NO_CHANGE) {
        return;
      }
      int attemptCount=0;
      do {
        MergeCommand mergeCommand=git.merge();
        org.eclipse.jgit.lib.Ref ref=getUpstreamBranchRef();
        if (ref == null) {
          throw new AssertionError();
        }
 else {
          mergeCommand.include(ref);
        }
        MergeResult mergeResult=mergeCommand.setFastForward(MergeCommand.FastForwardMode.FF_ONLY).call();
        if (LOG.isDebugEnabled()) {
          LOG.debug(mergeResult.toString());
        }
        MergeResult.MergeStatus status=mergeResult.getMergeStatus();
        if (status.isSuccessful()) {
          rebase(progressMonitor);
          return;
        }
 else         if (status != MergeResult.MergeStatus.ABORTED) {
          break;
        }
      }
 while (++attemptCount < 3);
    }
    private org.eclipse.jgit.lib.Ref getUpstreamBranchRef() throws IOException {
      return git.getRepository().getRef(Constants.DEFAULT_REMOTE_NAME + '/' + Constants.MASTER);
    }
    private void rebase(    @NotNull JGitProgressMonitor progressMonitor) throws GitAPIException {
      RebaseResult result=null;
      do {
        if (result == null) {
          result=git.rebase().setUpstream(Constants.DEFAULT_REMOTE_NAME + '/' + Constants.MASTER).setProgressMonitor(progressMonitor).call();
        }
 else         if (result.getStatus() == RebaseResult.Status.CONFLICTS) {
          throw new UnsupportedOperationException();
        }
 else         if (result.getStatus() == RebaseResult.Status.NOTHING_TO_COMMIT) {
          result=git.rebase().setOperation(RebaseCommand.Operation.SKIP).call();
        }
 else {
          throw new UnsupportedOperationException();
        }
      }
 while (!result.getStatus().isSuccessful());
    }
  }
,indicator);
}
