{
  final Map<String,Map<String,List<VarFieldPair>>> mapVarMasks=new HashMap<String,Map<String,List<VarFieldPair>>>();
  int clTypes=0;
  for (  ClassNode nd : node.nested) {
    if (nd.classStruct.hasModifier(CodeConstants.ACC_SYNTHETIC)) {
      continue;
    }
    if (nd.type != ClassNode.CLASS_LAMBDA && (nd.access & CodeConstants.ACC_STATIC) == 0 && (nd.access & CodeConstants.ACC_INTERFACE) == 0) {
      clTypes|=nd.type;
      Map<String,List<VarFieldPair>> mask=getMaskLocalVars(nd.getWrapper());
      if (mask.isEmpty()) {
        String message="Nested class " + nd.classStruct.qualifiedName + " has no constructor!";
        DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
      }
 else {
        mapVarMasks.put(nd.classStruct.qualifiedName,mask);
      }
    }
  }
  final Map<String,Map<String,List<VarFieldPair>>> mapVarFieldPairs=new HashMap<String,Map<String,List<VarFieldPair>>>();
  if (clTypes != ClassNode.CLASS_MEMBER) {
    for (    final MethodWrapper method : node.getWrapper().getMethods()) {
      if (method.root != null) {
        method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator(){
          @Override public int processExprent(          Exprent exprent){
            List<Exprent> lst=exprent.getAllExprents(true);
            lst.add(exprent);
            for (            Exprent expr : lst) {
              if (expr.type == Exprent.EXPRENT_NEW) {
                InvocationExprent constructor=((NewExprent)expr).getConstructor();
                if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) {
                  String refClassName=constructor.getClassname();
                  ClassNode nestedClassNode=node.getClassNode(refClassName);
                  if (nestedClassNode.type != ClassNode.CLASS_MEMBER) {
                    List<VarFieldPair> mask=mapVarMasks.get(refClassName).get(constructor.getStringDescriptor());
                    if (!mapVarFieldPairs.containsKey(refClassName)) {
                      mapVarFieldPairs.put(refClassName,new HashMap<String,List<VarFieldPair>>());
                    }
                    List<VarFieldPair> lstTemp=new ArrayList<VarFieldPair>();
                    for (int i=0; i < mask.size(); i++) {
                      Exprent param=constructor.getLstParameters().get(i);
                      VarFieldPair pair=null;
                      if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) {
                        VarVersionPair varPair=new VarVersionPair((VarExprent)param);
                        pair=new VarFieldPair(mask.get(i).fieldKey,varPair);
                      }
                      lstTemp.add(pair);
                    }
                    List<VarFieldPair> pairMask=mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor());
                    if (pairMask == null) {
                      pairMask=lstTemp;
                    }
 else {
                      for (int i=0; i < pairMask.size(); i++) {
                        if (!InterpreterUtil.equalObjects(pairMask.get(i),lstTemp.get(i))) {
                          pairMask.set(i,null);
                        }
                      }
                    }
                    mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(),pairMask);
                    nestedClassNode.enclosingMethod=InterpreterUtil.makeUniqueKey(method.methodStruct.getName(),method.methodStruct.getDescriptor());
                  }
                }
              }
            }
            return 0;
          }
        }
);
      }
    }
  }
  for (  Entry<String,Map<String,List<VarFieldPair>>> enclosing : mapVarMasks.entrySet()) {
    ClassNode nestedNode=node.getClassNode(enclosing.getKey());
    List<VarFieldPair> interPairMask=null;
    if (mapVarFieldPairs.containsKey(enclosing.getKey())) {
      for (      List<VarFieldPair> mask : mapVarFieldPairs.get(enclosing.getKey()).values()) {
        if (interPairMask == null) {
          interPairMask=new ArrayList<VarFieldPair>(mask);
        }
 else {
          mergeListSignatures(interPairMask,mask,false);
        }
      }
    }
    List<VarFieldPair> interMask=null;
    for (    List<VarFieldPair> mask : enclosing.getValue().values()) {
      if (interMask == null) {
        interMask=new ArrayList<VarFieldPair>(mask);
      }
 else {
        mergeListSignatures(interMask,mask,false);
      }
    }
    if (interPairMask == null) {
      interPairMask=interMask != null ? new ArrayList<VarFieldPair>(interMask) : new ArrayList<VarFieldPair>();
      boolean found=false;
      for (int i=0; i < interPairMask.size(); i++) {
        if (interPairMask.get(i) != null) {
          if (found) {
            interPairMask.set(i,null);
          }
          found=true;
        }
      }
    }
    mergeListSignatures(interPairMask,interMask,true);
    for (    VarFieldPair pair : interPairMask) {
      if (pair != null && pair.fieldKey.length() > 0) {
        nestedNode.mapFieldsToVars.put(pair.fieldKey,pair.varPair);
      }
    }
    for (    Entry<String,List<VarFieldPair>> entry : enclosing.getValue().entrySet()) {
      mergeListSignatures(entry.getValue(),interPairMask,false);
      MethodWrapper method=nestedNode.getWrapper().getMethodWrapper(CodeConstants.INIT_NAME,entry.getKey());
      method.signatureFields=new ArrayList<VarVersionPair>();
      for (      VarFieldPair pair : entry.getValue()) {
        method.signatureFields.add(pair == null ? null : pair.varPair);
      }
    }
  }
}
