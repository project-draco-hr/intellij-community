{
  final AtomicInteger usageCountWithoutDefinition=new AtomicInteger(0);
  final Project project=myProject;
  final FindUsagesIndicator findUsagesIndicator=new FindUsagesIndicator();
  Task.Backgroundable task=new Task.Backgroundable(project,UsageViewManagerImpl.getProgressTitle(myPresentation)){
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      setSearchInProgress(true);
      setCurrentSearchCancelled(false);
      myChangesDetected=false;
      UsageSearcher usageSearcher=myUsageSearcherFactory.create();
      usageSearcher.generate(new Processor<Usage>(){
        @Override public boolean process(        final Usage usage){
          if (searchHasBeenCancelled())           return false;
          boolean incrementCounter=!com.intellij.usages.UsageViewManager.isSelfUsage(usage,myTargets);
          if (incrementCounter) {
            final int usageCount=usageCountWithoutDefinition.incrementAndGet();
            if (usageCount > UsageLimitUtil.USAGES_LIMIT) {
              if (findUsagesIndicator.switchTooManyUsagesStatus()) {
                UsageViewManagerImpl.showTooManyUsagesWarning(project,findUsagesIndicator,usageCountWithoutDefinition.get(),UsageViewImpl.this);
              }
            }
            ApplicationManager.getApplication().runReadAction(new Runnable(){
              public void run(){
                appendUsage(usage);
              }
            }
);
          }
          return !findUsagesIndicator.isCanceled();
        }
      }
);
      drainQueuedUsageNodes();
      setSearchInProgress(false);
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressAsynchronously(task,findUsagesIndicator);
}
