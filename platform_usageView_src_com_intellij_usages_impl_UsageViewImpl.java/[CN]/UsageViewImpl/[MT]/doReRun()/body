{
  final AtomicInteger usageCountWithoutDefinition=new AtomicInteger(0);
  final Project project=myProject;
  Task.Backgroundable task=new Task.Backgroundable(project,UsageViewManagerImpl.getProgressTitle(myPresentation)){
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      final TooManyUsagesStatus tooManyUsagesStatus=TooManyUsagesStatus.createFor(indicator);
      setSearchInProgress(true);
      associateProgress(indicator);
      Processor<Usage> processor=new Processor<Usage>(){
        @Override public boolean process(        final Usage usage){
          if (searchHasBeenCancelled())           return false;
          TooManyUsagesStatus.getFrom(indicator).pauseProcessingIfTooManyUsages();
          boolean incrementCounter=!com.intellij.usages.UsageViewManager.isSelfUsage(usage,myTargets);
          if (incrementCounter) {
            final int usageCount=usageCountWithoutDefinition.incrementAndGet();
            if (usageCount > UsageLimitUtil.USAGES_LIMIT) {
              if (tooManyUsagesStatus.switchTooManyUsagesStatus()) {
                UsageViewManagerImpl.showTooManyUsagesWarning(project,tooManyUsagesStatus,indicator,getPresentation(),usageCountWithoutDefinition.get(),UsageViewImpl.this);
              }
            }
            ApplicationManager.getApplication().runReadAction(new Runnable(){
              @Override public void run(){
                appendUsage(usage);
              }
            }
);
          }
          return !indicator.isCanceled();
        }
      }
;
      myChangesDetected=false;
      PsiManager.getInstance(project).startBatchFilesProcessingMode();
      try {
        myUsageSearcherFactory.create().generate(processor);
        drainQueuedUsageNodes();
      }
  finally {
        PsiManager.getInstance(project).finishBatchFilesProcessingMode();
      }
      setSearchInProgress(false);
    }
  }
;
  ProgressManager.getInstance().run(task);
}
