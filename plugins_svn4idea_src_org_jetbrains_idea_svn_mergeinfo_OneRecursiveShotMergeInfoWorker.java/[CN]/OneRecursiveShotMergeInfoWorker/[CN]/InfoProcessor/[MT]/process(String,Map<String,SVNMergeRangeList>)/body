{
  boolean processed=false;
  final boolean self=relativeFileSubpath.equals(myFilePathAsked);
  if (map.isEmpty()) {
    myMerged=false;
    processed=true;
  }
 else {
    String mergedPathAffectingSourcePath=ContainerUtil.find(map.keySet(),new Condition<String>(){
      @Override public boolean value(      String path){
        return SVNPathUtil.isAncestor(myWcLevelRelativeSourceUrl,SvnUtil.ensureStartSlash(path));
      }
    }
);
    if (mergedPathAffectingSourcePath != null) {
      SVNMergeRangeList mergeRangeList=map.get(mergedPathAffectingSourcePath);
      processed=true;
      myMerged=ContainerUtil.or(mergeRangeList.getRanges(),new Condition<SVNMergeRange>(){
        @Override public boolean value(        @NotNull SVNMergeRange range){
          return BranchInfo.isInRange(range,myRevisionAsked) && (range.isInheritable() || self);
        }
      }
);
    }
  }
  return processed;
}
