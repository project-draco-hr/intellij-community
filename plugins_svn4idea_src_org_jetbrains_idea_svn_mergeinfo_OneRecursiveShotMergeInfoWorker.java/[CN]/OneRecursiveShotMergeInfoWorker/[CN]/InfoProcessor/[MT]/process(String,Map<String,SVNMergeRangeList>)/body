{
  boolean processed=false;
  final boolean isCurrentPath=workingCopyRelativePath.equals(mySourceRelativePath);
  if (mergedPathsMap.isEmpty()) {
    myIsMerged=false;
    processed=true;
  }
 else {
    String mergedPathAffectingSourcePath=ContainerUtil.find(mergedPathsMap.keySet(),new Condition<String>(){
      @Override public boolean value(      String path){
        return SVNPathUtil.isAncestor(myRepositoryRelativeSourcePath,SvnUtil.ensureStartSlash(path));
      }
    }
);
    if (mergedPathAffectingSourcePath != null) {
      SVNMergeRangeList mergeRangeList=mergedPathsMap.get(mergedPathAffectingSourcePath);
      processed=true;
      myIsMerged=ContainerUtil.or(mergeRangeList.getRanges(),new Condition<SVNMergeRange>(){
        @Override public boolean value(        @NotNull SVNMergeRange range){
          return BranchInfo.isInRange(range,myRevisionNumber) && (range.isInheritable() || isCurrentPath);
        }
      }
);
    }
  }
  return processed;
}
