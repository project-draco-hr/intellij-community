{
  StringNode currStringNode=null;
  pushOpp(null);
  ExpressionTokenizer et=new ExpressionTokenizer(expr);
  while (et.hasMoreTokens()) {
    int token=et.nextToken();
    if (token != ExpressionTokenizer.TOKEN_STRING) {
      currStringNode=null;
    }
switch (token) {
case ExpressionTokenizer.TOKEN_STRING:
      if (currStringNode == null) {
        currStringNode=new StringNode(et.getTokenValue());
        nodeStack.add(0,currStringNode);
      }
 else {
        currStringNode.value.append(" ");
        currStringNode.value.append(et.getTokenValue());
      }
    break;
case ExpressionTokenizer.TOKEN_AND:
  pushOpp(new AndNode());
break;
case ExpressionTokenizer.TOKEN_OR:
pushOpp(new OrNode());
break;
case ExpressionTokenizer.TOKEN_NOT:
pushOpp(new NotNode());
break;
case ExpressionTokenizer.TOKEN_EQ:
pushOpp(new EqualNode());
break;
case ExpressionTokenizer.TOKEN_NOT_EQ:
pushOpp(new NotNode());
oppStack.add(0,new EqualNode());
break;
case ExpressionTokenizer.TOKEN_RBRACE:
resolveGroup();
break;
case ExpressionTokenizer.TOKEN_LBRACE:
pushOpp(null);
break;
case ExpressionTokenizer.TOKEN_GE:
pushOpp(new NotNode());
oppStack.add(0,new LessThanNode());
break;
case ExpressionTokenizer.TOKEN_LE:
pushOpp(new NotNode());
oppStack.add(0,new GreaterThanNode());
break;
case ExpressionTokenizer.TOKEN_GT:
pushOpp(new GreaterThanNode());
break;
case ExpressionTokenizer.TOKEN_LT:
pushOpp(new LessThanNode());
break;
case ExpressionTokenizer.TOKEN_END:
break;
}
}
resolveGroup();
if (nodeStack.size() == 0) {
throw new ParseException("No nodes created.",et.getIndex());
}
if (nodeStack.size() > 1) {
throw new ParseException("Extra nodes created.",et.getIndex());
}
if (oppStack.size() != 0) {
throw new ParseException("Unused opp nodes exist.",et.getIndex());
}
root=nodeStack.get(0);
}
