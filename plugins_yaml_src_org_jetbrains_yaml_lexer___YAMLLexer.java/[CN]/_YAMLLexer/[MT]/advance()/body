{
  int zzInput;
  int zzAction;
  int zzCurrentPosL;
  int zzMarkedPosL;
  int zzEndReadL=zzEndRead;
  CharSequence zzBufferL=zzBuffer;
  char[] zzBufferArrayL=zzBufferArray;
  char[] zzCMapL=ZZ_CMAP;
  int[] zzTransL=ZZ_TRANS;
  int[] zzRowMapL=ZZ_ROWMAP;
  int[] zzAttrL=ZZ_ATTRIBUTE;
  while (true) {
    zzMarkedPosL=zzMarkedPos;
    zzAction=-1;
    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;
    zzState=ZZ_LEXSTATE[zzLexicalState];
    zzForAction: {
      while (true) {
        if (zzCurrentPosL < zzEndReadL)         zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++);
 else         if (zzAtEOF) {
          zzInput=YYEOF;
          break zzForAction;
        }
 else {
          zzCurrentPos=zzCurrentPosL;
          zzMarkedPos=zzMarkedPosL;
          boolean eof=zzRefill();
          zzCurrentPosL=zzCurrentPos;
          zzMarkedPosL=zzMarkedPos;
          zzBufferL=zzBuffer;
          zzEndReadL=zzEndRead;
          if (eof) {
            zzInput=YYEOF;
            break zzForAction;
          }
 else {
            zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++);
          }
        }
        int zzNext=zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
        if (zzNext == -1)         break zzForAction;
        zzState=zzNext;
        int zzAttributes=zzAttrL[zzState];
        if ((zzAttributes & 1) == 1) {
          zzAction=zzState;
          zzMarkedPosL=zzCurrentPosL;
          if ((zzAttributes & 8) == 8)           break zzForAction;
        }
      }
    }
    zzMarkedPos=zzMarkedPosL;
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
case 24:
{
        braceCount=0;
        yybegin(YYINITIAL);
        return DOCUMENT_MARKER;
      }
case 25:
    break;
case 17:
{
    if (zzMarkedPos == zzEndRead) {
      return SCALAR_KEY;
    }
    return TEXT;
  }
case 26:
break;
case 7:
{
braceCount++;
if (braceCount != 0 && yystate() != BRACES) {
  previousState=yystate();
}
yybegin(braceCount == 0 ? previousState : BRACES);
return LBRACE;
}
case 27:
break;
case 21:
zzMarkedPos=zzStartRead + 1;
{
yybegin(INDENT_VALUE);
valueIndent=0;
afterEOL=false;
valueTokenType=SCALAR_TEXT;
yypushback(1);
}
case 28:
break;
case 8:
{
braceCount++;
if (braceCount != 0 && yystate() != BRACES) {
previousState=yystate();
}
yybegin(braceCount == 0 ? previousState : BRACES);
return LBRACKET;
}
case 29:
break;
case 4:
{
char prev=previousChar();
return (prev == '\n' || prev == '\t' || prev == ' ' || prev == Character.MAX_VALUE) ? COMMENT : TEXT;
}
case 30:
break;
case 15:
{
afterEOL=true;
if (valueIndent < 0) {
yybegin(YYINITIAL);
}
 else if (valueIndent == 0) {
valueIndent--;
}
return EOL;
}
case 31:
break;
case 20:
{
if (braceCount <= 0) {
char c;
while ((c=getCharAfter(0)) == ' ' || c == ',') {
zzMarkedPos++;
}
}
return TEXT;
}
case 32:
break;
case 22:
{
int zzFState=7;
int zzFPos=zzStartRead;
if (zzFin.length <= (zzBufferArrayL != null ? zzBufferArrayL.length : zzBufferL.length())) {
zzFin=new boolean[(zzBufferArrayL != null ? zzBufferArrayL.length : zzBufferL.length()) + 1];
}
boolean zzFinL[]=zzFin;
while (zzFState != -1 && zzFPos < zzMarkedPos) {
if ((zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzFPos++] : zzBufferL.charAt(zzFPos++);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzFState=6;
zzFPos=zzMarkedPos;
while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
zzInput=zzBufferArrayL != null ? zzBufferArrayL[--zzFPos] : zzBufferL.charAt(--zzFPos);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
;
zzMarkedPos=zzFPos;
}
{
yybegin(INDENT_VALUE);
valueIndent=0;
afterEOL=false;
valueTokenType=SCALAR_LIST;
yypushback(yylength());
}
case 33:
break;
case 10:
{
return QUESTION;
}
case 34:
break;
case 9:
{
if (braceCount > 0) {
yybegin(BRACES);
return COMMA;
}
return TEXT;
}
case 35:
break;
case 14:
{
if (afterEOL) {
yypushback(yylength());
yybegin(YYINITIAL);
}
 else {
afterEOL=false;
if (valueIndent < 0) {
return TEXT;
}
return valueTokenType;
}
}
case 36:
break;
case 19:
zzMarkedPos=zzStartRead + 1;
{
return COLON;
}
case 37:
break;
case 2:
{
yybegin(YYINITIAL);
return EOL;
}
case 38:
break;
case 12:
{
return SCALAR_DSTRING;
}
case 39:
break;
case 6:
{
braceCount--;
if (yystate() == BRACES && braceCount == 0) {
yybegin(previousState);
}
return RBRACE;
}
case 40:
break;
case 16:
{
afterEOL=false;
final int matched=yylength();
if (valueIndent < 0) {
valueIndent=matched;
}
 else if (valueIndent > matched) {
yybegin(YYINITIAL);
}
return previousChar() == '\n' ? INDENT : WHITESPACE;
}
case 41:
break;
case 1:
{
return TEXT;
}
case 42:
break;
case 13:
{
return SCALAR_STRING;
}
case 43:
break;
case 5:
{
braceCount--;
if (yystate() == BRACES && braceCount == 0) {
yybegin(previousState);
}
return RBRACKET;
}
case 44:
break;
case 3:
{
final char prev=previousChar();
return prev == (char)-1 || prev == '\n' ? INDENT : WHITESPACE;
}
case 45:
break;
case 18:
zzMarkedPos=zzStartRead + 1;
{
yybegin(VALUE_OR_KEY);
return SEQUENCE_MARKER;
}
case 46:
break;
case 23:
{
int zzFState=5;
int zzFPos=zzStartRead;
if (zzFin.length <= (zzBufferArrayL != null ? zzBufferArrayL.length : zzBufferL.length())) {
zzFin=new boolean[(zzBufferArrayL != null ? zzBufferArrayL.length : zzBufferL.length()) + 1];
}
boolean zzFinL[]=zzFin;
while (zzFState != -1 && zzFPos < zzMarkedPos) {
if ((zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzFPos++] : zzBufferL.charAt(zzFPos++);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzFState=6;
zzFPos=zzMarkedPos;
while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
zzInput=zzBufferArrayL != null ? zzBufferArrayL[--zzFPos] : zzBufferL.charAt(--zzFPos);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
;
zzMarkedPos=zzFPos;
}
{
yybegin(VALUE);
return SCALAR_KEY;
}
case 47:
break;
case 11:
{
return WHITESPACE;
}
case 48:
break;
default :
if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
zzAtEOF=true;
zzDoEOF();
return null;
}
 else {
zzScanError(ZZ_NO_MATCH);
}
}
}
}
