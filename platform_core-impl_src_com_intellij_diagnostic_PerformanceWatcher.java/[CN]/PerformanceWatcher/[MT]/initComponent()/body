{
  if (!shouldWatch())   return;
  final AppScheduledExecutorService service=(AppScheduledExecutorService)AppExecutorUtil.getAppScheduledExecutorService();
  service.setNewThreadListener(new Consumer<Thread>(){
    private final int ourReasonableThreadPoolSize=Registry.intValue("core.pooled.threads");
    @Override public void consume(    Thread thread){
      if (service.getBackendPoolExecutorSize() > ourReasonableThreadPoolSize && ApplicationInfoImpl.getShadowInstance().isEAP()) {
        File file=dumpThreads("newPooledThread/",true);
        LOG.info("Not enough pooled threads" + (file != null ? "; dumped threads into file '" + file.getPath() + "'" : ""));
      }
    }
  }
);
  final String threshold=System.getProperty("performance.watcher.threshold");
  if (threshold != null) {
    try {
      UNRESPONSIVE_THRESHOLD_SECONDS=Integer.parseInt(threshold);
    }
 catch (    NumberFormatException e) {
    }
  }
  final String interval=System.getProperty("performance.watcher.interval");
  if (interval != null) {
    try {
      UNRESPONSIVE_INTERVAL_SECONDS=Integer.parseInt(interval);
    }
 catch (    NumberFormatException e) {
    }
  }
  if (UNRESPONSIVE_THRESHOLD_SECONDS == 0 || UNRESPONSIVE_INTERVAL_SECONDS == 0) {
    return;
  }
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      deleteOldThreadDumps();
    }
  }
);
  for (  MemoryPoolMXBean bean : ManagementFactory.getMemoryPoolMXBeans()) {
    if ("Code Cache".equals(bean.getName())) {
      watchCodeCache(bean);
      return;
    }
  }
}
