{
  final Ref<String> baseClassNameRef=new Ref<String>(null);
  final Ref<PsiClass> classAtPositionRef=new Ref<PsiClass>(null);
  final Ref<Boolean> isLocalOrAnonymous=new Ref<Boolean>(Boolean.FALSE);
  final Ref<Integer> requiredDepth=new Ref<Integer>(0);
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      classAtPositionRef.set(psiClass);
      String className=JVMNameUtil.getNonAnonymousClassName(psiClass);
      if (className == null) {
        isLocalOrAnonymous.set(Boolean.TRUE);
        final PsiClass topLevelClass=JVMNameUtil.getTopLevelParentClass(psiClass);
        if (topLevelClass != null) {
          final String parentClassName=JVMNameUtil.getNonAnonymousClassName(topLevelClass);
          if (parentClassName != null) {
            requiredDepth.set(getNestingDepth(psiClass));
            baseClassNameRef.set(parentClassName);
          }
        }
 else {
          final StringBuilder sb=new StringBuilder();
          PsiTreeUtil.treeWalkUp(psiClass,null,new PairProcessor<PsiElement,PsiElement>(){
            @Override public boolean process(            PsiElement element,            PsiElement element2){
              sb.append(element);
              return true;
            }
          }
);
          LOG.error("Local or anonymous class " + psiClass + " has no non-local parent, parents:"+ sb);
        }
      }
 else {
        baseClassNameRef.set(className);
      }
    }
  }
);
  final String className=baseClassNameRef.get();
  if (className == null) {
    return Collections.emptyList();
  }
  if (!isLocalOrAnonymous.get()) {
    return myDebugProcess.getVirtualMachineProxy().classesByName(className);
  }
  final List<ReferenceType> outers=myDebugProcess.getVirtualMachineProxy().classesByName(className);
  final List<ReferenceType> result=new ArrayList<ReferenceType>(outers.size());
  for (  ReferenceType outer : outers) {
    final ReferenceType nested=findNested(outer,0,classAtPositionRef.get(),requiredDepth.get(),position);
    if (nested != null) {
      result.add(nested);
    }
  }
  return result;
}
