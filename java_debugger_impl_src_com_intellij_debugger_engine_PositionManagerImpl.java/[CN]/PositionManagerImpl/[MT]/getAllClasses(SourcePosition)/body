{
  final Ref<String> baseClassNameRef=new Ref<String>(null);
  final Ref<PsiClass> classAtPositionRef=new Ref<PsiClass>(null);
  final Ref<Boolean> isLocalOrAnonymous=new Ref<Boolean>(Boolean.FALSE);
  final Ref<Integer> requiredDepth=new Ref<Integer>(0);
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      final PsiClass psiClass=JVMNameUtil.getClassAt(position);
      if (psiClass != null) {
        classAtPositionRef.set(psiClass);
        if (!classHasName(psiClass)) {
          isLocalOrAnonymous.set(Boolean.TRUE);
          final PsiClass topLevelClass=JVMNameUtil.getTopLevelParentClass(psiClass);
          if (topLevelClass != null) {
            final String parentClassName=JVMNameUtil.getNonAnonymousClassName(topLevelClass);
            if (parentClassName != null) {
              requiredDepth.set(getNestingDepth(psiClass));
              baseClassNameRef.set(parentClassName);
            }
          }
 else {
            LOG.error("Local or anonymous class has no non-local parent");
          }
        }
 else {
          final String className=JVMNameUtil.getNonAnonymousClassName(psiClass);
          if (className != null) {
            baseClassNameRef.set(className);
          }
        }
      }
    }
  }
);
  final String className=baseClassNameRef.get();
  if (className == null) {
    return Collections.emptyList();
  }
  if (!isLocalOrAnonymous.get()) {
    return myDebugProcess.getVirtualMachineProxy().classesByName(className);
  }
  final List<ReferenceType> outers=myDebugProcess.getVirtualMachineProxy().classesByName(className);
  final List<ReferenceType> result=new ArrayList<ReferenceType>(outers.size());
  for (  ReferenceType outer : outers) {
    final ReferenceType nested=findNested(outer,0,classAtPositionRef.get(),requiredDepth.get(),position);
    if (nested != null) {
      result.add(nested);
    }
  }
  return result;
}
