{
  ApplicationManager.getApplication().assertReadAccessAllowed();
  final VirtualMachineProxyImpl vmProxy=myDebugProcess.getVirtualMachineProxy();
  if (fromClass.isPrepared()) {
    try {
      if (currentDepth < requiredDepth) {
        final List<ReferenceType> nestedTypes=vmProxy.nestedTypes(fromClass);
        for (        ReferenceType nested : nestedTypes) {
          final ReferenceType found=findNested(nested,currentDepth + 1,classToFind,requiredDepth,position);
          if (found != null) {
            return found;
          }
        }
        return null;
      }
      int rangeBegin=Integer.MAX_VALUE;
      int rangeEnd=Integer.MIN_VALUE;
      for (      Location location : fromClass.allLineLocations()) {
        final int lnumber=location.lineNumber();
        if (lnumber <= 1) {
          continue;
        }
        final Method method=location.method();
        if (method == null || DebuggerUtils.isSynthetic(method) || method.isBridge()) {
          continue;
        }
        int locationLine=lnumber - 1;
        PsiFile psiFile=position.getFile().getOriginalFile();
        if (psiFile instanceof PsiCompiledFile) {
          locationLine=DebuggerUtilsEx.bytecodeToSourceLine(psiFile,locationLine);
          if (locationLine < 0)           continue;
        }
        rangeBegin=Math.min(rangeBegin,locationLine);
        rangeEnd=Math.max(rangeEnd,locationLine);
      }
      final int positionLine=position.getLine();
      if (positionLine >= rangeBegin && positionLine <= rangeEnd) {
        if (!classToFind.isValid()) {
          return null;
        }
        Set<PsiClass> lineClasses=getLineClasses(position.getFile(),rangeEnd);
        if (lineClasses.size() > 1) {
          for (          PsiClass aClass : lineClasses) {
            if (classToFind.equals(aClass)) {
              return fromClass;
            }
          }
        }
 else         if (!lineClasses.isEmpty()) {
          return classToFind.equals(lineClasses.iterator().next()) ? fromClass : null;
        }
        return null;
      }
    }
 catch (    AbsentInformationException ignored) {
    }
  }
  return null;
}
