{
  final Mappings delta=context.getProjectDescriptor().dataManager.getMappings().createDelta();
  final List<File> successfullyCompiledFiles=new ArrayList<File>();
  if (!successfullyCompiled.isEmpty()) {
    final Callbacks.Backend callback=delta.getCallback();
    for (    Map.Entry<ModuleBuildTarget,Collection<GroovycOSProcessHandler.OutputItem>> entry : successfullyCompiled.entrySet()) {
      final ModuleBuildTarget target=entry.getKey();
      final Collection<GroovycOSProcessHandler.OutputItem> compiled=entry.getValue();
      for (      GroovycOSProcessHandler.OutputItem item : compiled) {
        final String sourcePath=FileUtil.toSystemIndependentName(item.sourcePath);
        final String outputPath=FileUtil.toSystemIndependentName(item.outputPath);
        final File outputFile=new File(outputPath);
        outputConsumer.registerOutputFile(target,outputFile,Collections.singleton(sourcePath));
        try {
          callback.associate(outputPath,sourcePath,new ClassReader(FileUtil.loadFileBytes(outputFile)));
        }
 catch (        Throwable e) {
          final String message="Class dependency information may be incomplete! Error parsing generated class " + item.outputPath;
          LOG.info(message,e);
          context.processMessage(new CompilerMessage(myBuilderName,BuildMessage.Kind.WARNING,message + "\n" + CompilerMessage.getTextFromThrowable(e),sourcePath));
        }
        successfullyCompiledFiles.add(new File(sourcePath));
      }
    }
  }
  return JavaBuilderUtil.updateMappings(context,delta,dirtyFilesHolder,chunk,toCompile,successfullyCompiledFiles);
}
