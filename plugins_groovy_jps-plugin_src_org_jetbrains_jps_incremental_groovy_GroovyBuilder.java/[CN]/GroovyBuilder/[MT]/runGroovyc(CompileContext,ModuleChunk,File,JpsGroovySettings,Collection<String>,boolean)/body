{
  List<String> classpath=new ArrayList<String>();
  if (optimizeClassLoading) {
    classpath.add(getGroovyRtRoot().getPath());
    classpath.add(ClasspathBootstrap.getResourcePath(Function.class));
    classpath.add(ClasspathBootstrap.getResourcePath(UrlClassLoader.class));
    classpath.add(ClasspathBootstrap.getResourceFile(THashMap.class).getPath());
  }
 else {
    classpath.addAll(compilationClassPath);
  }
  List<String> programParams=ContainerUtilRt.newArrayList(optimizeClassLoading ? GroovyRtConstants.OPTIMIZE : "do_not_optimize",myForStubs ? "stubs" : "groovyc",tempFile.getPath());
  if (settings.invokeDynamic) {
    programParams.add("--indy");
  }
  List<String> vmParams=ContainerUtilRt.newArrayList();
  vmParams.add("-Xmx" + settings.heapSize + "m");
  vmParams.add("-Dfile.encoding=" + System.getProperty("file.encoding"));
  String grapeRoot=System.getProperty(GroovycOSProcessHandler.GRAPE_ROOT);
  if (grapeRoot != null) {
    vmParams.add("-D" + GroovycOSProcessHandler.GRAPE_ROOT + "="+ grapeRoot);
  }
  final List<String> cmd=ExternalProcessUtil.buildJavaCommandLine(getJavaExecutable(chunk),"org.jetbrains.groovy.compiler.rt.GroovycRunner",Collections.<String>emptyList(),classpath,vmParams,programParams);
  final Process process=Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmd));
  final Consumer<String> updater=new Consumer<String>(){
    public void consume(    String s){
      context.processMessage(new ProgressMessage(s + " [" + chunk.getName()+ "]"));
    }
  }
;
  final GroovycOSProcessHandler handler=new GroovycOSProcessHandler(process,updater){
    @Override protected Future<?> executeOnPooledThread(    Runnable task){
      return SharedThreadPool.getInstance().executeOnPooledThread(task);
    }
  }
;
  handler.startNotify();
  handler.waitFor();
  return handler;
}
