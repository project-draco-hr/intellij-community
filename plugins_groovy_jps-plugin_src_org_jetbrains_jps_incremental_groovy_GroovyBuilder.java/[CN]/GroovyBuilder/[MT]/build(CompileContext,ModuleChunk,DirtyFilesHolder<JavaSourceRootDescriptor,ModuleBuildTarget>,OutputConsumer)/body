{
  long start=0;
  try {
    JpsGroovySettings settings=JpsGroovySettings.getSettings(context.getProjectDescriptor().getProject());
    final List<File> toCompile=collectChangedFiles(context,dirtyFilesHolder,settings);
    if (toCompile.isEmpty()) {
      return hasFilesToCompileForNextRound(context) ? ExitCode.ADDITIONAL_PASS_REQUIRED : ExitCode.NOTHING_DONE;
    }
    if (Utils.IS_TEST_MODE || LOG.isDebugEnabled()) {
      LOG.info("forStubs=" + myForStubs);
    }
    Map<ModuleBuildTarget,String> finalOutputs=getCanonicalModuleOutputs(context,chunk);
    if (finalOutputs == null) {
      return ExitCode.ABORT;
    }
    start=System.currentTimeMillis();
    final Set<String> toCompilePaths=getPathsToCompile(toCompile);
    JpsSdk<JpsDummyElement> jdk=getJdk(chunk);
    String version=jdk == null ? SystemInfo.JAVA_RUNTIME_VERSION : jdk.getVersionString();
    boolean mayDependOnUtilJar=version != null && StringUtil.compareVersionNumbers(version,"1.6") >= 0;
    boolean optimizeClassLoading=mayDependOnUtilJar && ourOptimizeThreshold != 0 && toCompilePaths.size() >= ourOptimizeThreshold;
    Map<String,String> class2Src=buildClassToSourceMap(chunk,context,toCompilePaths,finalOutputs);
    final String encoding=context.getProjectDescriptor().getEncodingConfiguration().getPreferredModuleChunkEncoding(chunk);
    List<String> patchers=new ArrayList<String>();
    for (    GroovyBuilderExtension extension : JpsServiceManager.getInstance().getExtensions(GroovyBuilderExtension.class)) {
      patchers.addAll(extension.getCompilationUnitPatchers(context,chunk));
    }
    Map<ModuleBuildTarget,String> generationOutputs=myForStubs ? getStubGenerationOutputs(chunk,context) : finalOutputs;
    String compilerOutput=generationOutputs.get(chunk.representativeTarget());
    Collection<String> classpath=generateClasspath(context,chunk);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Optimized class loading: " + optimizeClassLoading);
      LOG.debug("Groovyc classpath: " + classpath);
    }
    final File tempFile=GroovycOSProcessHandler.fillFileWithGroovycParameters(compilerOutput,toCompilePaths,finalOutputs.values(),class2Src,encoding,patchers,optimizeClassLoading ? StringUtil.join(classpath,File.pathSeparator) : "");
    final GroovycOSProcessHandler handler=runGroovyc(context,chunk,tempFile,settings,classpath,optimizeClassLoading);
    Map<ModuleBuildTarget,Collection<GroovycOSProcessHandler.OutputItem>> compiled=processCompiledFiles(context,chunk,generationOutputs,compilerOutput,handler);
    if (checkChunkRebuildNeeded(context,handler)) {
      return ExitCode.CHUNK_REBUILD_REQUIRED;
    }
    if (myForStubs) {
      addStubRootsToJavacSourcePath(context,generationOutputs);
      rememberStubSources(context,compiled);
    }
    for (    CompilerMessage message : handler.getCompilerMessages(chunk.representativeTarget().getModule().getName())) {
      context.processMessage(message);
    }
    if (!myForStubs && updateDependencies(context,chunk,dirtyFilesHolder,toCompile,compiled,outputConsumer)) {
      return ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
    return hasFilesToCompileForNextRound(context) ? ExitCode.ADDITIONAL_PASS_REQUIRED : ExitCode.OK;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
 finally {
    if (start > 0 && LOG.isDebugEnabled()) {
      LOG.debug(myBuilderName + " took " + (System.currentTimeMillis() - start)+ " on "+ chunk.getName());
    }
    if (!myForStubs) {
      FILES_MARKED_DIRTY_FOR_NEXT_ROUND.set(context,null);
    }
  }
}
