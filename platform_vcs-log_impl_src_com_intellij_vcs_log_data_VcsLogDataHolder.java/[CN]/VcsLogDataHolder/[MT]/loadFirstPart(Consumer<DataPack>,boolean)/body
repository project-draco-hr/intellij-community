{
  runInBackground(new ThrowableConsumer<ProgressIndicator,VcsException>(){
    @Override public void consume(    ProgressIndicator indicator) throws VcsException {
      boolean initialization=myLogData == null;
      boolean isFullLogReady=!initialization && myLogData.isFullLogReady();
      boolean fairRefresh=invalidateWholeLog || !isFullLogReady;
      Map<VirtualFile,List<TimedVcsCommit>> logsToBuild=ContainerUtil.newHashMap();
      Map<VirtualFile,Collection<VcsRef>> refsByRoot=ContainerUtil.newHashMap();
      int topCommitCount=myLogData == null ? 0 : myLogData.getTopCommitsCount();
      for (      Map.Entry<VirtualFile,VcsLogProvider> entry : myLogProviders.entrySet()) {
        VirtualFile root=entry.getKey();
        VcsLogProvider logProvider=entry.getValue();
        List<? extends VcsFullCommitDetails> firstBlockDetails=logProvider.readFirstBlock(root,fairRefresh);
        Collection<VcsRef> newRefs=logProvider.readAllRefs(root);
        for (        VcsFullCommitDetails detail : firstBlockDetails) {
          myTopCommitsDetailsCache.put(detail.getHash(),detail);
        }
        List<TimedVcsCommit> firstBlockCommits=ContainerUtil.map(firstBlockDetails,new Function<VcsFullCommitDetails,TimedVcsCommit>(){
          @Override public TimedVcsCommit fun(          VcsFullCommitDetails details){
            return myFactory.createTimedCommit(details.getHash(),details.getParents(),details.getAuthorTime());
          }
        }
);
        List<TimedVcsCommit> refreshedLog;
        if (fairRefresh) {
          refreshedLog=firstBlockCommits;
          topCommitCount=firstBlockCommits.size();
        }
 else {
          Pair<List<TimedVcsCommit>,Integer> joinResult=myLogJoiner.addCommits(myLogData.getLog(root),myLogData.getRefs(root),firstBlockCommits,newRefs);
          refreshedLog=joinResult.getFirst();
          int newCommitsCount=joinResult.getSecond();
          topCommitCount+=newCommitsCount;
        }
        logsToBuild.put(root,refreshedLog);
        refsByRoot.put(root,newRefs);
      }
      List<TimedVcsCommit> compoundLog=myMultiRepoJoiner.join(logsToBuild.values());
      List<TimedVcsCommit> topPartOfTheLog=compoundLog.subList(0,topCommitCount);
      Collection<VcsRef> allRefs=new ArrayList<VcsRef>();
      for (      Collection<VcsRef> refs : refsByRoot.values()) {
        allRefs.addAll(refs);
      }
      List<TimedVcsCommit> logToBuild=myFullLogShowing ? compoundLog : topPartOfTheLog;
      final DataPack dataPack=DataPack.build(logToBuild,allRefs,indicator);
      myLogData=new LogData(logsToBuild,refsByRoot,topPartOfTheLog,dataPack,isFullLogReady);
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          onSuccess.consume(dataPack);
        }
      }
);
    }
  }
);
}
