{
  runInBackground(new ThrowableConsumer<ProgressIndicator,VcsException>(){
    @Override public void consume(    ProgressIndicator indicator) throws VcsException {
      if (invalidateWholeLog) {
        myLogData=null;
      }
      boolean ordered=!isFullLogReady();
      Map<VirtualFile,List<TimeCommitParents>> logsToBuild=ContainerUtil.newHashMap();
      Collection<VcsRef> allRefs=ContainerUtil.newHashSet();
      for (      Map.Entry<VirtualFile,VcsLogProvider> entry : myLogProviders.entrySet()) {
        VirtualFile root=entry.getKey();
        VcsLogProvider logProvider=entry.getValue();
        List<? extends VcsFullCommitDetails> firstBlockDetails=logProvider.readFirstBlock(root,ordered);
        Collection<VcsRef> newRefs=logProvider.readAllRefs(root);
        myDetailsGetter.saveInCache(firstBlockDetails);
        myMiniDetailsGetter.saveInCache(firstBlockDetails);
        List<TimeCommitParents> firstBlockCommits=ContainerUtil.map(firstBlockDetails,new Function<VcsFullCommitDetails,TimeCommitParents>(){
          @Override public TimeCommitParents fun(          VcsFullCommitDetails details){
            return new TimeCommitParents(details.getHash(),details.getParents(),details.getAuthorTime());
          }
        }
);
        List<TimeCommitParents> refreshedLog;
        int newCommitsCount;
        if (ordered) {
          refreshedLog=new ArrayList<TimeCommitParents>(firstBlockCommits);
          newCommitsCount=0;
        }
 else {
          Pair<List<TimeCommitParents>,Integer> joinResult=myLogJoiner.addCommits(myLogData.getLog(root),myLogData.getRefs(root),firstBlockCommits,newRefs);
          refreshedLog=joinResult.getFirst();
          newCommitsCount=joinResult.getSecond();
        }
        if (myFullLogShowing) {
          logsToBuild.put(root,refreshedLog);
        }
 else {
          int commitsToShow;
          if (myDataPack != null) {
            commitsToShow=myDataPack.getGraphModel().getGraph().getNodeRows().size() + newCommitsCount;
          }
 else {
            commitsToShow=firstBlockDetails.size();
          }
          logsToBuild.put(root,refreshedLog.subList(0,Math.min(commitsToShow,refreshedLog.size())));
        }
        allRefs.addAll(newRefs);
        if (myLogData != null) {
          myLogData.setRefs(root,newRefs);
        }
      }
      List<TimeCommitParents> compoundLog=myMultiRepoJoiner.join(logsToBuild.values());
      myDataPack=DataPack.build(compoundLog,allRefs,indicator);
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          onSuccess.consume(myDataPack);
        }
      }
);
    }
  }
);
}
