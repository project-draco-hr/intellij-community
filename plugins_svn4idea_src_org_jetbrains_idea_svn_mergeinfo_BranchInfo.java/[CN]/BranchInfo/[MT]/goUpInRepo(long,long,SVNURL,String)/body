{
  SvnMergeInfoCache.MergeCheckResult result;
  Set<Long> mergeInfo=myPathMergedMap.get(branchUrl.toString() + "@" + targetRevision);
  if (mergeInfo != null) {
    result=SvnMergeInfoCache.MergeCheckResult.getInstance(mergeInfo.contains(revisionAsked));
  }
 else {
    SvnTarget target=SvnTarget.fromURL(branchUrl);
    PropertyValue mergeinfoProperty=myVcs.getFactory(target).createPropertyClient().getProperty(target,SvnPropertyKeys.MERGE_INFO,false,SVNRevision.create(targetRevision));
    if (mergeinfoProperty == null) {
      final String newTrunkUrl=SVNPathUtil.removeTail(trunkUrl).trim();
      final SVNURL newBranchUrl=branchUrl.removePathTail();
      final String absoluteTrunk=SVNPathUtil.append(myInfo.getRepoUrl(),newTrunkUrl);
      result=newTrunkUrl.length() <= 1 || newBranchUrl.toString().length() <= myInfo.getRepoUrl().length() || newBranchUrl.toString().equals(absoluteTrunk) ? SvnMergeInfoCache.MergeCheckResult.NOT_MERGED : goUpInRepo(revisionAsked,targetRevision,newBranchUrl,newTrunkUrl);
    }
 else {
      result=processMergeinfoProperty(branchUrl.toString() + "@" + targetRevision,revisionAsked,mergeinfoProperty,trunkUrl,false);
    }
  }
  return result;
}
