{
  final String branchAsString=branchUrl.toString();
  final String keyString=branchAsString + "@" + targetRevision;
  final Set<Long> mergeInfo=myPathMergedMap.get(keyString);
  if (mergeInfo != null) {
    return SvnMergeInfoCache.MergeCheckResult.getInstance(mergeInfo.contains(revisionAsked));
  }
  final PropertyValue mergeinfoProperty;
  SvnTarget target=SvnTarget.fromURL(branchUrl);
  try {
    mergeinfoProperty=myVcs.getFactory(target).createPropertyClient().getProperty(target,SvnPropertyKeys.MERGE_INFO,false,SVNRevision.create(targetRevision));
  }
 catch (  VcsException e) {
    LOG.info(e);
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  if (mergeinfoProperty == null) {
    final String newTrunkUrl=SVNPathUtil.removeTail(trunkUrl).trim();
    final SVNURL newBranchUrl;
    try {
      newBranchUrl=branchUrl.removePathTail();
    }
 catch (    SVNException e) {
      LOG.info(e);
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
    final String absoluteTrunk=SVNPathUtil.append(myInfo.getRepoUrl(),newTrunkUrl);
    if ((1 >= newTrunkUrl.length()) || (myInfo.getRepoUrl().length() >= newBranchUrl.toString().length()) || (newBranchUrl.toString().equals(absoluteTrunk))) {
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
    return goUpInRepo(revisionAsked,targetRevision,newBranchUrl,newTrunkUrl);
  }
  return processMergeinfoProperty(keyString,revisionAsked,mergeinfoProperty,trunkUrl,false);
}
