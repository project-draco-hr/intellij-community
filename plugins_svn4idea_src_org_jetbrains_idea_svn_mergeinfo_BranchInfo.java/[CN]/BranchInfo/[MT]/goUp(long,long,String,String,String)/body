{
  SvnMergeInfoCache.MergeCheckResult result;
  String newTrunkUrl=SVNPathUtil.removeTail(trunkUrl).trim();
  if (newTrunkUrl.length() == 0 || "/".equals(newTrunkUrl)) {
    result=SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
 else {
    String newPath=new File(path).getParent();
    if (newPath.length() < branchRootPath.length()) {
      if (targetRevision == -1) {
        result=SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
      }
 else {
        Info svnInfo=myVcs.getInfo(new File(branchRootPath));
        result=svnInfo == null || svnInfo.getURL() == null ? SvnMergeInfoCache.MergeCheckResult.NOT_MERGED : goUpInRepo(revisionAsked,targetRevision,svnInfo.getURL().removePathTail(),newTrunkUrl);
      }
    }
 else {
      result=checkPathGoingUp(revisionAsked,targetRevision,branchRootPath,newPath,newTrunkUrl,false);
    }
  }
  return result;
}
