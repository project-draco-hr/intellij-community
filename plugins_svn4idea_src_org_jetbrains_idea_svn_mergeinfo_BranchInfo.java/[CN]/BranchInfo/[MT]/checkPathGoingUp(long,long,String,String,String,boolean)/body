{
  final File pathFile=new File(path);
  if (targetRevision == -1) {
    if (!pathFile.exists()) {
      return goUp(revisionAsked,targetRevision,branchRootPath,path,trunkUrl);
    }
  }
  final Info svnInfo=getInfo(pathFile);
  if (svnInfo == null || svnInfo.getRevision() == null || svnInfo.getURL() == null) {
    LOG.info("Svninfo for " + pathFile + " is null or not full.");
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  final long actualRevision=svnInfo.getRevision().getNumber();
  final long targetRevisionCorrected=(targetRevision == -1) ? actualRevision : targetRevision;
  final String keyString=path + "@" + targetRevisionCorrected;
  final Set<Long> selfInfo=self ? myNonInheritablePathMergedMap.get(keyString) : null;
  final Set<Long> mergeInfo=myPathMergedMap.get(keyString);
  if (mergeInfo != null || selfInfo != null) {
    final boolean merged=((mergeInfo != null) && mergeInfo.contains(revisionAsked)) || ((selfInfo != null) && selfInfo.contains(revisionAsked));
    return SvnMergeInfoCache.MergeCheckResult.getInstance(merged);
  }
  final PropertyValue mergeinfoProperty;
  try {
    if (actualRevision == targetRevisionCorrected) {
      SvnTarget target=SvnTarget.fromFile(pathFile,SVNRevision.WORKING);
      mergeinfoProperty=myVcs.getFactory(target).createPropertyClient().getProperty(target,SVNProperty.MERGE_INFO,false,SVNRevision.WORKING);
    }
 else {
      myMixedRevisionsFound=true;
      SvnTarget target=SvnTarget.fromURL(svnInfo.getURL());
      mergeinfoProperty=myVcs.getFactory(target).createPropertyClient().getProperty(target,SVNProperty.MERGE_INFO,false,SVNRevision.create(targetRevisionCorrected));
    }
  }
 catch (  VcsException e) {
    LOG.info(e);
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  if (mergeinfoProperty == null) {
    return goUp(revisionAsked,targetRevisionCorrected,branchRootPath,path,trunkUrl);
  }
  return processMergeinfoProperty(keyString,revisionAsked,mergeinfoProperty,trunkUrl,self);
}
