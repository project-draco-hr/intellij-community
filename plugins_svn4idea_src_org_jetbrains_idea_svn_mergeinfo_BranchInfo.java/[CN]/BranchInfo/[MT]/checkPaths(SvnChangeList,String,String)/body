{
  MultiMap<SvnMergeInfoCache.MergeCheckResult,String> result=MultiMap.create();
  String myTrunkPathCorrespondingToLocalBranchPath=SVNPathUtil.append(myInfo.getCurrentBranch().getUrl(),subPathUnderBranch);
  for (  String path : list.getAffectedPaths()) {
    String absoluteInTrunkPath=SVNPathUtil.append(myInfo.getRepoUrl(),path);
    SvnMergeInfoCache.MergeCheckResult mergeCheckResult;
    if (!absoluteInTrunkPath.startsWith(myTrunkPathCorrespondingToLocalBranchPath)) {
      mergeCheckResult=SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
    }
 else {
      String relativeToTrunkPath=absoluteInTrunkPath.substring(myTrunkPathCorrespondingToLocalBranchPath.length());
      String localPathInBranch=new File(branchPath,relativeToTrunkPath).getAbsolutePath();
      try {
        mergeCheckResult=checkPathGoingUp(list.getNumber(),-1,branchPath,localPathInBranch,path,true);
      }
 catch (      VcsException e) {
        LOG.info(e);
        mergeCheckResult=SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
      }
catch (      SVNException e) {
        LOG.info(e);
        mergeCheckResult=SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
      }
    }
    result.putValue(mergeCheckResult,path);
    if (SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS.equals(mergeCheckResult)) {
      break;
    }
  }
  return result;
}
