{
  final Info info=myVcs.getInfo(new File(branchPath));
  if (info == null || info.getURL() == null || !SVNPathUtil.isAncestor(myBranch.getUrl(),info.getURL().toString())) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  final String subPathUnderBranch=SVNPathUtil.getRelativePath(myBranch.getUrl(),info.getURL().toString());
  MultiMap<SvnMergeInfoCache.MergeCheckResult,String> result=MultiMap.create();
  checkPaths(list.getNumber(),list.getAddedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
  checkPaths(list.getNumber(),list.getDeletedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
  checkPaths(list.getNumber(),list.getChangedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
  if (result.containsKey(SvnMergeInfoCache.MergeCheckResult.NOT_MERGED)) {
    myPartlyMerged.put(list.getNumber(),result.get(SvnMergeInfoCache.MergeCheckResult.NOT_MERGED));
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  return SvnMergeInfoCache.MergeCheckResult.MERGED;
}
