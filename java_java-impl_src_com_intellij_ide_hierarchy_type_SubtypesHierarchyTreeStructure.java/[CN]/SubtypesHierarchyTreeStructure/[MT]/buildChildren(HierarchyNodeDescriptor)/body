{
  final Object element=((TypeHierarchyNodeDescriptor)descriptor).getPsiClass();
  if (!(element instanceof PsiClass))   return ArrayUtil.EMPTY_OBJECT_ARRAY;
  final PsiClass psiClass=(PsiClass)element;
  if (CommonClassNames.JAVA_LANG_OBJECT.equals(psiClass.getQualifiedName())) {
    return new Object[]{IdeBundle.message("node.hierarchy.java.lang.object")};
  }
  if (psiClass instanceof PsiAnonymousClass)   return ArrayUtil.EMPTY_OBJECT_ARRAY;
  if (psiClass.hasModifierProperty(PsiModifier.FINAL))   return ArrayUtil.EMPTY_OBJECT_ARRAY;
  final SearchScope searchScope=psiClass.getUseScope().intersectWith(getSearchScope(myCurrentScopeType,psiClass));
  final List<PsiClass> classes=new ArrayList<PsiClass>(ClassInheritorsSearch.search(psiClass,searchScope,false).findAll());
  final List<HierarchyNodeDescriptor> descriptors=new ArrayList<HierarchyNodeDescriptor>(classes.size());
  for (  PsiClass aClass : classes) {
    descriptors.add(new TypeHierarchyNodeDescriptor(myProject,descriptor,aClass,false));
  }
  FunctionalExpressionSearch.search(psiClass,searchScope).forEach(new Processor<PsiFunctionalExpression>(){
    @Override public boolean process(    PsiFunctionalExpression expression){
      descriptors.add(new TypeHierarchyNodeDescriptor(myProject,descriptor,expression,false));
      return true;
    }
  }
);
  return descriptors.toArray(new HierarchyNodeDescriptor[descriptors.size()]);
}
