{
  pushCommitFromBro();
  cd(myRepository);
  String hash=makeCommit("afile.txt");
  agreeToUpdate(GitRejectedPushUpdateDialog.MERGE_EXIT_CODE);
  refresh();
  PushSpec<GitPushSource,GitPushTarget> pushSpec=makePushSpec(myRepository,"master","origin/master");
  GitPushResult result=new GitPushOperation(myProject,singletonMap(myRepository,pushSpec),null,false){
    @NotNull @Override protected GitUpdateResult update(    @NotNull Collection<GitRepository> rootsToUpdate,    @NotNull UpdateMethod updateMethod){
      GitUpdateResult updateResult=super.update(rootsToUpdate,updateMethod);
      try {
        pushCommitFromBro();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
      return updateResult;
    }
  }
.execute();
  assertResult(REJECTED,-1,"master","origin/master",GitUpdateResult.SUCCESS,Collections.singletonList("bro.txt"),result);
  cd(myParentRepo.getPath());
  String history=git("log --all --pretty=%H ");
  assertFalse("The commit shouldn't be pushed",history.contains(hash));
}
