{
  PsiBuilder.Marker parameterList;
  parameterList=myBuilder.mark();
  if (advanceLexer) {
    myBuilder.advanceLexer();
  }
  boolean first=true;
  while (myBuilder.getTokenType() != endToken) {
    if (first) {
      first=false;
    }
 else {
      if (myBuilder.getTokenType() == PyTokenTypes.COMMA) {
        myBuilder.advanceLexer();
      }
 else       if (myBuilder.getTokenType() == PyTokenTypes.LPAR) {
        parseParameterSubList();
        continue;
      }
 else {
        myBuilder.error(message("PARSE.expected.comma.lpar.rpar"));
        break;
      }
    }
    final PsiBuilder.Marker parameter=myBuilder.mark();
    boolean isStarParameter=false;
    if (myBuilder.getTokenType() == PyTokenTypes.MULT) {
      myBuilder.advanceLexer();
      if (myContext.getLanguageLevel().isPy3K() && (myBuilder.getTokenType() == PyTokenTypes.COMMA) || myBuilder.getTokenType() == endToken) {
        parameter.done(PyElementTypes.SINGLE_STAR_PARAMETER);
        continue;
      }
      isStarParameter=true;
    }
 else     if (myBuilder.getTokenType() == PyTokenTypes.EXP) {
      myBuilder.advanceLexer();
      isStarParameter=true;
    }
    if (matchToken(PyTokenTypes.IDENTIFIER)) {
      if (!isLambda && myContext.getLanguageLevel().isPy3K() && atToken(PyTokenTypes.COLON)) {
        PsiBuilder.Marker annotationMarker=myBuilder.mark();
        nextToken();
        if (!getExpressionParser().parseSingleExpression(false)) {
          myBuilder.error(message("PARSE.expected.expression"));
        }
        annotationMarker.done(PyElementTypes.ANNOTATION);
      }
      if (!isStarParameter && matchToken(PyTokenTypes.EQ)) {
        getExpressionParser().parseSingleExpression(false);
      }
      parameter.done(PyElementTypes.NAMED_PARAMETER);
    }
 else {
      myBuilder.error(message("PARSE.expected.formal.param.name"));
      parameter.rollbackTo();
    }
  }
  if (myBuilder.getTokenType() == endToken) {
    myBuilder.advanceLexer();
  }
  parameterList.done(PyElementTypes.PARAMETER_LIST);
}
