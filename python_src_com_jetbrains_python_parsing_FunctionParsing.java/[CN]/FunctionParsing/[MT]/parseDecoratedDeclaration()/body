{
  assertCurrentToken(PyTokenTypes.AT);
  final PsiBuilder.Marker decoratorStartMarker=myBuilder.mark();
  final PsiBuilder.Marker decoListMarker=myBuilder.mark();
  boolean decorated=false;
  while (myBuilder.getTokenType() == PyTokenTypes.AT) {
    PsiBuilder.Marker decoratorMarker=myBuilder.mark();
    myBuilder.advanceLexer();
    getStatementParser().parseDottedName();
    if (myBuilder.getTokenType() == PyTokenTypes.LPAR) {
      getExpressionParser().parseArgumentList(myBuilder);
    }
 else {
      myBuilder.mark().done(PyElementTypes.ARGUMENT_LIST);
    }
    checkMatches(PyTokenTypes.STATEMENT_BREAK,message("PARSE.expected.statement.break"));
    decoratorMarker.done(PyElementTypes.DECORATOR_CALL);
    decorated=true;
  }
  if (decorated)   decoListMarker.done(PyElementTypes.DECORATOR_LIST);
  if (myBuilder.getTokenType() == PyTokenTypes.DEF_KEYWORD) {
    parseFunctionInnards(decoratorStartMarker);
  }
 else   if (myBuilder.getTokenType() == PyTokenTypes.CLASS_KEYWORD) {
    getStatementParser().parseClassDeclaration(decoratorStartMarker);
  }
 else {
    myBuilder.error(message("PARSE.expected.@.or.def"));
    PsiBuilder.Marker parameterList=myBuilder.mark();
    parameterList.done(PyElementTypes.PARAMETER_LIST);
    decoratorStartMarker.done(PyElementTypes.FUNCTION_DECLARATION);
  }
}
