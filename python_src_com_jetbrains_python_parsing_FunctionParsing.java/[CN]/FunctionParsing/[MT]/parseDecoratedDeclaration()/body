{
  assertCurrentToken(PyTokenTypes.AT);
  final PsiBuilder.Marker decoratorStartMarker=myBuilder.mark();
  final PsiBuilder.Marker decoListMarker=myBuilder.mark();
  boolean decorated=false;
  while (myBuilder.getTokenType() == PyTokenTypes.AT) {
    PsiBuilder.Marker decoratorMarker=myBuilder.mark();
    myBuilder.advanceLexer();
    getStatementParser().parseDottedName();
    if (myBuilder.getTokenType() == PyTokenTypes.LPAR) {
      getExpressionParser().parseArgumentList();
    }
 else {
      PsiBuilder.Marker argListMarker=myBuilder.mark();
      argListMarker.setCustomEdgeTokenBinders(WhitespacesBinders.GREEDY_LEFT_BINDER,null);
      argListMarker.done(PyElementTypes.ARGUMENT_LIST);
    }
    if (atToken(PyTokenTypes.STATEMENT_BREAK)) {
      decoratorMarker.done(PyElementTypes.DECORATOR_CALL);
      nextToken();
    }
 else {
      myBuilder.error(message("PARSE.expected.statement.break"));
      decoratorMarker.done(PyElementTypes.DECORATOR_CALL);
    }
    decorated=true;
  }
  if (decorated)   decoListMarker.done(PyElementTypes.DECORATOR_LIST);
  parseDeclarationAfterDecorator(decoratorStartMarker);
}
