{
  if (isRerunNeeded(pass)) {
    getUpdater().requeue(pass);
    return Promise.REJECTED;
  }
  if (isToYieldUpdateFor(node)) {
    final AsyncPromise<Void> result=new AsyncPromise<Void>();
    pass.setCurrentNode(node);
    boolean wasRun=yieldAndRun(new TreeRunnable("AbstractTreeUi.maybeYeild"){
      @Override public void perform(){
        if (pass.isExpired()) {
          result.setError("expired");
          return;
        }
        if (isRerunNeeded(pass)) {
          runDone(new TreeRunnable("AbstractTreeUi.maybeYeild: rerun"){
            @Override public void perform(){
              if (!pass.isExpired()) {
                getUpdater().requeue(pass);
              }
            }
          }
);
          result.setError("requeue");
        }
 else {
          try {
            execute(processRunnable,result);
          }
 catch (          ProcessCanceledException e) {
            pass.expire();
            result.setError("process cancelled");
            cancelUpdate();
          }
        }
      }
    }
,pass);
    if (!wasRun) {
      result.setError("rejected");
    }
    return result;
  }
 else {
    AsyncPromise<Void> result=new AsyncPromise<Void>();
    try {
      execute(processRunnable,result);
    }
 catch (    ProcessCanceledException e) {
      pass.expire();
      result.setError("process cancelled");
      cancelUpdate();
    }
    return result;
  }
}
