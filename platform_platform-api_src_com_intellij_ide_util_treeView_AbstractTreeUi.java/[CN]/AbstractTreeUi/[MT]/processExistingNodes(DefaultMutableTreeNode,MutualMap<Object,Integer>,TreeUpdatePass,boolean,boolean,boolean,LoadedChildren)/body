{
  final List<TreeNode> childNodes=TreeUtil.childrenToArray(node);
  return maybeYeild(new AsyncRunnable(){
    @NotNull @Override public Promise<?> run(){
      if (pass.isExpired())       return Promises.<Void>rejectedPromise();
      if (childNodes.isEmpty())       return Promise.DONE;
      List<Promise<?>> promises=new SmartList<>();
      for (      TreeNode each : childNodes) {
        final DefaultMutableTreeNode eachChild=(DefaultMutableTreeNode)each;
        if (isLoadingNode(eachChild)) {
          continue;
        }
        final boolean childForceUpdate=isChildNodeForceUpdate(eachChild,forceUpdate,wasExpaned);
        promises.add(maybeYeild(new AsyncRunnable(){
          @NotNull @Override public Promise<?> run(){
            NodeDescriptor descriptor=preloaded != null ? preloaded.getDescriptor(getElementFor(eachChild)) : null;
            NodeDescriptor descriptorFromNode=getDescriptorFrom(eachChild);
            if (descriptor != null) {
              eachChild.setUserObject(descriptor);
              if (descriptorFromNode != null) {
                descriptor.setChildrenSortingStamp(descriptorFromNode.getChildrenSortingStamp());
              }
            }
 else {
              descriptor=descriptorFromNode;
            }
            return processExistingNode(eachChild,descriptor,node,elementToIndexMap,pass,canSmartExpand,childForceUpdate,preloaded);
          }
        }
,pass,node));
        for (        Promise<?> promise : promises) {
          if (promise.getState() == Promise.State.REJECTED) {
            return Promises.<Void>rejectedPromise();
          }
        }
      }
      return Promises.all(promises);
    }
  }
,pass,node);
}
