{
  if (checkIfInStructure && !isInStructure(element)) {
    runDone(onDone);
    return;
  }
  if (wasRootNodeInitialized()) {
    List<Object> kidsToExpand=new ArrayList<Object>();
    Object eachElement=element;
    DefaultMutableTreeNode firstVisible=null;
    while (true) {
      if (eachElement == null || !isValid(eachElement))       break;
      final int preselected=getRowIfUnderSelection(eachElement);
      if (preselected >= 0) {
        firstVisible=(DefaultMutableTreeNode)getTree().getPathForRow(preselected).getLastPathComponent();
      }
 else {
        firstVisible=getNodeForElement(eachElement,true);
      }
      if (eachElement != element || !parentsOnly) {
        kidsToExpand.add(eachElement);
      }
      if (firstVisible != null)       break;
      eachElement=getTreeStructure().getParentElement(eachElement);
      if (eachElement == null) {
        firstVisible=null;
        break;
      }
      int i=kidsToExpand.indexOf(eachElement);
      if (i != -1) {
        try {
          Object existing=kidsToExpand.get(i);
          LOG.error("Tree path contains equal elements at different levels:\n" + " element: '" + eachElement + "'; "+ eachElement.getClass()+ " ("+ System.identityHashCode(eachElement)+ ");\n"+ "existing: '"+ existing+ "'; "+ existing.getClass()+ " ("+ System.identityHashCode(existing)+ "); "+ "path='"+ kidsToExpand+ "'; tree structure="+ myTreeStructure);
        }
 catch (        AssertionError ignored) {
        }
        runDone(onDone);
        throw new ProcessCanceledException();
      }
    }
    if (firstVisible == null) {
      runDone(onDone);
    }
 else     if (kidsToExpand.isEmpty()) {
      final DefaultMutableTreeNode parentNode=(DefaultMutableTreeNode)firstVisible.getParent();
      if (parentNode != null) {
        final TreePath parentPath=new TreePath(parentNode.getPath());
        if (!myTree.isExpanded(parentPath)) {
          expand(parentPath,canSmartExpand);
        }
      }
      runDone(onDone);
    }
 else {
      processExpand(firstVisible,kidsToExpand,kidsToExpand.size() - 1,onDone,canSmartExpand);
    }
  }
 else {
    deferExpansion(element,onDone,parentsOnly,canSmartExpand);
  }
}
