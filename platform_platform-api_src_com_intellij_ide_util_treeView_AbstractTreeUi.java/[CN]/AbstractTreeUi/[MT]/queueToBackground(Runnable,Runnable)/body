{
  if (!canInitiateNewActivity())   return Promise.REJECTED;
  final AsyncPromise<Void> result=new AsyncPromise<Void>();
  final AtomicReference<ProcessCanceledException> fail=new AtomicReference<ProcessCanceledException>();
  final Runnable finalizer=new TreeRunnable("AbstractTreeUi.queueToBackground: finalizer"){
    @Override public void perform(){
      ProcessCanceledException exception=fail.get();
      if (exception == null) {
        result.setResult(null);
      }
 else {
        result.setError(exception);
      }
    }
  }
;
  registerWorkerTask(bgBuildAction);
  final Runnable pooledThreadWithProgressRunnable=new TreeRunnable("AbstractTreeUi.queueToBackground: progress"){
    @Override public void perform(){
      try {
        final AbstractTreeBuilder builder=getBuilder();
        if (!canInitiateNewActivity()) {
          throw new ProcessCanceledException();
        }
        builder.runBackgroundLoading(new TreeRunnable("AbstractTreeUi.queueToBackground: background"){
          @Override public void perform(){
            assertNotDispatchThread();
            try {
              if (!canInitiateNewActivity()) {
                throw new ProcessCanceledException();
              }
              execute(bgBuildAction);
              if (edtPostRunnable != null) {
                builder.updateAfterLoadedInBackground(new TreeRunnable("AbstractTreeUi.queueToBackground: update after"){
                  @Override public void perform(){
                    try {
                      assertIsDispatchThread();
                      if (!canInitiateNewActivity()) {
                        throw new ProcessCanceledException();
                      }
                      execute(edtPostRunnable);
                    }
 catch (                    ProcessCanceledException e) {
                      fail.set(e);
                      cancelUpdate();
                    }
 finally {
                      unregisterWorkerTask(bgBuildAction,finalizer);
                    }
                  }
                }
);
              }
 else {
                unregisterWorkerTask(bgBuildAction,finalizer);
              }
            }
 catch (            ProcessCanceledException e) {
              fail.set(e);
              unregisterWorkerTask(bgBuildAction,finalizer);
              cancelUpdate();
            }
catch (            Throwable t) {
              unregisterWorkerTask(bgBuildAction,finalizer);
              throw new RuntimeException(t);
            }
          }
        }
);
      }
 catch (      ProcessCanceledException e) {
        unregisterWorkerTask(bgBuildAction,finalizer);
        cancelUpdate();
      }
    }
  }
;
  Runnable pooledThreadRunnable=new TreeRunnable("AbstractTreeUi.queueToBackground"){
    @Override public void perform(){
      try {
        if (myProgress != null) {
          ProgressManager.getInstance().runProcess(pooledThreadWithProgressRunnable,myProgress);
        }
 else {
          execute(pooledThreadWithProgressRunnable);
        }
      }
 catch (      ProcessCanceledException e) {
        fail.set(e);
        unregisterWorkerTask(bgBuildAction,finalizer);
        cancelUpdate();
      }
    }
  }
;
  if (isPassthroughMode()) {
    execute(pooledThreadRunnable);
  }
 else {
    myWorker.addFirst(pooledThreadRunnable);
  }
  return result;
}
