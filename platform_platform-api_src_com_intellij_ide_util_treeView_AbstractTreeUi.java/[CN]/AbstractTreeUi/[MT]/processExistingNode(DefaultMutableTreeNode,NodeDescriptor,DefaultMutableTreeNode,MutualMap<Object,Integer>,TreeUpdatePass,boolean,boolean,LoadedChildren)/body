{
  if (pass.isExpired()) {
    return ActionCallback.REJECTED;
  }
  if (childDescriptor == null) {
    pass.expire();
    return ActionCallback.REJECTED;
  }
  final Object oldElement=getElementFromDescriptor(childDescriptor);
  if (oldElement == null) {
    pass.expire();
    return ActionCallback.REJECTED;
  }
  Promise<Boolean> update;
  if (parentPreloadedChildren != null && parentPreloadedChildren.getDescriptor(oldElement) != null) {
    update=Promise.resolve(parentPreloadedChildren.isUpdated(oldElement));
  }
 else {
    update=update(childDescriptor,false);
  }
  final ActionCallback result=new ActionCallback();
  final Ref<NodeDescriptor> childDesc=new Ref<NodeDescriptor>(childDescriptor);
  update.done(new Consumer<Boolean>(){
    @Override public void consume(    Boolean isChanged){
      final AtomicBoolean changes=new AtomicBoolean(isChanged);
      final AtomicBoolean forceRemapping=new AtomicBoolean();
      final Ref<Object> newElement=new Ref<Object>(getElementFromDescriptor(childDesc.get()));
      final Integer index=newElement.get() == null ? null : elementToIndexMap.getValue(getBuilder().getTreeStructureElement(childDesc.get()));
      Promise<Boolean> promise;
      if (index == null) {
        promise=Promise.resolve(false);
      }
 else {
        final Object elementFromMap=elementToIndexMap.getKey(index);
        if (elementFromMap != newElement.get() && elementFromMap.equals(newElement.get())) {
          if (isInStructure(elementFromMap) && isInStructure(newElement.get())) {
            final AsyncPromise<Boolean> updateIndexDone=new AsyncPromise<Boolean>();
            promise=updateIndexDone;
            if (parentNode.getUserObject() instanceof NodeDescriptor) {
              final NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
              childDesc.set(getTreeStructure().createDescriptor(elementFromMap,parentDescriptor));
              NodeDescriptor oldDesc=getDescriptorFrom(childNode);
              if (oldDesc != null) {
                childDesc.get().applyFrom(oldDesc);
              }
              childNode.setUserObject(childDesc.get());
              newElement.set(elementFromMap);
              forceRemapping.set(true);
              update(childDesc.get(),false).done(new Consumer<Boolean>(){
                @Override public void consume(                Boolean isChanged){
                  changes.set(isChanged);
                  updateIndexDone.setResult(isChanged);
                }
              }
);
            }
          }
 else {
            promise=Promise.resolve(changes.get());
          }
        }
 else {
          promise=Promise.resolve(changes.get());
        }
        promise.done(new TreeConsumer<Boolean>("AbstractTreeUi.processExistingNode: on done index updating after update"){
          @Override public void perform(){
            if (childDesc.get().getIndex() != index.intValue()) {
              changes.set(true);
            }
            childDesc.get().setIndex(index.intValue());
          }
        }
);
      }
      promise.done(new TreeConsumer<Boolean>("AbstractTreeUi.processExistingNode: on done index updating"){
        @Override public void perform(){
          if (!oldElement.equals(newElement.get()) || forceRemapping.get()) {
            removeMapping(oldElement,childNode,newElement.get());
            Object newE=newElement.get();
            if (newE != null) {
              createMapping(newE,childNode);
            }
            NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
            if (parentDescriptor != null) {
              parentDescriptor.setChildrenSortingStamp(-1);
            }
          }
          if (index == null) {
            int selectedIndex=-1;
            if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
              selectedIndex=parentNode.getIndex(childNode);
            }
            if (childNode.getParent() instanceof DefaultMutableTreeNode) {
              final DefaultMutableTreeNode parent=(DefaultMutableTreeNode)childNode.getParent();
              if (myTree.isExpanded(new TreePath(parent.getPath()))) {
                if (parent.getChildCount() == 1 && parent.getChildAt(0) == childNode) {
                  insertLoadingNode(parent,false);
                }
              }
            }
            Object disposedElement=getElementFor(childNode);
            removeNodeFromParent(childNode,selectedIndex >= 0);
            disposeNode(childNode);
            adjustSelectionOnChildRemove(parentNode,selectedIndex,disposedElement);
            result.setDone();
          }
 else {
            elementToIndexMap.remove(getBuilder().getTreeStructureElement(childDesc.get()));
            ActionCallback callback=updateNodeChildren(childNode,pass,null,false,canSmartExpand,forceUpdate,true,true);
            callback.doWhenDone(result.createSetDoneRunnable());
          }
        }
      }
);
    }
  }
);
  return result;
}
