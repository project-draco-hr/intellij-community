{
  final Ref<Pair<Boolean,LoadedChildren>> result=new Ref<Pair<Boolean,LoadedChildren>>();
  execute(new TreeRunnable("AbstractTreeUi.processUnbuilt"){
    @Override public void perform(){
      if (!isExpanded && getBuilder().isAlwaysShowPlus(descriptor)) {
        result.set(new Pair<Boolean,LoadedChildren>(true,null));
        return;
      }
      final Object element=getElementFor(node);
      if (element == null) {
        debug("null element for node " + node);
        result.set(new Pair<Boolean,LoadedChildren>(true,null));
        return;
      }
      addToUpdatingChildren(node);
      try {
        final LoadedChildren children=loadedChildren != null ? loadedChildren : new LoadedChildren(getChildrenFor(element));
        boolean processed;
        if (children.getElements().isEmpty()) {
          removeFromUnbuilt(node);
          removeLoading(node,true);
          processed=true;
        }
 else {
          if (isAutoExpand(node)) {
            addNodeAction(getElementFor(node),new NodeAction(){
              @Override public void onReady(              @NotNull final DefaultMutableTreeNode node){
                final TreePath path=new TreePath(node.getPath());
                if (getTree().isExpanded(path) || children.getElements().isEmpty()) {
                  removeLoading(node,false);
                }
 else {
                  maybeYeild(new AsyncRunnable(){
                    @NotNull @Override public Promise<?> run(){
                      expand(element,null);
                      return Promise.DONE;
                    }
                  }
,pass,node);
                }
              }
            }
,false);
          }
          processed=false;
        }
        removeFromUpdatingChildren(node);
        processNodeActionsIfReady(node);
        result.set(new Pair<Boolean,LoadedChildren>(processed,children));
      }
  finally {
        removeFromUpdatingChildren(node);
      }
    }
  }
);
  return result.get();
}
