{
  try {
    if (!checkDeferred(deferred,onDone))     return;
    final Set<Object> currentElements=getSelectedElements();
    if (checkCurrentSelection && !currentElements.isEmpty() && elements.length == currentElements.size()) {
      boolean runSelection=false;
      for (      Object eachToSelect : elements) {
        if (!currentElements.contains(eachToSelect)) {
          runSelection=true;
          break;
        }
      }
      if (!runSelection) {
        if (elements.length > 0) {
          selectVisible(elements[0],onDone,true,true,scrollToVisible);
        }
        return;
      }
    }
    clearSelection();
    Set<Object> toSelect=new THashSet<Object>();
    ContainerUtil.addAllNotNull(toSelect,elements);
    if (addToSelection) {
      ContainerUtil.addAllNotNull(toSelect,currentElements);
    }
    if (checkIfInStructure) {
      final Iterator<Object> allToSelect=toSelect.iterator();
      while (allToSelect.hasNext()) {
        Object each=allToSelect.next();
        if (!isInStructure(each)) {
          allToSelect.remove();
        }
      }
    }
    final Object[] elementsToSelect=ArrayUtil.toObjectArray(toSelect);
    if (wasRootNodeInitialized()) {
      final int[] originalRows=myTree.getSelectionRows();
      if (!addToSelection) {
        clearSelection();
      }
      addNext(elementsToSelect,0,new TreeRunnable("AbstractTreeUi._select: addNext"){
        @Override public void perform(){
          if (getTree().isSelectionEmpty()) {
            processInnerChange(new TreeRunnable("AbstractTreeUi._select: addNext: processInnerChange"){
              @Override public void perform(){
                restoreSelection(currentElements);
              }
            }
);
          }
          runDone(onDone);
        }
      }
,originalRows,deferred,scrollToVisible,canSmartExpand);
    }
 else {
      addToDeferred(elementsToSelect,onDone,addToSelection);
    }
  }
  finally {
    maybeReady();
  }
}
