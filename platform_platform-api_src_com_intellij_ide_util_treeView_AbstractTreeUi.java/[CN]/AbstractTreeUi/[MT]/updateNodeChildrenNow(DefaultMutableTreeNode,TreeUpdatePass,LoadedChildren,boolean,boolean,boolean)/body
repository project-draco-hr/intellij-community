{
  if (isUpdatingChildrenNow(node))   return;
  if (!canInitiateNewActivity()) {
    throw new ProcessCanceledException();
  }
  final NodeDescriptor descriptor=getDescriptorFrom(node);
  final MutualMap<Object,Integer> elementToIndexMap=loadElementsFromStructure(descriptor,preloadedChildren);
  final LoadedChildren loadedChildren=preloadedChildren != null ? preloadedChildren : new LoadedChildren(elementToIndexMap.getKeys().toArray());
  addToUpdatingChildren(node);
  pass.setCurrentNode(node);
  final boolean canSmartExpand=canSmartExpand(node,toSmartExpand);
  removeFromUnbuilt(node);
  processExistingNodes(node,elementToIndexMap,pass,canSmartExpand(node,toSmartExpand),forceUpdate,wasExpanded,preloadedChildren).doWhenDone(new TreeRunnable("AbstractTreeUi.updateNodeChildrenNow: on done processExistingNodes"){
    @Override public void perform(){
      if (isDisposed(node)) {
        removeFromUpdatingChildren(node);
        return;
      }
      removeLoading(node,false);
      final boolean expanded=isExpanded(node,wasExpanded);
      if (expanded) {
        myWillBeExpanded.add(node);
      }
 else {
        myWillBeExpanded.remove(node);
      }
      collectNodesToInsert(descriptor,elementToIndexMap,node,expanded,loadedChildren).doWhenDone(new Consumer<List<TreeNode>>(){
        @Override public void consume(        @NotNull final List<TreeNode> nodesToInsert){
          insertNodesInto(nodesToInsert,node);
          ActionCallback callback=updateNodesToInsert(nodesToInsert,pass,canSmartExpand,isChildNodeForceUpdate(node,forceUpdate,expanded));
          callback.doWhenDone(new TreeRunnable("AbstractTreeUi.updateNodeChildrenNow: on done updateNodesToInsert"){
            @Override public void perform(){
              removeLoading(node,false);
              removeFromUpdatingChildren(node);
              if (node.getChildCount() > 0) {
                if (expanded) {
                  expand(node,canSmartExpand);
                }
              }
              if (!canInitiateNewActivity()) {
                throw new ProcessCanceledException();
              }
              final Object element=getElementFor(node);
              addNodeAction(element,new NodeAction(){
                @Override public void onReady(                @NotNull final DefaultMutableTreeNode node){
                  removeLoading(node,false);
                }
              }
,false);
              processNodeActionsIfReady(node);
            }
          }
);
        }
      }
).doWhenProcessed(new TreeRunnable("AbstractTreeUi.updateNodeChildrenNow: on processed collectNodesToInsert"){
        @Override public void perform(){
          myWillBeExpanded.remove(node);
          removeFromUpdatingChildren(node);
          processNodeActionsIfReady(node);
        }
      }
);
    }
  }
).doWhenRejected(new TreeRunnable("AbstractTreeUi.updateNodeChildrenNow: on reject processExistingNodes"){
    @Override public void perform(){
      removeFromUpdatingChildren(node);
      processNodeActionsIfReady(node);
    }
  }
);
}
