{
  final AsyncResult<Boolean> result=new AsyncResult<Boolean>();
  if (now || isPassthroughMode()) {
    result.setDone(update(nodeDescriptor));
  }
 else {
    Object element=getElementFromDescriptor(nodeDescriptor);
    boolean bgLoading=getTreeStructure().isToBuildChildrenInBackground(element);
    boolean edt=isEdt();
    if (bgLoading) {
      if (edt) {
        final AtomicBoolean changes=new AtomicBoolean();
        queueToBackground(new TreeRunnable("AbstractTreeUi.update: build"){
          @Override public void perform(){
            changes.set(update(nodeDescriptor));
          }
        }
,new TreeRunnable("AbstractTreeUi.update: post"){
          @Override public void perform(){
            result.setDone(changes.get());
          }
        }
);
      }
 else {
        result.setDone(update(nodeDescriptor));
      }
    }
 else {
      if (edt || !myWasEverShown) {
        result.setDone(update(nodeDescriptor));
      }
 else {
        invokeLaterIfNeeded(false,new TreeRunnable("AbstractTreeUi.update: later"){
          @Override public void perform(){
            execute(new TreeRunnable("AbstractTreeUi.update: later execute"){
              @Override public void perform(){
                result.setDone(update(nodeDescriptor));
              }
            }
);
          }
        }
);
      }
    }
  }
  result.doWhenDone(new Consumer<Boolean>(){
    @Override public void consume(    final Boolean changes){
      if (changes) {
        invokeLaterIfNeeded(false,new TreeRunnable("AbstractTreeUi.update: on done result"){
          @Override public void perform(){
            Object element=nodeDescriptor.getElement();
            DefaultMutableTreeNode node=getNodeForElement(element,false);
            if (node != null) {
              TreePath path=getPathFor(node);
              if (myTree.isVisible(path)) {
                updateNodeImageAndPosition(node,false,changes);
              }
            }
          }
        }
);
      }
    }
  }
);
  return result;
}
