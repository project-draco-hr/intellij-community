{
  if (!cls.isNewStyleClass())   return;
  PyFunction init_or_new=cls.findInitOrNew(false);
  final PyBuiltinCache builtins=PyBuiltinCache.getInstance(cls);
  if (init_or_new == null || builtins.hasInBuiltins(init_or_new.getContainingClass()))   return;
  String the_other_name=PyNames.NEW.equals(init_or_new.getName()) ? PyNames.INIT : PyNames.NEW;
  PyFunction the_other=cls.findMethodByName(the_other_name,true);
  if (the_other == null || builtins.getClass("object") == the_other.getContainingClass())   return;
  if (!PyUtil.isSignatureCompatibleTo(the_other,init_or_new,myTypeEvalContext) && !PyUtil.isSignatureCompatibleTo(init_or_new,the_other,myTypeEvalContext) && init_or_new.getContainingFile() == cls.getContainingFile()) {
    registerProblem(init_or_new.getParameterList(),PyNames.NEW.equals(init_or_new.getName()) ? PyBundle.message("INSP.new.incompatible.to.init") : PyBundle.message("INSP.init.incompatible.to.new"));
  }
}
