{
  if (!cls.isNewStyleClass())   return;
  PyFunction init_or_new=cls.findInitOrNew(true);
  final PyBuiltinCache builtins=PyBuiltinCache.getInstance(cls);
  if (init_or_new == null || builtins.hasInBuiltins(init_or_new.getContainingClass()))   return;
  String the_other_name=PyNames.NEW.equals(init_or_new.getName()) ? PyNames.INIT : PyNames.NEW;
  PyFunction the_other=cls.findMethodByName(the_other_name,true);
  if (the_other == null || builtins.getClass("object") == the_other.getContainingClass())   return;
  final PyParameterList closer_list=init_or_new.getParameterList();
  final PyParameterList farther_list=the_other.getParameterList();
  if (!farther_list.isCompatibleTo(closer_list) && !closer_list.isCompatibleTo(farther_list) && closer_list.getContainingFile() == cls.getContainingFile()) {
    registerProblem(closer_list,PyNames.NEW.equals(init_or_new.getName()) ? PyBundle.message("INSP.new.incompatible.to.init") : PyBundle.message("INSP.init.incompatible.to.new"));
  }
}
