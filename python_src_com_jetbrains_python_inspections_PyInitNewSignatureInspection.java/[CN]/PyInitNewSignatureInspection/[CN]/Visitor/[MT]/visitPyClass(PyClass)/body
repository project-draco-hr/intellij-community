{
  if (!cls.isNewStyleClass())   return;
  PyFunction initOrNew=cls.findInitOrNew(false);
  final PyBuiltinCache builtins=PyBuiltinCache.getInstance(cls);
  if (initOrNew == null || builtins.isBuiltin(initOrNew.getContainingClass()))   return;
  String the_other_name=PyNames.NEW.equals(initOrNew.getName()) ? PyNames.INIT : PyNames.NEW;
  PyFunction the_other=cls.findMethodByName(the_other_name,true);
  if (the_other == null || builtins.getClass("object") == the_other.getContainingClass())   return;
  if (!PyUtil.isSignatureCompatibleTo(the_other,initOrNew,myTypeEvalContext) && !PyUtil.isSignatureCompatibleTo(initOrNew,the_other,myTypeEvalContext) && initOrNew.getContainingFile() == cls.getContainingFile()) {
    registerProblem(initOrNew.getParameterList(),PyNames.NEW.equals(initOrNew.getName()) ? PyBundle.message("INSP.new.incompatible.to.init") : PyBundle.message("INSP.init.incompatible.to.new"));
  }
}
