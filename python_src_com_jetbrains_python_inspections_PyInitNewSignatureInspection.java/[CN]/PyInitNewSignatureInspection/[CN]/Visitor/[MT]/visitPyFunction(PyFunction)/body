{
  final String functionName=node.getName();
  if (!PyNames.NEW.equals(functionName) && !PyNames.INIT.equals(functionName))   return;
  final PyClass cls=node.getContainingClass();
  if (cls == null)   return;
  if (!cls.isNewStyleClass())   return;
  final PyBuiltinCache builtins=PyBuiltinCache.getInstance(cls);
  final String complementaryName=PyNames.NEW.equals(functionName) ? PyNames.INIT : PyNames.NEW;
  final PyFunction complementaryMethod=cls.findMethodByName(complementaryName,true);
  if (complementaryMethod == null || builtins.getClass("object") == complementaryMethod.getContainingClass())   return;
  if (!PyUtil.isSignatureCompatibleTo(complementaryMethod,node,myTypeEvalContext) && !PyUtil.isSignatureCompatibleTo(node,complementaryMethod,myTypeEvalContext) && node.getContainingFile() == cls.getContainingFile()) {
    registerProblem(node.getParameterList(),PyNames.NEW.equals(node.getName()) ? PyBundle.message("INSP.new.incompatible.to.init") : PyBundle.message("INSP.init.incompatible.to.new"),new PyChangeSignatureQuickFix(false));
  }
}
