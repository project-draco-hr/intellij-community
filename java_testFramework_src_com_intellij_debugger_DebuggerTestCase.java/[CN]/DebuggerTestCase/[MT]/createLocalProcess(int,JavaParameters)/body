{
  createBreakpoints(javaParameters.getMainClass());
  final DebuggerSession[] debuggerSession=new DebuggerSession[]{null};
  DebuggerSettings.getInstance().DEBUGGER_TRANSPORT=transport;
  GenericDebuggerRunnerSettings debuggerRunnerSettings=new GenericDebuggerRunnerSettings();
  debuggerRunnerSettings.LOCAL=true;
  debuggerRunnerSettings.DEBUG_PORT="3456";
  final JavaCommandLineState javaCommandLineState=new JavaCommandLineState(new ExecutionEnvironment(new MockConfiguration(),myProject,debuggerRunnerSettings)){
    @Override protected JavaParameters createJavaParameters(){
      return javaParameters;
    }
    @Override protected GeneralCommandLine createCommandLine() throws ExecutionException {
      return CommandLineBuilder.createFromJavaParameters(getJavaParameters());
    }
  }
;
  final RemoteConnection debugParameters=DebuggerManagerImpl.createDebugParameters(javaCommandLineState.getJavaParameters(),debuggerRunnerSettings,true);
  UIUtil.invokeAndWaitIfNeeded(new Runnable(){
    @Override public void run(){
      try {
        debuggerSession[0]=attachVirtualMachine(javaCommandLineState,debugParameters,false);
      }
 catch (      ExecutionException e) {
        fail(e.getMessage());
      }
    }
  }
);
  final ExecutionResult executionResult=debuggerSession[0].getProcess().getExecutionResult();
  debuggerSession[0].getProcess().addProcessListener(new ProcessAdapter(){
    @Override public void onTextAvailable(    ProcessEvent event,    Key outputType){
      print(event.getText(),outputType);
    }
  }
);
  DebugProcessImpl process=(DebugProcessImpl)DebuggerManagerEx.getInstanceEx(myProject).getDebugProcess(executionResult.getProcessHandler());
  assertNotNull(process);
  return debuggerSession[0];
}
