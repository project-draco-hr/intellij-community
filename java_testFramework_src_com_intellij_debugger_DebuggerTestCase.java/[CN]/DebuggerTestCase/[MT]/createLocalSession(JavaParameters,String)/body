{
  createBreakpoints(javaParameters.getMainClass());
  DebuggerSettings.getInstance().DEBUGGER_TRANSPORT=DebuggerSettings.SOCKET_TRANSPORT;
  GenericDebuggerRunnerSettings debuggerRunnerSettings=new GenericDebuggerRunnerSettings();
  debuggerRunnerSettings.LOCAL=true;
  final RemoteConnection debugParameters=DebuggerManagerImpl.createDebugParameters(javaParameters,debuggerRunnerSettings,false);
  ExecutionEnvironment environment=new ExecutionEnvironment(new MockConfiguration(),DefaultDebugExecutor.getDebugExecutorInstance(),myProject,debuggerRunnerSettings);
  final JavaCommandLineState javaCommandLineState=new JavaCommandLineState(environment){
    @Override protected JavaParameters createJavaParameters(){
      return javaParameters;
    }
    @Override protected GeneralCommandLine createCommandLine() throws ExecutionException {
      return CommandLineBuilder.createFromJavaParameters(getJavaParameters());
    }
  }
;
  final GenericDebuggerRunner runner=new GenericDebuggerRunner();
  ApplicationManager.getApplication().invokeAndWait(new Runnable(){
    @Override public void run(){
      try {
        myDebuggerSession=DebuggerManagerEx.getInstanceEx(myProject).attachVirtualMachine(DefaultDebugExecutor.getDebugExecutorInstance(),runner,new MockConfiguration(),javaCommandLineState,debugParameters,false);
      }
 catch (      ExecutionException e) {
        LOG.error(e);
      }
    }
  }
,ModalityState.defaultModalityState());
  myDebugProcess=myDebuggerSession.getProcess();
  myDebugProcess.addProcessListener(new ProcessAdapter(){
    @Override public void onTextAvailable(    ProcessEvent event,    Key outputType){
      print(event.getText(),outputType);
    }
  }
);
  assertNotNull(myDebuggerSession);
  assertNotNull(myDebugProcess);
  return myDebuggerSession;
}
