{
  ChangeBrowserSettings settings=new ChangeBrowserSettings();
  settings.CHANGE_AFTER=Long.toString(revision);
  settings.USE_CHANGE_AFTER_FILTER=true;
  final LinkedList<Pair<SvnChangeList,LogHierarchyNode>> result=ContainerUtil.newLinkedList();
  final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
  try {
    ((SvnCommittedChangesProvider)myMergeContext.getVcs().getCommittedChangesProvider()).getCommittedChangesWithMergedRevisons(settings,new SvnRepositoryLocation(myMergeContext.getSourceUrl()),0,new PairConsumer<SvnChangeList,LogHierarchyNode>(){
      public void consume(      @NotNull SvnChangeList changeList,      LogHierarchyNode tree){
        indicator.checkCanceled();
        if (revision < changeList.getNumber()) {
          result.add(Pair.create(changeList,tree));
        }
      }
    }
);
  }
 catch (  VcsException e) {
    finishWithError(context,"Checking revisions for merge fault",Collections.singletonList(e));
  }
  return result;
}
