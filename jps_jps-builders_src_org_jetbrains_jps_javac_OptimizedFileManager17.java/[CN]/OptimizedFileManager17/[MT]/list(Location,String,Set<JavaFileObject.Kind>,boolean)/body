{
  Iterable<? extends File> locationRoots=getLocation(location);
  if (locationRoots == null) {
    return List.nil();
  }
  RelativePath.RelativeDirectory subdirectory=new RelativePath.RelativeDirectory(packageName.replace('.','/'));
  ListBuffer<JavaFileObject> results=new ListBuffer<JavaFileObject>();
  final Set<File> outputRoots;
  if (location.isOutputLocation() || location != StandardLocation.CLASS_PATH) {
    outputRoots=Collections.emptySet();
  }
 else {
    final Iterable<? extends File> outputs=getLocation(StandardLocation.CLASS_OUTPUT);
    if (outputs == null) {
      outputRoots=Collections.emptySet();
    }
 else {
      outputRoots=new HashSet<File>(1,0.98f);
      for (      File file : outputs) {
        outputRoots.add(file);
      }
    }
  }
  for (  File root : locationRoots) {
    Archive archive=myArchives.get(root);
    final boolean isFile;
    if (archive != null) {
      isFile=true;
    }
 else {
      isFile=isFile(root);
    }
    if (isFile) {
      try {
        if (archive == null) {
          archive=openArchive(root);
        }
        listArchive(archive,subdirectory,kinds,recurse,results);
      }
 catch (      IOException ex) {
        log.error("error.reading.file",root,getMessage(ex));
      }
    }
 else {
      final File dir=subdirectory.getFile(root);
      final boolean canUseCache=!location.isOutputLocation() && !outputRoots.contains(root);
      if (recurse) {
        listDirectoryRecursively(dir,kinds,results,true,canUseCache);
      }
 else {
        listDirectory(dir,kinds,results,canUseCache);
      }
    }
  }
  return results.toList();
}
