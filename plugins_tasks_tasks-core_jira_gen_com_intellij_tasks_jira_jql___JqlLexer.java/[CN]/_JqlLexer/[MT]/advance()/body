{
  int zzInput;
  int zzAction;
  int zzCurrentPosL;
  int zzMarkedPosL;
  int zzEndReadL=zzEndRead;
  CharSequence zzBufferL=zzBuffer;
  int[] zzTransL=ZZ_TRANS;
  int[] zzRowMapL=ZZ_ROWMAP;
  int[] zzAttrL=ZZ_ATTRIBUTE;
  while (true) {
    zzMarkedPosL=zzMarkedPos;
    zzAction=-1;
    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;
    zzState=ZZ_LEXSTATE[zzLexicalState];
    int zzAttributes=zzAttrL[zzState];
    if ((zzAttributes & 1) == 1) {
      zzAction=zzState;
    }
    zzForAction: {
      while (true) {
        if (zzCurrentPosL < zzEndReadL) {
          zzInput=Character.codePointAt(zzBufferL,zzCurrentPosL);
          zzCurrentPosL+=Character.charCount(zzInput);
        }
 else         if (zzAtEOF) {
          zzInput=YYEOF;
          break zzForAction;
        }
 else {
          zzCurrentPos=zzCurrentPosL;
          zzMarkedPos=zzMarkedPosL;
          boolean eof=zzRefill();
          zzCurrentPosL=zzCurrentPos;
          zzMarkedPosL=zzMarkedPos;
          zzBufferL=zzBuffer;
          zzEndReadL=zzEndRead;
          if (eof) {
            zzInput=YYEOF;
            break zzForAction;
          }
 else {
            zzInput=Character.codePointAt(zzBufferL,zzCurrentPosL);
            zzCurrentPosL+=Character.charCount(zzInput);
          }
        }
        int zzNext=zzTransL[zzRowMapL[zzState] + ZZ_CMAP(zzInput)];
        if (zzNext == -1)         break zzForAction;
        zzState=zzNext;
        zzAttributes=zzAttrL[zzState];
        if ((zzAttributes & 1) == 1) {
          zzAction=zzState;
          zzMarkedPosL=zzCurrentPosL;
          if ((zzAttributes & 8) == 8)           break zzForAction;
        }
      }
    }
    zzMarkedPos=zzMarkedPosL;
    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
      zzAtEOF=true;
      return null;
    }
 else {
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
case 1:
{
          return JqlTokenTypes.STRING_LITERAL;
        }
case 41:
      break;
case 2:
{
      return JqlTokenTypes.WHITE_SPACE;
    }
case 42:
  break;
case 3:
{
  return JqlTokenTypes.NUMBER_LITERAL;
}
case 43:
break;
case 4:
{
return JqlTokenTypes.BAD_CHARACTER;
}
case 44:
break;
case 5:
{
return JqlTokenTypes.EQ;
}
case 45:
break;
case 6:
{
return JqlTokenTypes.BANG;
}
case 46:
break;
case 7:
{
return JqlTokenTypes.LT;
}
case 47:
break;
case 8:
{
return JqlTokenTypes.GT;
}
case 48:
break;
case 9:
{
return JqlTokenTypes.CONTAINS;
}
case 49:
break;
case 10:
{
return JqlTokenTypes.LPAR;
}
case 50:
break;
case 11:
{
return JqlTokenTypes.RPAR;
}
case 51:
break;
case 12:
{
return JqlTokenTypes.AMP;
}
case 52:
break;
case 13:
{
return JqlTokenTypes.PIPE;
}
case 53:
break;
case 14:
{
return JqlTokenTypes.COMMA;
}
case 54:
break;
case 15:
{
return JqlTokenTypes.BY_KEYWORD;
}
case 55:
break;
case 16:
{
return JqlTokenTypes.TO_KEYWORD;
}
case 56:
break;
case 17:
{
return JqlTokenTypes.ON_KEYWORD;
}
case 57:
break;
case 18:
{
return JqlTokenTypes.OR_KEYWORD;
}
case 58:
break;
case 19:
{
return JqlTokenTypes.IN_KEYWORD;
}
case 59:
break;
case 20:
{
return JqlTokenTypes.IS_KEYWORD;
}
case 60:
break;
case 21:
{
return JqlTokenTypes.NE;
}
case 61:
break;
case 22:
{
return JqlTokenTypes.NOT_CONTAINS;
}
case 62:
break;
case 23:
{
return JqlTokenTypes.LE;
}
case 63:
break;
case 24:
{
return JqlTokenTypes.GE;
}
case 64:
break;
case 25:
{
return JqlTokenTypes.AMP_AMP;
}
case 65:
break;
case 26:
{
return JqlTokenTypes.PIPE_PIPE;
}
case 66:
break;
case 27:
{
return JqlTokenTypes.AND_KEYWORD;
}
case 67:
break;
case 28:
{
return JqlTokenTypes.ASC_KEYWORD;
}
case 68:
break;
case 29:
{
return JqlTokenTypes.NOT_KEYWORD;
}
case 69:
break;
case 30:
{
return JqlTokenTypes.WAS_KEYWORD;
}
case 70:
break;
case 31:
{
return JqlTokenTypes.FROM_KEYWORD;
}
case 71:
break;
case 32:
{
return JqlTokenTypes.NULL_KEYWORD;
}
case 72:
break;
case 33:
{
return JqlTokenTypes.DESC_KEYWORD;
}
case 73:
break;
case 34:
{
return JqlTokenTypes.CUSTOM_FIELD;
}
case 74:
break;
case 35:
{
return JqlTokenTypes.AFTER_KEYWORD;
}
case 75:
break;
case 36:
{
return JqlTokenTypes.ORDER_KEYWORD;
}
case 76:
break;
case 37:
{
return JqlTokenTypes.EMPTY_KEYWORD;
}
case 77:
break;
case 38:
{
return JqlTokenTypes.BEFORE_KEYWORD;
}
case 78:
break;
case 39:
{
return JqlTokenTypes.DURING_KEYWORD;
}
case 79:
break;
case 40:
{
return JqlTokenTypes.CHANGED_KEYWORD;
}
case 80:
break;
default :
zzScanError(ZZ_NO_MATCH);
}
}
}
}
