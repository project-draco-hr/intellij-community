{
  ProgressManager.checkCanceled();
  Map<MethodSignature,HierarchicalMethodSignature> result=new LinkedHashMap<MethodSignature,HierarchicalMethodSignature>(new EqualityPolicy<MethodSignature>(){
    @Override public int getHashCode(    MethodSignature object){
      return object.hashCode();
    }
    @Override public boolean isEqual(    MethodSignature o1,    MethodSignature o2){
      if (o1.equals(o2)) {
        final PsiMethod method1=((MethodSignatureBackedByPsiMethod)o1).getMethod();
        final PsiType returnType1=method1.getReturnType();
        final PsiMethod method2=((MethodSignatureBackedByPsiMethod)o2).getMethod();
        final PsiType returnType2=method2.getReturnType();
        if (method1.hasModifierProperty(PsiModifier.STATIC) || method2.hasModifierProperty(PsiModifier.STATIC)) {
          return true;
        }
        if (MethodSignatureUtil.isReturnTypeSubstitutable(o1,o2,returnType1,returnType2)) {
          return true;
        }
        final PsiClass containingClass1=method1.getContainingClass();
        final PsiClass containingClass2=method2.getContainingClass();
        if (containingClass1 != null && containingClass2 != null) {
          return containingClass1.isAnnotationType() || containingClass2.isAnnotationType();
        }
      }
      return false;
    }
  }
);
  final Map<MethodSignature,List<PsiMethod>> sameParameterErasureMethods=new THashMap<MethodSignature,List<PsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  Map<MethodSignature,HierarchicalMethodSignatureImpl> map=new THashMap<MethodSignature,HierarchicalMethodSignatureImpl>(new TObjectHashingStrategy<MethodSignature>(){
    @Override public int computeHashCode(    MethodSignature signature){
      return MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.computeHashCode(signature);
    }
    @Override public boolean equals(    MethodSignature o1,    MethodSignature o2){
      if (!MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.equals(o1,o2))       return false;
      List<PsiMethod> list=sameParameterErasureMethods.get(o1);
      boolean toCheckReturnType=list != null && list.size() > 1;
      if (!toCheckReturnType)       return true;
      PsiType returnType1=((MethodSignatureBackedByPsiMethod)o1).getMethod().getReturnType();
      PsiType returnType2=((MethodSignatureBackedByPsiMethod)o2).getMethod().getReturnType();
      if (returnType1 == null && returnType2 == null)       return true;
      if (returnType1 == null || returnType2 == null)       return false;
      PsiType erasure1=TypeConversionUtil.erasure(o1.getSubstitutor().substitute(returnType1));
      PsiType erasure2=TypeConversionUtil.erasure(o2.getSubstitutor().substitute(returnType2));
      return erasure1.equals(erasure2);
    }
  }
);
  PsiMethod[] methods=aClass.getMethods();
  if ((nameHint == null || "values".equals(nameHint)) && aClass instanceof PsiClassImpl) {
    final PsiMethod valuesMethod=((PsiClassImpl)aClass).getValuesMethod();
    if (valuesMethod != null) {
      methods=ArrayUtil.append(methods,valuesMethod);
    }
  }
  for (  PsiMethod method : methods) {
    if (!method.isValid()) {
      throw new PsiInvalidElementAccessException(method,"class.valid=" + aClass.isValid() + "; name="+ method.getName());
    }
    if (nameHint != null && !nameHint.equals(method.getName()))     continue;
    if (!includePrivates && method.hasModifierProperty(PsiModifier.PRIVATE))     continue;
    final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,PsiSubstitutor.EMPTY,isInRawContext);
    HierarchicalMethodSignatureImpl newH=new HierarchicalMethodSignatureImpl(MethodSignatureBackedByPsiMethod.create(method,substitutor,isInRawContext));
    List<PsiMethod> list=sameParameterErasureMethods.get(signature);
    if (list == null) {
      list=new SmartList<PsiMethod>();
      sameParameterErasureMethods.put(signature,list);
    }
    list.add(method);
    LOG.assertTrue(newH.getMethod().isValid());
    result.put(signature,newH);
    map.put(signature,newH);
  }
  final List<PsiClassType.ClassResolveResult> superTypes=PsiClassImplUtil.getScopeCorrectedSuperTypes(aClass,resolveScope);
  for (  PsiClassType.ClassResolveResult superTypeResolveResult : superTypes) {
    PsiClass superClass=superTypeResolveResult.getElement();
    if (superClass == null)     continue;
    if (!visited.add(superClass))     continue;
    final PsiSubstitutor superSubstitutor=superTypeResolveResult.getSubstitutor();
    PsiSubstitutor finalSubstitutor=obtainFinalSubstitutor(superClass,superSubstitutor,substitutor,isInRawContext);
    final boolean isInRawContextSuper=(isInRawContext || PsiUtil.isRawSubstitutor(superClass,superSubstitutor)) && superClass.getTypeParameters().length != 0;
    Map<MethodSignature,HierarchicalMethodSignature> superResult=buildMethodHierarchy(superClass,nameHint,finalSubstitutor,false,visited,isInRawContextSuper,resolveScope);
    visited.remove(superClass);
    List<Pair<MethodSignature,HierarchicalMethodSignature>> flattened=new ArrayList<Pair<MethodSignature,HierarchicalMethodSignature>>();
    for (    Map.Entry<MethodSignature,HierarchicalMethodSignature> entry : superResult.entrySet()) {
      HierarchicalMethodSignature hms=entry.getValue();
      MethodSignature signature=MethodSignatureBackedByPsiMethod.create(hms.getMethod(),hms.getSubstitutor(),hms.isRaw());
      PsiClass containingClass=hms.getMethod().getContainingClass();
      List<HierarchicalMethodSignature> supers=new ArrayList<HierarchicalMethodSignature>(hms.getSuperSignatures());
      for (      HierarchicalMethodSignature aSuper : supers) {
        PsiClass superContainingClass=aSuper.getMethod().getContainingClass();
        if (containingClass != null && superContainingClass != null && !containingClass.isInheritor(superContainingClass,true)) {
          flattened.add(Pair.create(signature,aSuper));
        }
      }
      putInMap(aClass,result,map,hms,signature);
    }
    for (    Pair<MethodSignature,HierarchicalMethodSignature> pair : flattened) {
      putInMap(aClass,result,map,pair.second,pair.first);
    }
  }
  for (  Map.Entry<MethodSignature,HierarchicalMethodSignatureImpl> entry : map.entrySet()) {
    HierarchicalMethodSignatureImpl hierarchicalMethodSignature=entry.getValue();
    MethodSignature methodSignature=entry.getKey();
    if (result.get(methodSignature) == null && PsiUtil.isAccessible(aClass.getProject(),hierarchicalMethodSignature.getMethod(),aClass,aClass)) {
      LOG.assertTrue(hierarchicalMethodSignature.getMethod().isValid());
      result.put(methodSignature,hierarchicalMethodSignature);
    }
  }
  return result;
}
