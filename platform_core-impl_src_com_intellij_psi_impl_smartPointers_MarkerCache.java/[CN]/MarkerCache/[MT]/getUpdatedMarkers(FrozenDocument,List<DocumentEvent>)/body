{
  int eventCount=events.size();
  Trinity<Integer,Map<Trinity,ManualRangeMarker>,FrozenDocument> cache=myUpdatedRanges;
  if (cache != null && cache.first.intValue() == eventCount)   return cache.second;
synchronized (this) {
    cache=myUpdatedRanges;
    if (cache != null && cache.first.intValue() == eventCount)     return cache.second;
    Map<Trinity,ManualRangeMarker> answer=ContainerUtil.newHashMap();
    if (cache != null && cache.first < eventCount) {
      answer.putAll(cache.second);
      frozen=applyEvents(cache.third,events.subList(cache.first,eventCount),answer);
    }
 else {
      for (      ManualRangeMarker marker : myMarkerSet) {
        Trinity key=keyOf(marker);
        if (key != null) {
          answer.put(key,marker);
        }
      }
      frozen=applyEvents(frozen,events,answer);
    }
    if (eventCount > 0) {
      myUpdatedRanges=Trinity.create(eventCount,answer,frozen);
    }
    return answer;
  }
}
