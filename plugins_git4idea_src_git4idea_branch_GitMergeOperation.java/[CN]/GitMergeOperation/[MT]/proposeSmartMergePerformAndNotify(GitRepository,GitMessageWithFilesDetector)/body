{
  Pair<List<GitRepository>,List<Change>> conflictingRepositoriesAndAffectedChanges=getConflictingRepositoriesAndAffectedChanges(repository,localChangesOverwrittenByMerge,myCurrentHeads.get(repository),myBranchToMerge);
  List<GitRepository> allConflictingRepositories=conflictingRepositoriesAndAffectedChanges.getFirst();
  List<Change> affectedChanges=conflictingRepositoriesAndAffectedChanges.getSecond();
  Collection<String> absolutePaths=GitUtil.toAbsolute(repository.getRoot(),localChangesOverwrittenByMerge.getRelativeFilePaths());
  int smartCheckoutDecision=myUiHandler.showSmartOperationDialog(myProject,affectedChanges,absolutePaths,"merge",null);
  if (smartCheckoutDecision == GitSmartOperationDialog.SMART_EXIT_CODE) {
    return doSmartMerge(allConflictingRepositories);
  }
 else {
    fatalLocalChangesError(myBranchToMerge);
    return false;
  }
}
