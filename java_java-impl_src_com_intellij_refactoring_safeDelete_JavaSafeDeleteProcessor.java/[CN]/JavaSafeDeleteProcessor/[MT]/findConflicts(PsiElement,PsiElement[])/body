{
  if (element instanceof PsiMethod) {
    final PsiClass containingClass=((PsiMethod)element).getContainingClass();
    if (containingClass != null && !containingClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
      final PsiMethod[] superMethods=((PsiMethod)element).findSuperMethods();
      for (      PsiMethod superMethod : superMethods) {
        if (isInside(superMethod,allElementsToDelete))         continue;
        if (superMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
          String message=RefactoringBundle.message("0.implements.1",RefactoringUIUtil.getDescription(element,true),RefactoringUIUtil.getDescription(superMethod,true));
          return Collections.singletonList(message);
        }
      }
    }
  }
 else   if (element instanceof PsiParameter) {
    final PsiElement scope=((PsiParameter)element).getDeclarationScope();
    if (scope instanceof PsiMethod) {
      final PsiMethod method=(PsiMethod)scope;
      final PsiClass containingClass=method.getContainingClass();
      if (containingClass != null) {
        final int parameterIndex=method.getParameterList().getParameterIndex((PsiParameter)element);
        final PsiMethod methodCopy=(PsiMethod)method.copy();
        methodCopy.getParameterList().getParameters()[parameterIndex].delete();
        final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
        ConflictsUtil.checkMethodConflicts(containingClass,method,methodCopy,conflicts);
        return (Collection<String>)conflicts.values();
      }
    }
  }
  return null;
}
