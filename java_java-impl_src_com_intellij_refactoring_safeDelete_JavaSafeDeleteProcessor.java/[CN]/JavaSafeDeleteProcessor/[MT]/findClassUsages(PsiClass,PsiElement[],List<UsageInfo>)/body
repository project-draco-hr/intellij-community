{
  final boolean justPrivates=containsOnlyPrivates(psiClass);
  final String qualifiedName=psiClass.getQualifiedName();
  final boolean annotationType=psiClass.isAnnotationType() && qualifiedName != null;
  ReferencesSearch.search(psiClass).forEach(new Processor<PsiReference>(){
    public boolean process(    final PsiReference reference){
      final PsiElement element=reference.getElement();
      if (!isInside(element,allElementsToDelete)) {
        PsiElement parent=element.getParent();
        if (parent instanceof PsiReferenceList) {
          final PsiElement pparent=parent.getParent();
          if (pparent instanceof PsiClass && element instanceof PsiJavaCodeReferenceElement) {
            final PsiClass inheritor=(PsiClass)pparent;
            if (justPrivates) {
              if (parent.equals(inheritor.getExtendsList()) || parent.equals(inheritor.getImplementsList())) {
                usages.add(new SafeDeleteExtendsClassUsageInfo((PsiJavaCodeReferenceElement)element,psiClass,inheritor));
                return true;
              }
            }
          }
        }
        LOG.assertTrue(element.getTextRange() != null);
        final PsiFile containingFile=psiClass.getContainingFile();
        boolean sameFileWithSingleClass=false;
        if (containingFile instanceof PsiClassOwner) {
          final PsiClass[] classes=((PsiClassOwner)containingFile).getClasses();
          sameFileWithSingleClass=classes.length == 1 && classes[0] == psiClass && element.getContainingFile() == containingFile;
        }
        final boolean safeDelete=sameFileWithSingleClass || isInNonStaticImport(element);
        if (annotationType && parent instanceof PsiAnnotation) {
          usages.add(new SafeDeleteAnnotation((PsiAnnotation)parent,psiClass,safeDelete));
        }
 else {
          usages.add(new SafeDeleteReferenceJavaDeleteUsageInfo(element,psiClass,safeDelete));
        }
      }
      return true;
    }
  }
);
}
