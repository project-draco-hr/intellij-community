{
  final ChainIterable<String> reassignCat=new ChainIterable<String>();
  PsiElement followed=resolveToDocStringOwner(reassignCat);
  PyClass cls;
  PsiElement outer=null;
  boolean isProperty=false;
  String accessorKind="None";
  final TypeEvalContext context=TypeEvalContext.userInitiated(myElement.getProject(),myElement.getContainingFile());
  if (myOriginalElement != null) {
    final String elementName=myOriginalElement.getText();
    if (PyUtil.isPythonIdentifier(elementName)) {
      outer=myOriginalElement.getParent();
      if (outer instanceof PyQualifiedExpression) {
        final PyExpression qual=((PyQualifiedExpression)outer).getQualifier();
        if (qual != null) {
          final PyType type=context.getType(qual);
          if (type instanceof PyClassType) {
            cls=((PyClassType)type).getPyClass();
            final Property property=cls.findProperty(elementName,true,null);
            if (property != null) {
              isProperty=true;
              final AccessDirection dir=AccessDirection.of((PyElement)outer);
              final Maybe<PyCallable> accessor=property.getByDirection(dir);
              myProlog.addItem("property ").addWith(TagBold,$().addWith(TagCode,$(elementName))).addItem(" of ").add(PythonDocumentationProvider.describeClass(cls,TagCode,true,true));
              if (accessor.isDefined() && property.getDoc() != null) {
                myBody.addItem(": ").addItem(property.getDoc()).addItem(BR);
              }
 else {
                final PyCallable getter=property.getGetter().valueOrNull();
                if (getter != null && getter != myElement && getter instanceof PyFunction) {
                  final PyStringLiteralExpression docstring=((PyFunction)getter).getDocStringExpression();
                  if (docstring != null) {
                    myProlog.addItem(BR).addWith(TagItalic,$("Copied from getter:")).addItem(BR).addItem(docstring.getStringValue());
                  }
                }
                myBody.addItem(BR);
              }
              myBody.addItem(BR);
              if (accessor.isDefined() && accessor.value() == null)               followed=null;
              if (dir == AccessDirection.READ) {
                accessorKind="Getter";
              }
 else               if (dir == AccessDirection.WRITE) {
                accessorKind="Setter";
              }
 else {
                accessorKind="Deleter";
              }
              if (followed != null)               myEpilog.addWith(TagSmall,$(BR,BR,accessorKind," of property")).addItem(BR);
            }
          }
        }
      }
    }
  }
  if (myProlog.isEmpty() && !isProperty && !isAttribute()) {
    myProlog.add(reassignCat);
  }
  if (followed instanceof PyDocStringOwner) {
    String docString=null;
    final PyStringLiteralExpression docExpr=((PyDocStringOwner)followed).getDocStringExpression();
    if (docExpr != null)     docString=docExpr.getStringValue();
    if (followed instanceof PyClass) {
      cls=(PyClass)followed;
      myBody.add(PythonDocumentationProvider.describeDecorators(cls,TagItalic,BR,LCombUp));
      myBody.add(PythonDocumentationProvider.describeClass(cls,TagBold,true,false));
    }
 else     if (followed instanceof PyFunction) {
      final PyFunction fun=(PyFunction)followed;
      if (!isProperty) {
        cls=fun.getContainingClass();
        if (cls != null) {
          myBody.addWith(TagSmall,PythonDocumentationProvider.describeClass(cls,TagCode,true,true)).addItem(BR).addItem(BR);
        }
      }
 else {
        cls=null;
      }
      myBody.add(PythonDocumentationProvider.describeDecorators(fun,TagItalic,BR,LCombUp)).add(PythonDocumentationProvider.describeFunction(fun,TagBold,LCombUp));
      if (docString == null) {
        addInheritedDocString(fun,cls);
      }
    }
 else     if (followed instanceof PyFile) {
      addModulePath((PyFile)followed);
    }
    if (docString != null) {
      myBody.addItem(BR);
      addFormattedDocString(myElement,docString,myBody,myEpilog);
    }
  }
 else   if (isProperty) {
    final String accessorMessage;
    if (followed != null) {
      accessorMessage="Declaration: ";
    }
 else {
      accessorMessage=accessorKind + " is not defined.";
    }
    myBody.addWith(TagItalic,$(accessorMessage)).addItem(BR);
    if (followed != null)     myBody.addItem(combUp(PyUtil.getReadableRepr(followed,false)));
  }
 else   if (isAttribute()) {
    addAttributeDoc();
  }
 else   if (followed instanceof PyNamedParameter) {
    myBody.addItem(combUp("Parameter " + PyUtil.getReadableRepr(followed,false)));
    final boolean typeFromDocstringAdded=addTypeAndDescriptionFromDocstring((PyNamedParameter)followed);
    if (outer instanceof PyExpression) {
      final PyType type=context.getType((PyExpression)outer);
      if (type != null) {
        String s=null;
        if (type instanceof PyDynamicallyEvaluatedType) {
          if (!typeFromDocstringAdded) {
            s="\nDynamically inferred type: ";
          }
        }
 else {
          if (outer.getReference() != null) {
            final PsiElement target=outer.getReference().resolve();
            if (target instanceof PyTargetExpression && ((PyTargetExpression)target).getName().equals(((PyNamedParameter)followed).getName())) {
              s="\nReassigned value has type: ";
            }
          }
        }
        if (s == null && !typeFromDocstringAdded) {
          s="\nInferred type: ";
        }
        if (s != null) {
          myBody.addItem(combUp(s));
          PythonDocumentationProvider.describeTypeWithLinks(myBody,followed,type,context);
        }
      }
    }
  }
 else   if (followed != null && outer instanceof PyReferenceExpression) {
    myBody.addItem(combUp("\nInferred type: "));
    PythonDocumentationProvider.describeExpressionTypeWithLinks(myBody,(PyReferenceExpression)outer,context);
  }
  if (myBody.isEmpty() && myEpilog.isEmpty()) {
    return null;
  }
 else {
    return myResult.toString();
  }
}
