{
  PsiElement cap=PyUtil.getConcealingParent(node);
  if (cap instanceof PyClass) {
    PyParameterList plist=node.getParameterList();
    PyParameter[] params=plist.getParameters();
    Set<PyFunction.Flag> flags=PyUtil.detectDecorationsAndWrappersOf(node);
    boolean isMetaclassMethod=false;
    PyClass type_cls=PyBuiltinCache.getInstance(node).getClass("type");
    for (    PyClass ancestor_cls : ((PyClass)cap).iterateAncestors()) {
      if (ancestor_cls == type_cls) {
        isMetaclassMethod=true;
        break;
      }
    }
    final String method_name=node.getName();
    boolean isSpecialMetaclassMethod=isMetaclassMethod && among(method_name,PyNames.INIT,"__call__");
    final boolean is_staticmethod=flags.contains(STATICMETHOD);
    if (params.length == 0) {
      if (is_staticmethod)       return;
      ASTNode name_node=node.getNameNode();
      if (name_node != null) {
        PsiElement open_paren=plist.getFirstChild();
        PsiElement close_paren=plist.getLastChild();
        if (open_paren != null && close_paren != null && "(".equals(open_paren.getText()) && ")".equals(close_paren.getText())) {
          String paramName=flags.contains(CLASSMETHOD) || isMetaclassMethod ? "cls" : "self";
          registerProblem(plist,PyBundle.message("INSP.must.have.first.parameter",paramName),ProblemHighlightType.GENERIC_ERROR,null,new AddSelfQuickFix(paramName));
        }
      }
    }
 else {
      PyNamedParameter first_param=params[0].getAsNamed();
      if (first_param != null) {
        String pname=first_param.getText();
        @NonNls String[] mangled={"eslf","sself","elf","felf","slef","seelf","slf","sslf","sefl","sellf","sef","seef"};
        for (        String typo : mangled) {
          if (typo.equals(pname)) {
            registerProblem(PyUtil.sure(params[0].getNode()).getPsi(),PyBundle.message("INSP.probably.mistyped.self"),new RenameParameterQuickFix(PyNames.CANONICAL_SELF));
            return;
          }
        }
        String CLS="cls";
        if (flags.contains(CLASSMETHOD) || isSpecialMetaclassMethod) {
          if (!CLS.equals(pname)) {
            registerProblem(PyUtil.sure(params[0].getNode()).getPsi(),PyBundle.message("INSP.usually.named.$0",CLS),new RenameParameterQuickFix(CLS));
          }
        }
 else         if (isMetaclassMethod && PyNames.NEW.equals(method_name)) {
          final String[] POSSIBLE_PARAM_NAMES={"typ","meta"};
          if (!among(pname,POSSIBLE_PARAM_NAMES)) {
            registerProblem(PyUtil.sure(params[0].getNode()).getPsi(),PyBundle.message("INSP.usually.named.$0",POSSIBLE_PARAM_NAMES[0]),new RenameParameterQuickFix(POSSIBLE_PARAM_NAMES[0]));
          }
        }
 else         if (!is_staticmethod && !first_param.isPositionalContainer() && !PyNames.CANONICAL_SELF.equals(pname)) {
          if (isMetaclassMethod && CLS.equals(pname)) {
            return;
          }
          registerProblem(PyUtil.sure(params[0].getNode()).getPsi(),PyBundle.message("INSP.usually.named.self"),new RenameParameterQuickFix(PyNames.CANONICAL_SELF));
        }
      }
 else {
        if (!is_staticmethod) {
          registerProblem(plist,PyBundle.message("INSP.first.param.must.not.be.tuple"));
        }
      }
    }
  }
}
