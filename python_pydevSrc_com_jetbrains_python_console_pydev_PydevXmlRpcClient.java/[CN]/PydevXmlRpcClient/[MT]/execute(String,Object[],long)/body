{
  final Object[] result=new Object[]{null};
  this.impl.executeAsync(command,new Vector(Arrays.asList(args)),new AsyncCallback(){
    public void handleError(    Exception error,    URL url,    String method){
      result[0]=new Object[]{error.getMessage()};
    }
    public void handleResult(    Object recievedResult,    URL url,    String method){
      result[0]=recievedResult;
    }
  }
);
  final ProgressManager progressManager=ProgressManager.getInstance();
  if (progressManager.hasProgressIndicator()) {
    progressManager.getProgressIndicator().setText("Communicating with Pydev console with " + (int)(timeout / 10e8) + "s timeout");
  }
  final long startTime=System.nanoTime();
  while (result[0] == null) {
    try {
      ProgressManager.checkCanceled();
    }
 catch (    ProcessCanceledException e) {
      result[0]=new Object[]{"Canceled"};
      break;
    }
    final long time=System.nanoTime() - startTime;
    if (progressManager.hasProgressIndicator()) {
      progressManager.getProgressIndicator().setFraction(((double)time) / timeout);
    }
    if (time > timeout) {
      LOG.debug("Timeout exceeded");
      result[0]=new Object[]{"Timeout exceeded"};
      break;
    }
    try {
      if (process != null) {
        final String errStream=stdErrReader.getContents();
        if (errStream.indexOf("sys.exit called. Interactive console finishing.") != -1) {
          result[0]=new Object[]{errStream};
          break;
        }
        int exitValue=process.exitValue();
        result[0]=new Object[]{String.format("Console already exited with value: %s while waiting for an answer.\n" + "Error stream: " + errStream + "\n"+ "Output stream: "+ stdOutReader.getContents(),exitValue)};
        break;
      }
    }
 catch (    IllegalThreadStateException e) {
synchronized (this) {
        try {
          wait(10);
        }
 catch (        InterruptedException e1) {
          LOG.error(e1);
        }
      }
    }
  }
  return result[0];
}
