{
  final ScopeOwner owner=ScopeUtil.getScopeOwner(node);
  if (owner instanceof PyFunction) {
    final PyFunction function=(PyFunction)owner;
    final PyAnnotation annotation=function.getAnnotation();
    final String typeCommentAnnotation=function.getTypeCommentAnnotation();
    if (annotation != null || typeCommentAnnotation != null) {
      final PyExpression returnExpr=node.getExpression();
      final PyType actual=returnExpr != null ? myTypeEvalContext.getType(returnExpr) : PyNoneType.INSTANCE;
      final PyType expected=getExpectedReturnType(function);
      if (!PyTypeChecker.match(expected,actual,myTypeEvalContext)) {
        final String expectedName=PythonDocumentationProvider.getTypeName(expected,myTypeEvalContext);
        final String actualName=PythonDocumentationProvider.getTypeName(actual,myTypeEvalContext);
        PyMakeFunctionReturnTypeQuickFix localQuickFix=new PyMakeFunctionReturnTypeQuickFix(function,actualName,myTypeEvalContext);
        PyMakeFunctionReturnTypeQuickFix globalQuickFix=new PyMakeFunctionReturnTypeQuickFix(function,null,myTypeEvalContext);
        registerProblem(returnExpr != null ? returnExpr : node,String.format("Expected type '%s', got '%s' instead",expectedName,actualName),localQuickFix,globalQuickFix);
      }
    }
  }
}
