{
  if (LOG.isDebugEnabled()) {
    session.putUserData(TIME_KEY,System.nanoTime());
  }
  return new PyInspectionVisitor(holder){
    @Override public void visitPyCallExpression(    PyCallExpression node){
      List<PyFunction> functions=new ArrayList<PyFunction>();
      final PyExpression callee=node.getCallee();
      if (callee instanceof PyReferenceExpression) {
        PsiElement e=((PyReferenceExpression)callee).followAssignmentsChain(myTypeEvalContext).getElement();
        if (e instanceof PyFunction) {
          functions.add((PyFunction)e);
        }
      }
      if (!functions.isEmpty()) {
        PyFunction fun=functions.get(0);
        final PyArgumentList args=node.getArgumentList();
        if (args != null) {
          final PyArgumentList.AnalysisResult res=args.analyzeCall(myTypeEvalContext);
          final Map<PyExpression,PyNamedParameter> mapped=res.getPlainMappedParams();
          for (          Map.Entry<PyExpression,PyNamedParameter> entry : mapped.entrySet()) {
            final PyNamedParameter p=entry.getValue();
            if (p.isPositionalContainer() || p.isKeywordContainer()) {
              continue;
            }
            final PyType argType=entry.getKey().getType(myTypeEvalContext);
            final PyType paramType=p.getType(myTypeEvalContext);
            checkTypes(paramType,argType,entry.getKey(),myTypeEvalContext);
          }
        }
      }
    }
    @Override public void visitPyBinaryExpression(    PyBinaryExpression node){
      final PsiReference ref=node.getReference(PyResolveContext.noImplicits().withTypeEvalContext(myTypeEvalContext));
      final PyExpression arg=node.getRightExpression();
      checkSingleArgumentFunction(ref,arg);
    }
    @Override public void visitPySubscriptionExpression(    PySubscriptionExpression node){
      final PsiReference ref=node.getReference(PyResolveContext.noImplicits().withTypeEvalContext(myTypeEvalContext));
      final PyExpression arg=node.getIndexExpression();
      checkSingleArgumentFunction(ref,arg);
    }
    private void checkSingleArgumentFunction(    PsiReference functionReference,    PyExpression argument){
      if (functionReference != null && argument != null) {
        final PsiElement resolved=functionReference.resolve();
        if (resolved instanceof PyFunction) {
          final PyFunction fun=(PyFunction)resolved;
          final PyParameter[] parameters=fun.getParameterList().getParameters();
          if (parameters.length == 2) {
            final PyNamedParameter p=parameters[1].getAsNamed();
            if (p != null) {
              final PyType argType=argument.getType(myTypeEvalContext);
              final PyType paramType=p.getType(myTypeEvalContext);
              checkTypes(paramType,argType,argument,myTypeEvalContext);
            }
          }
        }
      }
    }
    private void checkTypes(    PyType superType,    PyType subType,    PsiElement node,    TypeEvalContext context){
      if (subType != null && superType != null) {
        if (!PyTypeChecker.match(superType,subType,context)) {
          registerProblem(node,String.format("Expected type '%s', got '%s' instead",PythonDocumentationProvider.getTypeName(superType,context),PythonDocumentationProvider.getTypeName(subType,myTypeEvalContext)));
        }
      }
    }
  }
;
}
