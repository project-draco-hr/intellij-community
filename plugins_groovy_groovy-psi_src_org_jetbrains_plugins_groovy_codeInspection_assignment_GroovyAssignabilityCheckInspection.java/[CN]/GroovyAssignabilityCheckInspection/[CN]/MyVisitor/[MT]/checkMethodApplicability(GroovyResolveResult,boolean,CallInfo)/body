{
  final PsiElement element=methodResolveResult.getElement();
  if (!(element instanceof PsiMethod))   return true;
  if (element instanceof GrBuilderMethod)   return true;
  final PsiMethod method=(PsiMethod)element;
  if ("call".equals(method.getName()) && info.getInvokedExpression() instanceof GrReferenceExpression) {
    final GrExpression qualifierExpression=((GrReferenceExpression)info.getInvokedExpression()).getQualifierExpression();
    if (qualifierExpression != null) {
      final PsiType type=qualifierExpression.getType();
      if (type instanceof GrClosureType) {
        GrClosureSignatureUtil.ApplicabilityResult result=PsiUtil.isApplicableConcrete(info.getArgumentTypes(),(GrClosureType)type,info.getInvokedExpression());
switch (result) {
case inapplicable:
          highlightInapplicableMethodUsage(methodResolveResult,info,method);
        return false;
case canBeApplicable:
      if (checkUnknownArgs) {
        highlightUnknownArgs(info);
      }
    return !checkUnknownArgs;
default :
  return true;
}
}
}
}
if (method instanceof GrGdkMethod && info.getInvokedExpression() instanceof GrReferenceExpression) {
final PsiMethod staticMethod=((GrGdkMethod)method).getStaticMethod();
final PsiType qualifierType=info.getQualifierInstanceType();
GrReferenceExpression invoked=(GrReferenceExpression)info.getInvokedExpression();
final GrExpression qualifier=PsiImplUtil.getRuntimeQualifier(invoked);
if (qualifierType != null && !GdkMethodUtil.isCategoryMethod(staticMethod,qualifierType,qualifier,methodResolveResult.getSubstitutor()) && !checkCategoryQualifier(invoked,qualifier,staticMethod,methodResolveResult.getSubstitutor())) {
registerError(info.getHighlightElementForCategoryQualifier(),GroovyInspectionBundle.message("category.method.0.cannot.be.applied.to.1",method.getName(),qualifierType.getCanonicalText()));
return false;
}
}
if (info.getArgumentTypes() == null) return true;
GrClosureSignatureUtil.ApplicabilityResult applicable=PsiUtil.isApplicableConcrete(info.getArgumentTypes(),method,methodResolveResult.getSubstitutor(),info.getCall(),false);
switch (applicable) {
case inapplicable:
highlightInapplicableMethodUsage(methodResolveResult,info,method);
return false;
case canBeApplicable:
if (checkUnknownArgs) {
highlightUnknownArgs(info);
}
return !checkUnknownArgs;
default :
return true;
}
}
