{
  PsiClassType.ClassResolveResult resolveResult=null;
  final PsiDocCommentOwner target=targetMember.getElement();
  if (target instanceof PsiField) {
    resolveResult=PsiUtil.resolveGenericsClassInType(targetMember.getSubstitutor().substitute(((PsiField)target).getType()));
  }
 else   if (target instanceof PsiMethod) {
    resolveResult=PsiUtil.resolveGenericsClassInType(targetMember.getSubstitutor().substitute(((PsiMethod)target).getReturnType()));
  }
  if (resolveResult == null || resolveResult.getElement() == null)   return null;
  PsiClass targetClass=resolveResult.getElement();
  PsiSubstitutor substitutor=resolveResult.getSubstitutor();
  int offset=editor.getCaretModel().getOffset();
  PsiElement element=file.findElementAt(offset);
  if (element == null)   return null;
  PsiClass aClass=PsiTreeUtil.getParentOfType(element,PsiClass.class);
  if (aClass == null)   return null;
  List<PsiMethodMember> methodInstances=new ArrayList<>();
  final PsiMethod[] allMethods;
  if (targetClass instanceof PsiTypeParameter) {
    LinkedHashSet<PsiMethod> meths=new LinkedHashSet<>();
    for (    PsiClass superClass : targetClass.getSupers()) {
      meths.addAll(Arrays.asList(superClass.getAllMethods()));
    }
    allMethods=meths.toArray(new PsiMethod[meths.size()]);
  }
 else {
    allMethods=targetClass.getAllMethods();
  }
  final Set<MethodSignature> signatures=new HashSet<>();
  final Set<MethodSignature> existingSignatures=new HashSet<>(aClass.getVisibleSignatures());
  final Set<PsiMethodMember> selection=new HashSet<>();
  Map<PsiClass,PsiSubstitutor> superSubstitutors=new HashMap<>();
  final PsiClass containingClass=targetMember.getContainingClass();
  JavaPsiFacade facade=JavaPsiFacade.getInstance(target.getProject());
  for (  PsiMethod method : allMethods) {
    final PsiClass superClass=method.getContainingClass();
    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName()))     continue;
    if (method.isConstructor())     continue;
    if (method.hasModifierProperty(PsiModifier.FINAL)) {
      PsiMethod overridden=containingClass.findMethodBySignature(method,true);
      if (overridden != null && overridden.getContainingClass() != containingClass) {
        continue;
      }
    }
    PsiSubstitutor superSubstitutor=superSubstitutors.get(superClass);
    if (superSubstitutor == null) {
      superSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(superClass,targetClass,substitutor);
      superSubstitutors.put(superClass,superSubstitutor);
    }
    PsiSubstitutor methodSubstitutor=OverrideImplementExploreUtil.correctSubstitutor(method,superSubstitutor);
    MethodSignature signature=method.getSignature(methodSubstitutor);
    if (!signatures.contains(signature)) {
      signatures.add(signature);
      if (facade.getResolveHelper().isAccessible(method,target,aClass)) {
        final PsiMethodMember methodMember=new PsiMethodMember(method,methodSubstitutor);
        methodInstances.add(methodMember);
        if (!existingSignatures.contains(signature)) {
          selection.add(methodMember);
        }
      }
    }
  }
  PsiMethodMember[] result;
  if (!ApplicationManager.getApplication().isUnitTestMode()) {
    MemberChooser<PsiElementClassMember> chooser=new MemberChooser<>(methodInstances.toArray(new PsiMethodMember[methodInstances.size()]),false,true,project);
    chooser.setTitle(CodeInsightBundle.message("generate.delegate.method.chooser.title"));
    chooser.setCopyJavadocVisible(true);
    if (!selection.isEmpty()) {
      chooser.selectElements(selection.toArray(new ClassMember[selection.size()]));
    }
    chooser.show();
    if (chooser.getExitCode() != DialogWrapper.OK_EXIT_CODE)     return null;
    myToCopyJavaDoc=chooser.isCopyJavadoc();
    final List<PsiElementClassMember> list=chooser.getSelectedElements();
    result=list.toArray(new PsiMethodMember[list.size()]);
  }
 else {
    result=methodInstances.isEmpty() ? new PsiMethodMember[0] : new PsiMethodMember[]{methodInstances.get(0)};
  }
  return result;
}
