{
  final CheckForUpdateResult result=checkForUpdates(updateSettings);
  if (manualCheck && result.getState() == UpdateStrategy.State.LOADED) {
    UpdateSettings settings=UpdateSettings.getInstance();
    settings.saveLastCheckedInfo();
    settings.setKnownChannelIds(result.getAllChannelsIds());
  }
 else   if (result.getState() == UpdateStrategy.State.CONNECTION_ERROR) {
    Exception e=result.getError();
    if (e != null)     LOG.warn(e);
    showErrorMessage(manualCheck,IdeBundle.message(e instanceof InterruptedIOException ? "updates.timeout.error" : "updates.error.connection.failed"));
    return;
  }
  final UpdateChannel updatedChannel=result.getUpdatedChannel();
  boolean platformUpdate=newChannelReady(result.getChannelToPropose());
  BuildNumber buildNumber=null;
  if (updatedChannel != null) {
    final BuildInfo latestBuild=updatedChannel.getLatestBuild();
    if (latestBuild != null) {
      buildNumber=latestBuild.getNumber();
    }
  }
  final Collection<IdeaPluginDescriptor> incompatiblePlugins=buildNumber != null ? new HashSet<IdeaPluginDescriptor>() : null;
  final Collection<PluginDownloader> updatedPlugins=platformUpdate ? null : updatePlugins(manualCheck,incompatiblePlugins,indicator,buildNumber);
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    @Override public void run(){
      showUpdateResult(project,result,updatedPlugins,incompatiblePlugins,enableLink,manualCheck);
      if (callback != null) {
        callback.setDone();
      }
    }
  }
);
}
