{
  if (!DebuggerSettings.EVALUATE_FINALLY_NEVER.equals(DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME)) {
    List<PsiStatement> statements=getFinallyStatements(project,stackFrame.getDescriptor().getSourcePosition());
    if (!statements.isEmpty()) {
      StringBuilder sb=new StringBuilder();
      for (      PsiStatement statement : statements) {
        sb.append("\n").append(statement.getText());
      }
      if (DebuggerSettings.EVALUATE_FINALLY_ALWAYS.equals(DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME)) {
        evaluateAndAct(project,stackFrame,sb,callback);
        return true;
      }
 else {
        int res=MessageDialogBuilder.yesNoCancel(title,DebuggerBundle.message("warning.finally.block.detected") + sb).project(project).icon(Messages.getWarningIcon()).yesText(DebuggerBundle.message("button.execute.finally")).noText(DebuggerBundle.message("button.drop.anyway")).cancelText(CommonBundle.message("button.cancel")).doNotAsk(new DialogWrapper.DoNotAskOption(){
          @Override public boolean isToBeShown(){
            return !DebuggerSettings.EVALUATE_FINALLY_ALWAYS.equals(DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME) && !DebuggerSettings.EVALUATE_FINALLY_NEVER.equals(DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME);
          }
          @Override public void setToBeShown(          boolean value,          int exitCode){
            if (!value) {
              DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME=exitCode == Messages.YES ? DebuggerSettings.EVALUATE_FINALLY_ALWAYS : DebuggerSettings.EVALUATE_FINALLY_NEVER;
            }
 else {
              DebuggerSettings.getInstance().EVALUATE_FINALLY_ON_POP_FRAME=DebuggerSettings.EVALUATE_FINALLY_ASK;
            }
          }
          @Override public boolean canBeHidden(){
            return true;
          }
          @Override public boolean shouldSaveOptionsOnCancel(){
            return false;
          }
          @NotNull @Override public String getDoNotShowMessage(){
            return CommonBundle.message("dialog.options.do.not.show");
          }
        }
).show();
switch (res) {
case Messages.CANCEL:
          return true;
case Messages.NO:
        break;
case Messages.YES:
      evaluateAndAct(project,stackFrame,sb,callback);
    return true;
}
}
}
}
return false;
}
