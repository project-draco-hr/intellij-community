{
  boolean literal=DecompilerContext.getOption(IFernflowerPreferences.LITERALS_AS_IS);
  boolean ascii=DecompilerContext.getOption(IFernflowerPreferences.ASCII_STRING_CHARACTERS);
  tracer.addMapping(bytecode);
  if (consttype.type != CodeConstants.TYPE_NULL && value == null) {
    return new TextBuffer(ExprProcessor.getCastTypeName(consttype));
  }
 else {
switch (consttype.type) {
case CodeConstants.TYPE_BOOLEAN:
      return new TextBuffer(Boolean.toString(((Integer)value).intValue() != 0));
case CodeConstants.TYPE_CHAR:
    Integer val=(Integer)value;
  String ret=escapes.get(val);
if (ret == null) {
  char c=(char)val.intValue();
  if (c >= 32 && c < 127 || !ascii && InterpreterUtil.isPrintableUnicode(c)) {
    ret=String.valueOf(c);
  }
 else {
    ret=InterpreterUtil.charToUnicodeLiteral(c);
  }
}
return new TextBuffer(ret).enclose("\'","\'");
case CodeConstants.TYPE_BYTE:
case CodeConstants.TYPE_BYTECHAR:
case CodeConstants.TYPE_SHORT:
case CodeConstants.TYPE_SHORTCHAR:
case CodeConstants.TYPE_INT:
int ival=((Integer)value).intValue();
String intfield;
if (literal) {
return new TextBuffer(value.toString());
}
 else if (ival == Integer.MAX_VALUE) {
intfield="MAX_VALUE";
}
 else if (ival == Integer.MIN_VALUE) {
intfield="MIN_VALUE";
}
 else {
return new TextBuffer(value.toString());
}
return new FieldExprent(intfield,"java/lang/Integer",true,null,FieldDescriptor.INTEGER_DESCRIPTOR).toJava(0,tracer);
case CodeConstants.TYPE_LONG:
long lval=((Long)value).longValue();
String longfield;
if (literal) {
return new TextBuffer(value.toString()).append("L");
}
 else if (lval == Long.MAX_VALUE) {
longfield="MAX_VALUE";
}
 else if (lval == Long.MIN_VALUE) {
longfield="MIN_VALUE";
}
 else {
return new TextBuffer(value.toString()).append("L");
}
return new FieldExprent(longfield,"java/lang/Long",true,null,FieldDescriptor.LONG_DESCRIPTOR).toJava(0,tracer);
case CodeConstants.TYPE_DOUBLE:
double dval=((Double)value).doubleValue();
String doublefield;
if (literal) {
if (Double.isNaN(dval)) {
return new TextBuffer("0.0D / 0.0");
}
 else if (dval == Double.POSITIVE_INFINITY) {
return new TextBuffer("1.0D / 0.0");
}
 else if (dval == Double.NEGATIVE_INFINITY) {
return new TextBuffer("-1.0D / 0.0");
}
 else {
return new TextBuffer(value.toString()).append("D");
}
}
 else if (Double.isNaN(dval)) {
doublefield="NaN";
}
 else if (dval == Double.POSITIVE_INFINITY) {
doublefield="POSITIVE_INFINITY";
}
 else if (dval == Double.NEGATIVE_INFINITY) {
doublefield="NEGATIVE_INFINITY";
}
 else if (dval == Double.MAX_VALUE) {
doublefield="MAX_VALUE";
}
 else if (dval == Double.MIN_VALUE) {
doublefield="MIN_VALUE";
}
 else {
return new TextBuffer(value.toString()).append("D");
}
return new FieldExprent(doublefield,"java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR).toJava(0,tracer);
case CodeConstants.TYPE_FLOAT:
float fval=((Float)value).floatValue();
String floatfield;
if (literal) {
if (Double.isNaN(fval)) {
return new TextBuffer("0.0F / 0.0");
}
 else if (fval == Double.POSITIVE_INFINITY) {
return new TextBuffer("1.0F / 0.0");
}
 else if (fval == Double.NEGATIVE_INFINITY) {
return new TextBuffer("-1.0F / 0.0");
}
 else {
return new TextBuffer(value.toString()).append("F");
}
}
 else if (Float.isNaN(fval)) {
floatfield="NaN";
}
 else if (fval == Float.POSITIVE_INFINITY) {
floatfield="POSITIVE_INFINITY";
}
 else if (fval == Float.NEGATIVE_INFINITY) {
floatfield="NEGATIVE_INFINITY";
}
 else if (fval == Float.MAX_VALUE) {
floatfield="MAX_VALUE";
}
 else if (fval == Float.MIN_VALUE) {
floatfield="MIN_VALUE";
}
 else {
return new TextBuffer(value.toString()).append("F");
}
return new FieldExprent(floatfield,"java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR).toJava(0,tracer);
case CodeConstants.TYPE_NULL:
return new TextBuffer("null");
case CodeConstants.TYPE_OBJECT:
if (consttype.equals(VarType.VARTYPE_STRING)) {
return new TextBuffer(convertStringToJava(value.toString(),ascii)).enclose("\"","\"");
}
 else if (consttype.equals(VarType.VARTYPE_CLASS)) {
String strval=value.toString();
VarType classtype;
if (strval.startsWith("[")) {
classtype=new VarType(strval,false);
}
 else {
classtype=new VarType(strval,true);
}
return new TextBuffer(ExprProcessor.getCastTypeName(classtype)).append(".class");
}
}
}
throw new RuntimeException("invalid constant type");
}
