{
  boolean literal=DecompilerContext.getOption(IFernflowerPreferences.LITERALS_AS_IS);
  boolean ascii=DecompilerContext.getOption(IFernflowerPreferences.ASCII_STRING_CHARACTERS);
  tracer.addMapping(bytecode);
  if (constType.type != CodeConstants.TYPE_NULL && value == null) {
    return new TextBuffer(ExprProcessor.getCastTypeName(constType));
  }
switch (constType.type) {
case CodeConstants.TYPE_BOOLEAN:
    return new TextBuffer(Boolean.toString(((Integer)value).intValue() != 0));
case CodeConstants.TYPE_CHAR:
  Integer val=(Integer)value;
String ret=ESCAPES.get(val);
if (ret == null) {
char c=(char)val.intValue();
if (c >= 32 && c < 127 || !ascii && TextUtil.isPrintableUnicode(c)) {
  ret=String.valueOf(c);
}
 else {
  ret=TextUtil.charToUnicodeLiteral(c);
}
}
return new TextBuffer().append('\'').append(ret).append('\'');
case CodeConstants.TYPE_BYTE:
case CodeConstants.TYPE_BYTECHAR:
case CodeConstants.TYPE_SHORT:
case CodeConstants.TYPE_SHORTCHAR:
case CodeConstants.TYPE_INT:
int intVal=((Integer)value).intValue();
if (!literal) {
if (intVal == Integer.MAX_VALUE) {
return new FieldExprent("MAX_VALUE","java/lang/Integer",true,null,FieldDescriptor.INTEGER_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (intVal == Integer.MIN_VALUE) {
return new FieldExprent("MIN_VALUE","java/lang/Integer",true,null,FieldDescriptor.INTEGER_DESCRIPTOR,bytecode).toJava(0,tracer);
}
}
return new TextBuffer(value.toString());
case CodeConstants.TYPE_LONG:
long longVal=((Long)value).longValue();
if (!literal) {
if (longVal == Long.MAX_VALUE) {
return new FieldExprent("MAX_VALUE","java/lang/Long",true,null,FieldDescriptor.LONG_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (longVal == Long.MIN_VALUE) {
return new FieldExprent("MIN_VALUE","java/lang/Long",true,null,FieldDescriptor.LONG_DESCRIPTOR,bytecode).toJava(0,tracer);
}
}
return new TextBuffer(value.toString()).append('L');
case CodeConstants.TYPE_FLOAT:
float floatVal=((Float)value).floatValue();
if (!literal) {
if (Float.isNaN(floatVal)) {
return new FieldExprent("NaN","java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (floatVal == Float.POSITIVE_INFINITY) {
return new FieldExprent("POSITIVE_INFINITY","java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (floatVal == Float.NEGATIVE_INFINITY) {
return new FieldExprent("NEGATIVE_INFINITY","java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (floatVal == Float.MAX_VALUE) {
return new FieldExprent("MAX_VALUE","java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (floatVal == Float.MIN_VALUE) {
return new FieldExprent("MIN_VALUE","java/lang/Float",true,null,FieldDescriptor.FLOAT_DESCRIPTOR,bytecode).toJava(0,tracer);
}
}
 else if (Float.isNaN(floatVal)) {
return new TextBuffer("0.0F / 0.0");
}
 else if (floatVal == Float.POSITIVE_INFINITY) {
return new TextBuffer("1.0F / 0.0");
}
 else if (floatVal == Float.NEGATIVE_INFINITY) {
return new TextBuffer("-1.0F / 0.0");
}
return new TextBuffer(value.toString()).append('F');
case CodeConstants.TYPE_DOUBLE:
double doubleVal=((Double)value).doubleValue();
if (!literal) {
if (Double.isNaN(doubleVal)) {
return new FieldExprent("NaN","java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (doubleVal == Double.POSITIVE_INFINITY) {
return new FieldExprent("POSITIVE_INFINITY","java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (doubleVal == Double.NEGATIVE_INFINITY) {
return new FieldExprent("NEGATIVE_INFINITY","java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (doubleVal == Double.MAX_VALUE) {
return new FieldExprent("MAX_VALUE","java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR,bytecode).toJava(0,tracer);
}
 else if (doubleVal == Double.MIN_VALUE) {
return new FieldExprent("MIN_VALUE","java/lang/Double",true,null,FieldDescriptor.DOUBLE_DESCRIPTOR,bytecode).toJava(0,tracer);
}
}
 else if (Double.isNaN(doubleVal)) {
return new TextBuffer("0.0D / 0.0");
}
 else if (doubleVal == Double.POSITIVE_INFINITY) {
return new TextBuffer("1.0D / 0.0");
}
 else if (doubleVal == Double.NEGATIVE_INFINITY) {
return new TextBuffer("-1.0D / 0.0");
}
return new TextBuffer(value.toString()).append('D');
case CodeConstants.TYPE_NULL:
return new TextBuffer("null");
case CodeConstants.TYPE_OBJECT:
if (constType.equals(VarType.VARTYPE_STRING)) {
return new TextBuffer().append('"').append(convertStringToJava(value.toString(),ascii)).append('"');
}
 else if (constType.equals(VarType.VARTYPE_CLASS)) {
String stringVal=value.toString();
VarType type=new VarType(stringVal,!stringVal.startsWith("["));
return new TextBuffer(ExprProcessor.getCastTypeName(type)).append(".class");
}
}
throw new RuntimeException("invalid constant type: " + constType);
}
