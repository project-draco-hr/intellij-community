{
  ClassesProcessor clProcessor=DecompilerContext.getClassProcessor();
  StructClass cl=node.classStruct;
  if (cl.getBytecodeVersion() < CodeConstants.BYTECODE_JAVA_8) {
    return false;
  }
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  if (bootstrap == null || bootstrap.getMethodsNumber() == 0) {
    return false;
  }
  BitSet lambda_methods=new BitSet();
  for (int i=0; i < bootstrap.getMethodsNumber(); ++i) {
    LinkConstant method_ref=bootstrap.getMethodReference(i);
    if (JAVAC_LAMBDA_CLASS.equals(method_ref.classname) && (JAVAC_LAMBDA_METHOD.equals(method_ref.elementname) || JAVAC_LAMBDA_ALT_METHOD.equals(method_ref.elementname))) {
      lambda_methods.set(i);
    }
  }
  if (lambda_methods.isEmpty()) {
    return false;
  }
  Map<String,String> mapMethodsLambda=new HashMap<String,String>();
  for (  StructMethod mt : cl.getMethods()) {
    mt.expandData();
    InstructionSequence seq=mt.getInstructionSequence();
    if (seq != null && seq.length() > 0) {
      int len=seq.length();
      for (int i=0; i < len; ++i) {
        Instruction instr=seq.getInstr(i);
        if (instr.opcode == CodeConstants.opc_invokedynamic) {
          LinkConstant invoke_dynamic=cl.getPool().getLinkConstant(instr.getOperand(0));
          if (lambda_methods.get(invoke_dynamic.index1)) {
            List<PooledConstant> bootstrap_arguments=bootstrap.getMethodArguments(invoke_dynamic.index1);
            MethodDescriptor md=MethodDescriptor.parseDescriptor(invoke_dynamic.descriptor);
            String lambda_class_name=md.ret.value;
            String lambda_method_name=invoke_dynamic.elementname;
            String lambda_method_descriptor=((PrimitiveConstant)bootstrap_arguments.get(2)).getString();
            LinkConstant content_method_handle=(LinkConstant)bootstrap_arguments.get(1);
            ClassNode node_lambda=new ClassNode(content_method_handle.classname,content_method_handle.elementname,content_method_handle.descriptor,content_method_handle.index1,lambda_class_name,lambda_method_name,lambda_method_descriptor,cl);
            node_lambda.simpleName=cl.qualifiedName + "##Lambda_" + invoke_dynamic.index1+ "_"+ invoke_dynamic.index2;
            node_lambda.enclosingMethod=InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor());
            node.nested.add(node_lambda);
            node_lambda.parent=node;
            clProcessor.getMapRootClasses().put(node_lambda.simpleName,node_lambda);
            mapMethodsLambda.put(node_lambda.lambdaInformation.content_method_key,node_lambda.simpleName);
          }
        }
      }
    }
    mt.releaseResources();
  }
  for (  ClassNode nd : node.nested) {
    if (nd.type == ClassNode.CLASS_LAMBDA) {
      String parent_class_name=mapMethodsLambda.get(nd.enclosingMethod);
      if (parent_class_name != null) {
        ClassNode parent_class=clProcessor.getMapRootClasses().get(parent_class_name);
        parent_class.nested.add(nd);
        nd.parent=parent_class;
      }
    }
  }
  return false;
}
