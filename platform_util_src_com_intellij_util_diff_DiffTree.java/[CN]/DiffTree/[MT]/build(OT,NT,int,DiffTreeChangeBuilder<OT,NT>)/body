{
  OT oldNode=myOldTree.prepareForGetChildren(oldN);
  NT newNode=myNewTree.prepareForGetChildren(newN);
  if (level == myNewChildrenLists.size()) {
    myNewChildrenLists.add(new Ref<NT[]>());
    myOldChildrenLists.add(new Ref<OT[]>());
  }
  final Ref<OT[]> oldChildrenR=myOldChildrenLists.get(level);
  int oldChildrenSize=myOldTree.getChildren(oldNode,oldChildrenR);
  final OT[] oldChildren=oldChildrenR.get();
  final Ref<NT[]> newChildrenR=myNewChildrenLists.get(level);
  int newChildrenSize=myNewTree.getChildren(newNode,newChildrenR);
  final NT[] newChildren=newChildrenR.get();
  CompareResult result;
  if (Math.abs(oldChildrenSize - newChildrenSize) > CHANGE_PARENT_VERSUS_CHILDREN_THRESHOLD) {
    consumer.nodeReplaced(oldNode,newNode);
    result=CompareResult.NOT_EQUAL;
  }
 else   if (oldChildrenSize == 0 && newChildrenSize == 0) {
    if (!myComparator.hashCodesEqual(oldNode,newNode) || !myComparator.typesEqual(oldNode,newNode)) {
      consumer.nodeReplaced(oldNode,newNode);
      result=CompareResult.NOT_EQUAL;
    }
 else {
      result=CompareResult.EQUAL;
    }
  }
 else {
    final ShallowNodeComparator<OT,NT> comparator=myComparator;
    int minSize=Math.min(oldChildrenSize,newChildrenSize);
    int suffixLength=match(oldChildren,oldChildrenSize - 1,newChildren,newChildrenSize - 1,level,-1,minSize);
    int prefixLength=oldChildrenSize == 1 && newChildrenSize == 1 ? 0 : match(oldChildren,0,newChildren,0,level,1,minSize - suffixLength);
    if (oldChildrenSize == newChildrenSize && suffixLength + prefixLength == oldChildrenSize) {
      result=CompareResult.EQUAL;
    }
 else     if (consumer == emptyConsumer()) {
      result=CompareResult.NOT_EQUAL;
    }
 else {
      int oldIndex=oldChildrenSize - suffixLength - 1;
      int newIndex=newChildrenSize - suffixLength - 1;
      while (oldIndex >= prefixLength || newIndex >= prefixLength) {
        OT oldChild1=oldIndex >= prefixLength ? oldChildren[oldIndex] : null;
        OT oldChild2=oldIndex >= prefixLength + 1 ? oldChildren[oldIndex - 1] : null;
        OT oldChild3=oldIndex >= prefixLength + 2 ? oldChildren[oldIndex - 2] : null;
        NT newChild1=newIndex >= prefixLength ? newChildren[newIndex] : null;
        NT newChild2=newIndex >= prefixLength + 1 ? newChildren[newIndex - 1] : null;
        NT newChild3=newIndex >= prefixLength + 2 ? newChildren[newIndex - 2] : null;
        CompareResult c11=looksEqual(comparator,oldChild1,newChild1);
        if (c11 == CompareResult.EQUAL || c11 == CompareResult.DRILL_DOWN_NEEDED) {
          if (c11 == CompareResult.DRILL_DOWN_NEEDED) {
            build(oldChild1,newChild1,level + 1,consumer);
          }
          oldIndex--;
          newIndex--;
          continue;
        }
        if (c11 == CompareResult.TYPE_ONLY) {
          CompareResult c21=looksEqual(comparator,oldChild2,newChild1);
          if (c21 == CompareResult.EQUAL || c21 == CompareResult.DRILL_DOWN_NEEDED) {
            consumer.nodeDeleted(oldNode,oldChild1);
            oldIndex--;
            continue;
          }
          CompareResult c12=looksEqual(comparator,oldChild1,newChild2);
          if (c12 == CompareResult.EQUAL || c12 == CompareResult.DRILL_DOWN_NEEDED) {
            consumer.nodeInserted(oldNode,newChild1,oldIndex + 1);
            newIndex--;
            continue;
          }
          consumer.nodeReplaced(oldChild1,newChild1);
          oldIndex--;
          newIndex--;
          continue;
        }
        CompareResult c12=looksEqual(comparator,oldChild1,newChild2);
        if (c12 == CompareResult.EQUAL || c12 == CompareResult.DRILL_DOWN_NEEDED) {
          consumer.nodeInserted(oldNode,newChild1,oldIndex + 1);
          newIndex--;
          continue;
        }
        CompareResult c21=looksEqual(comparator,oldChild2,newChild1);
        if (c21 == CompareResult.EQUAL || c21 == CompareResult.DRILL_DOWN_NEEDED || c21 == CompareResult.TYPE_ONLY) {
          consumer.nodeDeleted(oldNode,oldChild1);
          oldIndex--;
          continue;
        }
        if (c12 == CompareResult.TYPE_ONLY) {
          consumer.nodeInserted(oldNode,newChild1,oldIndex + 1);
          newIndex--;
          continue;
        }
        if (oldChild1 == null) {
          consumer.nodeInserted(oldNode,newChild1,oldIndex + 1);
          newIndex--;
          continue;
        }
        if (newChild1 == null) {
          consumer.nodeDeleted(oldNode,oldChild1);
          oldIndex--;
          continue;
        }
        if (oldChild3 != null || newChild3 != null) {
          CompareResult c13=looksEqual(comparator,oldChild1,newChild3);
          if (c13 == CompareResult.EQUAL || c13 == CompareResult.DRILL_DOWN_NEEDED || c13 == CompareResult.TYPE_ONLY) {
            consumer.nodeInserted(oldNode,newChild1,oldIndex + 1);
            consumer.nodeInserted(oldNode,newChild2,oldIndex + 1);
            newIndex--;
            newIndex--;
            continue;
          }
          CompareResult c31=looksEqual(comparator,oldChild3,newChild1);
          if (c31 == CompareResult.EQUAL || c31 == CompareResult.DRILL_DOWN_NEEDED || c31 == CompareResult.TYPE_ONLY) {
            consumer.nodeDeleted(oldNode,oldChild1);
            consumer.nodeDeleted(oldNode,oldChild2);
            oldIndex--;
            oldIndex--;
            continue;
          }
        }
        OT oldFirstChild=oldIndex >= prefixLength ? oldChildren[prefixLength] : null;
        NT newFirstChild=newIndex >= prefixLength ? newChildren[prefixLength] : null;
        CompareResult c=oldFirstChild == null || newFirstChild == null ? CompareResult.NOT_EQUAL : looksEqual(comparator,oldFirstChild,newFirstChild);
        if (c == CompareResult.EQUAL || c == CompareResult.TYPE_ONLY || c == CompareResult.DRILL_DOWN_NEEDED) {
          if (c == CompareResult.DRILL_DOWN_NEEDED) {
            build(oldFirstChild,newFirstChild,level + 1,consumer);
          }
 else {
            consumer.nodeReplaced(oldFirstChild,newFirstChild);
          }
          prefixLength++;
          continue;
        }
        consumer.nodeReplaced(oldChild1,newChild1);
        oldIndex--;
        newIndex--;
      }
      result=CompareResult.NOT_EQUAL;
    }
  }
  myOldTree.disposeChildren(oldChildren,oldChildrenSize);
  myNewTree.disposeChildren(newChildren,newChildrenSize);
  return result;
}
