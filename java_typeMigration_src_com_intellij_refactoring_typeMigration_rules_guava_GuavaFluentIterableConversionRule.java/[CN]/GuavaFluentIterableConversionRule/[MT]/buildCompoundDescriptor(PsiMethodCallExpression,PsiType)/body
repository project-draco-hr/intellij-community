{
  List<TypeConversionDescriptor> methodDescriptors=new SmartList<TypeConversionDescriptor>();
  PsiMethodCallExpression current=expression;
  while (true) {
    final PsiMethod method=current.resolveMethod();
    if (method == null) {
      break;
    }
    final String methodName=method.getName();
    final PsiClass containingClass=method.getContainingClass();
    if (containingClass == null || !FLUENT_ITERABLE.equals(containingClass.getQualifiedName())) {
      break;
    }
    final TypeConversionDescriptorFactory descriptorFactory=DESCRIPTORS_MAP.get(methodName);
    if (descriptorFactory == null) {
      return null;
    }
    methodDescriptors.add(descriptorFactory.create());
    final PsiExpression qualifier=current.getMethodExpression().getQualifierExpression();
    if (qualifier instanceof PsiMethodCallExpression) {
      current=(PsiMethodCallExpression)qualifier;
    }
 else     if (qualifier instanceof PsiReferenceExpression) {
      if (!methodName.equals("from")) {
        return null;
      }
      final PsiElement maybeClass=((PsiReferenceExpression)qualifier).resolve();
      if (!(maybeClass instanceof PsiClass)) {
        return null;
      }
      if (!FLUENT_ITERABLE.equals(((PsiClass)maybeClass).getQualifiedName())) {
        return null;
      }
      break;
    }
 else {
      return null;
    }
  }
  return new GuavaChainedConversionDescriptor(methodDescriptors,to);
}
