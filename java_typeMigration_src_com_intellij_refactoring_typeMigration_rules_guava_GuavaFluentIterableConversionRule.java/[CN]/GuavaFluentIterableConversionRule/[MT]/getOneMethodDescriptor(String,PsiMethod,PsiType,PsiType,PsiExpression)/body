{
  TypeConversionDescriptor descriptorBase=null;
  PsiType conversionType=null;
  boolean needSpecifyType=true;
  if (methodName.equals("of")) {
    descriptorBase=new TypeConversionDescriptor("'FluentIterable*.of($arr$)","java.util.Arrays.stream($arr$)");
  }
 else   if (methodName.equals("from")) {
    descriptorBase=new TypeConversionDescriptor("'FluentIterable*.from($it$)",null){
      @Override public PsiExpression replace(      PsiExpression expression,      TypeEvaluator evaluator){
        final PsiMethodCallExpression methodCall=(PsiMethodCallExpression)expression;
        PsiExpression argument=PseudoLambdaReplaceTemplate.replaceTypeParameters(methodCall.getArgumentList().getExpressions()[0]);
        if (argument == null) {
          return expression;
        }
        boolean isCollection=InheritanceUtil.isInheritor(PsiTypesUtil.getPsiClass(argument.getType()),CommonClassNames.JAVA_UTIL_COLLECTION);
        setReplaceByString(isCollection ? "$it$.stream()" : "java.util.stream.StreamSupport.stream($it$.spliterator(), false)");
        return super.replace(expression,evaluator);
      }
    }
;
  }
 else   if (methodName.equals("filter")) {
    descriptorBase=FluentIterableConversionUtil.getFilterDescriptor(method);
  }
 else   if (methodName.equals("transformAndConcat")) {
    descriptorBase=new FluentIterableConversionUtil.TransformAndConcatConversionRule();
  }
 else   if (methodName.equals("toArray")) {
    descriptorBase=FluentIterableConversionUtil.getToArrayDescriptor(from,context);
    needSpecifyType=false;
  }
 else   if (methodName.equals("copyInto")) {
    descriptorBase=new FluentIterableConversionUtil.CopyIntoConversionDescriptor();
    needSpecifyType=false;
  }
 else   if (methodName.equals("append")) {
    descriptorBase=createDescriptorForAppend(method,context);
  }
 else   if (methodName.equals("get")) {
    descriptorBase=new TypeConversionDescriptor("$it$.get($p$)",null){
      @Override public PsiExpression replace(      PsiExpression expression,      TypeEvaluator evaluator){
        PsiMethodCallExpression methodCall=(PsiMethodCallExpression)expression;
        final PsiExpression[] arguments=methodCall.getArgumentList().getExpressions();
        setReplaceByString("$it$.skip($p$).findFirst().get()");
        if (arguments.length == 1 && arguments[0] instanceof PsiLiteralExpression) {
          final Object value=((PsiLiteralExpression)arguments[0]).getValue();
          if (value != null && value.equals(0)) {
            setReplaceByString("$it$.findFirst().get()");
          }
        }
        return super.replace(expression,evaluator);
      }
    }
;
    needSpecifyType=false;
  }
 else   if (methodName.equals("contains")) {
    descriptorBase=new TypeConversionDescriptor("$it$.contains($o$)",null){
      @Override public PsiExpression replace(      PsiExpression expression,      TypeEvaluator evaluator){
        final PsiMethodCallExpression methodCallExpression=(PsiMethodCallExpression)expression;
        final PsiExpression qualifier=methodCallExpression.getMethodExpression().getQualifierExpression();
        LOG.assertTrue(qualifier != null);
        final PsiClassType qualifierType=(PsiClassType)qualifier.getType();
        LOG.assertTrue(qualifierType != null);
        final PsiType[] parameters=qualifierType.getParameters();
        final JavaCodeStyleManager codeStyleManager=JavaCodeStyleManager.getInstance(expression.getProject());
        final SuggestedNameInfo suggestedNameInfo=codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE,null,null,parameters.length == 1 ? parameters[0] : null,false);
        final String suggestedName=codeStyleManager.suggestUniqueVariableName(suggestedNameInfo,expression,false).names[0];
        setReplaceByString("$it$.anyMatch(" + suggestedName + " -> java.util.Objects.equals("+ suggestedName+ ", $o$))");
        return super.replace(expression,evaluator);
      }
    }
;
    needSpecifyType=false;
  }
 else {
    final TypeConversionDescriptorFactory base=DESCRIPTORS_MAP.get(methodName);
    if (base != null) {
      final TypeConversionDescriptor descriptor=base.create();
      needSpecifyType=base.isChainedMethod();
      if (needSpecifyType && !base.isFluentIterableReturnType()) {
        conversionType=GuavaConversionUtil.addTypeParameters(GuavaOptionalConversionRule.JAVA_OPTIONAL,context.getType(),context);
      }
      descriptorBase=descriptor;
    }
  }
  if (descriptorBase == null) {
    return FluentIterableConversionUtil.createToCollectionDescriptor(methodName,context);
  }
  if (descriptorBase != null) {
    if (needSpecifyType) {
      if (conversionType == null) {
        PsiMethodCallExpression methodCall=(PsiMethodCallExpression)(context instanceof PsiMethodCallExpression ? context : context.getParent());
        conversionType=GuavaConversionUtil.addTypeParameters(GuavaTypeConversionDescriptor.isIterable(methodCall) ? CommonClassNames.JAVA_LANG_ITERABLE : StreamApiConstants.JAVA_UTIL_STREAM_STREAM,context.getType(),context);
      }
      descriptorBase.withConversionType(conversionType);
    }
    return descriptorBase;
  }
  return null;
}
