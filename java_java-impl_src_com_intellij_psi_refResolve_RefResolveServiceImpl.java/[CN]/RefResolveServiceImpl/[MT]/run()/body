{
  while (!myDisposed) {
    boolean isEmpty;
synchronized (filesToResolve) {
      isEmpty=filesToResolve.isEmpty();
    }
    if (enableVetoes.get() > 0 || isEmpty || !resolveProcess.isDone() || HeavyProcessLatch.INSTANCE.isRunning() || PsiDocumentManager.getInstance(myProject).hasUncommitedDocuments()) {
      try {
        waitForQueue();
      }
 catch (      InterruptedException e) {
        break;
      }
      continue;
    }
    final Set<VirtualFile> files=pollFilesToResolve();
    if (files.isEmpty())     continue;
    upToDate=false;
    myApplication.invokeLater(new Runnable(){
      @Override public void run(){
        if (!resolveProcess.isDone())         return;
        log("Started to resolve " + files.size() + " files");
        Task.Backgroundable backgroundable=new Task.Backgroundable(myProject,"Resolving files...",false){
          @Override public void run(          @NotNull final ProgressIndicator indicator){
            if (!myApplication.isDisposed()) {
              try {
                processBatch(indicator,files);
              }
 catch (              RuntimeInterruptedException ignore) {
              }
            }
          }
        }
;
        ProgressIndicator indicator;
        if (files.size() > 1) {
          indicator=new BackgroundableProcessIndicator(backgroundable);
        }
 else {
          indicator=new MyProgress();
        }
        resolveProcess=ProgressManagerImpl.runProcessWithProgressAsynchronously(backgroundable,indicator,null);
      }
    }
,myProject.getDisposed());
    flushLog();
  }
}
