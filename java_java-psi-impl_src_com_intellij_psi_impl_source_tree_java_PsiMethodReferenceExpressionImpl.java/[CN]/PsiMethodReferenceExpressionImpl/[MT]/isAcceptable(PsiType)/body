{
  if (left instanceof PsiIntersectionType) {
    for (    PsiType conjunct : ((PsiIntersectionType)left).getConjuncts()) {
      if (isAcceptable(conjunct))       return true;
    }
    return false;
  }
  final PsiExpressionList argsList=PsiTreeUtil.getParentOfType(this,PsiExpressionList.class);
  final boolean isExact=isExact();
  if (MethodCandidateInfo.ourOverloadGuard.currentStack().contains(argsList)) {
    final MethodCandidateInfo.CurrentCandidateProperties candidateProperties=MethodCandidateInfo.getCurrentMethod(argsList);
    if (candidateProperties != null) {
      final PsiMethod method=candidateProperties.getMethod();
      if (isExact && !InferenceSession.isPertinentToApplicability(this,method)) {
        return true;
      }
      if (LambdaUtil.isPotentiallyCompatibleWithTypeParameter(this,argsList,method)) {
        return true;
      }
    }
  }
  left=FunctionalInterfaceParameterizationUtil.getGroundTargetType(left);
  if (!isPotentiallyCompatible(left)) {
    return false;
  }
  if (MethodCandidateInfo.ourOverloadGuard.currentStack().contains(argsList)) {
    if (!isExact) {
      return true;
    }
  }
  Map<PsiElement,PsiType> map=LambdaUtil.getFunctionalTypeMap();
  final JavaResolveResult result;
  try {
    if (map.put(this,left) != null) {
      return false;
    }
    result=advancedResolve(false);
  }
  finally {
    map.remove(this);
  }
  if (result instanceof MethodCandidateInfo && !((MethodCandidateInfo)result).isApplicable()) {
    return false;
  }
  final PsiElement resolve=result.getElement();
  if (resolve == null) {
    return false;
  }
  return PsiMethodReferenceUtil.isReturnTypeCompatible(this,result,left);
}
