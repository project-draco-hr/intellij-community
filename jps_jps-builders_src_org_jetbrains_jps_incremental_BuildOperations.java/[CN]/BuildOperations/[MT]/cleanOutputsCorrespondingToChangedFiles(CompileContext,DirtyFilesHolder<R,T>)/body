{
  final BuildDataManager dataManager=context.getProjectDescriptor().dataManager;
  try {
    final Map<T,Set<File>> cleanedSources=new java.util.HashMap<T,Set<File>>();
    final THashSet<File> dirsToDelete=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
    final Collection<String> deletedPaths=new ArrayList<String>();
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<R,T>(){
      private final Map<T,SourceToOutputMapping> mappingsCache=new java.util.HashMap<T,SourceToOutputMapping>();
      private final TObjectIntHashMap<T> idsCache=new TObjectIntHashMap<T>();
      @Override public boolean apply(      T target,      File file,      R sourceRoot) throws IOException {
        SourceToOutputMapping srcToOut=mappingsCache.get(target);
        if (srcToOut == null) {
          srcToOut=dataManager.getSourceToOutputMap(target);
          mappingsCache.put(target,srcToOut);
        }
        final int targetId;
        if (!idsCache.containsKey(target)) {
          targetId=dataManager.getTargetsState().getBuildTargetId(target);
          idsCache.put(target,targetId);
        }
 else {
          targetId=idsCache.get(target);
        }
        final String srcPath=file.getPath();
        final Collection<String> outputs=srcToOut.getOutputs(srcPath);
        if (outputs != null) {
          final boolean shouldPruneOutputDirs=target instanceof ModuleBasedTarget;
          final List<String> deletedForThisSource=new ArrayList<String>(outputs.size());
          for (          String output : outputs) {
            deleteRecursively(output,deletedForThisSource,shouldPruneOutputDirs ? dirsToDelete : null);
          }
          deletedPaths.addAll(deletedForThisSource);
          dataManager.getOutputToTargetRegistry().removeMapping(deletedForThisSource,targetId);
          Set<File> cleaned=cleanedSources.get(target);
          if (cleaned == null) {
            cleaned=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
            cleanedSources.put(target,cleaned);
          }
          cleaned.add(file);
        }
        return true;
      }
    }
);
    if (context.isMake()) {
      final ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
      if (logger.isEnabled()) {
        logger.logDeletedFiles(deletedPaths);
      }
    }
    if (!deletedPaths.isEmpty()) {
      context.processMessage(new FileDeletedEvent(deletedPaths));
    }
    FSOperations.pruneEmptyDirs(context,dirsToDelete);
    return cleanedSources;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
