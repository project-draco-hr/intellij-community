{
  for (  BuilderCategory category : BuilderCategory.values()) {
    for (    ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
      builder.chunkBuildStarted(context,chunk);
    }
  }
  boolean doneSomething=false;
  boolean rebuildFromScratchRequested=false;
  float stageCount=myTotalModuleLevelBuilderCount;
  final int modulesInChunk=chunk.getModules().size();
  int buildersPassed=0;
  boolean nextPassRequired;
  ChunkBuildOutputConsumerImpl outputConsumer=new ChunkBuildOutputConsumerImpl(context);
  try {
    do {
      nextPassRequired=false;
      myProjectDescriptor.fsState.beforeNextRoundStart(context,chunk);
      DirtyFilesHolder<JavaSourceRootDescriptor,ModuleBuildTarget> dirtyFilesHolder=new DirtyFilesHolderBase<JavaSourceRootDescriptor,ModuleBuildTarget>(context){
        @Override public void processDirtyFiles(        @NotNull FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget> processor) throws IOException {
          FSOperations.processFilesToRecompile(context,chunk,processor);
        }
      }
;
      if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) {
        final Map<ModuleBuildTarget,Set<File>> cleanedSources=BuildOperations.cleanOutputsCorrespondingToChangedFiles(context,dirtyFilesHolder);
        for (        Map.Entry<ModuleBuildTarget,Set<File>> entry : cleanedSources.entrySet()) {
          final ModuleBuildTarget target=entry.getKey();
          final Set<File> files=entry.getValue();
          if (!files.isEmpty()) {
            final SourceToOutputMapping mapping=context.getProjectDescriptor().dataManager.getSourceToOutputMap(target);
            for (            File srcFile : files) {
              mapping.setOutputs(srcFile.getPath(),Collections.<String>emptyList());
            }
          }
        }
      }
      BUILDER_CATEGORY_LOOP:       for (      BuilderCategory category : BuilderCategory.values()) {
        final List<ModuleLevelBuilder> builders=myBuilderRegistry.getBuilders(category);
        if (category == BuilderCategory.CLASS_POST_PROCESSOR) {
          saveInstrumentedClasses(outputConsumer);
        }
        if (builders.isEmpty()) {
          continue;
        }
        try {
          for (          ModuleLevelBuilder builder : builders) {
            processDeletedPaths(context,chunk.getTargets());
            long start=System.nanoTime();
            int processedSourcesBefore=outputConsumer.getNumberOfProcessedSources();
            final ModuleLevelBuilder.ExitCode buildResult=builder.build(context,chunk,dirtyFilesHolder,outputConsumer);
            storeBuilderStatistics(builder,System.nanoTime() - start,outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore);
            doneSomething|=(buildResult != ModuleLevelBuilder.ExitCode.NOTHING_DONE);
            if (buildResult == ModuleLevelBuilder.ExitCode.ABORT) {
              throw new StopBuildException("Builder " + builder.getPresentableName() + " requested build stop");
            }
            context.checkCanceled();
            if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) {
              nextPassRequired=true;
            }
 else             if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) {
              if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) {
                LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk "+ chunk.getName());
                rebuildFromScratchRequested=true;
                try {
                  context.getProjectDescriptor().fsState.clearContextRoundData(context);
                  FSOperations.markDirty(context,CompilationRound.NEXT,chunk,null);
                  myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
                  stageCount=myTotalModuleLevelBuilderCount;
                  buildersPassed=0;
                  nextPassRequired=true;
                  outputConsumer.clear();
                  break BUILDER_CATEGORY_LOOP;
                }
 catch (                Exception e) {
                  throw new ProjectBuildException(e);
                }
              }
 else {
                LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild");
              }
            }
            buildersPassed++;
            updateDoneFraction(context,modulesInChunk / (stageCount));
          }
        }
  finally {
          final boolean moreToCompile=JavaBuilderUtil.updateMappingsOnRoundCompletion(context,dirtyFilesHolder,chunk);
          if (moreToCompile) {
            nextPassRequired=true;
          }
          if (nextPassRequired && !rebuildFromScratchRequested) {
            myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
            stageCount+=myTotalModuleLevelBuilderCount;
            myTargetsProcessed+=(buildersPassed * modulesInChunk) / stageCount;
          }
        }
      }
    }
 while (nextPassRequired);
  }
  finally {
    saveInstrumentedClasses(outputConsumer);
    outputConsumer.fireFileGeneratedEvents();
    outputConsumer.clear();
    for (    BuilderCategory category : BuilderCategory.values()) {
      for (      ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
        builder.chunkBuildFinished(context,chunk);
      }
    }
  }
  return doneSomething;
}
