{
  Set<? extends BuildTarget<?>> targets=chunk.getTargets();
  if (targets.size() > 1) {
    Set<ModuleBuildTarget> moduleTargets=new LinkedHashSet<ModuleBuildTarget>();
    for (    BuildTarget<?> target : targets) {
      if (target instanceof ModuleBuildTarget) {
        moduleTargets.add((ModuleBuildTarget)target);
      }
 else {
        context.processMessage(new CompilerMessage("",BuildMessage.Kind.ERROR,"Cannot build " + target.getPresentableName() + " because it is included into a circular dependency"));
        return false;
      }
    }
    return runModuleLevelBuilders(context,new ModuleChunk(moduleTargets));
  }
  final BuildTarget<?> target=targets.iterator().next();
  if (target instanceof ModuleBuildTarget) {
    return runModuleLevelBuilders(context,new ModuleChunk(Collections.singleton((ModuleBuildTarget)target)));
  }
  cleanOldOutputs(context,target);
  final List<TargetBuilder<?,?>> builders=BuilderRegistry.getInstance().getTargetBuilders();
  final float builderProgressDelta=1.0f / builders.size();
  for (  TargetBuilder<?,?> builder : builders) {
    buildTarget(target,context,builder);
    updateDoneFraction(context,builderProgressDelta);
  }
  return true;
}
