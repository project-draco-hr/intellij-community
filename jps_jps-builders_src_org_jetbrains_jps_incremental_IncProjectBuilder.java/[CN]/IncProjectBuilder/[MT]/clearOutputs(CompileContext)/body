{
  final long cleanStart=System.currentTimeMillis();
  final MultiMap<File,BuildTarget<?>> rootsToDelete=MultiMap.createSet();
  final Set<File> allSourceRoots=new HashSet<File>();
  final ProjectDescriptor projectDescriptor=context.getProjectDescriptor();
  final List<? extends BuildTarget<?>> allTargets=projectDescriptor.getBuildTargetIndex().getAllTargets();
  for (  BuildTarget<?> target : allTargets) {
    for (    File file : target.getOutputRoots(context)) {
      rootsToDelete.putValue(file,target);
    }
  }
  final ModuleExcludeIndex moduleIndex=projectDescriptor.getModuleExcludeIndex();
  for (  BuildTarget<?> target : allTargets) {
    for (    BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target,context)) {
      if (!descriptor.isGenerated()) {
        File rootFile=descriptor.getRootFile();
        if (moduleIndex.isInContent(rootFile)) {
          allSourceRoots.add(rootFile);
        }
      }
    }
  }
  final CompileScope compileScope=context.getScope();
  final List<File> filesToDelete=new ArrayList<File>();
  final Predicate<BuildTarget<?>> forcedBuild=new Predicate<BuildTarget<?>>(){
    public boolean apply(    BuildTarget<?> input){
      return compileScope.isBuildForced(input);
    }
  }
;
  for (  Map.Entry<File,Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) {
    context.checkCanceled();
    final File outputRoot=entry.getKey();
    final Collection<BuildTarget<?>> rootTargets=entry.getValue();
    final Applicability applicability=Applicability.calculate(forcedBuild,rootTargets);
    if (applicability == Applicability.NONE) {
      continue;
    }
    boolean okToDelete=applicability == Applicability.ALL;
    if (okToDelete && !moduleIndex.isExcluded(outputRoot)) {
      if (JpsPathUtil.isUnder(allSourceRoots,outputRoot)) {
        okToDelete=false;
      }
 else {
        final Set<File> _outRoot=Collections.singleton(outputRoot);
        for (        File srcRoot : allSourceRoots) {
          if (JpsPathUtil.isUnder(_outRoot,srcRoot)) {
            okToDelete=false;
            break;
          }
        }
      }
    }
    if (okToDelete) {
      final File[] children=outputRoot.listFiles();
      if (children != null) {
        for (        File child : children) {
          if (!child.delete()) {
            filesToDelete.add(child);
          }
        }
      }
 else {
        if (!outputRoot.delete()) {
          filesToDelete.add(outputRoot);
        }
      }
      registerTargetsWithClearedOutput(context,rootTargets);
    }
 else {
      if (applicability == Applicability.ALL) {
        context.processMessage(new CompilerMessage("",BuildMessage.Kind.WARNING,"Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."));
      }
      context.processMessage(new ProgressMessage("Cleaning output directories..."));
      for (      BuildTarget<?> target : rootTargets) {
        if (compileScope.isBuildForced(target)) {
          clearOutputFilesUninterruptibly(context,target);
        }
      }
    }
  }
  if (!filesToDelete.isEmpty()) {
    context.processMessage(new ProgressMessage("Cleaning output directories..."));
    if (SYNC_DELETE) {
      for (      File file : filesToDelete) {
        context.checkCanceled();
        FileUtil.delete(file);
      }
    }
 else {
      myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete));
    }
  }
  LOG.info("Cleaned output directories in " + (System.currentTimeMillis() - cleanStart) + " ms");
}
