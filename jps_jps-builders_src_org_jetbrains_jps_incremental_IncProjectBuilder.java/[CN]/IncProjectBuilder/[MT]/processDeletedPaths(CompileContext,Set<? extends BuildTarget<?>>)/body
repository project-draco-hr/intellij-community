{
  boolean doneSomething=false;
  try {
    final Map<BuildTarget<?>,Collection<String>> targetToRemovedSources=new HashMap<BuildTarget<?>,Collection<String>>();
    final THashSet<File> dirsToDelete=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
    for (    BuildTarget<?> target : targets) {
      final Collection<String> deletedPaths=myProjectDescriptor.fsState.getAndClearDeletedPaths(target);
      if (deletedPaths.isEmpty()) {
        continue;
      }
      targetToRemovedSources.put(target,deletedPaths);
      if (isTargetOutputCleared(context,target)) {
        continue;
      }
      final int buildTargetId=context.getProjectDescriptor().getTargetsState().getBuildTargetId(target);
      final boolean shouldPruneEmptyDirs=target instanceof ModuleBasedTarget;
      final SourceToOutputMapping sourceToOutputStorage=context.getProjectDescriptor().dataManager.getSourceToOutputMap(target);
      final ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
      final Collection<String> pathsForIteration;
      if (myIsTestMode) {
        pathsForIteration=new ArrayList<String>(deletedPaths);
        Collections.sort((List<String>)pathsForIteration);
      }
 else {
        pathsForIteration=deletedPaths;
      }
      for (      String deletedSource : pathsForIteration) {
        final Collection<String> outputs=sourceToOutputStorage.getOutputs(deletedSource);
        if (outputs != null && !outputs.isEmpty()) {
          List<String> deletedOutputPaths=new ArrayList<String>();
          final OutputToTargetRegistry outputToSourceRegistry=context.getProjectDescriptor().dataManager.getOutputToTargetRegistry();
          for (          String output : outputToSourceRegistry.getSafeToDeleteOutputs(outputs,buildTargetId)) {
            final boolean deleted=BuildOperations.deleteRecursively(output,deletedOutputPaths,shouldPruneEmptyDirs ? dirsToDelete : null);
            if (deleted) {
              doneSomething=true;
            }
          }
          for (          String outputPath : outputs) {
            outputToSourceRegistry.removeMapping(outputPath,buildTargetId);
          }
          if (!deletedOutputPaths.isEmpty()) {
            if (logger.isEnabled()) {
              logger.logDeletedFiles(deletedOutputPaths);
            }
            context.processMessage(new FileDeletedEvent(deletedOutputPaths));
          }
        }
        if (target instanceof ModuleBuildTarget) {
          final OneToManyPathsMapping sourceToFormMap=context.getProjectDescriptor().dataManager.getSourceToFormMap();
          final Collection<String> boundForms=sourceToFormMap.getState(deletedSource);
          if (boundForms != null) {
            for (            String formPath : boundForms) {
              final File formFile=new File(formPath);
              if (formFile.exists()) {
                FSOperations.markDirty(context,CompilationRound.CURRENT,formFile);
              }
            }
            sourceToFormMap.remove(deletedSource);
          }
        }
      }
    }
    if (!targetToRemovedSources.isEmpty()) {
      final Map<BuildTarget<?>,Collection<String>> existing=Utils.REMOVED_SOURCES_KEY.get(context);
      if (existing != null) {
        for (        Map.Entry<BuildTarget<?>,Collection<String>> entry : existing.entrySet()) {
          final Collection<String> paths=targetToRemovedSources.get(entry.getKey());
          if (paths != null) {
            paths.addAll(entry.getValue());
          }
 else {
            targetToRemovedSources.put(entry.getKey(),entry.getValue());
          }
        }
      }
      Utils.REMOVED_SOURCES_KEY.set(context,targetToRemovedSources);
    }
    FSOperations.pruneEmptyDirs(context,dirsToDelete);
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
  return doneSomething;
}
