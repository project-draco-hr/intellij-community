{
  boolean doneSomething;
  try {
    sendBuildingTargetMessages(chunk.getTargets(),BuildingTargetProgressMessage.Event.STARTED);
    Utils.ERRORS_DETECTED_KEY.set(context,Boolean.FALSE);
    for (    BuildTarget<?> target : chunk.getTargets()) {
      BuildOperations.ensureFSStateInitialized(context,target);
    }
    doneSomething=processDeletedPaths(context,chunk.getTargets());
    myProjectDescriptor.fsState.beforeChunkBuildStart(context,chunk);
    doneSomething|=runBuildersForChunk(context,chunk);
    onChunkBuildComplete(context,chunk);
  }
 catch (  BuildDataCorruptedException e) {
    throw e;
  }
catch (  ProjectBuildException e) {
    throw e;
  }
catch (  Throwable e) {
    final StringBuilder message=new StringBuilder();
    message.append(chunk.getPresentableName()).append(": ").append(e.getClass().getName());
    final String exceptionMessage=e.getMessage();
    if (exceptionMessage != null) {
      message.append(" :").append(exceptionMessage);
    }
    throw new ProjectBuildException(message.toString(),e);
  }
 finally {
    for (    BuildRootDescriptor rd : context.getProjectDescriptor().getBuildRootIndex().clearTempRoots(context)) {
      context.getProjectDescriptor().fsState.clearRecompile(rd);
    }
    try {
      final Map<BuildTarget<?>,Collection<String>> map=Utils.REMOVED_SOURCES_KEY.get(context);
      if (map != null) {
        for (        Map.Entry<BuildTarget<?>,Collection<String>> entry : map.entrySet()) {
          final BuildTarget<?> target=entry.getKey();
          final Collection<String> paths=entry.getValue();
          if (paths != null) {
            for (            String path : paths) {
              myProjectDescriptor.fsState.registerDeleted(target,new File(path),null);
            }
          }
        }
      }
    }
 catch (    IOException e) {
      throw new ProjectBuildException(e);
    }
 finally {
      Utils.REMOVED_SOURCES_KEY.set(context,null);
    }
    sendBuildingTargetMessages(chunk.getTargets(),BuildingTargetProgressMessage.Event.FINISHED);
  }
}
