{
  final LowMemoryWatcher memWatcher=LowMemoryWatcher.register(new Runnable(){
    @Override public void run(){
      JavacMain.clearCompilerZipFileCache();
      myProjectDescriptor.dataManager.flush(false);
      myProjectDescriptor.timestamps.getStorage().force();
    }
  }
);
  startTempDirectoryCleanupTask();
  CompileContextImpl context=null;
  try {
    context=createContext(scope);
    runBuild(context,forceCleanCaches);
    myProjectDescriptor.dataManager.saveVersion();
    reportRebuiltModules(context);
    reportUnprocessedChanges(context);
  }
 catch (  StopBuildException e) {
    reportRebuiltModules(context);
    reportUnprocessedChanges(context);
    final String msg=e.getMessage();
    if (!StringUtil.isEmptyOrSpaces(msg)) {
      myMessageDispatcher.processMessage(new ProgressMessage(msg));
    }
  }
catch (  BuildDataCorruptedException e) {
    LOG.info(e);
    requestRebuild(e,e);
  }
catch (  ProjectBuildException e) {
    LOG.info(e);
    final Throwable cause=e.getCause();
    if (cause instanceof PersistentEnumerator.CorruptedException || cause instanceof MappingFailedException || cause instanceof IOException|| cause instanceof BuildDataCorruptedException) {
      requestRebuild(e,cause);
    }
 else {
      final String errMessage=e.getMessage();
      final CompilerMessage msg;
      if (StringUtil.isEmptyOrSpaces(errMessage)) {
        msg=new CompilerMessage("",cause != null ? cause : e);
      }
 else {
        final String causeMessage=cause != null ? cause.getMessage() : "";
        msg=new CompilerMessage("",BuildMessage.Kind.ERROR,StringUtil.isEmptyOrSpaces(causeMessage) || errMessage.trim().endsWith(causeMessage) ? errMessage : errMessage + ": " + causeMessage);
      }
      myMessageDispatcher.processMessage(msg);
    }
  }
 finally {
    memWatcher.stop();
    flushContext(context);
    final CanceledStatus status=context == null ? CanceledStatus.NULL : context.getCancelStatus();
synchronized (myAsyncTasks) {
      for (      Future task : myAsyncTasks) {
        if (status.isCanceled()) {
          break;
        }
        waitForTask(status,task);
      }
    }
  }
}
