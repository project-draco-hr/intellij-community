{
  context.setDone(0.0f);
  LOG.info("Building project; isRebuild:" + context.isProjectRebuild() + "; isMake:"+ context.isMake()+ " parallel compilation:"+ BuildRunner.PARALLEL_BUILD_ENABLED);
  context.addBuildListener(new ChainedTargetsBuildListener(context));
  context.addBuildListener(new BuildListener(){
    @Override public void filesGenerated(    Collection<Pair<String,String>> paths){
      final Set<File> outputs=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
      for (      Pair<String,String> pair : paths) {
        outputs.add(new File(pair.getFirst()));
      }
      for (      File root : outputs) {
        new File(root,CLASSPATH_INDEX_FILE_NAME).delete();
      }
    }
    @Override public void filesDeleted(    Collection<String> paths){
    }
  }
);
  for (  TargetBuilder builder : myBuilderRegistry.getTargetBuilders()) {
    builder.buildStarted(context);
  }
  for (  ModuleLevelBuilder builder : myBuilderRegistry.getModuleLevelBuilders()) {
    builder.buildStarted(context);
  }
  try {
    if (context.isProjectRebuild() || forceCleanCaches) {
      cleanOutputRoots(context);
    }
    context.processMessage(new ProgressMessage("Running 'before' tasks"));
    runTasks(context,myBuilderRegistry.getBeforeTasks());
    TimingLog.LOG.debug("'before' tasks finished");
    context.processMessage(new ProgressMessage("Checking sources"));
    buildChunks(context);
    TimingLog.LOG.debug("Building targets finished");
    context.processMessage(new ProgressMessage("Running 'after' tasks"));
    runTasks(context,myBuilderRegistry.getAfterTasks());
    TimingLog.LOG.debug("'after' tasks finished");
    sendElapsedTimeMessages(context);
  }
  finally {
    for (    TargetBuilder builder : myBuilderRegistry.getTargetBuilders()) {
      builder.buildFinished(context);
    }
    for (    ModuleLevelBuilder builder : myBuilderRegistry.getModuleLevelBuilders()) {
      builder.buildFinished(context);
    }
    context.processMessage(new ProgressMessage("Finished, saving caches..."));
  }
}
