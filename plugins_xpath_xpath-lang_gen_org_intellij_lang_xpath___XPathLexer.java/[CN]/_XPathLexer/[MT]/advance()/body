{
  int zzInput;
  int zzAction;
  int zzCurrentPosL;
  int zzMarkedPosL;
  int zzEndReadL=zzEndRead;
  CharSequence zzBufferL=zzBuffer;
  char[] zzCMapL=ZZ_CMAP;
  int[] zzTransL=ZZ_TRANS;
  int[] zzRowMapL=ZZ_ROWMAP;
  int[] zzAttrL=ZZ_ATTRIBUTE;
  while (true) {
    zzMarkedPosL=zzMarkedPos;
    zzAction=-1;
    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;
    zzState=ZZ_LEXSTATE[zzLexicalState];
    int zzAttributes=zzAttrL[zzState];
    if ((zzAttributes & 1) == 1) {
      zzAction=zzState;
    }
    zzForAction: {
      while (true) {
        if (zzCurrentPosL < zzEndReadL) {
          zzInput=Character.codePointAt(zzBufferL,zzCurrentPosL);
          zzCurrentPosL+=Character.charCount(zzInput);
        }
 else         if (zzAtEOF) {
          zzInput=YYEOF;
          break zzForAction;
        }
 else {
          zzCurrentPos=zzCurrentPosL;
          zzMarkedPos=zzMarkedPosL;
          boolean eof=zzRefill();
          zzCurrentPosL=zzCurrentPos;
          zzMarkedPosL=zzMarkedPos;
          zzBufferL=zzBuffer;
          zzEndReadL=zzEndRead;
          if (eof) {
            zzInput=YYEOF;
            break zzForAction;
          }
 else {
            zzInput=Character.codePointAt(zzBufferL,zzCurrentPosL);
            zzCurrentPosL+=Character.charCount(zzInput);
          }
        }
        if (zzInput >= zzCMapL.length)         ZZ_CMAP=zzCMapL=zzInput >= ZZ_MX ? L.MAP : M.MAP;
        int zzNext=zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
        if (zzNext == -1)         break zzForAction;
        zzState=zzNext;
        zzAttributes=zzAttrL[zzState];
        if ((zzAttributes & 1) == 1) {
          zzAction=zzState;
          zzMarkedPosL=zzCurrentPosL;
          if ((zzAttributes & 8) == 8)           break zzForAction;
        }
      }
    }
    zzMarkedPos=zzMarkedPosL;
    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
      zzAtEOF=true;
      return null;
    }
 else {
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
case 1:
{
          yybegin(YYINITIAL);
          return XPathTokenTypes.BAD_CHARACTER;
        }
case 81:
      break;
case 2:
{
      return XPathTokenTypes.WHITESPACE;
    }
case 82:
  break;
case 3:
{
  yybegin(S1);
  return XPathTokenTypes.NCNAME;
}
case 83:
break;
case 4:
{
yybegin(S1);
return XPathTokenTypes.NUMBER;
}
case 84:
break;
case 5:
{
yybegin(S1);
return XPathTokenTypes.DOT;
}
case 85:
break;
case 6:
{
yybegin(YYINITIAL);
return XPathTokenTypes.MINUS;
}
case 86:
break;
case 7:
{
yybegin(YYINITIAL);
return XPathTokenTypes.COL;
}
case 87:
break;
case 8:
{
yybegin(S1);
return XPathTokenTypes.STRING_LITERAL;
}
case 88:
break;
case 9:
{
yybegin(YYINITIAL);
return XPathTokenTypes.PLUS;
}
case 89:
break;
case 10:
{
yybegin(YYINITIAL);
return XPathTokenTypes.LPAREN;
}
case 90:
break;
case 11:
{
yybegin(S1);
return XPathTokenTypes.RPAREN;
}
case 91:
break;
case 12:
{
yybegin(VAR);
return XPathTokenTypes.DOLLAR;
}
case 92:
break;
case 13:
{
yybegin(YYINITIAL);
return XPathTokenTypes.LT;
}
case 93:
break;
case 14:
{
yybegin(YYINITIAL);
return XPathTokenTypes.GT;
}
case 94:
break;
case 15:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.QUEST;
}
 else {
return XPathTokenTypes.BAD_CHARACTER;
}
}
case 95:
break;
case 16:
{
yybegin(S1);
return XPathTokenTypes.STAR;
}
case 96:
break;
case 17:
{
yybegin(YYINITIAL);
return XPathTokenTypes.AT;
}
case 97:
break;
case 18:
{
yybegin(YYINITIAL);
return XPathTokenTypes.COMMA;
}
case 98:
break;
case 19:
{
yybegin(YYINITIAL);
return XPathTokenTypes.PATH;
}
case 99:
break;
case 20:
{
yybegin(YYINITIAL);
return XPathTokenTypes.UNION;
}
case 100:
break;
case 21:
{
yybegin(YYINITIAL);
return XPathTokenTypes.EQ;
}
case 101:
break;
case 22:
{
yybegin(YYINITIAL);
return XPathTokenTypes.LBRACKET;
}
case 102:
break;
case 23:
{
yybegin(S1);
return XPathTokenTypes.RBRACKET;
}
case 103:
break;
case 24:
{
return XPathTokenTypes.LBRACE;
}
case 104:
break;
case 25:
{
return XPathTokenTypes.RBRACE;
}
case 105:
break;
case 26:
{
yybegin(YYINITIAL);
return XPathTokenTypes.MULT;
}
case 106:
break;
case 27:
{
yybegin(S1);
return XPathTokenTypes.VARIABLE_NAME;
}
case 107:
break;
case 28:
{
return XPathTokenTypes.COL;
}
case 108:
break;
case 29:
{
return XPathTokenTypes.NCNAME;
}
case 109:
break;
case 30:
{
yybegin(S1);
return XPathTokenTypes.PLUS;
}
case 110:
break;
case 31:
{
return XPathTokenTypes.LPAREN;
}
case 111:
break;
case 32:
{
return XPathTokenTypes.RPAREN;
}
case 112:
break;
case 33:
{
yybegin(S1);
return XPath2TokenTypes.QUEST;
}
case 113:
break;
case 34:
{
yybegin(S1);
return XPathTokenTypes.STAR;
}
case 114:
break;
case 35:
{
yybegin(S1);
return XPathTokenTypes.DOTDOT;
}
case 115:
break;
case 36:
{
yybegin(YYINITIAL);
return XPathTokenTypes.COLCOL;
}
case 116:
break;
case 37:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.END_COMMENT;
}
 else {
yypushback(1);
return XPathTokenTypes.COL;
}
}
case 117:
break;
case 38:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WNE;
}
 else {
return ncName();
}
}
case 118:
break;
case 39:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WEQ;
}
 else {
return ncName();
}
}
case 119:
break;
case 40:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WLE;
}
 else {
return ncName();
}
}
case 120:
break;
case 41:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WLT;
}
 else {
return ncName();
}
}
case 121:
break;
case 42:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.IS;
}
 else {
return ncName();
}
}
case 122:
break;
case 43:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.IF;
}
 else {
return ncName();
}
}
case 123:
break;
case 44:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WGE;
}
 else {
return ncName();
}
}
case 124:
break;
case 45:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.WGT;
}
 else {
return ncName();
}
}
case 125:
break;
case 46:
{
if (allowXPath2Syntax) {
readComment();
return XPath2TokenTypes.COMMENT;
}
 else {
yypushback(1);
return XPathTokenTypes.LPAREN;
}
}
case 126:
break;
case 47:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.BEFORE;
}
 else {
yypushback(1);
return XPathTokenTypes.LT;
}
}
case 127:
break;
case 48:
{
yybegin(YYINITIAL);
return XPathTokenTypes.LE;
}
case 128:
break;
case 49:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.AFTER;
}
 else {
yypushback(1);
return XPathTokenTypes.GT;
}
}
case 129:
break;
case 50:
{
yybegin(YYINITIAL);
return XPathTokenTypes.GE;
}
case 130:
break;
case 51:
{
yybegin(YYINITIAL);
return XPathTokenTypes.ANY_PATH;
}
case 131:
break;
case 52:
{
yybegin(YYINITIAL);
return XPathTokenTypes.NE;
}
case 132:
break;
case 53:
{
if (allowXPath2Syntax) {
yybegin(TYPE);
return XPath2TokenTypes.AS;
}
 else {
return ncName();
}
}
case 133:
break;
case 54:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.TO;
}
 else {
return ncName();
}
}
case 134:
break;
case 55:
{
yybegin(YYINITIAL);
return XPathTokenTypes.OR;
}
case 135:
break;
case 56:
{
if (allowXPath2Syntax) {
yybegin(TYPE);
return XPath2TokenTypes.OF;
}
 else {
return ncName();
}
}
case 136:
break;
case 57:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.IN;
}
 else {
return ncName();
}
}
case 137:
break;
case 58:
{
int zzFState=4;
int zzFPos=zzStartRead;
if (zzFin.length <= zzBufferL.length()) {
zzFin=new boolean[zzBufferL.length() + 1];
}
boolean zzFinL[]=zzFin;
while (zzFState != -1 && zzFPos < zzMarkedPos) {
zzFinL[zzFPos]=((zzAttrL[zzFState] & 1) == 1);
zzInput=Character.codePointAt(zzBufferL,zzFPos);
zzFPos+=Character.charCount(zzInput);
if (zzInput >= zzCMapL.length) ZZ_CMAP=zzCMapL=zzInput >= ZZ_MX ? L.MAP : M.MAP;
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
if (zzFState != -1) {
zzFinL[zzFPos++]=((zzAttrL[zzFState] & 1) == 1);
}
while (zzFPos <= zzMarkedPos) {
zzFinL[zzFPos++]=false;
}
zzFState=5;
zzFPos=zzMarkedPos;
while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
zzInput=Character.codePointBefore(zzBufferL,zzFPos);
zzFPos-=Character.charCount(zzInput);
if (zzInput >= zzCMapL.length) ZZ_CMAP=zzCMapL=zzInput >= ZZ_MX ? L.MAP : M.MAP;
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
;
zzMarkedPos=zzFPos;
}
{
return XPathTokenTypes.VARIABLE_PREFIX;
}
case 138:
break;
case 59:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.FOR;
}
 else {
return ncName();
}
}
case 139:
break;
case 60:
{
yybegin(YYINITIAL);
return XPathTokenTypes.AND;
}
case 140:
break;
case 61:
{
yybegin(YYINITIAL);
return XPathTokenTypes.DIV;
}
case 141:
break;
case 62:
{
yybegin(YYINITIAL);
return XPathTokenTypes.MOD;
}
case 142:
break;
case 63:
{
yybegin(S1);
return XPathTokenTypes.NODE_TYPE;
}
case 143:
break;
case 64:
{
yybegin(S1);
return XPathTokenTypes.AXIS_NAME;
}
case 144:
break;
case 65:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.SOME;
}
 else {
return ncName();
}
}
case 145:
break;
case 66:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.CAST;
}
 else {
return ncName();
}
}
case 146:
break;
case 67:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.ELSE;
}
 else {
return ncName();
}
}
case 147:
break;
case 68:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.THEN;
}
 else {
return ncName();
}
}
case 148:
break;
case 69:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.IDIV;
}
 else {
return ncName();
}
}
case 149:
break;
case 70:
{
return XPath2TokenTypes.ITEM;
}
case 150:
break;
case 71:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.EVERY;
}
 else {
return ncName();
}
}
case 151:
break;
case 72:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.TREAT;
}
 else {
return ncName();
}
}
case 152:
break;
case 73:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.UNION;
}
 else {
return ncName();
}
}
case 153:
break;
case 74:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.EXCEPT;
}
 else {
return ncName();
}
}
case 154:
break;
case 75:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.RETURN;
}
 else {
return ncName();
}
}
case 155:
break;
case 76:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.CASTABLE;
}
 else {
return ncName();
}
}
case 156:
break;
case 77:
{
if (allowXPath2Syntax) {
return XPath2TokenTypes.INSTANCE;
}
 else {
return ncName();
}
}
case 157:
break;
case 78:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.SATISFIES;
}
 else {
return ncName();
}
}
case 158:
break;
case 79:
{
if (allowXPath2Syntax) {
yybegin(YYINITIAL);
return XPath2TokenTypes.INTERSECT;
}
 else {
return ncName();
}
}
case 159:
break;
case 80:
{
yybegin(YYINITIAL);
return XPath2TokenTypes.EMPTY_SEQUENCE;
}
case 160:
break;
default :
zzScanError(ZZ_NO_MATCH);
}
}
}
}
