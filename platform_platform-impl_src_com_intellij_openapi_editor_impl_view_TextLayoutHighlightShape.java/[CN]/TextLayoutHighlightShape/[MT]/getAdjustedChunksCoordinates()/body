{
  TFloatArrayList[] coords=new TFloatArrayList[]{new TFloatArrayList(),new TFloatArrayList()};
  PathIterator it=myShape.getPathIterator(null);
  float[] data=new float[6];
  while (!it.isDone()) {
switch (it.currentSegment(data)) {
case PathIterator.SEG_MOVETO:
case PathIterator.SEG_LINETO:
      addBoundaryPoint(data[0],data[1],coords);
    break;
case PathIterator.SEG_QUADTO:
  addBoundaryPoint(data[2],data[3],coords);
break;
case PathIterator.SEG_CUBICTO:
addBoundaryPoint(data[4],data[5],coords);
}
it.next();
}
if (coords[0].isEmpty() || coords[0].size() != coords[1].size() || coords[0].size() % 2 != 0 || coords[1].size() % 2 != 0) return null;
coords[0].sort();
coords[1].sort();
int pos=2;
while (pos < coords[0].size()) {
if (coords[0].get(pos) == coords[0].get(pos - 1) && coords[1].get(pos) == coords[1].get(pos - 1)) {
coords[0].remove(pos - 1,2);
coords[1].remove(pos - 1,2);
}
 else {
pos+=2;
}
}
for (int i=0; i < coords[0].size(); i+=2) {
float topStart=coords[0].get(i);
float topEnd=coords[0].get(i + 1);
float bottomStart=coords[1].get(i);
float bottomEnd=coords[1].get(i + 1);
if (topStart == topEnd) {
coords[0].set(i + 1,topEnd + 1);
}
 else {
coords[0].set(i + 1,topEnd - 1);
}
if (bottomStart == bottomEnd) {
coords[1].set(i + 1,bottomEnd + 1);
}
 else {
float slopeLeft=(bottomStart - topStart) / myHeight;
float slopeRight=(bottomEnd - topEnd) / myHeight;
coords[1].set(i,bottomStart - slopeLeft);
coords[1].set(i + 1,bottomEnd - 1 - slopeRight);
}
}
return coords;
}
