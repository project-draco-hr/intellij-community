{
  TFloatArrayList[] leadingCoords=leadingShape.getAdjustedChunksCoordinates();
  TFloatArrayList[] trailingCoords=trailingShape.getAdjustedChunksCoordinates();
  if (leadingCoords == null || trailingCoords == null)   return;
  maxWidth--;
  boolean containsInnerLines=verticalShift > leadingShape.myHeight;
  Path2D.Float path=new Path2D.Float();
  float bottomY=leadingShape.myHeight - 1;
  float topStart=0;
  float topEnd=0;
  float bottomStart;
  float bottomEnd=0;
  float leftGap=leadingCoords[1].get(0) - (containsInnerLines ? 0 : trailingCoords[0].get(0));
  float adjustY=leftGap == 0 ? 2 : leftGap > 0 ? 1 : 0;
  for (int i=0; i < leadingCoords[0].size(); i+=2) {
    topStart=leadingCoords[0].get(i);
    topEnd=leadingCoords[0].get(i + 1);
    bottomStart=leadingCoords[1].get(i);
    bottomEnd=leadingCoords[1].get(i + 1);
    if (i > 0) {
      addLine(path,leadingCoords[1].get(i - 1),bottomY,bottomStart,bottomY,rounded);
    }
    addLine(path,bottomStart,bottomY + adjustY,topStart,0,rounded);
    if ((i + 2) < leadingCoords[0].size() || !extendFirstLineToTheRight) {
      addLine(path,topStart,0,topEnd,0,rounded);
      addLine(path,topEnd,0,bottomEnd,bottomY,rounded);
    }
    adjustY=0;
  }
  if (extendFirstLineToTheRight) {
    topEnd=Math.max(topEnd,maxWidth);
    addLine(path,topStart,0,topEnd,0,rounded);
    addLine(path,topEnd,0,topEnd,verticalShift - 1,rounded);
  }
 else   if (containsInnerLines) {
    if (bottomEnd < maxWidth) {
      addLine(path,bottomEnd,bottomY + 1,rounded);
      addLine(path,bottomEnd,bottomY + 1,maxWidth,bottomY + 1,rounded);
      addLine(path,maxWidth,bottomY + 1,maxWidth,verticalShift - 1,rounded);
    }
 else {
      addLine(path,bottomEnd,verticalShift - 1,rounded);
    }
  }
  bottomY=trailingShape.myHeight - 1 + verticalShift;
  float lastX=(float)path.getCurrentPoint().getX();
  float targetX=trailingCoords[0].get(trailingCoords[0].size() - 1);
  if (lastX < targetX) {
    addLine(path,lastX,verticalShift,rounded);
    addLine(path,lastX,verticalShift,targetX,verticalShift,rounded);
  }
 else {
    addLine(path,lastX,verticalShift - 1,targetX,verticalShift - 1,rounded);
    adjustY=lastX == targetX ? -2 : -1;
  }
  for (int i=trailingCoords[0].size() - 2; i >= 0; i-=2) {
    topStart=trailingCoords[0].get(i);
    topEnd=trailingCoords[0].get(i + 1);
    bottomStart=trailingCoords[1].get(i);
    bottomEnd=trailingCoords[1].get(i + 1);
    addLine(path,topEnd,verticalShift + adjustY,bottomEnd,bottomY,rounded);
    addLine(path,bottomEnd,bottomY,bottomStart,bottomY,rounded);
    addLine(path,bottomStart,bottomY,topStart,verticalShift,rounded);
    if (i > 0) {
      addLine(path,topStart,verticalShift,trailingCoords[0].get(i - 1),verticalShift,rounded);
    }
    adjustY=0;
  }
  if (containsInnerLines) {
    if (topStart > 0) {
      addLine(path,topStart,verticalShift + 1,rounded);
      addLine(path,topStart,verticalShift + 1,0,verticalShift + 1,rounded);
      addLine(path,0,verticalShift + 1,0,leadingShape.myHeight,rounded);
    }
 else {
      addLine(path,0,leadingShape.myHeight,rounded);
    }
  }
  lastX=(float)path.getCurrentPoint().getX();
  targetX=leadingCoords[1].get(0);
  bottomY=leadingShape.myHeight - 1;
  if (lastX < targetX) {
    addLine(path,lastX,bottomY + 1,targetX,bottomY + 1,rounded);
  }
 else {
    addLine(path,lastX,bottomY,rounded);
    addLine(path,lastX,bottomY,targetX,bottomY,rounded);
  }
  g.setStroke(DEFAULT_STROKE);
  g.draw(path);
}
