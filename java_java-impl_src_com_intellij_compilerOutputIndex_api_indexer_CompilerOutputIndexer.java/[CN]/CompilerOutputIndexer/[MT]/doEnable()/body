{
  if (!myInitialized) {
    myIndexes=Extensions.getExtensions(CompilerOutputBaseIndex.EXTENSION_POINT_NAME,myProject);
    myIndexTypeQNameToIndex=new HashMap<String,CompilerOutputBaseIndex>();
    boolean needReindex=false;
    for (    final CompilerOutputBaseIndex index : myIndexes) {
      if (index.init(myProject)) {
        needReindex=true;
      }
      myIndexTypeQNameToIndex.put(index.getClass().getCanonicalName(),index);
    }
    initTimestampIndex(needReindex);
    File storageFile=IndexInfrastructure.getStorageFile(CompilerOutputIndexUtil.generateIndexId("compilerOutputIndexFileId.enum",myProject));
    for (int i=0; i < 2; ++i) {
      try {
        myFileEnumerator=new PersistentEnumeratorDelegate<String>(storageFile,new EnumeratorStringDescriptor(),2048);
      }
 catch (      IOException e) {
        if (i == 1)         throw new RuntimeException(e);
        IOUtil.deleteAllFilesStartingWith(storageFile);
      }
    }
    CompilerManager.getInstance(myProject).addCompilationStatusListener(new CompilationStatusAdapter(){
      @Override public void fileGenerated(      final String outputRoot,      final String relativePath){
        if (StringUtil.endsWith(relativePath,CompilerOutputFilesUtil.CLASS_FILES_SUFFIX) && myEnabled) {
          try {
            doIndexing(new File(outputRoot,relativePath),null);
          }
 catch (          ProcessCanceledException e0) {
            throw e0;
          }
catch (          RuntimeException e) {
            LOG.error(e);
          }
        }
      }
    }
,myProject);
    if (needReindex) {
      reindexAllProjectInBackground();
    }
    myInitialized=true;
  }
}
