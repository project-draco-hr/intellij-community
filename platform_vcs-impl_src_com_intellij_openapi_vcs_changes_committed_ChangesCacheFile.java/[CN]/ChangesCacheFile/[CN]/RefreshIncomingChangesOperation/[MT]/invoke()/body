{
  final DiffProvider diffProvider=myChangesCacheFile.myVcs.getDiffProvider();
  if (diffProvider == null)   return false;
  myChangesCacheFile.myLocation.onBeforeBatch();
  final Collection<FilePath> incomingFiles=myChangesCacheFile.myChangesProvider.getIncomingFiles(myChangesCacheFile.myLocation);
  myAnyChanges=false;
  myChangesCacheFile.openStreams();
  myChangesCacheFile.loadHeader();
  myCurrentRevisions=new FactoryMap<VirtualFile,VcsRevisionNumber>(){
    protected VcsRevisionNumber create(    final VirtualFile key){
      return diffProvider.getCurrentRevision(key);
    }
  }
;
  try {
    IncomingChangeState.header(myChangesCacheFile.myLocation.toPresentableString());
    final List<IncomingChangeListData> list=myChangesCacheFile.loadIncomingChangeListData();
    boolean shouldChangeHeader;
    if (incomingFiles != null && incomingFiles.isEmpty()) {
      shouldChangeHeader=!list.isEmpty();
      for (      IncomingChangeListData data : list) {
        myChangesCacheFile.saveIncoming(data,true);
      }
    }
 else {
      shouldChangeHeader=refreshIncomingInFile(incomingFiles,list);
    }
    IncomingChangeState.footer();
    if (shouldChangeHeader) {
      myChangesCacheFile.writeHeader();
    }
  }
  finally {
    myChangesCacheFile.myLocation.onAfterBatch();
    myChangesCacheFile.closeStreams();
  }
  return myAnyChanges;
}
