{
  final PsiMethod method=methodCallExpression.resolveMethod();
  if (method == null) {
    return false;
  }
  final PsiReferenceList throwsList=method.getThrowsList();
  final PsiClassType[] classTypes=throwsList.getReferencedTypes();
  final Collection<PsiClassType> thrownTypes=new HashSet<PsiClassType>(Arrays.asList(classTypes));
  final List<PsiMethod> superMethods=findAllSuperMethods(method);
  boolean checked=false;
  if (!superMethods.isEmpty()) {
    final PsiType expectedType=ExpectedTypeUtils.findExpectedType(methodCallExpression,false);
    for (    PsiMethod superMethod : superMethods) {
      final PsiType returnType=superMethod.getReturnType();
      if (expectedType instanceof PsiClassType) {
        if (!(returnType instanceof PsiClassType)) {
          continue;
        }
        final PsiClassType expectedClassType=(PsiClassType)expectedType;
        expectedClassType.rawType().isAssignableFrom(returnType);
      }
 else       if (expectedType != null && returnType != null && !expectedType.isAssignableFrom(returnType)) {
        continue;
      }
      if (throwsIncompatibleException(superMethod,thrownTypes)) {
        continue;
      }
      if (!PsiUtil.isAccessible(superMethod,methodCallExpression,null)) {
        continue;
      }
      final PsiClass containingClass=superMethod.getContainingClass();
      if (checkClass(containingClass,weakestTypeClasses)) {
        checked=true;
        break;
      }
    }
  }
  if (!checked) {
    if (TypeUtils.isTypeParameter(method.getReturnType())) {
      return false;
    }
    final PsiClass containingClass=method.getContainingClass();
    checkClass(containingClass,weakestTypeClasses);
  }
  return true;
}
