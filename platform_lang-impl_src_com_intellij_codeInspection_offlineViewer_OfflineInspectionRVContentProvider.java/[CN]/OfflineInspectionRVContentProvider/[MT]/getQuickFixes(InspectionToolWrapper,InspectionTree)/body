{
  final TreePath[] treePaths=tree.getSelectionPaths();
  if (treePaths == null)   return QuickFixAction.EMPTY;
  final List<RefEntity> selectedElements=new ArrayList<RefEntity>();
  final Map<RefEntity,CommonProblemDescriptor[]> actions=new HashMap<>();
  for (  TreePath selectionPath : treePaths) {
    TreeUtil.traverseDepth((TreeNode)selectionPath.getLastPathComponent(),new TreeUtil.Traverse(){
      @Override public boolean accept(      final Object node){
        if (!((InspectionTreeNode)node).isValid())         return true;
        if (node instanceof OfflineProblemDescriptorNode) {
          final OfflineProblemDescriptorNode descriptorNode=(OfflineProblemDescriptorNode)node;
          final RefEntity element=descriptorNode.getElement();
          selectedElements.add(element);
          CommonProblemDescriptor[] quickFixes=actions.get(element);
          actions.put(element,quickFixes == null ? new CommonProblemDescriptor[]{descriptorNode.getDescriptor()} : DefaultInspectionToolPresentation.mergeDescriptors(quickFixes,new CommonProblemDescriptor[]{descriptorNode.getDescriptor()}));
        }
 else         if (node instanceof RefElementNode) {
          selectedElements.add(((RefElementNode)node).getElement());
        }
        return true;
      }
    }
);
  }
  if (selectedElements.isEmpty())   return null;
  final RefEntity[] selectedRefElements=selectedElements.toArray(new RefEntity[selectedElements.size()]);
  GlobalInspectionContextImpl context=tree.getContext();
  InspectionToolPresentation presentation=context.getPresentation(toolWrapper);
  return presentation.extractActiveFixes(selectedRefElements,actions,tree.getSelectedDescriptors());
}
