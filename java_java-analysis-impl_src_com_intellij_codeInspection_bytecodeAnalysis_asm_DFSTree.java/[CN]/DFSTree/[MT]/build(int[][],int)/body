{
  HashSet<Edge> nonBack=new HashSet<>();
  HashSet<Edge> back=new HashSet<>();
  boolean[] marked=new boolean[transitions.length];
  boolean[] scanned=new boolean[transitions.length];
  int[] preOrder=new int[transitions.length];
  int[] postOrder=new int[transitions.length];
  int entered=0;
  int completed=0;
  boolean[] loopEnters=new boolean[transitions.length];
  entered++;
  preOrder[0]=entered;
  marked[0]=true;
  boolean[] stackFlag=new boolean[edgeCount * 2 + 1];
  int[] stackFrom=new int[edgeCount * 2 + 1];
  int[] stackTo=new int[edgeCount * 2 + 1];
  int top=0;
  stackFlag[top]=true;
  stackTo[top]=0;
  top++;
  for (  int to : transitions[0]) {
    stackFlag[top]=false;
    stackFrom[top]=0;
    stackTo[top]=to;
    top++;
  }
  while (top > 0) {
    top--;
    if (stackFlag[top]) {
      completed++;
      postOrder[stackTo[top]]=completed;
      scanned[stackTo[top]]=true;
    }
 else {
      int from=stackFrom[top];
      int to=stackTo[top];
      if (!marked[to]) {
        nonBack.add(new Edge(from,to));
        entered++;
        preOrder[to]=entered;
        marked[to]=true;
        stackFlag[top]=true;
        stackTo[top]=to;
        top++;
        for (        int to1 : transitions[to]) {
          stackFlag[top]=false;
          stackFrom[top]=to;
          stackTo[top]=to1;
          top++;
        }
      }
 else       if (preOrder[to] > preOrder[from]) {
        nonBack.add(new Edge(from,to));
      }
 else       if (preOrder[to] < preOrder[from] && !scanned[to]) {
        back.add(new Edge(from,to));
        loopEnters[to]=true;
      }
 else {
        nonBack.add(new Edge(from,to));
      }
    }
  }
  return new DFSTree(preOrder,postOrder,nonBack,back,loopEnters);
}
