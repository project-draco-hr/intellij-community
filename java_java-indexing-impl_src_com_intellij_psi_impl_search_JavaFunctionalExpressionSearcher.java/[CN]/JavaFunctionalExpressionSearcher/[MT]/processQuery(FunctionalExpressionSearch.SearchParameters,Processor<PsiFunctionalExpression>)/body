{
  final GlobalSearchScope useScope;
  final PsiClass aClass;
  final Project project;
  final int expectedFunExprParamsCount;
  AccessToken token=ReadAction.start();
  try {
    aClass=queryParameters.getElementToSearch();
    if (!aClass.isValid() || !LambdaUtil.isFunctionalClass(aClass))     return;
    project=aClass.getProject();
    final Set<Module> highLevelModules=getJava8Modules(project);
    if (highLevelModules.isEmpty())     return;
    useScope=convertToGlobalScope(project,queryParameters.getEffectiveSearchScope());
    final MethodSignature functionalInterfaceMethod=LambdaUtil.getFunction(aClass);
    LOG.assertTrue(functionalInterfaceMethod != null);
    expectedFunExprParamsCount=functionalInterfaceMethod.getParameterTypes().length;
  }
  finally {
    token.finish();
  }
  Set<VirtualFile> candidateFiles=getFilesWithFunctionalExpressionsScope(project,new JavaSourceFilterScope(useScope));
  if (candidateFiles.size() < SMART_SEARCH_THRESHOLD) {
    searchInFiles(aClass,consumer,candidateFiles,expectedFunExprParamsCount);
    return;
  }
  final GlobalSearchScope candidateScope=GlobalSearchScope.filesScope(project,candidateFiles);
  final Collection<PsiMethod> methodCandidates=getCandidateMethodsWithSuitableParams(aClass,project,useScope,candidateFiles,candidateScope);
  final LinkedHashSet<VirtualFile> filesToProcess=new LinkedHashSet<VirtualFile>();
  final FileBasedIndex fileBasedIndex=FileBasedIndex.getInstance();
  for (  final PsiMethod psiMethod : methodCandidates) {
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        if (!psiMethod.isValid())         return;
        final int parametersCount=psiMethod.getParameterList().getParametersCount();
        final boolean varArgs=psiMethod.isVarArgs();
        final PsiParameter[] parameters=psiMethod.getParameterList().getParameters();
        final GlobalSearchScope methodUseScope=convertToGlobalScope(project,psiMethod.getUseScope());
        final LinkedHashMap<VirtualFile,Set<JavaFunctionalExpressionIndex.IndexHolder>> holders=new LinkedHashMap<VirtualFile,Set<JavaFunctionalExpressionIndex.IndexHolder>>();
        final SuitableFilesProcessor processor=new SuitableFilesProcessor(holders,expectedFunExprParamsCount,parametersCount,varArgs,parameters);
        fileBasedIndex.processValues(JavaFunctionalExpressionIndex.JAVA_FUNCTIONAL_EXPRESSION_INDEX_ID,psiMethod.getName(),null,processor,useScope.intersectWith(methodUseScope));
        for (        Map.Entry<VirtualFile,Set<JavaFunctionalExpressionIndex.IndexHolder>> entry : holders.entrySet()) {
          for (          JavaFunctionalExpressionIndex.IndexHolder holder : entry.getValue()) {
            if (processor.canBeFunctional(holder)) {
              filesToProcess.add(entry.getKey());
              break;
            }
          }
        }
      }
    }
);
  }
  collectFilesWithTypeOccurrencesAndFieldAssignments(aClass,candidateScope,filesToProcess);
  searchInFiles(aClass,consumer,filesToProcess,expectedFunExprParamsCount);
}
