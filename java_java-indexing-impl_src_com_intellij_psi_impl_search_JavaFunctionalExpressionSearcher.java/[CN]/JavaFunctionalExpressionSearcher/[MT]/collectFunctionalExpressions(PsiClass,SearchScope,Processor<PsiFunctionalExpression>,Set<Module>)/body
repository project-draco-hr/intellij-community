{
  final Project project=PsiUtilCore.getProjectInReadAction(aClass);
  final ModulesScope modulesScope=new ModulesScope(highLevelModules,project);
  final GlobalSearchScope useScope=ApplicationManager.getApplication().runReadAction(new Computable<GlobalSearchScope>(){
    @Override public GlobalSearchScope compute(){
      return modulesScope.intersectWith(convertToGlobalScope(project,searchScope.intersectWith(aClass.getUseScope())));
    }
  }
);
  final PsiSearchHelperImpl helper=(PsiSearchHelperImpl)PsiSearchHelper.SERVICE.getInstance(project);
  final HashSet<VirtualFile> files=new HashSet<VirtualFile>();
  final CommonProcessors.CollectProcessor<VirtualFile> processor=new CommonProcessors.CollectProcessor<VirtualFile>(files);
  helper.processFilesWithText(useScope,UsageSearchContext.IN_CODE,true,"::",processor);
  helper.processFilesWithText(useScope,UsageSearchContext.IN_CODE,true,"->",processor);
  final GlobalSearchScope filesScope=GlobalSearchScope.filesScope(project,files);
  final Collection<PsiMethod> lambdaCandidates=ApplicationManager.getApplication().runReadAction(new Computable<Collection<PsiMethod>>(){
    @Override public Collection<PsiMethod> compute(){
      final String functionalInterfaceName=aClass.getName();
      JavaMethodParameterTypesIndex parameterTypesIndex=JavaMethodParameterTypesIndex.getInstance();
      LinkedHashSet<PsiMethod> methods=new LinkedHashSet<PsiMethod>(parameterTypesIndex.get(functionalInterfaceName,project,useScope));
      methods.addAll(parameterTypesIndex.get(JavaMethodElementType.TYPE_PARAMETER_PSEUDO_NAME,project,GlobalSearchScope.allScope(project)));
      return methods;
    }
  }
);
  final LinkedHashSet<VirtualFile> usageFiles=new LinkedHashSet<VirtualFile>();
  final MethodSignature functionalInterfaceMethod=ApplicationManager.getApplication().runReadAction(new Computable<MethodSignature>(){
    @Override public MethodSignature compute(){
      return LambdaUtil.getFunction(aClass);
    }
  }
);
  LOG.assertTrue(functionalInterfaceMethod != null);
  final int expectedFunExprParamsCount=functionalInterfaceMethod.getParameterTypes().length;
  final FileBasedIndex fileBasedIndex=FileBasedIndex.getInstance();
  for (  final PsiMethod psiMethod : lambdaCandidates) {
    final int parametersCount=psiMethod.getParameterList().getParametersCount();
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        final boolean varArgs=psiMethod.isVarArgs();
        final PsiParameter[] parameters=psiMethod.getParameterList().getParameters();
        final GlobalSearchScope methodUseScope=modulesScope.intersectWith(convertToGlobalScope(project,psiMethod.getUseScope()));
        fileBasedIndex.processValues(JavaFunctionalExpressionIndex.JAVA_FUNCTIONAL_EXPRESSION_INDEX_ID,psiMethod.getName(),null,new FileBasedIndex.ValueProcessor<Collection<JavaFunctionalExpressionIndex.IndexHolder>>(){
          @Override public boolean process(          VirtualFile file,          Collection<JavaFunctionalExpressionIndex.IndexHolder> holders){
            for (            JavaFunctionalExpressionIndex.IndexHolder holder : holders) {
              if (holder.getLambdaParamsNumber() == expectedFunExprParamsCount && (varArgs ? holder.getMethodArgsLength() >= parametersCount - 1 : holder.getMethodArgsLength() == parametersCount) && canBeFunctional(holder)) {
                usageFiles.add(file);
                break;
              }
            }
            return true;
          }
          private boolean canBeFunctional(          JavaFunctionalExpressionIndex.IndexHolder holder){
            final int paramIdx=holder.getFunctionExpressionIndex();
            final PsiClass functionalCandidate=PsiUtil.resolveClassInClassTypeOnly(parameters[paramIdx].getType());
            return functionalCandidate instanceof PsiTypeParameter || LambdaUtil.isFunctionalClass(functionalCandidate);
          }
        }
,useScope.intersectWith(methodUseScope));
      }
    }
);
  }
  collectFilesWithAssignments(aClass,filesScope,usageFiles);
  LOG.info("#usage files: " + usageFiles.size());
  return ContainerUtil.process(usageFiles,new ReadActionProcessor<VirtualFile>(){
    @Override public boolean processInReadAction(    VirtualFile file){
      return processFileWithFunctionalInterfaces(aClass,expectedFunExprParamsCount,consumer,file);
    }
  }
);
}
