{
  final PsiElement psiElement=reference.getElement();
  @NonNls final String referenceName=reference.getRangeInElement().substring(psiElement.getText());
  Project project=psiElement.getProject();
  PsiFile containingFile=psiElement.getContainingFile();
  if (containingFile == null)   return null;
  final VirtualFile classVFile=containingFile.getVirtualFile();
  if (classVFile == null)   return null;
  final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(project).getFileIndex();
  final Module currentModule=fileIndex.getModuleForFile(classVFile);
  if (currentModule == null)   return null;
  if ("TestCase".equals(referenceName) || isAnnotation(psiElement) && isJunitAnnotationName(referenceName,psiElement)) {
    final boolean isJunit4=!referenceName.equals("TestCase");
    @NonNls final String className=isJunit4 ? "org.junit." + referenceName : "junit.framework.TestCase";
    PsiClass found=JavaPsiFacade.getInstance(project).findClass(className,currentModule.getModuleWithDependenciesAndLibrariesScope(true));
    if (found != null)     return null;
    final OrderEntryFix fix=new OrderEntryFix(){
      @Override @NotNull public String getText(){
        return QuickFixBundle.message("orderEntry.fix.add.junit.jar.to.classpath");
      }
      @Override @NotNull public String getFamilyName(){
        return getText();
      }
      @Override public boolean isAvailable(      @NotNull Project project,      Editor editor,      PsiFile file){
        return !project.isDisposed() && !currentModule.isDisposed();
      }
      @Override public void invoke(      @NotNull Project project,      @Nullable Editor editor,      PsiFile file){
        List<String> jarPaths;
        String libraryName;
        if (isJunit4) {
          jarPaths=getJUnit4JarPaths();
          libraryName=JUNIT4_LIBRARY_NAME;
        }
 else {
          jarPaths=Collections.singletonList(JavaSdkUtil.getJunit3JarPath());
          libraryName=null;
        }
        addJarsToRootsAndImportClass(jarPaths,libraryName,currentModule,editor,reference,className);
      }
    }
;
    registrar.register(fix);
    return Collections.singletonList((LocalQuickFix)fix);
  }
  if (isAnnotation(psiElement) && AnnotationUtil.isJetbrainsAnnotation(referenceName)) {
    @NonNls final String className="org.jetbrains.annotations." + referenceName;
    PsiClass found=JavaPsiFacade.getInstance(project).findClass(className,currentModule.getModuleWithDependenciesAndLibrariesScope(true));
    if (found != null)     return null;
    final OrderEntryFix fix=new OrderEntryFix(){
      @Override @NotNull public String getText(){
        return QuickFixBundle.message("orderEntry.fix.add.annotations.jar.to.classpath");
      }
      @Override @NotNull public String getFamilyName(){
        return getText();
      }
      @Override public boolean isAvailable(      @NotNull Project project,      Editor editor,      PsiFile file){
        return !project.isDisposed() && !currentModule.isDisposed();
      }
      @Override public void invoke(      @NotNull final Project project,      final Editor editor,      PsiFile file){
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          @Override public void run(){
            final String libraryPath=locateAnnotationsJar(currentModule);
            if (libraryPath != null) {
              new WriteCommandAction(project){
                @Override protected void run(                final Result result) throws Throwable {
                  addJarsToRootsAndImportClass(Collections.singletonList(libraryPath),null,currentModule,editor,reference,"org.jetbrains.annotations." + referenceName);
                }
              }
.execute();
            }
          }
        }
);
      }
    }
;
    registrar.register(fix);
    return Collections.singletonList((LocalQuickFix)fix);
  }
  List<LocalQuickFix> result=new ArrayList<LocalQuickFix>();
  Set<Object> librariesToAdd=new THashSet<Object>();
  final JavaPsiFacade facade=JavaPsiFacade.getInstance(psiElement.getProject());
  PsiClass[] classes=PsiShortNamesCache.getInstance(project).getClassesByName(referenceName,GlobalSearchScope.allScope(project));
  List<PsiClass> allowedDependencies=filterAllowedDependencies(psiElement,classes);
  if (allowedDependencies.isEmpty()) {
    return result;
  }
  classes=allowedDependencies.toArray(new PsiClass[allowedDependencies.size()]);
  final OrderEntryFix moduleDependencyFix=new AddModuleDependencyFix(currentModule,classVFile,classes,reference);
  registrar.register(moduleDependencyFix);
  result.add(moduleDependencyFix);
  for (  final PsiClass aClass : classes) {
    if (!facade.getResolveHelper().isAccessible(aClass,psiElement,aClass))     continue;
    PsiFile psiFile=aClass.getContainingFile();
    if (psiFile == null)     continue;
    VirtualFile virtualFile=psiFile.getVirtualFile();
    if (virtualFile == null)     continue;
    ModuleFileIndex moduleFileIndex=ModuleRootManager.getInstance(currentModule).getFileIndex();
    for (    OrderEntry orderEntry : fileIndex.getOrderEntriesForFile(virtualFile)) {
      if (orderEntry instanceof LibraryOrderEntry) {
        final LibraryOrderEntry libraryEntry=(LibraryOrderEntry)orderEntry;
        final Library library=libraryEntry.getLibrary();
        if (library == null)         continue;
        VirtualFile[] files=library.getFiles(OrderRootType.CLASSES);
        if (files.length == 0)         continue;
        final VirtualFile jar=files[0];
        if (jar == null || libraryEntry.isModuleLevel() && !librariesToAdd.add(jar) || !librariesToAdd.add(library))         continue;
        OrderEntry entryForFile=moduleFileIndex.getOrderEntryForFile(virtualFile);
        if (entryForFile != null && !(entryForFile instanceof ExportableOrderEntry && ((ExportableOrderEntry)entryForFile).getScope() == DependencyScope.TEST && !ModuleRootManager.getInstance(currentModule).getFileIndex().isInTestSourceContent(classVFile))) {
          continue;
        }
        final OrderEntryFix fix=new OrderEntryFix(){
          @Override @NotNull public String getText(){
            return QuickFixBundle.message("orderEntry.fix.add.library.to.classpath",libraryEntry.getPresentableName());
          }
          @Override @NotNull public String getFamilyName(){
            return QuickFixBundle.message("orderEntry.fix.family.add.library.to.classpath");
          }
          @Override public boolean isAvailable(          @NotNull Project project,          Editor editor,          PsiFile file){
            return !project.isDisposed() && !currentModule.isDisposed() && libraryEntry.isValid();
          }
          @Override public void invoke(          @NotNull final Project project,          @Nullable final Editor editor,          PsiFile file){
            OrderEntryUtil.addLibraryToRoots(libraryEntry,currentModule);
            if (editor != null) {
              DumbService.getInstance(project).withAlternativeResolveEnabled(new Runnable(){
                @Override public void run(){
                  new AddImportAction(project,reference,editor,aClass).execute();
                }
              }
);
            }
          }
        }
;
        registrar.register(fix);
        result.add(fix);
      }
    }
  }
  return result;
}
