{
  final Project project=buildFile.getProject();
  final StatusBar statusbar=WindowManager.getInstance().getStatusBar(project);
  if (statusbar != null) {
    statusbar.setInfo(AntBundle.message("ant.build.started.status.message"));
  }
  final CheckCancelTask checkCancelTask=new CheckCancelTask(progress,handler);
  checkCancelTask.start(0);
  final OutputParser parser=OutputParser2.attachParser(project,handler,errorView,progress,buildFile);
  handler.addProcessListener(new ProcessAdapter(){
    private final StringBuilder myUnprocessedStdErr=new StringBuilder();
    public void onTextAvailable(    ProcessEvent event,    Key outputType){
      if (outputType == ProcessOutputTypes.STDERR) {
        final String text=event.getText();
synchronized (myUnprocessedStdErr) {
          myUnprocessedStdErr.append(text);
        }
      }
    }
    public void processTerminated(    ProcessEvent event){
      final long buildTime=System.currentTimeMillis() - startTime;
      checkCancelTask.cancel();
      parser.setStopped(true);
      final OutputPacketProcessor dispatcher=handler.getErr().getEventsDispatcher();
      if (event.getExitCode() != 0) {
        final String unprocessed;
synchronized (myUnprocessedStdErr) {
          unprocessed=myUnprocessedStdErr.toString();
          myUnprocessedStdErr.setLength(0);
        }
        if (!unprocessed.isEmpty()) {
          dispatcher.processOutput(new Printable(){
            public void printOn(            Printer printer){
              errorView.outputError(unprocessed,AntBuildMessageView.PRIORITY_ERR);
            }
          }
);
        }
      }
 else {
synchronized (myUnprocessedStdErr) {
          myUnprocessedStdErr.setLength(0);
        }
      }
      errorView.buildFinished(progress != null && progress.isCanceled(),buildTime,antBuildListener,dispatcher);
    }
  }
);
  handler.startNotify();
}
