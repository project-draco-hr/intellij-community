{
  final Project project=buildFile.getProject();
  final StatusBar statusbar=WindowManager.getInstance().getStatusBar(project);
  if (statusbar != null) {
    statusbar.setInfo(AntBundle.message("ant.build.started.status.message"));
  }
  final CheckCancelTask checkCancelTask=new CheckCancelTask(progress,handler);
  checkCancelTask.start(0);
  final OutputParser parser=OutputParser2.attachParser(project,handler,errorView,progress,buildFile);
  handler.addProcessListener(new ProcessAdapter(){
    private final StringBuilder myUnprocessedStdErr=new StringBuilder();
    public void onTextAvailable(    ProcessEvent event,    Key outputType){
      if (outputType == ProcessOutputTypes.STDERR) {
        final String text=event.getText();
synchronized (myUnprocessedStdErr) {
          myUnprocessedStdErr.append(text);
        }
      }
    }
    public void processTerminated(    ProcessEvent event){
      final long buildTime=System.currentTimeMillis() - startTime;
      checkCancelTask.cancel();
      parser.setStopped(true);
      final OutputPacketProcessor dispatcher=handler.getErr().getEventsDispatcher();
      try {
        if (event.getExitCode() != 0) {
          final String unprocessed;
synchronized (myUnprocessedStdErr) {
            unprocessed=myUnprocessedStdErr.toString();
            myUnprocessedStdErr.setLength(0);
          }
          if (!unprocessed.isEmpty()) {
            dispatcher.processOutput(new Printable(){
              public void printOn(              Printer printer){
                errorView.outputError(unprocessed,AntBuildMessageView.PRIORITY_ERR);
              }
            }
);
          }
        }
 else {
synchronized (myUnprocessedStdErr) {
            myUnprocessedStdErr.setLength(0);
          }
        }
      }
  finally {
        errorView.buildFinished(progress != null && progress.isCanceled(),buildTime,antBuildListener,dispatcher);
      }
    }
  }
);
  handler.startNotify();
}
