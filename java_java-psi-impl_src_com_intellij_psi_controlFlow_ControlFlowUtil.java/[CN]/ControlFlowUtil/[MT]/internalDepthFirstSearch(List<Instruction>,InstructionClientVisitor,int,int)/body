{
  final WalkThroughStack walkThroughStack=new WalkThroughStack(instructions.size() / 2);
  walkThroughStack.push(startOffset);
synchronized (instructions) {
    final IntArrayList currentProcedureReturnOffsets=new IntArrayList();
    ControlFlowInstructionVisitor getNextOffsetVisitor=new ControlFlowInstructionVisitor(){
      @Override public void visitCallInstruction(      CallInstruction instruction,      int offset,      int nextOffset){
        instruction.execute(offset + 1);
        int newOffset=instruction.offset;
        int i;
        for (i=instruction.procBegin; i < instruction.procEnd || instructions.get(i) instanceof ReturnInstruction; i++) {
          clientVisitor.processedInstructions[i]=false;
        }
        clientVisitor.procedureEntered(instruction.procBegin,i);
        walkThroughStack.push(offset,newOffset);
        walkThroughStack.push(newOffset);
        currentProcedureReturnOffsets.add(offset + 1);
      }
      @Override public void visitReturnInstruction(      ReturnInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.execute(false);
        if (newOffset != -1) {
          walkThroughStack.push(offset,newOffset);
          walkThroughStack.push(newOffset);
        }
      }
      @Override public void visitBranchingInstruction(      BranchingInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.offset;
        walkThroughStack.push(offset,newOffset);
        walkThroughStack.push(newOffset);
      }
      @Override public void visitConditionalBranchingInstruction(      ConditionalBranchingInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.offset;
        walkThroughStack.push(offset,newOffset);
        walkThroughStack.push(offset,offset + 1);
        walkThroughStack.push(newOffset);
        walkThroughStack.push(offset + 1);
      }
      @Override public void visitInstruction(      Instruction instruction,      int offset,      int nextOffset){
        int newOffset=offset + 1;
        walkThroughStack.push(offset,newOffset);
        walkThroughStack.push(newOffset);
      }
    }
;
    while (!walkThroughStack.isEmpty()) {
      final int offset=walkThroughStack.peekOldOffset();
      final int newOffset=walkThroughStack.popNewOffset();
      if (offset >= endOffset) {
        continue;
      }
      Instruction instruction=instructions.get(offset);
      if (clientVisitor.processedInstructions[offset]) {
        if (newOffset != -1) {
          instruction.accept(clientVisitor,offset,newOffset);
        }
        if (!currentProcedureReturnOffsets.isEmpty() && currentProcedureReturnOffsets.get(currentProcedureReturnOffsets.size() - 1) - 1 == offset) {
          currentProcedureReturnOffsets.remove(currentProcedureReturnOffsets.size() - 1);
        }
        continue;
      }
      if (!currentProcedureReturnOffsets.isEmpty()) {
        int returnOffset=currentProcedureReturnOffsets.get(currentProcedureReturnOffsets.size() - 1);
        CallInstruction callInstruction=(CallInstruction)instructions.get(returnOffset - 1);
synchronized (callInstruction.stack) {
          if (callInstruction.procBegin <= offset && offset < callInstruction.procEnd + 2 && (callInstruction.stack.size() == 0 || callInstruction.stack.peekReturnOffset() != returnOffset)) {
            callInstruction.stack.push(returnOffset,callInstruction);
          }
        }
      }
      clientVisitor.processedInstructions[offset]=true;
      instruction.accept(getNextOffsetVisitor,offset,newOffset);
    }
  }
}
