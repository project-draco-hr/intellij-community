{
  final List<Instruction> instructions=flow.getInstructions();
  final Map<PsiVariable,IntArrayList> writeOffsets=new THashMap<PsiVariable,IntArrayList>();
  for (int i=flowStart; i < flowEnd; i++) {
    Instruction instruction=instructions.get(i);
    if (instruction instanceof WriteVariableInstruction) {
      final PsiVariable variable=((WriteVariableInstruction)instruction).variable;
      if (variable instanceof PsiLocalVariable || variable instanceof PsiParameter) {
        IntArrayList offsets=writeOffsets.get(variable);
        if (offsets == null)         writeOffsets.put(variable,offsets=new IntArrayList());
        offsets.add(i);
      }
    }
  }
  if (writeOffsets.isEmpty())   return false;
  LOG.debug("minWriteOffsets:",writeOffsets);
  final PsiElement commonParent=elements.length != 1 ? PsiTreeUtil.findCommonParent(elements) : elements[0].getParent();
  final List<PsiTryStatement> tryStatements=collectTryStatementStack(commonParent,enclosingCodeFragment);
  if (tryStatements.isEmpty())   return false;
  final PsiCodeBlock tryBlock=tryStatements.get(0).getTryBlock();
  if (tryBlock == null)   return false;
  final Map<PsiVariable,IntArrayList> visibleReadOffsets=new THashMap<PsiVariable,IntArrayList>();
  for (  PsiVariable variable : writeOffsets.keySet()) {
    if (!PsiTreeUtil.isAncestor(tryBlock,variable,true)) {
      visibleReadOffsets.put(variable,new IntArrayList());
    }
  }
  if (visibleReadOffsets.isEmpty())   return false;
  for (int i=0; i < instructions.size(); i++) {
    final Instruction instruction=instructions.get(i);
    if (instruction instanceof ReadVariableInstruction) {
      final PsiVariable variable=((ReadVariableInstruction)instruction).variable;
      final IntArrayList readOffsets=visibleReadOffsets.get(variable);
      if (readOffsets != null) {
        readOffsets.add(i);
      }
    }
  }
  if (visibleReadOffsets.isEmpty())   return false;
  LOG.debug("visibleReadOffsets:",visibleReadOffsets);
  final Map<PsiVariable,Set<PsiElement>> afterWrite=new THashMap<PsiVariable,Set<PsiElement>>();
  for (  PsiVariable variable : visibleReadOffsets.keySet()) {
    final Function<Integer,BitSet> calculator=getReachableInstructionsCalculator(flow,flowStart,flowEnd);
    final BitSet collectedOffsets=new BitSet(flowEnd);
    for (    final int writeOffset : writeOffsets.get(variable).toArray()) {
      LOG.assertTrue(writeOffset >= flowStart,"writeOffset");
      final BitSet reachableOffsets=calculator.fun(writeOffset);
      collectedOffsets.or(reachableOffsets);
    }
    Set<PsiElement> throwSources=afterWrite.get(variable);
    if (throwSources == null)     afterWrite.put(variable,throwSources=new THashSet<PsiElement>());
    for (int i=flowStart; i < flowEnd; i++) {
      if (collectedOffsets.get(i)) {
        throwSources.add(flow.getElement(i));
      }
    }
    final List<PsiElement> subordinates=new ArrayList<PsiElement>();
    for (    PsiElement element : throwSources) {
      if (throwSources.contains(element.getParent())) {
        subordinates.add(element);
      }
    }
    throwSources.removeAll(subordinates);
  }
  LOG.debug("afterWrite:",afterWrite);
  for (  Map.Entry<PsiVariable,Set<PsiElement>> entry : afterWrite.entrySet()) {
    final PsiVariable variable=entry.getKey();
    final PsiElement[] psiElements=entry.getValue().toArray(PsiElement.EMPTY_ARRAY);
    final List<PsiClassType> thrownExceptions=ExceptionUtil.getThrownExceptions(psiElements);
    if (!thrownExceptions.isEmpty()) {
      final IntArrayList catchOrFinallyOffsets=new IntArrayList();
      for (      PsiTryStatement tryStatement : tryStatements) {
        final PsiCodeBlock finallyBlock=tryStatement.getFinallyBlock();
        if (finallyBlock != null) {
          int offset=flow.getStartOffset(finallyBlock);
          if (offset >= 0) {
            catchOrFinallyOffsets.add(offset - 2);
          }
        }
        for (        PsiCatchSection catchSection : tryStatement.getCatchSections()) {
          final PsiCodeBlock catchBlock=catchSection.getCatchBlock();
          final PsiParameter parameter=catchSection.getParameter();
          if (catchBlock != null && parameter != null) {
            for (            PsiClassType throwType : thrownExceptions) {
              if (ControlFlowUtil.isCaughtExceptionType(throwType,parameter.getType())) {
                int offset=flow.getStartOffset(catchBlock);
                if (offset >= 0) {
                  catchOrFinallyOffsets.add(offset - 1);
                }
              }
            }
          }
        }
      }
      if (!catchOrFinallyOffsets.isEmpty()) {
        final IntArrayList readOffsets=visibleReadOffsets.get(variable);
        if (readOffsets != null && !readOffsets.isEmpty()) {
          for (int j=0; j < catchOrFinallyOffsets.size(); j++) {
            int catchOrFinallyOffset=catchOrFinallyOffsets.get(j);
            if (ControlFlowUtil.areInstructionsReachable(flow,readOffsets.toArray(),catchOrFinallyOffset)) {
              LOG.debug("catchOrFinallyOffset:",catchOrFinallyOffset);
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
