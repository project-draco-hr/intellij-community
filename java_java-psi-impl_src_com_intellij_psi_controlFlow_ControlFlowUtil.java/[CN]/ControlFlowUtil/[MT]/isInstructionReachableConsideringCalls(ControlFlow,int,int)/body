{
class ControlFlowGraph {
    final int[][] nextOffsets;
    ControlFlowGraph(    int size){
      nextOffsets=new int[size][];
    }
    void addArc(    int offset,    int nextOffset){
      if (nextOffsets[offset] == null) {
        nextOffsets[offset]=new int[]{nextOffset,-1};
      }
 else {
        int[] targets=nextOffsets[offset];
        if (ArrayUtil.indexOf(targets,nextOffset) < 0) {
          int freeIndex=ArrayUtil.indexOf(targets,-1);
          if (freeIndex >= 0) {
            targets[freeIndex]=nextOffset;
          }
 else {
            int oldLength=targets.length;
            nextOffsets[offset]=targets=ArrayUtil.realloc(targets,oldLength * 3 / 2);
            Arrays.fill(targets,oldLength,targets.length,-1);
            targets[oldLength]=nextOffset;
          }
        }
      }
    }
    int[] getNextOffsets(    int offset){
      return nextOffsets[offset] != null ? nextOffsets[offset] : ArrayUtil.EMPTY_INT_ARRAY;
    }
    int size(){
      return nextOffsets.length;
    }
    @Override public String toString(){
      StringBuilder s=new StringBuilder();
      for (int i=0; i < nextOffsets.length; i++) {
        int[] targets=nextOffsets[i];
        if (targets != null && targets.length != 0 && targets[0] != -1) {
          if (s.length() != 0)           s.append(' ');
          s.append('(').append(i).append("->");
          for (int j=0; j < targets.length && targets[j] != -1; j++) {
            if (j != 0)             s.append(",");
            s.append(targets[j]);
          }
          s.append(')');
        }
      }
      return s.toString();
    }
  }
class MyVisitor extends InstructionClientVisitor<Boolean> {
    final ControlFlowGraph graph=new ControlFlowGraph(flow.getInstructions().size());
    @Override public void visitInstruction(    Instruction instruction,    int offset,    int nextOffset){
      if (nextOffset > graph.size())       nextOffset=graph.size();
      graph.addArc(offset,nextOffset);
    }
    @Override public Boolean getResult(){
      Arrays.fill(processedInstructions,false);
      IntStack walkThroughStack=new IntStack(Math.max(graph.size() / 2,2));
      walkThroughStack.push(startOffset);
      while (!walkThroughStack.empty()) {
        int currentOffset=walkThroughStack.pop();
        if (currentOffset < graph.size() && !processedInstructions[currentOffset]) {
          processedInstructions[currentOffset]=true;
          int[] nextOffsets=graph.getNextOffsets(currentOffset);
          for (          int nextOffset : nextOffsets) {
            if (nextOffset == -1)             break;
            if (nextOffset == instructionOffset) {
              return true;
            }
            walkThroughStack.push(nextOffset);
          }
        }
      }
      return false;
    }
  }
  MyVisitor visitor=new MyVisitor();
  depthFirstSearch(flow,visitor,0,flow.getSize());
  return visitor.getResult().booleanValue();
}
