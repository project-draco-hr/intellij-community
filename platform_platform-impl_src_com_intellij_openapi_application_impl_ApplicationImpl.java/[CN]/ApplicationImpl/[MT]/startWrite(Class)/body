{
  assertIsDispatchThread(getStatus(),"Write access is allowed from event dispatch thread only");
  boolean writeActionPending=myWriteActionPending;
  myWriteActionPending=true;
  if ((LOG.isDebugEnabled() || isUnitTestMode()) && myWriteActionsStack.isEmpty()) {
    writePauses.started();
  }
  try {
    ActivityTracker.getInstance().inc();
    fireBeforeWriteActionStart(clazz);
    try {
      if (!isWriteAccessAllowed()) {
        assertNoPsiLock();
      }
      if (!myLock.writeLock().tryLock()) {
        final AtomicBoolean lockAcquired=new AtomicBoolean(false);
        if (ourDumpThreadsOnLongWriteActionWaiting > 0) {
          executeOnPooledThread(new Runnable(){
            @Override public void run(){
              while (!lockAcquired.get()) {
                TimeoutUtil.sleep(ourDumpThreadsOnLongWriteActionWaiting);
                if (!lockAcquired.get()) {
                  PerformanceWatcher.getInstance().dumpThreads("waiting",true);
                }
              }
            }
          }
);
        }
        myLock.writeLock().lockInterruptibly();
        lockAcquired.set(true);
      }
    }
 catch (    InterruptedException e) {
      throw new RuntimeInterruptedException(e);
    }
  }
  finally {
    myWriteActionPending=writeActionPending;
  }
  myWriteActionsStack.push(clazz);
  fireWriteActionStarted(clazz);
}
