{
  assertIsDispatchThread();
  if (myExceptionalThreadWithReadAccessRunnable != null || isUnitTestMode() || isHeadlessEnvironment()) {
    try {
      ProgressManager.getInstance().runProcess(process,new EmptyProgressIndicator());
    }
 catch (    ProcessCanceledException e) {
      return false;
    }
    return true;
  }
  final ProgressWindow progress=new ProgressWindow(canBeCanceled,false,project,parentComponent,cancelText);
  Disposer.register(this,progress);
  progress.setTitle(progressTitle);
  try {
    myExceptionalThreadWithReadAccessRunnable=process;
    final AtomicBoolean threadStarted=new AtomicBoolean();
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        if (myExceptionalThreadWithReadAccessRunnable != process) {
          LOG.error("myExceptionalThreadWithReadAccessRunnable != process, process = " + myExceptionalThreadWithReadAccessRunnable);
        }
        executeOnPooledThread(new Runnable(){
          @Override public void run(){
            if (myExceptionalThreadWithReadAccessRunnable != process) {
              LOG.error("myExceptionalThreadWithReadAccessRunnable != process, process = " + myExceptionalThreadWithReadAccessRunnable);
            }
            setExceptionalThreadWithReadAccessFlag(true);
            try {
              LOG.assertTrue(isReadAccessAllowed());
              ProgressManager.getInstance().runProcess(process,progress);
            }
 catch (            ProcessCanceledException e) {
              progress.cancel();
            }
catch (            RuntimeException e) {
              progress.cancel();
              throw e;
            }
 finally {
              setExceptionalThreadWithReadAccessFlag(false);
            }
          }
        }
);
        threadStarted.set(true);
      }
    }
);
    progress.startBlocking();
    LOG.assertTrue(threadStarted.get());
    LOG.assertTrue(!progress.isRunning());
  }
  finally {
    myExceptionalThreadWithReadAccessRunnable=null;
  }
  return !progress.isCanceled();
}
