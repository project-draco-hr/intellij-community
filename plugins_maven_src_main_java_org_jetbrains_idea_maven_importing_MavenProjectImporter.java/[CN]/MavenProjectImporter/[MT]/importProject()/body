{
  List<MavenProjectsProcessorTask> postTasks=new ArrayList<MavenProjectsProcessorTask>();
  boolean hasChanges;
  myAllProjects=new LinkedHashSet<MavenProject>(myProjectsTree.getProjects());
  myAllProjects.addAll(myProjectsToImportWithChanges.keySet());
  hasChanges=deleteIncompatibleModules();
  myProjectsToImportWithChanges=collectProjectsToImport(myProjectsToImportWithChanges);
  mapMavenProjectsToModulesAndNames();
  if (myProject.isDisposed())   return null;
  final boolean projectsHaveChanges=projectsToImportHaveChanges();
  if (projectsHaveChanges) {
    hasChanges=true;
    importModules(postTasks);
    scheduleRefreshResolvedArtifacts(postTasks);
  }
  if (projectsHaveChanges || myImportModuleGroupsRequired) {
    hasChanges=true;
    configModuleGroups();
  }
  if (myProject.isDisposed())   return null;
  try {
    boolean modulesDeleted=deleteObsoleteModules();
    hasChanges|=modulesDeleted;
    if (hasChanges) {
      removeUnusedProjectLibraries();
    }
  }
 catch (  ProcessCanceledException e) {
    throw e;
  }
catch (  Exception e) {
    disposeModifiableModels();
    LOG.error(e);
    return null;
  }
  if (hasChanges) {
    MavenUtil.invokeAndWaitWriteAction(myProject,new Runnable(){
      public void run(){
        myModelsProvider.commit();
        if (projectsHaveChanges) {
          removeOutdatedCompilerConfigSettings();
          for (          MavenProject mavenProject : myAllProjects) {
            Module module=myMavenProjectToModule.get(mavenProject);
            if (module != null && module.isDisposed()) {
              module=null;
            }
            for (            MavenModuleConfigurer configurer : MavenModuleConfigurer.getConfigurers()) {
              configurer.configure(mavenProject,myProject,module);
            }
          }
        }
      }
    }
);
  }
 else {
    disposeModifiableModels();
  }
  return postTasks;
}
