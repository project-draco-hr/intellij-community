{
  ProgressManager.checkCanceled();
  Result rhs=equation.rhs;
  HResult hResult;
  if (rhs instanceof Final) {
    hResult=new HFinal(((Final)rhs).value);
  }
 else   if (rhs instanceof Pending) {
    Pending pending=(Pending)rhs;
    Set<Product> sumOrigin=pending.sum;
    HComponent[] components=new HComponent[sumOrigin.size()];
    int componentI=0;
    for (    Product prod : sumOrigin) {
      HKey[] intProd=new HKey[prod.ids.size()];
      int idI=0;
      for (      Key key : prod.ids) {
        intProd[idI]=asmKey(key,md);
        idI++;
      }
      HComponent intIdComponent=new HComponent(prod.value,intProd);
      components[componentI]=intIdComponent;
      componentI++;
    }
    hResult=new HPending(components);
  }
 else {
    Effects wrapper=(Effects)rhs;
    Set<EffectQuantum> effects=wrapper.effects;
    Set<HEffectQuantum> hEffects=new HashSet<HEffectQuantum>();
    for (    EffectQuantum effect : effects) {
      if (effect == EffectQuantum.TopEffectQuantum) {
        hEffects.add(HEffectQuantum.TopEffectQuantum);
      }
 else       if (effect == EffectQuantum.ThisChangeQuantum) {
        hEffects.add(HEffectQuantum.ThisChangeQuantum);
      }
 else       if (effect instanceof EffectQuantum.ParamChangeQuantum) {
        EffectQuantum.ParamChangeQuantum paramChangeQuantum=(EffectQuantum.ParamChangeQuantum)effect;
        hEffects.add(new HEffectQuantum.ParamChangeQuantum(paramChangeQuantum.n));
      }
 else       if (effect instanceof EffectQuantum.CallQuantum) {
        EffectQuantum.CallQuantum callQuantum=(EffectQuantum.CallQuantum)effect;
        hEffects.add(new HEffectQuantum.CallQuantum(asmKey(callQuantum.key,md),callQuantum.data,callQuantum.isStatic));
      }
    }
    hResult=new HEffects(hEffects);
  }
  return new DirectionResultPair(mkDirectionKey(equation.id.direction),hResult);
}
