{
  Result<Key,Value> rhs=equation.rhs;
  IntIdResult result;
  if (rhs instanceof Final) {
    result=new IntIdFinal(((Final<Key,Value>)rhs).value);
  }
 else {
    Pending<Key,Value> pending=(Pending<Key,Value>)rhs;
    Set<Set<Key>> deltaOrig=pending.delta;
    IntIdComponent[] components=new IntIdComponent[deltaOrig.size()];
    int componentI=0;
    for (    Set<Key> keyComponent : deltaOrig) {
      int[] ids=new int[keyComponent.size()];
      int idI=0;
      for (      Key id : keyComponent) {
        int[] compoundKey=mkCompoundKey(id);
        int rawId=myCompoundKeyEnumerator.enumerate(compoundKey);
        if (rawId <= 0) {
          LOG.error("raw key is not positive");
        }
        ids[idI]=id.stable ? rawId : -rawId;
        idI++;
      }
      IntIdComponent intIdComponent=new IntIdComponent(ids);
      components[componentI]=intIdComponent;
      componentI++;
    }
    result=new IntIdPending(pending.infinum,components);
  }
  int rawKey=myCompoundKeyEnumerator.enumerate(mkCompoundKey(equation.id));
  if (rawKey <= 0) {
    LOG.error("raw key is not positive");
  }
  int key=equation.id.stable ? rawKey : -rawKey;
  return new IntIdEquation(key,result);
}
