{
  ProgressManager.checkCanceled();
  Result<Key,Value> rhs=equation.rhs;
  IdResult result;
  if (rhs instanceof Final) {
    result=new IdFinal(((Final<Key,Value>)rhs).value);
  }
 else {
    Pending<Key,Value> pending=(Pending<Key,Value>)rhs;
    Set<Product<Key,Value>> sumOrigin=pending.sum;
    IntIdComponent[] components=new IntIdComponent[sumOrigin.size()];
    int componentI=0;
    for (    Product<Key,Value> prod : sumOrigin) {
      long[] intProd=new long[prod.ids.size()];
      int idI=0;
      for (      Key id : prod.ids) {
        long rawId=mkAsmKey(id);
        if (rawId <= 0) {
          LOG.error("raw key should be positive. rawId = " + rawId);
        }
        intProd[idI]=id.stable ? rawId : -rawId;
        idI++;
      }
      IntIdComponent intIdComponent=new IntIdComponent(prod.value,intProd);
      components[componentI]=intIdComponent;
      componentI++;
    }
    result=new IdPending(components);
  }
  long rawKey=mkAsmKey(equation.id);
  if (rawKey <= 0) {
    LOG.error("raw key should be positive. rawKey = " + rawKey);
  }
  long key=equation.id.stable ? rawKey : -rawKey;
  return new IdEquation(key,result);
}
