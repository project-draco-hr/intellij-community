{
  Result<Key,Value> rhs=equation.rhs;
  IntIdResult result;
  if (rhs instanceof Final) {
    result=new IntIdFinal(((Final<Key,Value>)rhs).value);
  }
 else {
    Pending<Key,Value> pending=(Pending<Key,Value>)rhs;
    Set<Product<Key,Value>> sumOrigin=pending.sum;
    IntIdComponent[] components=new IntIdComponent[sumOrigin.size()];
    int componentI=0;
    for (    Product<Key,Value> prod : sumOrigin) {
      int[] ids=new int[prod.ids.size()];
      int idI=0;
      for (      Key id : prod.ids) {
        int[] compoundKey=mkCompoundKey(id);
        int rawId=myCompoundKeyEnumerator.enumerate(compoundKey);
        if (rawId <= 0) {
          LOG.error("raw key is not positive");
        }
        ids[idI]=id.stable ? rawId : -rawId;
        idI++;
      }
      IntIdComponent intIdComponent=new IntIdComponent(prod.value,ids);
      components[componentI]=intIdComponent;
      componentI++;
    }
    result=new IntIdPending(components);
  }
  int rawKey=myCompoundKeyEnumerator.enumerate(mkCompoundKey(equation.id));
  if (rawKey <= 0) {
    LOG.error("raw key is not positive");
  }
  int key=equation.id.stable ? rawKey : -rawKey;
  return new IntIdEquation(key,result);
}
