{
  ProgressManager.checkCanceled();
  Result<Key,Value> rhs=equation.rhs;
  HResult result;
  if (rhs instanceof Final) {
    result=new HFinal(((Final<Key,Value>)rhs).value);
  }
 else {
    Pending<Key,Value> pending=(Pending<Key,Value>)rhs;
    Set<Product<Key,Value>> sumOrigin=pending.sum;
    HComponent[] components=new HComponent[sumOrigin.size()];
    int componentI=0;
    for (    Product<Key,Value> prod : sumOrigin) {
      HKey[] intProd=new HKey[prod.ids.size()];
      int idI=0;
      for (      Key id : prod.ids) {
        intProd[idI]=asmKey(id,md);
        idI++;
      }
      HComponent intIdComponent=new HComponent(prod.value,intProd);
      components[componentI]=intIdComponent;
      componentI++;
    }
    result=new HPending(components);
  }
  return new DirectionResultPair(mkDirectionKey(equation.id.direction),result);
}
