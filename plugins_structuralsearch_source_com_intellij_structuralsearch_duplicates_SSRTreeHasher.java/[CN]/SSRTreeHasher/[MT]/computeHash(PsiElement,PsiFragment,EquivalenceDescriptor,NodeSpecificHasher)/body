{
  final boolean canSkip=SkippingHandler.skipNodeIfNeccessary(element) != element;
  final PsiFragment fragment=new TreePsiFragment(nodeSpecificHasher,element,0);
  if (parent != null) {
    fragment.setParent(parent);
  }
  int hash=canSkip ? 0 : nodeSpecificHasher.getNodeHash(element);
  int cost=canSkip ? 0 : nodeSpecificHasher.getNodeCost(element);
  for (  SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) {
    final TreeHashResult childHashResult=computeHash(childDescriptor,fragment,nodeSpecificHasher);
    hash=hash * 31 + childHashResult.getHash();
    cost+=childHashResult.getCost();
  }
  for (  MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) {
    final TreeHashResult childHashResult=computeHash(childDescriptor,fragment,nodeSpecificHasher);
    hash=hash * 31 + childHashResult.getHash();
    cost+=childHashResult.getCost();
  }
  for (  Object constant : descriptor.getConstants()) {
    final int constantHash=constant != null ? constant.hashCode() : 0;
    hash=hash * 31 + constantHash;
  }
  for (  PsiElement[] codeBlock : descriptor.getCodeBlocks()) {
    final TreeHashResult childHashResult=hashCodeBlock(Arrays.asList(codeBlock),fragment,nodeSpecificHasher);
    hash=hash * 31 + childHashResult.getHash();
    cost+=childHashResult.getCost();
  }
  if (myCallback != null) {
    myCallback.add(hash,cost,fragment);
  }
  return new TreeHashResult(hash,cost,fragment);
}
