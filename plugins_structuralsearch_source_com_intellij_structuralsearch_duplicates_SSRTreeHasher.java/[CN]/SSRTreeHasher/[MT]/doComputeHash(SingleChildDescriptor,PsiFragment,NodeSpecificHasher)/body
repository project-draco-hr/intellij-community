{
  final PsiElement element=childDescriptor.getElement();
switch (childDescriptor.getType()) {
case OPTIONALLY_IN_PATTERN:
case DEFAULT:
    return hash(element,parentFragment,nodeSpecificHasher);
case CHILDREN_OPTIONALLY_IN_PATTERN:
case CHILDREN:
  TreeHashResult[] childResults=computeHashesForChildren(element,parentFragment,nodeSpecificHasher);
int[] hashes=getHashes(childResults);
int[] costs=getCosts(childResults);
int hash=AbstractTreeHasher.vector(hashes,31);
int cost=AbstractTreeHasher.vector(costs);
return new TreeHashResult(hash,cost,parentFragment);
case CHILDREN_IN_ANY_ORDER:
childResults=computeHashesForChildren(element,parentFragment,nodeSpecificHasher);
hashes=getHashes(childResults);
costs=getCosts(childResults);
hash=AbstractTreeHasher.vector(hashes);
cost=AbstractTreeHasher.vector(costs);
return new TreeHashResult(hash,cost,parentFragment);
default :
return new TreeHashResult(0,0,parentFragment);
}
}
