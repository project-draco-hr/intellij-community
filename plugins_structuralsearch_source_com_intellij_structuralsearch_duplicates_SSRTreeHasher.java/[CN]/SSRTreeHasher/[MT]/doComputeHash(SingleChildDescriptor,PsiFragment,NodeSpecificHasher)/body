{
  final PsiElement element=childDescriptor.getElement();
switch (childDescriptor.getType()) {
case OPTIONALLY_IN_PATTERN:
case DEFAULT:
    final TreeHashResult result=hash(element,parentFragment,nodeSpecificHasher);
  return new Pair<Integer,Integer>(result.getHash(),result.getCost());
case CHILDREN_OPTIONALLY_IN_PATTERN:
case CHILDREN:
TreeHashResult[] childResults=computeHashesForChildren(element,parentFragment,nodeSpecificHasher);
int[] hashes=getHashes(childResults);
int[] costs=getCosts(childResults);
int hash=AbstractTreeHasher.vector(hashes,31);
int cost=AbstractTreeHasher.vector(costs);
return new Pair<Integer,Integer>(hash,cost);
case CHILDREN_IN_ANY_ORDER:
childResults=computeHashesForChildren(element,parentFragment,nodeSpecificHasher);
hashes=getHashes(childResults);
costs=getCosts(childResults);
hash=AbstractTreeHasher.vector(hashes);
cost=AbstractTreeHasher.vector(costs);
return new Pair<Integer,Integer>(hash,cost);
default :
return new Pair<Integer,Integer>(0,0);
}
}
