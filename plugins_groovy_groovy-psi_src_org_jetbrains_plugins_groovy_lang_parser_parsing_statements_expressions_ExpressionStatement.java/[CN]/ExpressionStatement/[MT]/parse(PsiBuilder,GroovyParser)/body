{
  PsiBuilder.Marker marker=builder.mark();
  final IElementType result=parseExpressionStatement(builder,parser);
  if (result != GroovyElementTypes.CALL_EXPRESSION && result != GroovyElementTypes.PATH_METHOD_CALL) {
    marker.drop();
    return result == GroovyElementTypes.WRONGWAY ? Result.WRONG_WAY : Result.EXPRESSION;
  }
  boolean isExprStatement=result == GroovyElementTypes.CALL_EXPRESSION;
  while (true) {
    boolean nameParsed=namePartParse(builder,parser) == GroovyElementTypes.REFERENCE_EXPRESSION;
    PsiBuilder.Marker exprStatement;
    if (nameParsed) {
      exprStatement=marker.precede();
      marker.done(GroovyElementTypes.REFERENCE_EXPRESSION);
    }
 else {
      exprStatement=marker;
    }
    if (builder.getTokenType() == GroovyTokenTypes.mLPAREN) {
      PrimaryExpression.methodCallArgsParse(builder,parser);
      exprStatement.done(GroovyElementTypes.PATH_METHOD_CALL);
    }
 else     if (GroovyTokenTypes.mLBRACK.equals(builder.getTokenType()) && !ParserUtils.lookAhead(builder,GroovyTokenTypes.mLBRACK,GroovyTokenTypes.mCOLON) && !ParserUtils.lookAhead(builder,GroovyTokenTypes.mLBRACK,GroovyTokenTypes.mNLS,GroovyTokenTypes.mCOLON)) {
      PathExpression.indexPropertyArgsParse(builder,parser);
      exprStatement.done(GroovyElementTypes.PATH_INDEX_PROPERTY);
      if (GroovyTokenTypes.mLPAREN.equals(builder.getTokenType())) {
        PrimaryExpression.methodCallArgsParse(builder,parser);
      }
 else       if (GroovyTokenTypes.mLCURLY.equals(builder.getTokenType())) {
        PsiBuilder.Marker argsMarker=builder.mark();
        argsMarker.done(GroovyElementTypes.ARGUMENTS);
      }
      while (GroovyTokenTypes.mLCURLY.equals(builder.getTokenType())) {
        OpenOrClosableBlock.parseClosableBlock(builder,parser);
      }
      exprStatement=exprStatement.precede();
      exprStatement.done(GroovyElementTypes.PATH_METHOD_CALL);
    }
 else     if (nameParsed && CommandArguments.parseCommandArguments(builder,parser)) {
      isExprStatement=true;
      exprStatement.done(GroovyElementTypes.CALL_EXPRESSION);
    }
 else {
      exprStatement.drop();
      break;
    }
    marker=exprStatement.precede();
  }
  return isExprStatement ? Result.EXPR_STATEMENT : Result.EXPRESSION;
}
