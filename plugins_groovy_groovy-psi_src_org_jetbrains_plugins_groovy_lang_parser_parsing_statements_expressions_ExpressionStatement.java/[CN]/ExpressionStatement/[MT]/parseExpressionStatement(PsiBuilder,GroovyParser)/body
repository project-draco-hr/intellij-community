{
  if (checkForTypeCast(builder,parser))   return GroovyElementTypes.CAST_EXPRESSION;
  PsiBuilder.Marker marker=builder.mark();
  final PathExpression.Result result=PathExpression.parsePathExprQualifierForExprStatement(builder,parser);
  if (result != PathExpression.Result.WRONG_WAY && !TokenSets.SEPARATORS.contains(builder.getTokenType()) && !TokenSets.BINARY_OP_SET.contains(builder.getTokenType()) && !TokenSets.POSTFIX_UNARY_OP_SET.contains(builder.getTokenType())) {
    if (result == PathExpression.Result.METHOD_CALL) {
      marker.drop();
      return GroovyElementTypes.PATH_METHOD_CALL;
    }
    if (result == PathExpression.Result.LITERAL) {
      final PsiBuilder.Marker newMarker=marker.precede();
      marker.rollbackTo();
      marker=newMarker;
      PrimaryExpression.parsePrimaryExpression(builder,parser,true);
    }
    if (CommandArguments.parseCommandArguments(builder,parser)) {
      marker.done(GroovyElementTypes.CALL_EXPRESSION);
      return GroovyElementTypes.CALL_EXPRESSION;
    }
  }
  marker.drop();
  return GroovyElementTypes.WRONGWAY;
}
