{
  PanelProgressIndicator progress=createProgressIndicator(requestFocus);
  progress.setBordersVisible(false);
  myCurrentProgress=progress;
  Runnable updateModel=new Runnable(){
    @Override public void run(){
      final ProcessCanceledException[] ex=new ProcessCanceledException[1];
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          if (myProject.isDisposed())           return;
          try {
            myTreeExpansionMonitor.freeze();
            final TreeModel model=PatternDialectProvider.getInstance(DependencyUISettings.getInstance().SCOPE_TYPE).createTreeModel(myProject,myTreeMarker);
            ((PackageDependenciesNode)model.getRoot()).sortChildren();
            if (myErrorMessage == null) {
              String message=IdeBundle.message("label.scope.contains.files",model.getMarkedFileCount(),model.getTotalFileCount());
              if (FilePatternPackageSet.SCOPE_FILE.equals(DependencyUISettings.getInstance().SCOPE_TYPE)) {
                message=UIUtil.toHtml(message + "<br/>(Non-project files are not shown)");
              }
              myMatchingCountLabel.setText(message);
              myMatchingCountLabel.setForeground(new JLabel().getForeground());
            }
 else {
              showErrorMessage();
            }
            SwingUtilities.invokeLater(new Runnable(){
              @Override public void run(){
                myPackageTree.setModel(model);
                myTreeExpansionMonitor.restore();
              }
            }
);
          }
 catch (          ProcessCanceledException e) {
            ex[0]=e;
          }
 finally {
            myCurrentProgress=null;
            setToComponent(myMatchingCountLabel,requestFocus);
          }
        }
      }
);
      if (ex[0] != null) {
        throw ex[0];
      }
    }
  }
;
  ProgressManager.getInstance().runProcess(updateModel,progress);
}
