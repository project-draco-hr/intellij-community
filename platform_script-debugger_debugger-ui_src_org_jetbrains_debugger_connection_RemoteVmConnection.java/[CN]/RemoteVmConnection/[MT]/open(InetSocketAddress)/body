{
  setState(ConnectionStatus.WAITING_FOR_CONNECTION,"Connecting to " + address.getHostName() + ":"+ address.getPort());
  final Future<?> future=ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      if (Thread.interrupted()) {
        return;
      }
      final AsyncPromise<Vm> result=new AsyncPromise<Vm>();
      connectCancelHandler.set(new Runnable(){
        @Override public void run(){
          result.setError("Closed explicitly");
        }
      }
);
      ActionCallback callback=new ActionCallback();
      NettyUtil.connectClient(createBootstrap(address,result),address,callback);
      callback.doWhenRejected(new Consumer<String>(){
        @Override public void consume(        String error){
          result.setError(error);
        }
      }
);
      result.done(new Consumer<Vm>(){
        @Override public void consume(        @NotNull Vm vm){
          RemoteVmConnection.this.vm=vm;
          setState(ConnectionStatus.CONNECTED,"Connected to " + connectedAddressToPresentation(address,vm));
          startProcessing();
        }
      }
).rejected(new Consumer<String>(){
        @Override public void consume(        String error){
          setState(ConnectionStatus.CONNECTION_FAILED,error == null ? "Internal error" : error);
        }
      }
).processed(new Consumer<Vm>(){
        @Override public void consume(        Vm vm){
          connectCancelHandler.set(null);
        }
      }
);
    }
  }
);
  connectCancelHandler.set(new Runnable(){
    @Override public void run(){
      future.cancel(true);
    }
  }
);
}
