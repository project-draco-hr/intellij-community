{
  setState(ConnectionStatus.WAITING_FOR_CONNECTION,"Connecting to " + address.getHostName() + ":"+ address.getPort());
  final Future<?> future=ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      if (Thread.interrupted()) {
        return;
      }
      final AsyncResult<Vm> result=new AsyncResult<Vm>();
      connectCancelHandler.set(new Runnable(){
        @Override public void run(){
          result.reject("Closed explicitly");
        }
      }
);
      createVmAndConnect(address,result);
      result.doWhenDone(new Consumer<Vm>(){
        @Override public void consume(        @NotNull Vm vm){
          RemoteVmConnection.this.vm=vm;
          setState(ConnectionStatus.CONNECTED,"Connected to " + address.getHostName() + ":"+ address.getPort());
          startProcessing();
        }
      }
).doWhenRejected(new Consumer<String>(){
        @Override public void consume(        String error){
          if (getState().getStatus() == ConnectionStatus.WAITING_FOR_CONNECTION) {
            setState(ConnectionStatus.CONNECTION_FAILED,error == null ? "Internal error" : error);
          }
        }
      }
).doWhenProcessed(new Runnable(){
        @Override public void run(){
          connectCancelHandler.set(null);
        }
      }
);
    }
  }
);
  connectCancelHandler.set(new Runnable(){
    @Override public void run(){
      future.cancel(true);
    }
  }
);
}
