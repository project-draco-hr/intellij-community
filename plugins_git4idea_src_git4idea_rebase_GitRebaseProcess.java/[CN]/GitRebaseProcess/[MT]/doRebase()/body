{
  LOG.info("Started rebase");
  LOG.debug("Started rebase with the following spec: " + myRebaseSpec);
  Map<GitRepository,GitRebaseStatus> statuses=newLinkedHashMap(myRebaseSpec.getStatuses());
  Collection<GitRepository> toRefresh=newLinkedHashSet();
  List<GitRepository> repositoriesToRebase=myRebaseSpec.getIncompleteRepositories();
  AccessToken token=DvcsUtil.workingTreeChangeStarted(myProject);
  try {
    if (!saveDirtyRootsInitially(repositoriesToRebase))     return;
    GitRepository failed=null;
    for (    GitRepository repository : repositoriesToRebase) {
      GitRebaseResumeMode customMode=null;
      if (repository == myRebaseSpec.getOngoingRebase()) {
        customMode=myCustomMode == null ? GitRebaseResumeMode.CONTINUE : myCustomMode;
      }
      GitRebaseStatus rebaseStatus=rebaseSingleRoot(repository,customMode,getSuccessfulRepositories(statuses));
      statuses.put(repository,rebaseStatus);
      if (shouldBeRefreshed(rebaseStatus)) {
        toRefresh.add(repository);
      }
      if (rebaseStatus.getType() != GitRebaseStatus.Type.SUCCESS) {
        failed=repository;
        break;
      }
    }
    if (failed == null) {
      LOG.debug("Rebase completed successfully.");
      mySaver.load();
    }
    refresh(toRefresh);
    if (failed == null) {
      notifySuccess(getSuccessfulRepositories(statuses),getSkippedCommits(statuses));
    }
    saveUpdatedSpec(statuses);
  }
 catch (  Throwable e) {
    myRepositoryManager.setOngoingRebaseSpec(null);
    ExceptionUtil.rethrowUnchecked(e);
  }
 finally {
    DvcsUtil.workingTreeChangeFinished(myProject,token);
  }
}
