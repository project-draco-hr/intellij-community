{
  Set<PyClassType> visited=context.get(CTX_VISITED);
  if (visited == null) {
    visited=new HashSet<PyClassType>();
    context.put(CTX_VISITED,visited);
  }
  if (visited.contains(this)) {
    return ArrayUtil.EMPTY_OBJECT_ARRAY;
  }
  visited.add(this);
  Set<String> namesAlready=context.get(CTX_NAMES);
  if (namesAlready == null) {
    namesAlready=new HashSet<String>();
  }
  final Map<String,Pair<ElementType,Object>> usedNames=new HashMap<String,Pair<ElementType,Object>>();
  boolean suppressParentheses=context.get(CTX_SUPPRESS_PARENTHESES) != null;
  addOwnClassMembers(location,namesAlready,suppressParentheses,usedNames);
  namesAlready.addAll(usedNames.keySet());
  PsiFile origin=(location != null) ? CompletionUtil.getOriginalOrSelf(location).getContainingFile() : null;
  final TypeEvalContext typeEvalContext=TypeEvalContext.codeCompletion(myClass.getProject(),origin);
  final List<Object> inheritedMembers=addInheritedMembers(prefix,location,namesAlready,context,usedNames,typeEvalContext);
  namesAlready.addAll(usedNames.keySet());
  for (  final PyClassMembersProvider provider : Extensions.getExtensions(PyClassMembersProvider.EP_NAME)) {
    for (    final PyCustomMember member : provider.getMembers(this,location)) {
      final String name=member.getName();
      final LookupElementBuilder element=PyCustomMemberUtils.toLookUpElement(member,getName());
      final Pair<ElementType,Object> usedNameInfo=usedNames.get(name);
      if (usedNameInfo == null || (usedNameInfo.first == ElementType.INHERITED && provider instanceof PyOverridingAncestorsClassMembersProvider) || (usedNameInfo.first == ElementType.OWN && provider instanceof PyOverridingClassMembersProvider)) {
        usedNames.put(name,Pair.<ElementType,Object>create(ElementType.BY_PROVIDER,element));
      }
 else {
        int i=1;
      }
    }
  }
  final List<Object> ret=new ArrayList<Object>(getElementsFromUsedNames(usedNames));
  namesAlready.addAll(usedNames.keySet());
  ret.addAll(inheritedMembers);
  if (!myClass.isNewStyleClass()) {
    final PyBuiltinCache cache=PyBuiltinCache.getInstance(myClass);
    final PyClassType classobjType=cache.getOldstyleClassobjType();
    if (classobjType != null) {
      ret.addAll(Arrays.asList(classobjType.getCompletionVariants(prefix,location,context)));
    }
  }
  if (isDefinition() && myClass.isNewStyleClass()) {
    final PyClassLikeType typeType=getMetaClassType(typeEvalContext,true);
    if (typeType != null) {
      Collections.addAll(ret,typeType.getCompletionVariants(prefix,location,context));
    }
  }
  return ret.toArray();
}
