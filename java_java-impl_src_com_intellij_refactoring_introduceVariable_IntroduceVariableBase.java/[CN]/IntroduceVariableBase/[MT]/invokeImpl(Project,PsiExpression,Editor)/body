{
  if (expr != null) {
    final String errorMessage=getErrorMessage(expr);
    if (errorMessage != null) {
      showErrorMessage(project,editor,RefactoringBundle.getCannotRefactorMessage(errorMessage));
      return false;
    }
  }
  if (expr != null && expr.getParent() instanceof PsiExpressionStatement) {
    FeatureUsageTracker.getInstance().triggerFeatureUsed("refactoring.introduceVariable.incompleteStatement");
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + expr);
  }
  if (expr == null || !expr.isPhysical()) {
    if (ReassignVariableUtil.reassign(editor))     return false;
    if (expr == null) {
      String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.block.should.represent.an.expression"));
      showErrorMessage(project,editor,message);
      return false;
    }
  }
  final PsiType originalType=RefactoringUtil.getTypeByExpressionWithExpectedType(expr);
  if (originalType == null || LambdaUtil.notInferredType(originalType)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("unknown.expression.type"));
    showErrorMessage(project,editor,message);
    return false;
  }
  if (PsiType.VOID.equals(originalType)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiElement physicalElement=expr.getUserData(ElementToWorkOn.PARENT);
  final PsiElement anchorStatement=RefactoringUtil.getParentStatement(physicalElement != null ? physicalElement : expr,false);
  if (anchorStatement == null) {
    return parentStatementNotFound(project,editor);
  }
  if (checkAnchorBeforeThisOrSuper(project,editor,anchorStatement,REFACTORING_NAME,HelpID.INTRODUCE_VARIABLE))   return false;
  final PsiElement tempContainer=anchorStatement.getParent();
  if (!(tempContainer instanceof PsiCodeBlock) && !RefactoringUtil.isLoopOrIf(tempContainer) && (tempContainer.getParent() instanceof PsiLambdaExpression)) {
    String message=RefactoringBundle.message("refactoring.is.not.supported.in.the.current.context",REFACTORING_NAME);
    showErrorMessage(project,editor,message);
    return false;
  }
  if (!NotInSuperCallOccurrenceFilter.INSTANCE.isOK(expr)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("cannot.introduce.variable.in.super.constructor.call"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiFile file=anchorStatement.getContainingFile();
  LOG.assertTrue(file != null,"expr.getContainingFile() == null");
  final PsiElement nameSuggestionContext=editor == null ? null : file.findElementAt(editor.getCaretModel().getOffset());
  final RefactoringSupportProvider supportProvider=LanguageRefactoringSupport.INSTANCE.forLanguage(expr.getLanguage());
  final boolean isInplaceAvailableOnDataContext=supportProvider != null && editor.getSettings().isVariableInplaceRenameEnabled() && supportProvider.isInplaceIntroduceAvailable(expr,nameSuggestionContext) && (!ApplicationManager.getApplication().isUnitTestMode() || isInplaceAvailableInTestMode()) && !isInJspHolderMethod(expr);
  if (isInplaceAvailableOnDataContext) {
    final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
    checkInLoopCondition(expr,conflicts);
    if (!conflicts.isEmpty()) {
      showErrorMessage(project,editor,StringUtil.join(conflicts.values(),"<br>"));
      return false;
    }
  }
  final ExpressionOccurrenceManager occurrenceManager=createOccurrenceManager(expr,tempContainer);
  final PsiExpression[] occurrences=occurrenceManager.getOccurrences();
  final PsiElement anchorStatementIfAll=occurrenceManager.getAnchorStatementForAll();
  final List<PsiExpression> nonWrite=new ArrayList<PsiExpression>();
  boolean cantReplaceAll=false;
  boolean cantReplaceAllButWrite=false;
  for (  PsiExpression occurrence : occurrences) {
    if (!RefactoringUtil.isAssignmentLHS(occurrence)) {
      nonWrite.add(occurrence);
    }
 else     if (isFinalVariableOnLHS(occurrence)) {
      cantReplaceAll=true;
    }
 else     if (!nonWrite.isEmpty()) {
      cantReplaceAllButWrite=true;
      cantReplaceAll=true;
    }
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,file))   return false;
  final LinkedHashMap<OccurrencesChooser.ReplaceChoice,List<PsiExpression>> occurrencesMap=ContainerUtil.newLinkedHashMap();
  occurrencesMap.put(OccurrencesChooser.ReplaceChoice.NO,Collections.singletonList(expr));
  final boolean hasWriteAccess=occurrences.length > nonWrite.size() && occurrences.length > 1;
  if (hasWriteAccess && !cantReplaceAllButWrite) {
    occurrencesMap.put(OccurrencesChooser.ReplaceChoice.NO_WRITE,nonWrite);
  }
  if (occurrences.length > 1 && !cantReplaceAll) {
    occurrencesMap.put(OccurrencesChooser.ReplaceChoice.ALL,Arrays.asList(occurrences));
  }
  final boolean inFinalContext=occurrenceManager.isInFinalContext();
  final InputValidator validator=new InputValidator(this,project,anchorStatementIfAll,anchorStatement,occurrenceManager);
  final TypeSelectorManagerImpl typeSelectorManager=new TypeSelectorManagerImpl(project,originalType,expr,occurrences);
  final boolean[] wasSucceed=new boolean[]{true};
  final Pass<OccurrencesChooser.ReplaceChoice> callback=new Pass<OccurrencesChooser.ReplaceChoice>(){
    @Override public void pass(    final OccurrencesChooser.ReplaceChoice choice){
      final boolean allOccurences=choice == OccurrencesChooser.ReplaceChoice.ALL || choice == OccurrencesChooser.ReplaceChoice.NO_WRITE;
      final Ref<SmartPsiElementPointer<PsiVariable>> variable=new Ref<SmartPsiElementPointer<PsiVariable>>();
      final Editor topLevelEditor;
      if (!InjectedLanguageManager.getInstance(project).isInjectedFragment(anchorStatement.getContainingFile())) {
        topLevelEditor=InjectedLanguageUtil.getTopLevelEditor(editor);
      }
 else {
        topLevelEditor=editor;
      }
      final IntroduceVariableSettings settings;
      final PsiElement chosenAnchor;
      if (choice != null) {
        chosenAnchor=chooseAnchor(allOccurences,choice == OccurrencesChooser.ReplaceChoice.NO_WRITE,nonWrite,anchorStatementIfAll,anchorStatement);
        settings=getSettings(project,topLevelEditor,expr,occurrences,typeSelectorManager,inFinalContext,hasWriteAccess,validator,chosenAnchor,choice);
      }
 else {
        settings=getSettings(project,topLevelEditor,expr,occurrences,typeSelectorManager,inFinalContext,hasWriteAccess,validator,anchorStatement,choice);
        chosenAnchor=chooseAnchor(settings.isReplaceAllOccurrences(),hasWriteAccess,nonWrite,anchorStatementIfAll,anchorStatement);
      }
      if (!settings.isOK()) {
        wasSucceed[0]=false;
        return;
      }
      typeSelectorManager.setAllOccurrences(allOccurences);
      final TypeExpression expression=new TypeExpression(project,allOccurences ? typeSelectorManager.getTypesForAll() : typeSelectorManager.getTypesForOne());
      final RangeMarker exprMarker=topLevelEditor.getDocument().createRangeMarker(expr.getTextRange());
      final SuggestedNameInfo suggestedName=getSuggestedName(settings.getSelectedType(),expr,chosenAnchor);
      final List<RangeMarker> occurrenceMarkers=new ArrayList<RangeMarker>();
      final boolean noWrite=choice == OccurrencesChooser.ReplaceChoice.NO_WRITE;
      for (      PsiExpression occurrence : occurrences) {
        if (allOccurences || (noWrite && !PsiUtil.isAccessedForWriting(occurrence))) {
          occurrenceMarkers.add(topLevelEditor.getDocument().createRangeMarker(occurrence.getTextRange()));
        }
      }
      final RefactoringEventData beforeData=new RefactoringEventData();
      beforeData.addElement(expr);
      project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(REFACTORING_ID,beforeData);
      final String expressionText=expr.getText();
      final Runnable runnable=introduce(project,expr,topLevelEditor,chosenAnchor,occurrences,settings,variable);
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        public void run(){
          try {
            ApplicationManager.getApplication().runWriteAction(runnable);
          }
  finally {
            final RefactoringEventData afterData=new RefactoringEventData();
            final SmartPsiElementPointer<PsiVariable> pointer=variable.get();
            afterData.addElement(pointer != null ? pointer.getElement() : null);
            project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(REFACTORING_ID,afterData);
          }
          if (isInplaceAvailableOnDataContext) {
            final PsiVariable elementToRename=variable.get().getElement();
            if (elementToRename != null) {
              topLevelEditor.getCaretModel().moveToOffset(elementToRename.getTextOffset());
              final boolean cantChangeFinalModifier=(hasWriteAccess || inFinalContext) && choice == OccurrencesChooser.ReplaceChoice.ALL;
              final JavaVariableInplaceIntroducer renamer=new JavaVariableInplaceIntroducer(project,expression,topLevelEditor,elementToRename,cantChangeFinalModifier,typeSelectorManager.getTypesForAll().length > 1,exprMarker,occurrenceMarkers,REFACTORING_NAME);
              renamer.initInitialText(expressionText);
              PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(topLevelEditor.getDocument());
              renamer.performInplaceRefactoring(new LinkedHashSet<String>(Arrays.asList(suggestedName.names)));
            }
          }
        }
      }
,REFACTORING_NAME,null);
    }
  }
;
  if (!isInplaceAvailableOnDataContext) {
    callback.pass(null);
  }
 else {
    OccurrencesChooser.<PsiExpression>simpleChooser(editor).showChooser(callback,occurrencesMap);
  }
  return wasSucceed[0];
}
