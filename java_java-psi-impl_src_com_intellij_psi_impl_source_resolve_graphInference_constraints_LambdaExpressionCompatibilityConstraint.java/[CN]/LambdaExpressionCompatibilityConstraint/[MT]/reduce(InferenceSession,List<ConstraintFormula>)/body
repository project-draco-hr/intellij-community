{
  if (LambdaHighlightingUtil.checkInterfaceFunctional(myT) != null) {
    return false;
  }
  final PsiType groundTargetType=FunctionalInterfaceParameterizationUtil.getGroundTargetType(myT,myExpression,false);
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(groundTargetType);
  final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
  if (interfaceMethod == null) {
    return false;
  }
  final PsiSubstitutor substitutor=LambdaUtil.getSubstitutor(interfaceMethod,resolveResult);
  final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
  final PsiParameter[] lambdaParameters=myExpression.getParameterList().getParameters();
  if (lambdaParameters.length != parameters.length) {
    return false;
  }
  if (myExpression.hasFormalParameterTypes()) {
    for (int i=0; i < lambdaParameters.length; i++) {
      constraints.add(new TypeEqualityConstraint(lambdaParameters[i].getType(),substitutor.substitute(parameters[i].getType())));
    }
  }
 else {
    for (    PsiParameter parameter : parameters) {
      if (!session.isProperType(substitutor.substitute(parameter.getType()))) {
        return false;
      }
    }
  }
  PsiType returnType=interfaceMethod.getReturnType();
  if (returnType != null) {
    final List<PsiExpression> returnExpressions=LambdaUtil.getReturnExpressions(myExpression);
    if (returnType.equals(PsiType.VOID)) {
      if (!returnExpressions.isEmpty() && !(myExpression.getBody() instanceof PsiExpression)) {
        return false;
      }
    }
 else {
      if (returnExpressions.isEmpty() && !myExpression.isValueCompatible()) {
        return false;
      }
      returnType=substitutor.substitute(returnType);
      if (!session.isProperType(returnType)) {
        for (        PsiExpression returnExpression : returnExpressions) {
          constraints.add(new ExpressionCompatibilityConstraint(returnExpression,GenericsUtil.eliminateWildcards(returnType)));
        }
      }
    }
  }
  return true;
}
