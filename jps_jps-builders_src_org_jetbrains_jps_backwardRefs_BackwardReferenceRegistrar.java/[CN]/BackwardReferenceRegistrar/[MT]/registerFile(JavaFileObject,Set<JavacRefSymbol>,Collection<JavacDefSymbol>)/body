{
  List<JavacRefSymbol> fileIndexData=null;
  for (  JavacDefSymbol def : defs) {
    Tree.Kind kind=def.getPlaceKind();
    if (kind == Tree.Kind.CLASS) {
      Symbol.ClassSymbol sym=(Symbol.ClassSymbol)def.getSymbol();
      Type superclass=sym.getSuperclass();
      List<Type> interfaces=sym.getInterfaces();
      final Symbol[] supers;
      if (superclass != Type.noType) {
        supers=new Symbol[interfaces.size() + 1];
        supers[interfaces.size()]=superclass.asElement();
      }
 else {
        supers=interfaces.isEmpty() ? EMPTY_SYMBOL_ARRAY : new Symbol[interfaces.size()];
      }
      int i=0;
      for (      Type anInterface : interfaces) {
        supers[i++]=anInterface.asElement();
      }
      myWriter.writeHierarchy(sym,supers);
    }
 else     if (kind == LightUsage.MEMBER_REFERENCE || kind == LightUsage.LAMBDA_EXPRESSION) {
      if (fileIndexData == null) {
        fileIndexData=new ArrayList<JavacRefSymbol>();
      }
      fileIndexData.add(def);
    }
  }
  final List<LightUsage> usages;
  if (fileIndexData != null) {
    fileIndexData.addAll(refs);
    usages=myWriter.asLightUsages(fileIndexData);
  }
 else {
    usages=myWriter.asLightUsages(refs);
  }
  myWriter.writeReferences(file,usages);
}
