{
  final UnversionedAndNotTouchedFilesGroupCollector collector=new UnversionedAndNotTouchedFilesGroupCollector();
  final ChangesChecker checker=new ChangesChecker(changeProvider,collector);
  checker.gather(changes);
  exceptions.addAll(checker.getExceptions());
  ProgressTracker revertHandler=new ProgressTracker(){
    public void consume(    ProgressEvent event){
      if (event.getAction() == EventAction.REVERT) {
        final File file=event.getFile();
        if (file != null) {
          listener.accept(file);
        }
      }
      if (event.getAction() == EventAction.FAILED_REVERT) {
        exceptions.add(new VcsException("Revert failed"));
      }
    }
    public void checkCancelled(){
      listener.checkCanceled();
    }
  }
;
  final List<CopiedAsideInfo> fromToModified=new ArrayList<CopiedAsideInfo>();
  final Map<File,PropertiesMap> properties=ContainerUtil.newHashMap();
  moveRenamesToTmp(exceptions,fromToModified,properties,collector);
  final Reverter reverter=new Reverter(mySvnVcs,revertHandler,exceptions);
  reverter.revert(checker.getForAdds(),true);
  reverter.revert(checker.getForDeletes(),true);
  final List<File> edits=checker.getForEdits();
  reverter.revert(edits.toArray(new File[edits.size()]),false);
  moveGroup(exceptions,fromToModified,properties);
  final List<Couple<File>> toBeDeleted=collector.getToBeDeleted();
  for (  Couple<File> pair : toBeDeleted) {
    if (pair.getFirst().exists()) {
      FileUtil.delete(pair.getSecond());
    }
  }
}
