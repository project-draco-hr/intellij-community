{
  ClassNode root=mapRootClasses.get(cl.qualifiedName);
  if (root.type != ClassNode.CLASS_ROOT) {
    return;
  }
  try {
    ImportCollector importCollector=new ImportCollector(root);
    DecompilerContext.setImportCollector(importCollector);
    DecompilerContext.setCounterContainer(new CounterContainer());
    DecompilerContext.setBytecodeSourceMapper(new BytecodeSourceMapper());
    new LambdaProcessor().processClass(root);
    addClassnameToImport(root,importCollector);
    initWrappers(root);
    new NestedClassProcessor().processClass(root,root);
    new NestedMemberAccess().propagateMemberAccess(root);
    StringBuilder classBuffer=new StringBuilder();
    new ClassWriter().classToJava(root,classBuffer,0);
    String lineSeparator=DecompilerContext.getNewLineSeparator();
    int index=cl.qualifiedName.lastIndexOf("/");
    if (index >= 0) {
      String packageName=cl.qualifiedName.substring(0,index).replace('/','.');
      buffer.append("package ");
      buffer.append(packageName);
      buffer.append(";");
      buffer.append(lineSeparator);
      buffer.append(lineSeparator);
    }
    if (importCollector.writeImports(buffer)) {
      buffer.append(lineSeparator);
    }
    buffer.append(classBuffer);
    if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {
      buffer.append(lineSeparator);
      DecompilerContext.getBytecodeSourceMapper().dumpMapping(classBuffer);
    }
  }
  finally {
    destroyWrappers(root);
  }
}
