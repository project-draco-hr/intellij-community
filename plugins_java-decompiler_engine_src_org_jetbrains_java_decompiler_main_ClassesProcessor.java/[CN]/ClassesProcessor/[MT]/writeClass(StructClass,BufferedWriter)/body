{
  ClassNode root=mapRootClasses.get(cl.qualifiedName);
  if (root.type != ClassNode.CLASS_ROOT) {
    return;
  }
  try {
    DecompilerContext.setImportCollector(new ImportCollector(root));
    DecompilerContext.setCounterContainer(new CounterContainer());
    LambdaProcessor lambda_proc=new LambdaProcessor();
    lambda_proc.processClass(root);
    addClassnameToImport(root,DecompilerContext.getImportCollector());
    initWrappers(root);
    NestedClassProcessor nestedproc=new NestedClassProcessor();
    nestedproc.processClass(root,root);
    NestedMemberAccess nstmember=new NestedMemberAccess();
    nstmember.propagateMemberAccess(root);
    ClassWriter clwriter=new ClassWriter();
    StringWriter strwriter=new StringWriter();
    clwriter.classToJava(root,new BufferedWriter(strwriter),0);
    int index=cl.qualifiedName.lastIndexOf("/");
    if (index >= 0) {
      String packageName=cl.qualifiedName.substring(0,index).replace('/','.');
      writer.write("package ");
      writer.write(packageName);
      writer.write(";");
      writer.write(DecompilerContext.getNewLineSeparator());
      writer.write(DecompilerContext.getNewLineSeparator());
    }
    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE,root);
    DecompilerContext.getImportCollector().writeImports(writer);
    writer.write(DecompilerContext.getNewLineSeparator());
    writer.write(strwriter.toString());
    writer.flush();
  }
  finally {
    destroyWrappers(root);
  }
}
