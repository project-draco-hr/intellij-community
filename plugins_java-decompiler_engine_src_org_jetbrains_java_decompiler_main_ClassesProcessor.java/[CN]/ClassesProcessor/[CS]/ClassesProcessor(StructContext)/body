{
  Map<String,Object[]> mapInnerClasses=new HashMap<String,Object[]>();
  Map<String,Set<String>> mapNestedClassReferences=new HashMap<String,Set<String>>();
  Map<String,Set<String>> mapEnclosingClassReferences=new HashMap<String,Set<String>>();
  Map<String,String> mapNewSimpleNames=new HashMap<String,String>();
  boolean bDecompileInner=DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_INNER);
  for (  StructClass cl : context.getClasses().values()) {
    if (cl.isOwn() && !mapRootClasses.containsKey(cl.qualifiedName)) {
      if (bDecompileInner) {
        StructInnerClassesAttribute inner=(StructInnerClassesAttribute)cl.getAttributes().getWithKey("InnerClasses");
        if (inner != null) {
          for (int i=0; i < inner.getClassEntries().size(); i++) {
            int[] entry=inner.getClassEntries().get(i);
            String[] strEntry=inner.getStringEntries().get(i);
            Object[] arr=new Object[4];
            String innerName=strEntry[0];
            arr[2]=entry[1] == 0 ? (entry[2] == 0 ? ClassNode.CLASS_ANONYMOUS : ClassNode.CLASS_LOCAL) : ClassNode.CLASS_MEMBER;
            String simpleName=strEntry[2];
            String savedName=mapNewSimpleNames.get(innerName);
            if (savedName != null) {
              simpleName=savedName;
            }
 else             if (simpleName != null && DecompilerContext.getOption(IFernflowerPreferences.RENAME_ENTITIES)) {
              IIdentifierRenamer renamer=DecompilerContext.getPoolInterceptor().getHelper();
              if (renamer.toBeRenamed(IIdentifierRenamer.Type.ELEMENT_CLASS,simpleName,null,null)) {
                simpleName=renamer.getNextClassName(innerName,simpleName);
                mapNewSimpleNames.put(innerName,simpleName);
              }
            }
            arr[1]=simpleName;
            arr[3]=entry[3];
            String enclClassName;
            if (entry[1] != 0) {
              enclClassName=strEntry[1];
            }
 else {
              enclClassName=cl.qualifiedName;
            }
            if (!innerName.equals(enclClassName)) {
              StructClass enclosing_class=context.getClasses().get(enclClassName);
              if (enclosing_class != null && enclosing_class.isOwn()) {
                Object[] arrOld=mapInnerClasses.get(innerName);
                if (arrOld == null) {
                  mapInnerClasses.put(innerName,arr);
                }
 else                 if (!InterpreterUtil.equalObjectArrays(arrOld,arr)) {
                  String message="Inconsistent inner class entries for " + innerName + "!";
                  DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
                }
                Set<String> set=mapNestedClassReferences.get(enclClassName);
                if (set == null) {
                  mapNestedClassReferences.put(enclClassName,set=new HashSet<String>());
                }
                set.add(innerName);
                set=mapEnclosingClassReferences.get(innerName);
                if (set == null) {
                  mapEnclosingClassReferences.put(innerName,set=new HashSet<String>());
                }
                set.add(enclClassName);
              }
            }
          }
        }
      }
      ClassNode node=new ClassNode(ClassNode.CLASS_ROOT,cl);
      node.access=cl.getAccessFlags();
      mapRootClasses.put(cl.qualifiedName,node);
    }
  }
  if (bDecompileInner) {
    for (    Entry<String,ClassNode> ent : mapRootClasses.entrySet()) {
      if (!mapInnerClasses.containsKey(ent.getKey())) {
        Set<String> setVisited=new HashSet<String>();
        LinkedList<String> stack=new LinkedList<String>();
        stack.add(ent.getKey());
        setVisited.add(ent.getKey());
        while (!stack.isEmpty()) {
          String superClass=stack.removeFirst();
          ClassNode superNode=mapRootClasses.get(superClass);
          Set<String> setNestedClasses=mapNestedClassReferences.get(superClass);
          if (setNestedClasses != null) {
            StructClass scl=superNode.classStruct;
            StructInnerClassesAttribute inner=(StructInnerClassesAttribute)scl.getAttributes().getWithKey("InnerClasses");
            for (int i=0; i < inner.getStringEntries().size(); i++) {
              String nestedClass=inner.getStringEntries().get(i)[0];
              if (!setNestedClasses.contains(nestedClass)) {
                continue;
              }
              if (!setVisited.add(nestedClass)) {
                continue;
              }
              ClassNode nestedNode=mapRootClasses.get(nestedClass);
              if (nestedNode == null) {
                DecompilerContext.getLogger().writeMessage("Nested class " + nestedClass + " missing!",IFernflowerLogger.Severity.WARN);
                continue;
              }
              Object[] arr=mapInnerClasses.get(nestedClass);
              nestedNode.type=(Integer)arr[2];
              nestedNode.simpleName=(String)arr[1];
              nestedNode.access=(Integer)arr[3];
              if (nestedNode.type == ClassNode.CLASS_ANONYMOUS) {
                StructClass cl=nestedNode.classStruct;
                nestedNode.access&=~CodeConstants.ACC_STATIC;
                int[] interfaces=cl.getInterfaces();
                if (interfaces.length > 0) {
                  if (interfaces.length > 1) {
                    String message="Inconsistent anonymous class definition: " + cl.qualifiedName;
                    DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
                  }
                  nestedNode.anonymousClassType=new VarType(cl.getInterface(0),true);
                }
 else {
                  nestedNode.anonymousClassType=new VarType(cl.superClass.getString(),true);
                }
              }
 else               if (nestedNode.type == ClassNode.CLASS_LOCAL) {
                nestedNode.access&=(CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_FINAL);
              }
              superNode.nested.add(nestedNode);
              nestedNode.parent=superNode;
              nestedNode.enclosingClasses.addAll(mapEnclosingClassReferences.get(nestedClass));
              stack.add(nestedClass);
            }
          }
        }
      }
    }
  }
}
