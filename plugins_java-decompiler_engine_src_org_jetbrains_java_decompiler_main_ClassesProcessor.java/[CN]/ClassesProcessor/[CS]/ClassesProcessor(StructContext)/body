{
  Map<String,Inner> mapInnerClasses=new HashMap<String,Inner>();
  Map<String,Set<String>> mapNestedClassReferences=new HashMap<String,Set<String>>();
  Map<String,Set<String>> mapEnclosingClassReferences=new HashMap<String,Set<String>>();
  Map<String,String> mapNewSimpleNames=new HashMap<String,String>();
  boolean bDecompileInner=DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_INNER);
  for (  StructClass cl : context.getClasses().values()) {
    if (cl.isOwn() && !mapRootClasses.containsKey(cl.qualifiedName)) {
      if (bDecompileInner) {
        StructInnerClassesAttribute inner=(StructInnerClassesAttribute)cl.getAttributes().getWithKey("InnerClasses");
        if (inner != null) {
          for (          StructInnerClassesAttribute.Entry entry : inner.getEntries()) {
            String innerName=entry.innerName;
            String simpleName=entry.simpleName;
            String savedName=mapNewSimpleNames.get(innerName);
            if (savedName != null) {
              simpleName=savedName;
            }
 else             if (simpleName != null && DecompilerContext.getOption(IFernflowerPreferences.RENAME_ENTITIES)) {
              IIdentifierRenamer renamer=DecompilerContext.getPoolInterceptor().getHelper();
              if (renamer.toBeRenamed(IIdentifierRenamer.Type.ELEMENT_CLASS,simpleName,null,null)) {
                simpleName=renamer.getNextClassName(innerName,simpleName);
                mapNewSimpleNames.put(innerName,simpleName);
              }
            }
            Inner rec=new Inner();
            rec.simpleName=simpleName;
            rec.type=entry.outerNameIdx != 0 ? ClassNode.CLASS_MEMBER : entry.simpleNameIdx != 0 ? ClassNode.CLASS_LOCAL : ClassNode.CLASS_ANONYMOUS;
            rec.accessFlags=entry.accessFlags;
            String enclClassName;
            if (entry.outerNameIdx != 0) {
              enclClassName=entry.enclosingName;
            }
 else {
              enclClassName=cl.qualifiedName;
            }
            if (!innerName.equals(enclClassName)) {
              StructClass enclosing_class=context.getClasses().get(enclClassName);
              if (enclosing_class != null && enclosing_class.isOwn()) {
                Inner existingRec=mapInnerClasses.get(innerName);
                if (existingRec == null) {
                  mapInnerClasses.put(innerName,rec);
                }
 else                 if (!Inner.equal(existingRec,rec)) {
                  String message="Inconsistent inner class entries for " + innerName + "!";
                  DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
                }
                Set<String> set=mapNestedClassReferences.get(enclClassName);
                if (set == null) {
                  mapNestedClassReferences.put(enclClassName,set=new HashSet<String>());
                }
                set.add(innerName);
                set=mapEnclosingClassReferences.get(innerName);
                if (set == null) {
                  mapEnclosingClassReferences.put(innerName,set=new HashSet<String>());
                }
                set.add(enclClassName);
              }
            }
          }
        }
      }
      ClassNode node=new ClassNode(ClassNode.CLASS_ROOT,cl);
      node.access=cl.getAccessFlags();
      mapRootClasses.put(cl.qualifiedName,node);
    }
  }
  if (bDecompileInner) {
    for (    Entry<String,ClassNode> ent : mapRootClasses.entrySet()) {
      if (!mapInnerClasses.containsKey(ent.getKey())) {
        Set<String> setVisited=new HashSet<String>();
        LinkedList<String> stack=new LinkedList<String>();
        stack.add(ent.getKey());
        setVisited.add(ent.getKey());
        while (!stack.isEmpty()) {
          String superClass=stack.removeFirst();
          ClassNode superNode=mapRootClasses.get(superClass);
          Set<String> setNestedClasses=mapNestedClassReferences.get(superClass);
          if (setNestedClasses != null) {
            StructClass scl=superNode.classStruct;
            StructInnerClassesAttribute inner=(StructInnerClassesAttribute)scl.getAttributes().getWithKey("InnerClasses");
            if (inner == null || inner.getEntries().isEmpty()) {
              DecompilerContext.getLogger().writeMessage(superClass + " does not contain inner classes!",IFernflowerLogger.Severity.WARN);
              continue;
            }
            for (            StructInnerClassesAttribute.Entry entry : inner.getEntries()) {
              String nestedClass=entry.innerName;
              if (!setNestedClasses.contains(nestedClass)) {
                continue;
              }
              if (!setVisited.add(nestedClass)) {
                continue;
              }
              ClassNode nestedNode=mapRootClasses.get(nestedClass);
              if (nestedNode == null) {
                DecompilerContext.getLogger().writeMessage("Nested class " + nestedClass + " missing!",IFernflowerLogger.Severity.WARN);
                continue;
              }
              Inner rec=mapInnerClasses.get(nestedClass);
              nestedNode.simpleName=rec.simpleName;
              nestedNode.type=rec.type;
              nestedNode.access=rec.accessFlags;
              if (nestedNode.type == ClassNode.CLASS_ANONYMOUS) {
                StructClass cl=nestedNode.classStruct;
                nestedNode.access&=~CodeConstants.ACC_STATIC;
                int[] interfaces=cl.getInterfaces();
                if (interfaces.length > 0) {
                  if (interfaces.length > 1) {
                    String message="Inconsistent anonymous class definition: " + cl.qualifiedName;
                    DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
                  }
                  nestedNode.anonymousClassType=new VarType(cl.getInterface(0),true);
                }
 else {
                  nestedNode.anonymousClassType=new VarType(cl.superClass.getString(),true);
                }
              }
 else               if (nestedNode.type == ClassNode.CLASS_LOCAL) {
                nestedNode.access&=(CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_FINAL);
              }
              superNode.nested.add(nestedNode);
              nestedNode.parent=superNode;
              nestedNode.enclosingClasses.addAll(mapEnclosingClassReferences.get(nestedClass));
              stack.add(nestedClass);
            }
          }
        }
      }
    }
  }
}
