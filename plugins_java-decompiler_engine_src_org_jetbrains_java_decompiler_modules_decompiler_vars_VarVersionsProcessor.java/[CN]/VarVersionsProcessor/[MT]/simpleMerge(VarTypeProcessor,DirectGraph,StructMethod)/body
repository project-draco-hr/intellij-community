{
  Map<VarVersionPaar,VarType> mapExprentMaxTypes=typeProcessor.getMapExprentMaxTypes();
  Map<VarVersionPaar,VarType> mapExprentMinTypes=typeProcessor.getMapExprentMinTypes();
  Map<Integer,Set<Integer>> mapVarVersions=new HashMap<Integer,Set<Integer>>();
  for (  VarVersionPaar pair : mapExprentMinTypes.keySet()) {
    if (pair.version >= 0) {
      Set<Integer> set=mapVarVersions.get(pair.var);
      if (set == null) {
        set=new HashSet<Integer>();
        mapVarVersions.put(pair.var,set);
      }
      set.add(pair.version);
    }
  }
  boolean is_method_static=mt.hasModifier(CodeConstants.ACC_STATIC);
  Map<VarVersionPaar,Integer> mapMergedVersions=new HashMap<VarVersionPaar,Integer>();
  for (  Entry<Integer,Set<Integer>> ent : mapVarVersions.entrySet()) {
    if (ent.getValue().size() > 1) {
      List<Integer> lstVersions=new ArrayList<Integer>(ent.getValue());
      Collections.sort(lstVersions);
      for (int i=0; i < lstVersions.size(); i++) {
        VarVersionPaar firstPair=new VarVersionPaar(ent.getKey(),lstVersions.get(i));
        VarType firstType=mapExprentMinTypes.get(firstPair);
        if (firstPair.var == 0 && firstPair.version == 1 && !is_method_static) {
          continue;
        }
        for (int j=i + 1; j < lstVersions.size(); j++) {
          VarVersionPaar secondPair=new VarVersionPaar(ent.getKey(),lstVersions.get(j));
          VarType secondType=mapExprentMinTypes.get(secondPair);
          if (firstType.equals(secondType) || (firstType.equals(VarType.VARTYPE_NULL) && secondType.type == CodeConstants.TYPE_OBJECT) || (secondType.equals(VarType.VARTYPE_NULL) && firstType.type == CodeConstants.TYPE_OBJECT)) {
            VarType firstMaxType=mapExprentMaxTypes.get(firstPair);
            VarType secondMaxType=mapExprentMaxTypes.get(secondPair);
            VarType type=firstMaxType == null ? secondMaxType : secondMaxType == null ? firstMaxType : VarType.getCommonMinType(firstMaxType,secondMaxType);
            mapExprentMaxTypes.put(firstPair,type);
            mapMergedVersions.put(secondPair,firstPair.version);
            mapExprentMaxTypes.remove(secondPair);
            mapExprentMinTypes.remove(secondPair);
            if (firstType.equals(VarType.VARTYPE_NULL)) {
              mapExprentMinTypes.put(firstPair,secondType);
              firstType=secondType;
            }
            typeProcessor.getMapFinalVars().put(firstPair,VarTypeProcessor.VAR_NON_FINAL);
            lstVersions.remove(j);
            j--;
          }
        }
      }
    }
  }
  if (!mapMergedVersions.isEmpty()) {
    updateVersions(graph,mapMergedVersions);
  }
}
