{
  final PsiBuilder.Marker marker=builder.mark();
  builder.advanceLexer();
  if (builder.getTokenType() == RegExpTT.CATEGORY_SHORT_HAND) {
    if (!myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND)) {
      builder.error("Category shorthand not allowed in this regular expression dialect");
    }
    builder.advanceLexer();
  }
 else {
    if (builder.getTokenType() == RegExpTT.CHARACTER && isLetter(builder.getTokenText())) {
      builder.error(myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND) ? "Illegal category shorthand" : "'{' expected");
      builder.advanceLexer();
    }
 else     if (checkMatches(builder,RegExpTT.LBRACE,myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND) ? "'{' or category shorthand expected" : "'{' expected")) {
      if (builder.getTokenType() == RegExpTT.CARET) {
        if (!myCapabilities.contains(RegExpCapability.CARET_NEGATED_PROPERTIES)) {
          builder.error("Negating a property not allowed in this regular expression dialect");
        }
        builder.advanceLexer();
      }
      if (builder.getTokenType() == RegExpTT.NAME) {
        builder.advanceLexer();
        checkMatches(builder,RegExpTT.RBRACE,"Unclosed property");
      }
 else {
        if (builder.getTokenType() == RegExpTT.RBRACE) {
          builder.error("Empty property");
          builder.advanceLexer();
        }
 else {
          builder.error("Property name expected");
        }
        while (PROPERTY_TOKENS.contains(builder.getTokenType())) {
          builder.advanceLexer();
        }
      }
    }
  }
  marker.done(RegExpElementTypes.PROPERTY);
}
