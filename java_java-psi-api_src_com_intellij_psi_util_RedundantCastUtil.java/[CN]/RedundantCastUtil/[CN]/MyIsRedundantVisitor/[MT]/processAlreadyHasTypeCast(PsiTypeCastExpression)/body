{
  PsiElement parent=typeCast.getParent();
  while (parent instanceof PsiParenthesizedExpression)   parent=parent.getParent();
  if (parent instanceof PsiExpressionList)   return;
  if (parent instanceof PsiReturnStatement)   return;
  if (parent instanceof PsiTypeCastExpression)   return;
  if (parent instanceof PsiLambdaExpression)   return;
  if (parent instanceof PsiConditionalExpression) {
    PsiElement gParent=PsiUtil.skipParenthesizedExprUp(parent.getParent());
    if (gParent instanceof PsiLambdaExpression)     return;
    if (gParent instanceof PsiReturnStatement && PsiTreeUtil.getParentOfType(gParent,PsiMethod.class,PsiLambdaExpression.class) instanceof PsiLambdaExpression)     return;
  }
  if (isTypeCastSemantic(typeCast))   return;
  PsiTypeElement typeElement=typeCast.getCastType();
  if (typeElement == null)   return;
  final PsiType castTo=typeElement.getType();
  final PsiExpression operand=typeCast.getOperand();
  PsiType opType=operand.getType();
  final PsiType expectedTypeByParent=PsiTypesUtil.getExpectedTypeByParent(typeCast);
  if (expectedTypeByParent != null) {
    try {
      final Project project=operand.getProject();
      final String uniqueVariableName=JavaCodeStyleManager.getInstance(project).suggestUniqueVariableName("l",parent,false);
      final PsiDeclarationStatement declarationStatement=(PsiDeclarationStatement)JavaPsiFacade.getElementFactory(project).createStatementFromText(expectedTypeByParent.getCanonicalText() + " " + uniqueVariableName+ " = "+ operand.getText()+ ";",parent);
      final PsiExpression initializer=((PsiLocalVariable)declarationStatement.getDeclaredElements()[0]).getInitializer();
      LOG.assertTrue(initializer != null,operand.getText());
      opType=initializer.getType();
      if (opType != null) {
        final PsiExpression expr=PsiUtil.skipParenthesizedExprDown(operand);
        if (expr instanceof PsiConditionalExpression) {
          if (!isApplicableForConditionalBranch(opType,((PsiConditionalExpression)expr).getThenExpression()))           return;
          if (!isApplicableForConditionalBranch(opType,((PsiConditionalExpression)expr).getElseExpression()))           return;
        }
      }
    }
 catch (    IncorrectOperationException ignore) {
    }
  }
  if (opType == null)   return;
  if (parent instanceof PsiReferenceExpression) {
    if (castTo instanceof PsiClassType && opType instanceof PsiPrimitiveType)     return;
    if (opType instanceof PsiClassType) {
      final PsiReferenceExpression refExpression=(PsiReferenceExpression)parent;
      PsiElement element=refExpression.resolve();
      if (!(element instanceof PsiMember))       return;
      PsiClass accessClass=((PsiClassType)opType).resolve();
      if (accessClass == null)       return;
      if (!JavaPsiFacade.getInstance(parent.getProject()).getResolveHelper().isAccessible((PsiMember)element,typeCast,accessClass))       return;
      if (!isCastRedundantInRefExpression(refExpression,operand))       return;
    }
  }
  if (arrayAccessAtTheLeftSideOfAssignment(parent)) {
    if (TypeConversionUtil.isAssignable(opType,castTo,false) && opType.getArrayDimensions() == castTo.getArrayDimensions()) {
      addToResults(typeCast);
    }
  }
 else {
    if (parent instanceof PsiInstanceOfExpression && opType instanceof PsiPrimitiveType) {
      return;
    }
    if (parent instanceof PsiForeachStatement) {
      final PsiClassType.ClassResolveResult castResolveResult=PsiUtil.resolveGenericsClassInType(opType);
      final PsiClass psiClass=castResolveResult.getElement();
      if (psiClass != null) {
        final PsiClass iterableClass=JavaPsiFacade.getInstance(parent.getProject()).findClass(CommonClassNames.JAVA_LANG_ITERABLE,psiClass.getResolveScope());
        if (iterableClass != null && InheritanceUtil.isInheritorOrSelf(psiClass,iterableClass,true)) {
          final PsiTypeParameter[] iterableTypeParameters=iterableClass.getTypeParameters();
          if (iterableTypeParameters.length == 1) {
            final PsiType resultedParamType=TypeConversionUtil.getSuperClassSubstitutor(iterableClass,psiClass,castResolveResult.getSubstitutor()).substitute(iterableTypeParameters[0]);
            if (resultedParamType != null && TypeConversionUtil.isAssignable(((PsiForeachStatement)parent).getIterationParameter().getType(),resultedParamType)) {
              addToResults(typeCast);
              return;
            }
          }
        }
      }
 else {
        return;
      }
    }
    if (parent instanceof PsiThrowStatement) {
      final PsiClass thrownClass=PsiUtil.resolveClassInType(opType);
      if (InheritanceUtil.isInheritor(thrownClass,false,CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION)) {
        addToResults(typeCast);
        return;
      }
      if (InheritanceUtil.isInheritor(thrownClass,false,CommonClassNames.JAVA_LANG_THROWABLE)) {
        final PsiMethod method=PsiTreeUtil.getParentOfType(parent,PsiMethod.class);
        if (method != null) {
          for (          PsiClassType thrownType : method.getThrowsList().getReferencedTypes()) {
            if (TypeConversionUtil.isAssignable(thrownType,opType,false)) {
              addToResults(typeCast);
              return;
            }
          }
        }
      }
    }
    if (parent instanceof PsiInstanceOfExpression) {
      final PsiTypeElement checkTypeElement=((PsiInstanceOfExpression)parent).getCheckType();
      if (checkTypeElement != null && TypeConversionUtil.areTypesConvertible(opType,checkTypeElement.getType())) {
        addToResults(typeCast);
      }
    }
 else     if (TypeConversionUtil.isAssignable(castTo,opType,false) && (expectedTypeByParent == null || TypeConversionUtil.isAssignable(expectedTypeByParent,opType,false))) {
      addToResults(typeCast);
    }
  }
}
