{
  int startLine=myDocument.getLineNumber(startOffset);
  int endLine=myDocument.getLineNumber(endOffset);
  if (startLine + 1 == endLine && startOffset == myDocument.getLineStartOffset(startLine) && endOffset == myDocument.getLineStartOffset(endLine)) {
    endLine--;
    endOffset=myDocument.getLineEndOffset(endLine);
  }
  boolean rounded=attributes.getEffectType() == EffectType.ROUNDED_BOX;
  int lineHeight=myView.getLineHeight() - 1;
  g.setColor(attributes.getEffectColor());
  if (startLine == endLine) {
    int y=myView.visualLineToY(startLine);
    TFloatArrayList ranges=adjustedLogicalRangeToVisualRanges(startLine,startOffset,endOffset);
    for (int i=0; i < ranges.size() - 1; i+=2) {
      int startX=(int)ranges.get(i);
      int endX=(int)ranges.get(i + 1);
      if (rounded) {
        UIUtil.drawRectPickedOut(g,startX,y,endX - startX,lineHeight);
      }
 else {
        g.drawRect(startX,y,endX - startX,lineHeight);
      }
    }
  }
 else {
    int maxWidth=myView.getMaxWidthInLineRange(startLine,endLine) - 1;
    TFloatArrayList leadingRanges=adjustedLogicalRangeToVisualRanges(startLine,startOffset,myDocument.getLineEndOffset(startLine));
    TFloatArrayList trailingRanges=adjustedLogicalRangeToVisualRanges(endLine,myDocument.getLineStartOffset(endLine),endOffset);
    if (!leadingRanges.isEmpty() && !trailingRanges.isEmpty()) {
      boolean containsInnerLines=endLine > startLine + 1;
      int leadingTopY=myView.visualLineToY(startLine);
      int leadingBottomY=leadingTopY + lineHeight;
      int trailingTopY=myView.visualLineToY(endLine);
      int trailingBottomY=trailingTopY + lineHeight;
      float start=0;
      float end=0;
      float leftGap=leadingRanges.get(0) - (containsInnerLines ? 0 : trailingRanges.get(0));
      int adjustY=leftGap == 0 ? 2 : leftGap > 0 ? 1 : 0;
      for (int i=0; i < leadingRanges.size() - 1; i+=2) {
        start=leadingRanges.get(i);
        end=leadingRanges.get(i + 1);
        if (i > 0) {
          drawLine(g,leadingRanges.get(i - 1),leadingBottomY,start,leadingBottomY,rounded);
        }
        drawLine(g,start,leadingBottomY + (i == 0 ? adjustY : 0),start,leadingTopY,rounded);
        if ((i + 2) < leadingRanges.size()) {
          drawLine(g,start,leadingTopY,end,leadingTopY,rounded);
          drawLine(g,end,leadingTopY,end,leadingBottomY,rounded);
        }
      }
      end=Math.max(end,maxWidth);
      drawLine(g,start,leadingTopY,end,leadingTopY,rounded);
      drawLine(g,end,leadingTopY,end,trailingTopY - 1,rounded);
      float targetX=trailingRanges.get(trailingRanges.size() - 1);
      drawLine(g,end,trailingTopY - 1,targetX,trailingTopY - 1,rounded);
      adjustY=end == targetX ? -2 : -1;
      for (int i=trailingRanges.size() - 2; i >= 0; i-=2) {
        start=trailingRanges.get(i);
        end=trailingRanges.get(i + 1);
        drawLine(g,end,trailingTopY + (i == 0 ? adjustY : 0),end,trailingBottomY,rounded);
        drawLine(g,end,trailingBottomY,start,trailingBottomY,rounded);
        drawLine(g,start,trailingBottomY,start,trailingTopY,rounded);
        if (i > 0) {
          drawLine(g,start,trailingTopY,trailingRanges.get(i - 1),trailingTopY,rounded);
        }
      }
      float lastX=start;
      if (containsInnerLines) {
        if (start > 0) {
          drawLine(g,start,trailingTopY,start,trailingTopY - 1,rounded);
          drawLine(g,start,trailingTopY - 1,0,trailingTopY - 1,rounded);
          drawLine(g,0,trailingTopY - 1,0,leadingBottomY + 1,rounded);
        }
 else {
          drawLine(g,start,trailingTopY,0,leadingBottomY + 1,rounded);
        }
        lastX=0;
      }
      targetX=leadingRanges.get(0);
      if (lastX < targetX) {
        drawLine(g,lastX,leadingBottomY + 1,targetX,leadingBottomY + 1,rounded);
      }
 else {
        drawLine(g,lastX,leadingBottomY + 1,lastX,leadingBottomY,rounded);
        drawLine(g,lastX,leadingBottomY,targetX,leadingBottomY,rounded);
      }
    }
  }
}
