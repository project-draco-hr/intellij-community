{
  myStatic=isStatic;
  myScope=scope;
  final MultiMap<String,PsiMethod> byName=new MultiMap<String,PsiMethod>();
  myPsiManager=categoryClass.getManager();
  for (  PsiMethod m : categoryClass.getMethods()) {
    final PsiParameter[] params=m.getParameterList().getParameters();
    if (params.length == 0)     continue;
    if (PsiUtil.isDGMMethod(m) && (PsiImplUtil.isDeprecatedByAnnotation(m) || PsiImplUtil.isDeprecatedByDocTag(m))) {
      continue;
    }
    byName.putValue(m.getName(),m);
  }
  this.myOriginalMethodByType=new VolatileNotNullLazyValue<MultiMap<String,PsiMethod>>(){
    @NotNull @Override protected MultiMap<String,PsiMethod> compute(){
      MultiMap<String,PsiMethod> map=new MultiMap<String,PsiMethod>();
      for (      PsiMethod method : byName.values()) {
        if (!method.hasModifierProperty(PsiModifier.PUBLIC))         continue;
        map.putValue(getCategoryTargetType(method).getCanonicalText(),method);
      }
      return map;
    }
  }
;
  myOriginalMethodsByNameAndType=new ConcurrentFactoryMap<String,MultiMap<String,PsiMethod>>(){
    @Override protected MultiMap<String,PsiMethod> create(    String name){
      MultiMap<String,PsiMethod> map=new MultiMap<String,PsiMethod>();
      for (      PsiMethod method : byName.get(name)) {
        map.putValue(getCategoryTargetType(method).getCanonicalText(),method);
      }
      return map;
    }
  }
;
}
