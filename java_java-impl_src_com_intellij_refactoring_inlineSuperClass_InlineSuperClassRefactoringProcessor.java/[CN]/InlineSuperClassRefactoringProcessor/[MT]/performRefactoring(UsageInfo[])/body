{
  final DocCommentPolicy docPolicy=new DocCommentPolicy(myPolicy);
  new PushDownProcessor(mySuperClass,myMemberInfos,docPolicy){
    @Override protected boolean showConflicts(    @NotNull MultiMap<PsiElement,String> conflicts,    UsageInfo[] usages){
      return true;
    }
    @Override protected void performRefactoring(    @NotNull UsageInfo[] pushDownUsages){
      if (myCurrentInheritor != null) {
        pushDownToDedicatedClass(myCurrentInheritor);
      }
 else {
        super.performRefactoring(pushDownUsages);
      }
      CommonRefactoringUtil.sortDepthFirstRightLeftOrder(usages);
      for (      UsageInfo usageInfo : usages) {
        if (!(usageInfo instanceof ReplaceExtendsListUsageInfo || usageInfo instanceof RemoveImportUsageInfo)) {
          try {
            ((FixableUsageInfo)usageInfo).fixUsage();
          }
 catch (          IncorrectOperationException e) {
            LOG.info(e);
          }
        }
      }
      replaceInnerTypeUsages();
      for (      UsageInfo usage : usages) {
        if (usage instanceof ReplaceExtendsListUsageInfo || usage instanceof RemoveImportUsageInfo) {
          ((FixableUsageInfo)usage).fixUsage();
        }
      }
      if (myCurrentInheritor == null) {
        try {
          mySuperClass.delete();
        }
 catch (        IncorrectOperationException e) {
          LOG.error(e);
        }
      }
    }
  }
.run();
}
