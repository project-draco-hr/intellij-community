{
  try {
    final UsageInfo[] infos=ContainerUtil.map2Array(myTargetClasses,UsageInfo.class,new Function<PsiClass,UsageInfo>(){
      @Override public UsageInfo fun(      PsiClass psiClass){
        return new UsageInfo(psiClass);
      }
    }
);
    new PushDownProcessor(mySuperClass,myMemberInfos,new DocCommentPolicy(myPolicy)).pushDownToClasses(infos);
    CommonRefactoringUtil.sortDepthFirstRightLeftOrder(usages);
    for (    UsageInfo usageInfo : usages) {
      if (!(usageInfo instanceof ReplaceExtendsListUsageInfo || usageInfo instanceof RemoveImportUsageInfo)) {
        try {
          ((FixableUsageInfo)usageInfo).fixUsage();
        }
 catch (        IncorrectOperationException e) {
          LOG.info(e);
        }
      }
    }
    replaceInnerTypeUsages();
    for (    UsageInfo usage : usages) {
      if (usage instanceof ReplaceExtendsListUsageInfo || usage instanceof RemoveImportUsageInfo) {
        ((FixableUsageInfo)usage).fixUsage();
      }
    }
    if (myCurrentInheritor == null) {
      mySuperClass.delete();
    }
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
