{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(mySuperClass,myMemberInfos,conflicts);
  for (  PsiClass targetClass : myTargetClasses) {
    if (targetClass instanceof PsiAnonymousClass) {
      conflicts.putValue(targetClass,"Cannot inline into anonymous class.");
    }
 else     if (PsiTreeUtil.isAncestor(mySuperClass,targetClass,false)) {
      conflicts.putValue(targetClass,"Cannot inline into the inner class. Move \'" + targetClass.getName() + "\' to upper level");
    }
 else {
      for (      MemberInfo info : myMemberInfos) {
        final PsiMember member=info.getMember();
        pushDownConflicts.checkMemberPlacementInTargetClassConflict(targetClass,member);
      }
    }
  }
  if (myCurrentInheritor != null) {
    ReferencesSearch.search(myCurrentInheritor).forEach(new Processor<PsiReference>(){
      @Override public boolean process(      PsiReference reference){
        final PsiElement element=reference.getElement();
        if (element != null) {
          final PsiElement parent=element.getParent();
          if (parent instanceof PsiNewExpression) {
            final PsiClass aClass=PsiUtil.resolveClassInType(getPlaceExpectedType(parent));
            if (aClass == mySuperClass) {
              conflicts.putValue(parent,"Instance of target type is passed to a place where super class is expected.");
              return false;
            }
          }
        }
        return true;
      }
    }
);
  }
  checkConflicts(refUsages,conflicts);
  return showConflicts(conflicts,refUsages.get());
}
