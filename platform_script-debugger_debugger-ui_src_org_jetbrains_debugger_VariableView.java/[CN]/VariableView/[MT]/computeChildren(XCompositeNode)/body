{
  node.setAlreadySorted(true);
  if (!(value instanceof ObjectValue)) {
    node.addChildren(XValueChildrenList.EMPTY,true);
    return;
  }
  List<Variable> list=remainingChildren;
  if (list != null) {
    int to=Math.min(remainingChildrenOffset + XCompositeNode.MAX_CHILDREN_TO_SHOW,list.size());
    boolean isLast=to == list.size();
    node.addChildren(Variables.createVariablesList(list,remainingChildrenOffset,to,this,memberFilter),isLast);
    if (!isLast) {
      node.tooManyChildren(list.size() - to);
      remainingChildrenOffset+=XCompositeNode.MAX_CHILDREN_TO_SHOW;
    }
    return;
  }
  final ObjectValue objectValue=(ObjectValue)value;
  final boolean hasNamedProperties=objectValue.hasProperties() != ThreeState.NO;
  boolean hasIndexedProperties=objectValue.hasIndexedProperties() != ThreeState.NO;
  List<Promise<?>> promises=new SmartList<Promise<?>>();
  Promise<Void> additionalProperties=getViewSupport().computeAdditionalObjectProperties(objectValue,variable,this,node);
  if (additionalProperties != null) {
    promises.add(additionalProperties);
  }
  if (hasIndexedProperties) {
    promises.add(computeIndexedProperties((ArrayValue)objectValue,node,!hasNamedProperties && additionalProperties == null));
  }
  if (hasNamedProperties) {
    if (additionalProperties == null || additionalProperties.getState() != Promise.State.PENDING) {
      promises.add(computeNamedProperties(objectValue,node,!hasIndexedProperties && additionalProperties == null));
    }
 else {
      promises.add(additionalProperties.then(new AsyncFunction<Void,Void>(){
        @NotNull @Override public Promise<Void> fun(        Void o){
          return computeNamedProperties(objectValue,node,true);
        }
      }
));
    }
  }
  if (hasIndexedProperties == hasNamedProperties || additionalProperties != null) {
    Promise.all(promises).processed(new ConsumerRunnable(){
      @Override public void run(){
        if (!node.isObsolete()) {
          node.addChildren(XValueChildrenList.EMPTY,true);
        }
      }
    }
);
  }
}
