{
  Set<Change> changes=new LinkedHashSet<Change>();
  if (paths == null) {
    return new Change[0];
  }
  for (  TreePath path : paths) {
    ChangesBrowserNode<?> node=(ChangesBrowserNode)path.getLastPathComponent();
    changes.addAll(node.getAllChangesUnder());
  }
  if (changes.isEmpty()) {
    final List<VirtualFile> selectedModifiedWithoutEditing=getVirtualFiles(paths,ChangesBrowserNode.MODIFIED_WITHOUT_EDITING_TAG);
    if (selectedModifiedWithoutEditing != null && !selectedModifiedWithoutEditing.isEmpty()) {
      for (      VirtualFile file : selectedModifiedWithoutEditing) {
        AbstractVcs vcs=ProjectLevelVcsManager.getInstance(project).getVcsFor(file);
        if (vcs == null)         continue;
        final VcsCurrentRevisionProxy before=VcsCurrentRevisionProxy.create(file,project,vcs.getKeyInstanceMethod());
        if (before != null) {
          ContentRevision afterRevision=new CurrentContentRevision(VcsUtil.getFilePath(file));
          changes.add(new Change(before,afterRevision,FileStatus.HIJACKED));
        }
      }
    }
  }
  return changes.toArray(new Change[changes.size()]);
}
