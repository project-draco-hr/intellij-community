{
  final Git git=ServiceManager.getService(Git.class);
  final GitRepository repository=GithubUtil.getGitRepository(project,file);
  if (repository == null) {
    GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"Can't find git repository");
    return;
  }
  repository.update();
  final Pair<GitRemote,String> remote=GithubUtil.findGithubRemote(repository);
  if (remote == null) {
    GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"Can't find GitHub remote");
    return;
  }
  final String remoteUrl=remote.getSecond();
  final String remoteName=remote.getFirst().getName();
  String upstreamUrl=GithubUtil.findUpstreamRemote(repository);
  final GithubFullPath upstreamUserAndRepo=upstreamUrl == null || !GithubUrlUtil.isGithubUrl(upstreamUrl) ? null : GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(upstreamUrl);
  final GithubFullPath userAndRepo=GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(remoteUrl);
  if (userAndRepo == null) {
    GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"Can't process remote: " + remoteUrl);
    return;
  }
  final GitLocalBranch currentBranch=repository.getCurrentBranch();
  if (currentBranch == null) {
    GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"No current branch");
    return;
  }
  final GithubInfo info=loadGithubInfoWithModal(project,userAndRepo,upstreamUserAndRepo);
  if (info == null) {
    return;
  }
  final Set<RemoteBranch> branches=getAvailableBranchesFromGit(repository);
  branches.addAll(info.getBranches());
  final BranchesInfo branchesInfo=new BranchesInfo(info.getRepo(),upstreamUserAndRepo,branches);
  GithubRepo parent=info.getRepo().getParent();
  String suggestedBranch=parent == null ? null : parent.getUserName() + ":" + parent.getDefaultBranch();
  Collection<String> suggestions=ContainerUtil.map(branches,new Function<RemoteBranch,String>(){
    @Override public String fun(    RemoteBranch remoteBranch){
      return remoteBranch.getReference();
    }
  }
);
  Consumer<String> showDiff=new Consumer<String>(){
    @Override public void consume(    String ref){
      showDiffByRef(project,ref,repository,currentBranch.getName(),info.getAuthData(),branchesInfo);
    }
  }
;
  final GithubCreatePullRequestDialog dialog=new GithubCreatePullRequestDialog(project,suggestions,suggestedBranch,showDiff);
  DialogManager.show(dialog);
  if (!dialog.isOK()) {
    return;
  }
  new Task.Backgroundable(project,"Creating pull request..."){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      LOG.info("Pushing current branch");
      indicator.setText("Pushing current branch...");
      GitCommandResult result=git.push(repository,remoteName,remoteUrl,currentBranch.getName(),true);
      if (!result.success()) {
        GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"Push failed:<br/>" + result.getErrorOutputAsHtmlString());
        return;
      }
      String from=info.getRepo().getUserName() + ":" + currentBranch.getName();
      String onto=dialog.getTargetBranch();
      GithubAuthData auth=info.getAuthData();
      GithubFullPath targetRepo=findTargetRepository(project,auth,onto,branchesInfo);
      if (targetRepo == null) {
        GithubNotifications.showError(project,CANNOT_CREATE_PULL_REQUEST,"Can't find repository for specified branch: " + onto);
        return;
      }
      LOG.info("Creating pull request");
      indicator.setText("Creating pull request...");
      GithubPullRequest request=createPullRequest(project,auth,targetRepo,dialog.getRequestTitle(),dialog.getDescription(),from,onto);
      if (request == null) {
        return;
      }
      GithubNotifications.showInfoURL(project,"Successfully created pull request","Pull Request #" + request.getNumber(),request.getHtmlUrl());
    }
  }
.queue();
}
