{
  return GithubUtil.computeValueInModal(project,"Access to GitHub",new Convertor<ProgressIndicator,GithubInfo2>(){
    @Nullable @Override public GithubInfo2 convert(    ProgressIndicator indicator){
      try {
        final Set<GithubFullPath> forks=new HashSet<GithubFullPath>();
        final AtomicReference<GithubRepo> sourceRef=new AtomicReference<GithubRepo>();
        GithubAuthData authData=GithubUtil.runAndGetValidAuth(project,indicator,new ThrowableConsumer<GithubAuthData,IOException>(){
          @Override public void consume(          GithubAuthData authData) throws IOException {
            GithubRepoDetailed repo=GithubApiUtil.getDetailedRepoInfo(authData,path.getUser(),path.getRepository());
            forks.add(path);
            if (repo.getParent() != null) {
              forks.add(repo.getParent().getFullPath());
            }
            if (repo.getSource() != null) {
              forks.add(repo.getSource().getFullPath());
            }
            if (repo.getSource() != null) {
              sourceRef.set(repo.getSource());
            }
 else {
              sourceRef.set(repo);
            }
          }
        }
);
        forks.addAll(getAvailableForksFromGit(gitRepository));
        return new GithubInfo2(forks,authData,sourceRef.get());
      }
 catch (      GithubAuthenticationCanceledException e) {
        return null;
      }
catch (      IOException e) {
        GithubNotifications.showErrorDialog(project,CANNOT_CREATE_PULL_REQUEST,e);
        return null;
      }
    }
  }
);
}
