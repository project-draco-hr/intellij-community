{
  if (states.isEmpty())   return Collections.emptyList();
  if (states.size() > 300)   return Collections.emptyList();
  if (expr instanceof PsiPolyadicExpression) {
    PsiExpression[] operands=((PsiPolyadicExpression)expr).getOperands();
    IElementType op=((PsiPolyadicExpression)expr).getOperationTokenType();
    if (operands.length == 2 && (op == JavaTokenType.EQEQ || op == JavaTokenType.NE)) {
      return visitEqualityComparison(states,operands[0],operands[1],op == JavaTokenType.EQEQ);
    }
    if (op == JavaTokenType.ANDAND || op == JavaTokenType.OROR) {
      return visitLogicalOperation(operands,op == JavaTokenType.ANDAND,states);
    }
  }
  if (expr instanceof PsiConditionalExpression) {
    List<MethodContract> conditionResults=visitExpression(states,((PsiConditionalExpression)expr).getCondition());
    return ContainerUtil.concat(visitExpression(antecedentsOf(filterReturning(conditionResults,TRUE_VALUE)),((PsiConditionalExpression)expr).getThenExpression()),visitExpression(antecedentsOf(filterReturning(conditionResults,FALSE_VALUE)),((PsiConditionalExpression)expr).getElseExpression()));
  }
  if (expr instanceof PsiParenthesizedExpression) {
    return visitExpression(states,((PsiParenthesizedExpression)expr).getExpression());
  }
  if (expr instanceof PsiTypeCastExpression) {
    return visitExpression(states,((PsiTypeCastExpression)expr).getOperand());
  }
  if (expr instanceof PsiPrefixExpression && ((PsiPrefixExpression)expr).getOperationTokenType() == JavaTokenType.EXCL) {
    List<MethodContract> result=ContainerUtil.newArrayList();
    for (    MethodContract contract : visitExpression(states,((PsiPrefixExpression)expr).getOperand())) {
      if (contract.returnValue == TRUE_VALUE || contract.returnValue == FALSE_VALUE) {
        result.add(new MethodContract(contract.arguments,negateConstraint(contract.returnValue)));
      }
    }
    return result;
  }
  if (expr instanceof PsiInstanceOfExpression) {
    final int parameter=resolveParameter(((PsiInstanceOfExpression)expr).getOperand());
    if (parameter >= 0) {
      return ContainerUtil.mapNotNull(states,new Function<ValueConstraint[],MethodContract>(){
        @Override public MethodContract fun(        ValueConstraint[] state){
          ValueConstraint paramConstraint=NULL_VALUE;
          ValueConstraint returnValue=FALSE_VALUE;
          return contractWithConstraint(state,parameter,paramConstraint,returnValue);
        }
      }
);
    }
  }
  if (expr instanceof PsiNewExpression) {
    return toContracts(states,NOT_NULL_VALUE);
  }
  if (expr instanceof PsiMethodCallExpression) {
    PsiMethod method=((PsiMethodCallExpression)expr).resolveMethod();
    if (method != null && NullableNotNullManager.isNotNull(method)) {
      return toContracts(states,NOT_NULL_VALUE);
    }
  }
  final ValueConstraint constraint=getLiteralConstraint(expr);
  if (constraint != null) {
    return toContracts(states,constraint);
  }
  int paramIndex=resolveParameter(expr);
  if (paramIndex >= 0) {
    List<MethodContract> result=ContainerUtil.newArrayList();
    for (    ValueConstraint[] state : states) {
      if (state[paramIndex] != ANY_VALUE) {
        result.add(new MethodContract(state,state[paramIndex]));
      }
 else       if (textMatches(getParameter(paramIndex).getTypeElement(),PsiKeyword.BOOLEAN)) {
        ContainerUtil.addIfNotNull(result,contractWithConstraint(state,paramIndex,TRUE_VALUE,TRUE_VALUE));
        ContainerUtil.addIfNotNull(result,contractWithConstraint(state,paramIndex,FALSE_VALUE,FALSE_VALUE));
      }
    }
    return result;
  }
  return Collections.emptyList();
}
