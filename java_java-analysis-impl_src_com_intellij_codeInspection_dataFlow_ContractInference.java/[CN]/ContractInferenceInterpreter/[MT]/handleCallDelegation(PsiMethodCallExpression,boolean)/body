{
  final PsiMethod targetMethod=expression.resolveMethod();
  if (targetMethod == null)   return Collections.emptyList();
  final PsiExpression[] arguments=expression.getArgumentList().getExpressions();
  final boolean notNull=NullableNotNullManager.isNotNull(targetMethod);
  List<MethodContract> fromDelegate=ContainerUtil.mapNotNull(ControlFlowAnalyzer.getMethodContracts(targetMethod),new NullableFunction<MethodContract,MethodContract>(){
    @Nullable @Override public MethodContract fun(    MethodContract delegateContract){
      ValueConstraint[] answer=myEmptyConstraints;
      for (int i=0; i < delegateContract.arguments.length; i++) {
        if (i >= arguments.length)         return null;
        ValueConstraint argConstraint=delegateContract.arguments[i];
        if (argConstraint != ANY_VALUE) {
          int paramIndex=resolveParameter(arguments[i]);
          if (paramIndex < 0) {
            if (argConstraint != getLiteralConstraint(arguments[i])) {
              return null;
            }
          }
 else {
            answer=withConstraint(answer,paramIndex,argConstraint);
            if (answer == null) {
              return null;
            }
          }
        }
      }
      ValueConstraint returnValue=negated ? negateConstraint(delegateContract.returnValue) : delegateContract.returnValue;
      if (notNull && returnValue != THROW_EXCEPTION) {
        returnValue=NOT_NULL_VALUE;
      }
      return answer == null ? null : new MethodContract(answer,returnValue);
    }
  }
);
  if (notNull) {
    return ContainerUtil.concat(fromDelegate,Arrays.asList(new MethodContract(myEmptyConstraints,NOT_NULL_VALUE)));
  }
  return fromDelegate;
}
