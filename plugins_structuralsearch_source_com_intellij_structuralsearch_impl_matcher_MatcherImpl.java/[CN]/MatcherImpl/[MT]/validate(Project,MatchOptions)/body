{
  PsiDocumentManager.getInstance(project).commitAllDocuments();
  CompiledPattern lastPattern;
synchronized (MatcherImpl.class) {
    final LastMatchData data=new LastMatchData();
    lastPattern=data.lastPattern=PatternCompiler.compilePattern(project,options);
    data.lastOptions=options;
    lastMatchData=new SoftReference<LastMatchData>(data);
  }
class ValidatingVisitor extends JavaRecursiveElementWalkingVisitor {
    @Override public void visitAnnotation(    PsiAnnotation annotation){
      final PsiJavaCodeReferenceElement nameReferenceElement=annotation.getNameReferenceElement();
      if (nameReferenceElement == null || !nameReferenceElement.getText().equals(MatchOptions.MODIFIER_ANNOTATION_NAME)) {
        return;
      }
      for (      PsiNameValuePair pair : annotation.getParameterList().getAttributes()) {
        final PsiAnnotationMemberValue value=pair.getValue();
        if (value instanceof PsiArrayInitializerMemberValue) {
          for (          PsiAnnotationMemberValue v : ((PsiArrayInitializerMemberValue)value).getInitializers()) {
            final String name=StringUtil.stripQuotesAroundValue(v.getText());
            checkModifier(name);
          }
        }
 else {
          final String name=StringUtil.stripQuotesAroundValue(value.getText());
          checkModifier(name);
        }
      }
    }
    private void checkModifier(    final String name){
      if (!MatchOptions.INSTANCE_MODIFIER_NAME.equals(name) && !MatchOptions.PACKAGE_LOCAL_MODIFIER_NAME.equals(name) && Arrays.binarySearch(MatchingVisitor.MODIFIERS,name) < 0) {
        throw new MalformedPatternException(SSRBundle.message("invalid.modifier.type",name));
      }
    }
  }
  ValidatingVisitor visitor=new ValidatingVisitor();
  final NodeIterator nodes=lastPattern.getNodes();
  while (nodes.hasNext()) {
    nodes.current().accept(visitor);
    nodes.advance();
  }
  nodes.reset();
}
