{
  final Set<PsiMethod> remainingMethods=new HashSet<>(usedMethods);
  boolean stabilized=false;
  while (!stabilized) {
    ProgressManager.checkCanceled();
    stabilized=true;
    final Set<PsiMethod> methodsDeterminedThisPass=new HashSet<>();
    for (    PsiMethod method : remainingMethods) {
      ProgressManager.checkCanceled();
      final Collection<PsiReference> references=referenceMap.get(method);
      boolean areAllReferencesSynchronized=true;
      for (      PsiReference reference : references) {
        ProgressManager.checkCanceled();
        if (isKnownToBeUsed(reference)) {
          if (isInKnownUnsynchronizedContext(reference)) {
            methodsNotAlwaysSynchronized.add(method);
            methodsDeterminedThisPass.add(method);
            areAllReferencesSynchronized=false;
            stabilized=false;
            break;
          }
          if (!isInKnownSynchronizedContext(reference)) {
            areAllReferencesSynchronized=false;
          }
        }
      }
      if (areAllReferencesSynchronized && unusedMethods.contains(method)) {
        methodsAlwaysSynchronized.add(method);
        methodsDeterminedThisPass.add(method);
        stabilized=false;
      }
    }
    remainingMethods.removeAll(methodsDeterminedThisPass);
  }
  methodsAlwaysSynchronized.addAll(remainingMethods);
}
