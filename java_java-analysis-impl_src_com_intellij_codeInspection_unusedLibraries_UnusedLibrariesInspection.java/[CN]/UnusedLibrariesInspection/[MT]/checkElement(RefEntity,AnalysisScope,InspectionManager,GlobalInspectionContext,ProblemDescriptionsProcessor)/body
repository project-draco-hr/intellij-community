{
  if (refEntity instanceof RefModule) {
    final RefModule refModule=(RefModule)refEntity;
    final Module module=refModule.getModule();
    if (module.isDisposed())     return CommonProblemDescriptor.EMPTY_ARRAY;
    final ModuleRootManager moduleRootManager=ModuleRootManager.getInstance(module);
    final Set<VirtualFile> usedRoots=refModule.getUserData(UnusedLibraryGraphAnnotator.USED_LIBRARY_ROOTS);
    final List<CommonProblemDescriptor> result=new ArrayList<CommonProblemDescriptor>();
    for (    OrderEntry entry : moduleRootManager.getOrderEntries()) {
      if (entry instanceof LibraryOrderEntry && !((LibraryOrderEntry)entry).isExported()) {
        if (usedRoots == null) {
          String message=InspectionsBundle.message("unused.library.problem.descriptor",entry.getPresentableName());
          result.add(manager.createProblemDescriptor(message,new RemoveUnusedLibrary(refModule,entry,null)));
        }
 else {
          final Set<VirtualFile> files=new HashSet<VirtualFile>(Arrays.asList(((LibraryOrderEntry)entry).getRootFiles(OrderRootType.CLASSES)));
          files.removeAll(usedRoots);
          if (!files.isEmpty()) {
            final String unusedLibraryRoots=StringUtil.join(files,new Function<VirtualFile,String>(){
              @Override public String fun(              final VirtualFile file){
                return file.getPresentableName();
              }
            }
,",");
            String message=InspectionsBundle.message("unused.library.roots.problem.descriptor",unusedLibraryRoots,entry.getPresentableName());
            processor.addProblemElement(refModule,manager.createProblemDescriptor(message,new RemoveUnusedLibrary(refModule,entry,files)));
          }
        }
      }
    }
    return result.isEmpty() ? null : result.toArray(new CommonProblemDescriptor[result.size()]);
  }
  return null;
}
