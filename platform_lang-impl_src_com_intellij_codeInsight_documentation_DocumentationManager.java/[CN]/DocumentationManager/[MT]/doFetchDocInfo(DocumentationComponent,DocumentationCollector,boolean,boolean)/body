{
  final ActionCallback callback=new ActionCallback();
  myLastAction=callback;
  boolean wasEmpty=component.isEmpty();
  component.startWait();
  if (cancelRequests) {
    myUpdateDocAlarm.cancelAllRequests();
  }
  if (wasEmpty) {
    component.setText(CodeInsightBundle.message("javadoc.fetching.progress"),null,clearHistory);
    final AbstractPopup jbPopup=(AbstractPopup)getDocInfoHint();
    if (jbPopup != null) {
      jbPopup.setDimensionServiceKey(null);
    }
  }
  myUpdateDocAlarm.addRequest(new Runnable(){
    @Override public void run(){
      if (myProject.isDisposed())       return;
      LOG.debug("Started fetching documentation...");
      final Throwable[] ex=new Throwable[1];
      String text=null;
      try {
        text=provider.getDocumentation();
      }
 catch (      Throwable e) {
        LOG.info(e);
        ex[0]=e;
      }
      if (ex[0] != null) {
        SwingUtilities.invokeLater(new Runnable(){
          @Override public void run(){
            String message=ex[0] instanceof IndexNotReadyException ? "Documentation is not available until indices are built." : CodeInsightBundle.message("javadoc.external.fetch.error.message");
            component.setText(message,null,true);
            callback.setDone();
          }
        }
);
        return;
      }
      LOG.debug("Documentation fetched successfully:\n",text);
      final PsiElement element=ApplicationManager.getApplication().runReadAction(new Computable<PsiElement>(){
        @Override @Nullable public PsiElement compute(){
          return provider.getElement();
        }
      }
);
      if (element == null) {
        LOG.debug("Element for which documentation was requested is not available anymore");
        return;
      }
      final String documentationText=text;
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          PsiDocumentManager.getInstance(myProject).commitAllDocuments();
          if (!element.isValid()) {
            LOG.debug("Element for which documentation was requested is not valid");
            callback.setDone();
            return;
          }
          if (documentationText == null) {
            component.setText(CodeInsightBundle.message("no.documentation.found"),element,true,clearHistory);
          }
 else           if (documentationText.isEmpty()) {
            component.setText(component.getText(),element,true,clearHistory);
          }
 else {
            component.setData(element,documentationText,clearHistory,provider.getEffectiveExternalUrl(),provider.getRef());
          }
          final AbstractPopup jbPopup=(AbstractPopup)getDocInfoHint();
          if (jbPopup == null) {
            callback.setDone();
            return;
          }
          jbPopup.setDimensionServiceKey(JAVADOC_LOCATION_AND_SIZE);
          jbPopup.setCaption(getTitle(element,false));
          callback.setDone();
        }
      }
);
    }
  }
,10);
  return callback;
}
