{
  String samMethodName=null;
  PsiType type=expression.getType();
  if (type instanceof PsiClassType) {
    PsiClass resolvedClass=((PsiClassType)type).resolve();
    if (resolvedClass != null) {
      final JavaPsiFacade javaPsiFacade=JavaPsiFacade.getInstance(expression.getProject());
      final GlobalSearchScope scope=resolvedClass.getResolveScope();
      if (InheritanceUtil.isInheritorOrSelf(resolvedClass,javaPsiFacade.findClass(GuavaSupplierConversionRule.GUAVA_SUPPLIER,scope),true)) {
        samMethodName="get";
      }
 else       if (InheritanceUtil.isInheritorOrSelf(resolvedClass,javaPsiFacade.findClass(GuavaFunctionConversionRule.GUAVA_FUNCTION,scope),true)) {
        samMethodName="apply";
      }
 else       if (InheritanceUtil.isInheritorOrSelf(resolvedClass,javaPsiFacade.findClass(GuavaPredicateConversionRule.GUAVA_PREDICATE,scope),true)) {
        samMethodName="test";
      }
    }
    LOG.assertTrue(samMethodName != null);
  }
  return (PsiExpression)expression.replace(JavaPsiFacade.getElementFactory(expression.getProject()).createExpressionFromText(expression.getText() + "::" + samMethodName,null));
}
