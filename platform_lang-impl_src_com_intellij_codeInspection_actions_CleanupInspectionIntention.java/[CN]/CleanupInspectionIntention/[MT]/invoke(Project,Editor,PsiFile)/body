{
  if (!FileModificationService.getInstance().preparePsiElementForWrite(file))   return;
  final List<ProblemDescriptor> descriptions=ProgressManager.getInstance().runProcess(new Computable<List<ProblemDescriptor>>(){
    @Override public List<ProblemDescriptor> compute(){
      InspectionManager inspectionManager=InspectionManager.getInstance(project);
      return InspectionEngine.runInspectionOnFile(file,myToolWrapper,inspectionManager.createNewGlobalContext(false));
    }
  }
,new EmptyProgressIndicator());
  Collections.sort(descriptions,new Comparator<CommonProblemDescriptor>(){
    @Override public int compare(    final CommonProblemDescriptor o1,    final CommonProblemDescriptor o2){
      final ProblemDescriptorBase d1=(ProblemDescriptorBase)o1;
      final ProblemDescriptorBase d2=(ProblemDescriptorBase)o2;
      final int offset2=d2.getTextRange().getStartOffset();
      final int offset1=d1.getTextRange().getStartOffset();
      return offset2 < offset1 ? -1 : offset1 == offset2 ? 0 : 1;
    }
  }
);
  final String templatePresentationText="Apply Fixes";
  final SequentialModalProgressTask progressTask=new SequentialModalProgressTask(project,templatePresentationText,true);
  final boolean isBatch=BatchQuickFix.class.isAssignableFrom(myQuickfixClass);
  final AbstractPerformFixesTask fixesTask=createTask(project,descriptions.toArray(new ProblemDescriptor[descriptions.size()]),progressTask,isBatch);
  CommandProcessor.getInstance().executeCommand(project,new Runnable(){
    @Override public void run(){
      CommandProcessor.getInstance().markCurrentCommandAsGlobal(project);
      progressTask.setMinIterationTime(200);
      progressTask.setTask(fixesTask);
      ProgressManager.getInstance().run(progressTask);
    }
  }
,templatePresentationText,null);
  if (!fixesTask.isApplicableFixFound()) {
    HintManager.getInstance().showErrorHint(editor,"Unfortunately '" + myText + "' is currently not available for batch mode\n User interaction is required for each problem found");
  }
}
