{
  if (!FileModificationService.getInstance().preparePsiElementForWrite(file))   return;
  final List<ProblemDescriptor> descriptions=ProgressManager.getInstance().runProcess(new Computable<List<ProblemDescriptor>>(){
    @Override public List<ProblemDescriptor> compute(){
      InspectionManager inspectionManager=InspectionManager.getInstance(project);
      return InspectionEngine.runInspectionOnFile(file,myToolWrapper,inspectionManager.createNewGlobalContext(false));
    }
  }
,new EmptyProgressIndicator());
  Collections.sort(descriptions,new Comparator<CommonProblemDescriptor>(){
    @Override public int compare(    final CommonProblemDescriptor o1,    final CommonProblemDescriptor o2){
      final ProblemDescriptorBase d1=(ProblemDescriptorBase)o1;
      final ProblemDescriptorBase d2=(ProblemDescriptorBase)o2;
      return d2.getTextRange().getStartOffset() - d1.getTextRange().getStartOffset();
    }
  }
);
  final String templatePresentationText="Apply Fixes";
  final SequentialModalProgressTask progressTask=new SequentialModalProgressTask(project,templatePresentationText,false);
  final PerformFixesTask fixesTask=new PerformFixesTask(project,descriptions.toArray(new CommonProblemDescriptor[descriptions.size()]),progressTask);
  CommandProcessor.getInstance().executeCommand(project,new Runnable(){
    @Override public void run(){
      CommandProcessor.getInstance().markCurrentCommandAsGlobal(project);
      progressTask.setMinIterationTime(200);
      progressTask.setTask(fixesTask);
      ProgressManager.getInstance().run(progressTask);
    }
  }
,templatePresentationText,null);
  if (!fixesTask.isApplicableFixFound()) {
    HintManager.getInstance().showErrorHint(editor,"Unfortunately '" + myText + "' is currently not available for batch mode");
  }
}
