{
  final int length=pattern.length();
  char ch=pattern.charAt(index);
  if (ch == '+' || ch == '*') {
switch (ch) {
case '+':
      constraint.setStrictlyWithinHierarchy(true);
    break;
case '*':
  constraint.setWithinHierarchy(true);
break;
}
++index;
if (index >= length) throw new MalformedPatternException(SSRBundle.message("error.expected.condition",ch));
ch=pattern.charAt(index);
}
if (ch == '[') {
miscBuffer.setLength(0);
boolean quoted=false;
while (++index < length) {
ch=pattern.charAt(index);
if (pattern.charAt(index - 1) != '\\') {
if (ch == '"') quoted=!quoted;
 else if (ch == ']' && !quoted) break;
}
miscBuffer.append(ch);
}
if (quoted) throw new MalformedPatternException(SSRBundle.message("error.expected.value","\""));
if (ch != ']') throw new MalformedPatternException(SSRBundle.message("error.expected.condition.or.bracket"));
++index;
parseCondition(constraint,miscBuffer.toString());
}
 else {
miscBuffer.setLength(0);
index=handleRegExp(index,pattern,miscBuffer,constraint);
}
return index;
}
