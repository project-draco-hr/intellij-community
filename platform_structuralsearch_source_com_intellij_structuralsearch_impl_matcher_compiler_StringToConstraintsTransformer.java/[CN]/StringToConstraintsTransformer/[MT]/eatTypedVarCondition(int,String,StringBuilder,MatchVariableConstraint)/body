{
  final int length=pattern.length();
  char ch=pattern.charAt(index);
  if (ch == '+' || ch == '*') {
switch (ch) {
case '+':
      constraint.setStrictlyWithinHierarchy(true);
    break;
case '*':
  constraint.setWithinHierarchy(true);
break;
}
++index;
if (index >= length) throw new MalformedPatternException(SSRBundle.message("error.expected.condition",ch));
ch=pattern.charAt(index);
}
if (ch == '[') {
miscBuffer.setLength(0);
for (++index; index < length && ((ch=pattern.charAt(index)) != ']' || pattern.charAt(index - 1) == '\\'); ++index) {
if (ch == '"') {
miscBuffer.append(ch);
for (++index; index < length && (ch=pattern.charAt(index)) != '"'; ++index) {
  if (ch == '\\') {
    ++index;
    if (index >= length)     break;
    ch=pattern.charAt(index);
  }
  miscBuffer.append(ch);
}
if (ch != '"') throw new MalformedPatternException(SSRBundle.message("error.expected.end.quote"));
}
miscBuffer.append(ch);
}
if (ch != ']') throw new MalformedPatternException(SSRBundle.message("error.expected.condition.or.bracket"));
++index;
parseCondition(constraint,miscBuffer.toString());
}
 else {
miscBuffer.setLength(0);
index=handleRegExp(index,pattern,miscBuffer,constraint);
}
return index;
}
