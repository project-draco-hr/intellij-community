{
  argument=argument.trim();
  if (option.equalsIgnoreCase(REF)) {
    constraint.setReference(true);
    constraint.setInvertReference(invert);
    if (argument.length() == 0 || argument.charAt(0) != '\'')     throw new MalformedPatternException(SSRBundle.message("error.reference.variable.name.expected",option));
    constraint.setNameOfReferenceVar(argument.substring(1));
  }
 else   if (option.equalsIgnoreCase(READ)) {
    if (argument.length() != 0)     throw new MalformedPatternException(SSRBundle.message("error.no.argument.expected",option));
    constraint.setReadAccess(true);
    constraint.setInvertReadAccess(invert);
  }
 else   if (option.equalsIgnoreCase(WRITE)) {
    if (argument.length() != 0)     throw new MalformedPatternException(SSRBundle.message("error.no.argument.expected",option));
    constraint.setWriteAccess(true);
    constraint.setInvertWriteAccess(invert);
  }
 else   if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) {
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected",option));
    if (argument.charAt(0) == '*') {
      argument=argument.substring(1);
      constraint.setWithinHierarchy(true);
    }
    checkRegex(argument);
    constraint.setRegExp(argument);
    constraint.setInvertRegExp(invert);
    if (option.equalsIgnoreCase(REGEXW)) {
      constraint.setWholeWordsOnly(true);
    }
  }
 else   if (option.equalsIgnoreCase(EXPRTYPE)) {
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected",option));
    if (argument.charAt(0) == '*') {
      argument=argument.substring(1);
      constraint.setExprTypeWithinHierarchy(true);
    }
    checkRegex(argument);
    constraint.setNameOfExprType(argument);
    constraint.setInvertExprType(invert);
  }
 else   if (option.equalsIgnoreCase(FORMAL)) {
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected",option));
    if (argument.charAt(0) == '*') {
      argument=argument.substring(1);
      constraint.setFormalArgTypeWithinHierarchy(true);
    }
    checkRegex(argument);
    constraint.setNameOfFormalArgType(argument);
    constraint.setInvertFormalType(invert);
  }
 else   if (option.equalsIgnoreCase(SCRIPT)) {
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.script.argument.expected",option));
    if (invert)     throw new MalformedPatternException(SSRBundle.message("error.cannot.invert",option));
    constraint.setScriptCodeConstraint(argument);
  }
 else   if (option.equalsIgnoreCase(CONTAINS)) {
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.pattern.argument.expected",option));
    constraint.setContainsConstraint(argument);
    constraint.setInvertContainsConstraint(invert);
  }
 else   if (option.equalsIgnoreCase(WITHIN)) {
    if (!Configuration.CONTEXT_VAR_NAME.equals(constraint.getName()))     throw new MalformedPatternException(SSRBundle.message("error.only.applicable.to.complete.match",option));
    if (argument.length() == 0)     throw new MalformedPatternException(SSRBundle.message("error.pattern.argument.expected",option));
    constraint.setWithinConstraint(argument);
    constraint.setInvertWithinConstraint(invert);
  }
 else {
    throw new UnsupportedPatternException(SSRBundle.message("option.is.not.recognized.error.message",option));
  }
}
