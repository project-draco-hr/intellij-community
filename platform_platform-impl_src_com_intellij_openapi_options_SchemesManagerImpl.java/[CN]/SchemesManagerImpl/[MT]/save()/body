{
  boolean hasSchemes=false;
  UniqueNameGenerator nameGenerator=new UniqueNameGenerator();
  List<E> schemesToSave=new SmartList<E>();
  for (  T scheme : mySchemes) {
    if (scheme instanceof ExternalizableScheme) {
      E eScheme=(E)scheme;
      BaseSchemeProcessor.State state=getState(eScheme);
      if (state == BaseSchemeProcessor.State.NON_PERSISTENT) {
        continue;
      }
      hasSchemes=true;
      if (state != BaseSchemeProcessor.State.UNCHANGED) {
        schemesToSave.add(eScheme);
      }
      String fileName=getFileName(eScheme);
      if (fileName != null && !isRenamed(eScheme)) {
        nameGenerator.addExistingName(fileName);
      }
    }
  }
  List<Throwable> errors=null;
  for (  E scheme : schemesToSave) {
    try {
      saveScheme(scheme,nameGenerator);
    }
 catch (    Throwable e) {
      if (errors == null) {
        errors=new SmartList<Throwable>();
      }
      errors.add(e);
    }
  }
  VirtualFile dir=getVirtualDir();
  errors=deleteFiles(dir,errors);
  if (!hasSchemes && dir != null) {
    LOG.info("No schemes to save, directory " + dir.getName() + " will be removed");
    AccessToken token=ApplicationManager.getApplication().acquireWriteActionLock(DocumentRunnable.IgnoreDocumentRunnable.class);
    try {
      boolean remove=true;
      for (      VirtualFile file : dir.getChildren()) {
        if (StringUtilRt.endsWithIgnoreCase(file.getNameSequence(),mySchemeExtension)) {
          LOG.info("Directory " + dir.getName() + " cannot be removed - scheme "+ file.getName()+ " exists");
          remove=false;
          break;
        }
      }
      if (remove) {
        LOG.info("Remove schemes directory " + dir.getName());
        try {
          StorageUtil.deleteFile(this,dir);
          myDir=null;
        }
 catch (        Throwable e) {
          if (errors == null) {
            errors=new SmartList<Throwable>();
          }
          errors.add(e);
        }
      }
    }
  finally {
      token.finish();
    }
  }
  CompoundRuntimeException.doThrow(errors);
}
