{
  final List<UsageInfo> allUsages=new ArrayList<UsageInfo>();
  final List<UsageInfo> usagesToSkip=new ArrayList<UsageInfo>();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  for (  PsiElement element : myElementsToMove) {
    String newName=getNewQName(element);
    if (newName == null)     continue;
    final UsageInfo[] usages=MoveClassesOrPackagesUtil.findUsages(element,mySearchInComments,mySearchInNonJavaFiles,newName);
    final ArrayList<UsageInfo> infos=new ArrayList<UsageInfo>(Arrays.asList(usages));
    allUsages.addAll(infos);
    if (Comparing.strEqual(newName,getOldQName(element))) {
      usagesToSkip.addAll(infos);
    }
    if (element instanceof PsiPackage) {
      for (      PsiDirectory directory : ((PsiPackage)element).getDirectories()) {
        final UsageInfo[] dirUsages=MoveClassesOrPackagesUtil.findUsages(directory,mySearchInComments,mySearchInNonJavaFiles,newName);
        allUsages.addAll(new ArrayList<UsageInfo>(Arrays.asList(dirUsages)));
      }
    }
  }
  myMoveDestination.analyzeModuleConflicts(Arrays.asList(myElementsToMove),conflicts,allUsages.toArray(new UsageInfo[allUsages.size()]));
  final UsageInfo[] usageInfos=allUsages.toArray(new UsageInfo[allUsages.size()]);
  detectPackageLocalsMoved(usageInfos,conflicts);
  detectPackageLocalsUsed(conflicts);
  if (!conflicts.isEmpty()) {
    for (    PsiElement element : conflicts.keySet()) {
      allUsages.add(new ConflictsUsageInfo(element,conflicts.get(element)));
    }
  }
  allUsages.removeAll(usagesToSkip);
  return UsageViewUtil.removeDuplicatedUsages(allUsages.toArray(new UsageInfo[allUsages.size()]));
}
