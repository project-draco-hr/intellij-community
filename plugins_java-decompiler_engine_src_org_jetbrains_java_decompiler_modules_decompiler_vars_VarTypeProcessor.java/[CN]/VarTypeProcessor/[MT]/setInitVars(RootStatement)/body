{
  StructMethod mt=(StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
  boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
  MethodDescriptor md=(MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR);
  if (thisVar) {
    StructClass cl=(StructClass)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS);
    VarType clType=new VarType(CodeConstants.TYPE_OBJECT,0,cl.qualifiedName);
    mapExprentMinTypes.put(new VarVersionPair(0,1),clType);
    mapExprentMaxTypes.put(new VarVersionPair(0,1),clType);
  }
  int varIndex=0;
  for (int i=0; i < md.params.length; i++) {
    mapExprentMinTypes.put(new VarVersionPair(varIndex + (thisVar ? 1 : 0),1),md.params[i]);
    mapExprentMaxTypes.put(new VarVersionPair(varIndex + (thisVar ? 1 : 0),1),md.params[i]);
    varIndex+=md.params[i].stackSize;
  }
  LinkedList<Statement> stack=new LinkedList<Statement>();
  stack.add(root);
  while (!stack.isEmpty()) {
    Statement stat=stack.removeFirst();
    List<VarExprent> lstVars=null;
    if (stat.type == Statement.TYPE_CATCHALL) {
      lstVars=((CatchAllStatement)stat).getVars();
    }
 else     if (stat.type == Statement.TYPE_TRYCATCH) {
      lstVars=((CatchStatement)stat).getVars();
    }
    if (lstVars != null) {
      for (      VarExprent var : lstVars) {
        mapExprentMinTypes.put(new VarVersionPair(var.getIndex(),1),var.getVarType());
        mapExprentMaxTypes.put(new VarVersionPair(var.getIndex(),1),var.getVarType());
      }
    }
    stack.addAll(stat.getStats());
  }
}
