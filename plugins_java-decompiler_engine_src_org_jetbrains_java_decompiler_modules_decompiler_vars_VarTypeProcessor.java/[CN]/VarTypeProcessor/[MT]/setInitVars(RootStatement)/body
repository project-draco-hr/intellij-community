{
  StructMethod mt=(StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
  boolean thisvar=!mt.hasModifier(CodeConstants.ACC_STATIC);
  MethodDescriptor md=(MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR);
  if (thisvar) {
    VarType cltype=new VarType(CodeConstants.TYPE_OBJECT,0,((StructClass)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS)).qualifiedName);
    mapExprentMinTypes.put(new VarVersionPaar(0,1),cltype);
    mapExprentMaxTypes.put(new VarVersionPaar(0,1),cltype);
  }
  int varindex=0;
  for (int i=0; i < md.params.length; i++) {
    mapExprentMinTypes.put(new VarVersionPaar(varindex + (thisvar ? 1 : 0),1),md.params[i]);
    mapExprentMaxTypes.put(new VarVersionPaar(varindex + (thisvar ? 1 : 0),1),md.params[i]);
    varindex+=md.params[i].stack_size;
  }
  LinkedList<Statement> stack=new LinkedList<Statement>();
  stack.add(root);
  while (!stack.isEmpty()) {
    Statement stat=stack.removeFirst();
    List<VarExprent> lstVars=null;
    if (stat.type == Statement.TYPE_CATCHALL) {
      lstVars=((CatchAllStatement)stat).getVars();
    }
 else     if (stat.type == Statement.TYPE_TRYCATCH) {
      lstVars=((CatchStatement)stat).getVars();
    }
    if (lstVars != null) {
      for (      VarExprent var : lstVars) {
        mapExprentMinTypes.put(new VarVersionPaar(var.getIndex(),1),var.getVartype());
        mapExprentMaxTypes.put(new VarVersionPaar(var.getIndex(),1),var.getVartype());
      }
    }
    stack.addAll(stat.getStats());
  }
}
