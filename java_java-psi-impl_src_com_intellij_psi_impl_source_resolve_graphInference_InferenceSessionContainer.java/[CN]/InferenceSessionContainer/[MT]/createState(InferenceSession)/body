{
  final PsiSubstitutor topInferenceSubstitutor=replaceVariables(topLevelSession.getInferenceVariables());
  final Map<PsiElement,InitialInferenceState> nestedStates=new LinkedHashMap<PsiElement,InitialInferenceState>();
  final InferenceSessionContainer copy=new InferenceSessionContainer(){
    @Override public PsiSubstitutor findNestedSubstitutor(    PsiElement arg,    @Nullable PsiSubstitutor defaultSession){
      final PsiSubstitutor substitutor=super.findNestedSubstitutor(arg,null);
      if (substitutor != null) {
        return substitutor;
      }
      final InitialInferenceState state=nestedStates.get(PsiTreeUtil.getParentOfType(arg,PsiCall.class));
      if (state != null) {
        return state.getInferenceSubstitutor();
      }
      return super.findNestedSubstitutor(arg,defaultSession);
    }
  }
;
  final Map<PsiElement,InferenceSession> nestedSessions=topLevelSession.getInferenceSessionContainer().myNestedSessions;
  for (  Map.Entry<PsiElement,InferenceSession> entry : nestedSessions.entrySet()) {
    nestedStates.put(entry.getKey(),entry.getValue().createInitialState(copy,topInferenceSubstitutor));
  }
  PsiSubstitutor substitutor=PsiSubstitutor.EMPTY;
  for (  InferenceVariable variable : topLevelSession.getInferenceVariables()) {
    final PsiType instantiation=variable.getInstantiation();
    if (instantiation != PsiType.NULL) {
      final PsiClass psiClass=PsiUtil.resolveClassInClassTypeOnly(topInferenceSubstitutor.substitute(variable));
      if (psiClass instanceof InferenceVariable) {
        substitutor=substitutor.put((PsiTypeParameter)psiClass,instantiation);
      }
    }
  }
  return new CompoundInitialState(substitutor,nestedStates);
}
