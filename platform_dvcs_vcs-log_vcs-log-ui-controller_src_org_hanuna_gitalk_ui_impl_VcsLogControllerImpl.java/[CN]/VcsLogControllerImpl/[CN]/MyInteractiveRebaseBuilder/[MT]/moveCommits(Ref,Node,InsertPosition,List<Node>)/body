{
  if (resultRef != null && resultRef != subjectRef) {
    reset();
  }
  if (position == InsertPosition.BELOW) {
    base=getParent(base);
  }
 else {
  }
  Node lowestInserted=nodesToInsert.get(nodesToInsert.size() - 1);
  if (dataPack.isAncestorOf(base,lowestInserted)) {
    this.branchBase=base;
  }
 else {
    this.branchBase=getParent(lowestInserted);
  }
  if (!fakeBranch.isEmpty()) {
    FakeCommitParents lowestFakeCommit=fakeBranch.get(fakeBranch.size() - 1);
    Node lowestFakeNode=dataPack.getNodeByHash(lowestFakeCommit.getHash());
    if (lowestFakeNode == branchBase || dataPack.isAncestorOf(lowestFakeNode,branchBase)) {
      branchBase=getParent(lowestFakeNode);
    }
  }
  Set<Node> nodesToRemove=new HashSet<Node>(nodesToInsert);
  List<Node> branch=dataPack.getCommitsInBranchAboveBase(this.branchBase,dataPack.getNodeByHash(subjectRef.getCommitHash()));
  List<Node> result=new ArrayList<Node>();
  boolean baseFound=false;
  for (  Node node : branch) {
    if (node == base) {
      result.addAll(nodesToInsert);
      baseFound=true;
    }
    if (!nodesToRemove.contains(node)) {
      result.add(node);
    }
  }
  if (!baseFound) {
    result.addAll(nodesToInsert);
  }
  this.fakeBranch=createFakeCommits(this.branchBase,result);
  int maxIndex=-1;
  for (  Node node : result) {
    if (maxIndex < node.getRowIndex()) {
      maxIndex=node.getRowIndex();
    }
  }
  insertAfter=maxIndex + 1;
  selected.clear();
  for (  Node node : nodesToInsert) {
    Hash fakeHash=FakeCommitParents.fakeHash(node.getCommitHash());
    selected.add(fakeHash);
  }
  setResultRef(subjectRef);
  dumpCommands();
}
