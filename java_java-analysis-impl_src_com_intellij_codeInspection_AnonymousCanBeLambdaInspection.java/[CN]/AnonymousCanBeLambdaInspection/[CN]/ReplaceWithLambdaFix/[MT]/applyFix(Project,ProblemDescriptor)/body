{
  final PsiElement element=descriptor.getPsiElement();
  if (element instanceof PsiNewExpression) {
    if (!FileModificationService.getInstance().preparePsiElementForWrite(element))     return;
    final PsiAnonymousClass anonymousClass=((PsiNewExpression)element).getAnonymousClass();
    LOG.assertTrue(anonymousClass != null);
    ChangeContextUtil.encodeContextInfo(anonymousClass,true);
    final PsiElement lambdaContext=anonymousClass.getParent().getParent();
    boolean validContext=LambdaUtil.isValidLambdaContext(lambdaContext);
    final String canonicalText=anonymousClass.getBaseClassType().getCanonicalText();
    final PsiMethod method=anonymousClass.getMethods()[0];
    LOG.assertTrue(method != null);
    final PsiCodeBlock body=method.getBody();
    LOG.assertTrue(body != null);
    final ForbiddenRefsChecker checker=new ForbiddenRefsChecker(method,anonymousClass);
    body.accept(checker);
    PsiResolveHelper helper=PsiResolveHelper.SERVICE.getInstance(body.getProject());
    final Set<PsiLocalVariable> conflictingLocals=checker.getLocals();
    for (Iterator<PsiLocalVariable> iterator=conflictingLocals.iterator(); iterator.hasNext(); ) {
      PsiLocalVariable local=iterator.next();
      final String localName=local.getName();
      if (localName == null || helper.resolveReferencedVariable(localName,anonymousClass) == null) {
        iterator.remove();
      }
    }
    final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(project);
    giveUniqueNames(project,lambdaContext,elementFactory,body,conflictingLocals.toArray(new PsiVariable[conflictingLocals.size()]));
    final String lambdaWithTypesDeclared=composeLambdaText(method,true);
    final String withoutTypesDeclared=composeLambdaText(method,false);
    PsiLambdaExpression lambdaExpression=(PsiLambdaExpression)elementFactory.createExpressionFromText(withoutTypesDeclared,anonymousClass);
    PsiElement lambdaBody=lambdaExpression.getBody();
    LOG.assertTrue(lambdaBody != null);
    lambdaBody.replace(body);
    giveUniqueNames(project,lambdaContext,elementFactory,lambdaExpression,lambdaExpression.getParameterList().getParameters());
    final PsiNewExpression newExpression=(PsiNewExpression)anonymousClass.getParent();
    lambdaExpression=(PsiLambdaExpression)newExpression.replace(lambdaExpression);
    final PsiExpression singleExpr=RedundantLambdaCodeBlockInspection.isCodeBlockRedundant(lambdaExpression,lambdaExpression.getBody());
    if (singleExpr != null) {
      lambdaExpression.getBody().replace(singleExpr);
    }
    ChangeContextUtil.decodeContextInfo(lambdaExpression,null,null);
    if (!validContext) {
      final PsiParenthesizedExpression typeCast=(PsiParenthesizedExpression)elementFactory.createExpressionFromText("((" + canonicalText + ")"+ withoutTypesDeclared+ ")",lambdaExpression);
      final PsiExpression typeCastExpr=typeCast.getExpression();
      LOG.assertTrue(typeCastExpr != null);
      final PsiExpression typeCastOperand=((PsiTypeCastExpression)typeCastExpr).getOperand();
      LOG.assertTrue(typeCastOperand != null);
      final PsiElement fromText=((PsiLambdaExpression)typeCastOperand).getBody();
      LOG.assertTrue(fromText != null);
      lambdaBody=lambdaExpression.getBody();
      LOG.assertTrue(lambdaBody != null);
      fromText.replace(lambdaBody);
      lambdaExpression.replace(typeCast);
      return;
    }
    PsiType interfaceType=lambdaExpression.getFunctionalInterfaceType();
    if (isInferred(lambdaExpression,interfaceType)) {
      final PsiLambdaExpression withTypes=(PsiLambdaExpression)elementFactory.createExpressionFromText(lambdaWithTypesDeclared,lambdaExpression);
      final PsiElement withTypesBody=withTypes.getBody();
      LOG.assertTrue(withTypesBody != null);
      lambdaBody=lambdaExpression.getBody();
      LOG.assertTrue(lambdaBody != null);
      withTypesBody.replace(lambdaBody);
      lambdaExpression=(PsiLambdaExpression)lambdaExpression.replace(withTypes);
      interfaceType=lambdaExpression.getFunctionalInterfaceType();
      if (isInferred(lambdaExpression,interfaceType)) {
        final PsiTypeCastExpression typeCast=(PsiTypeCastExpression)elementFactory.createExpressionFromText("(" + canonicalText + ")"+ withoutTypesDeclared,lambdaExpression);
        final PsiExpression typeCastOperand=typeCast.getOperand();
        LOG.assertTrue(typeCastOperand instanceof PsiLambdaExpression);
        final PsiElement fromText=((PsiLambdaExpression)typeCastOperand).getBody();
        LOG.assertTrue(fromText != null);
        lambdaBody=lambdaExpression.getBody();
        LOG.assertTrue(lambdaBody != null);
        fromText.replace(lambdaBody);
        lambdaExpression.replace(typeCast);
      }
    }
  }
}
