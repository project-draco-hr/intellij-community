{
  final GitVcs vcs=GitVcs.getInstance(myProject);
  if (vcs == null) {
    return;
  }
  if (LOG.isDebugEnabled())   LOG.debug("initial dirty scope: " + dirtyScope);
  appendNestedVcsRootsToDirt(dirtyScope,vcs,myVcsManager);
  if (LOG.isDebugEnabled())   LOG.debug("after adding nested vcs roots to dirt: " + dirtyScope);
  final Collection<VirtualFile> affected=dirtyScope.getAffectedContentRoots();
  Collection<VirtualFile> roots=GitUtil.gitRootsForPaths(affected);
  try {
    final MyNonChangedHolder holder=new MyNonChangedHolder(myProject,dirtyScope.getDirtyFilesNoExpand(),addGate,myFileDocumentManager,myVcsManager);
    for (    VirtualFile root : roots) {
      LOG.debug("checking root: " + root.getPath());
      GitChangesCollector collector=isNewGitChangeProviderAvailable() ? GitNewChangesCollector.collect(myProject,myGit,myChangeListManager,myVcsManager,vcs,dirtyScope,root) : GitOldChangesCollector.collect(myProject,myChangeListManager,myVcsManager,vcs,dirtyScope,root);
      final Collection<Change> changes=collector.getChanges();
      holder.changed(changes);
      for (      Change file : changes) {
        LOG.debug("process change: " + ChangesUtil.getFilePath(file).getPath());
        builder.processChange(file,GitVcs.getKey());
      }
      for (      VirtualFile f : collector.getUnversionedFiles()) {
        builder.processUnversionedFile(f);
        holder.unversioned(f);
      }
      holder.feedBuilder(builder);
    }
  }
 catch (  VcsException e) {
    LOG.info(e);
    vcs.getExecutableValidator().showNotificationOrThrow(e);
  }
}
