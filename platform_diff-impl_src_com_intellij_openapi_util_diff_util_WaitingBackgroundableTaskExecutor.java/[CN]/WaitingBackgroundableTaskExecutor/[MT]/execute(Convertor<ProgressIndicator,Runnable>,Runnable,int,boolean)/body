{
  abort();
  myModificationStamp++;
  final int modificationStamp=myModificationStamp;
  final ModalityState modality=ModalityState.current();
  myProgressIndicator=new EmptyProgressIndicator(){
    @NotNull @Override public ModalityState getModalityState(){
      return modality;
    }
  }
;
  final ProgressIndicator indicator=myProgressIndicator;
  final Semaphore semaphore=new Semaphore(0);
  final AtomicReference<Runnable> resultRef=new AtomicReference<Runnable>();
  if (forceEDT) {
    Runnable result=backgroundTask.convert(indicator);
    finish(result,modificationStamp,indicator);
  }
 else {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      @Override public void run(){
        ProgressManager.getInstance().executeProcessUnderProgress(new Runnable(){
          @Override public void run(){
            final Runnable result=backgroundTask.convert(indicator);
            if (indicator.isCanceled()) {
              semaphore.release();
              return;
            }
            if (!resultRef.compareAndSet(null,result)) {
              ApplicationManager.getApplication().invokeLater(new Runnable(){
                @Override public void run(){
                  finish(result,modificationStamp,indicator);
                }
              }
,modality);
            }
            semaphore.release();
          }
        }
,indicator);
      }
    }
);
    try {
      semaphore.tryAcquire(waitMillis,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException ignore) {
    }
    if (!resultRef.compareAndSet(null,TOO_SLOW_OPERATION)) {
      finish(resultRef.get(),modificationStamp,indicator);
    }
 else {
      if (onSlowAction != null)       onSlowAction.run();
    }
  }
}
