{
  MultiMap<Fact,DfaMemoryStateImpl> statesByFact=MultiMap.createLinked();
  for (  DfaMemoryStateImpl state : states) {
    ProgressManager.checkCanceled();
    for (    Fact fact : getFacts(state)) {
      statesByFact.putValue(fact,state);
    }
  }
  for (  final Fact fact : statesByFact.keySet()) {
    if (statesByFact.get(fact).size() == states.size() || fact.myPositive)     continue;
    Collection<DfaMemoryStateImpl> statesWithNegations=statesByFact.get(fact.getPositiveCounterpart());
    if (statesWithNegations.isEmpty())     continue;
    ProgressManager.checkCanceled();
    MultiMap<Set<Fact>,DfaMemoryStateImpl> statesByUnrelatedFacts=MultiMap.createLinked();
    for (    DfaMemoryStateImpl state : ContainerUtil.concat(statesByFact.get(fact),statesWithNegations)) {
      statesByUnrelatedFacts.putValue(getUnrelatedFacts(fact,state),state);
    }
    Replacements replacements=new Replacements(states);
    for (    Set<Fact> key : statesByUnrelatedFacts.keySet()) {
      final Collection<DfaMemoryStateImpl> group=statesByUnrelatedFacts.get(key);
      final Set<DfaVariableValue> unknowns=getAllUnknownVariables(group);
      replacements.stripAndMerge(group,new Function<DfaMemoryStateImpl,DfaMemoryStateImpl>(){
        @Override public DfaMemoryStateImpl fun(        DfaMemoryStateImpl original){
          DfaMemoryStateImpl copy=withUnknownVariables(original,unknowns);
          fact.removeFromState(copy);
          if (fact.myType == FactType.equality) {
            restoreOtherInequalities(fact,group,copy);
          }
          return copy;
        }
      }
);
    }
    if (replacements.hasMerges())     return replacements.getMergeResult();
  }
  return null;
}
