{
  MultiMap<Fact,DfaMemoryStateImpl> statesByFact=MultiMap.createLinked();
  for (  DfaMemoryStateImpl state : states) {
    ProgressManager.checkCanceled();
    for (    Fact fact : getFacts(state)) {
      statesByFact.putValue(fact,state);
    }
  }
  for (  final Fact fact : statesByFact.keySet()) {
    if (statesByFact.get(fact).size() == states.size() || fact.myPositive)     continue;
    Collection<DfaMemoryStateImpl> statesWithNegations=statesByFact.get(fact.getPositiveCounterpart());
    if (statesWithNegations.isEmpty())     continue;
    ProgressManager.checkCanceled();
    MultiMap<Set<Fact>,DfaMemoryStateImpl> statesByUnrelatedFacts1=mapByUnrelatedFacts(fact,statesByFact.get(fact));
    MultiMap<Set<Fact>,DfaMemoryStateImpl> statesByUnrelatedFacts2=mapByUnrelatedFacts(fact,statesWithNegations);
    Replacements replacements=new Replacements(states);
    for (    Set<Fact> key : statesByUnrelatedFacts1.keySet()) {
      final Collection<DfaMemoryStateImpl> group1=statesByUnrelatedFacts1.get(key);
      final Collection<DfaMemoryStateImpl> group2=statesByUnrelatedFacts2.get(key);
      if (group1.isEmpty() || group2.isEmpty())       continue;
      final Collection<DfaMemoryStateImpl> group=ContainerUtil.newArrayList(ContainerUtil.concat(group1,group2));
      final Set<DfaVariableValue> unknowns=getAllUnknownVariables(group);
      replacements.stripAndMerge(group,new Function<DfaMemoryStateImpl,DfaMemoryStateImpl>(){
        @Override public DfaMemoryStateImpl fun(        DfaMemoryStateImpl original){
          DfaMemoryStateImpl copy=withUnknownVariables(original,unknowns);
          fact.removeFromState(copy);
          if (fact.myType == FactType.equality) {
            restoreOtherInequalities(fact,group,copy);
          }
          return copy;
        }
      }
);
    }
    if (replacements.hasMerges())     return replacements.getMergeResult();
  }
  return null;
}
