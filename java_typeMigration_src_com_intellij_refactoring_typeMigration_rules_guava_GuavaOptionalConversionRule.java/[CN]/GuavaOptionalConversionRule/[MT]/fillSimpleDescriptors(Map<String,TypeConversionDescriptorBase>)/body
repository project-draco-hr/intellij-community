{
  descriptorsMap.put("absent",new TypeConversionDescriptor("Optional.absent()","java.util.Optional.empty()"){
    @Override public PsiExpression replace(    PsiExpression expression){
      LOG.assertTrue(expression instanceof PsiMethodCallExpression);
      final PsiReferenceParameterList typeArguments=((PsiMethodCallExpression)expression).getTypeArgumentList();
      PsiReferenceParameterList typeArgumentsCopy=typeArguments.getTypeArguments().length == 0 ? null : (PsiReferenceParameterList)typeArguments.copy();
      final PsiMethodCallExpression replacedExpression=(PsiMethodCallExpression)super.replace(expression);
      if (typeArgumentsCopy != null) {
        replacedExpression.getTypeArgumentList().replace(typeArgumentsCopy);
      }
      return replacedExpression;
    }
  }
);
  descriptorsMap.put("of",new TypeConversionDescriptor("Optional.of($ref$)","java.util.Optional.of($ref$)"));
  descriptorsMap.put("fromNullable",new TypeConversionDescriptor("Optional.fromNullable($ref$)","java.util.Optional.ofNullable($ref$)"));
  descriptorsMap.put("presentInstances",new TypeConversionDescriptor("Optional.presentInstances($it$)","java.util.stream.StreamSupport.stream($it$.spliterator(), false).map(java.util.Optional::get).collect(java.util.Collectors.toList())"));
  final TypeConversionDescriptorBase identity=new TypeConversionDescriptorBase();
  descriptorsMap.put("get",identity);
  descriptorsMap.put("isPresent",identity);
  descriptorsMap.put("orNull",new TypeConversionDescriptor("$val$.orNull()","$val$.orElse(null)"));
  descriptorsMap.put("asSet",new TypeConversionDescriptor("$val$.asSet()","$val$.isPresent() ? java.util.Collections.singleton($val$.get()) : java.util.Collections.emptySet()"));
  descriptorsMap.put("transform",new TypeConversionDescriptor("$val$.transform($fun$)","$val$.map($fun$)"));
}
