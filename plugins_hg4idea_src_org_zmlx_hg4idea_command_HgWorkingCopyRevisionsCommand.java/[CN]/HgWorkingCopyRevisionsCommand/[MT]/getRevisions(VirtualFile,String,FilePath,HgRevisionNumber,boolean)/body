{
  final List<String> args=new LinkedList<>();
  args.add("--template");
  args.add(HgChangesetUtil.makeTemplate("{rev}","{node}"));
  if (revision != null) {
    args.add("-r");
    args.add(revision.getChangeset());
  }
  if (file != null) {
    args.add(HgUtil.getOriginalFileName(file,ChangeListManager.getInstance(myProject)).getPath());
  }
  final HgCommandExecutor executor=new HgCommandExecutor(myProject);
  executor.setSilent(silent);
  final HgCommandResult result=executor.executeInCurrentThread(repo,command,args);
  if (result == null) {
    return new ArrayList<>(0);
  }
  final List<String> lines=new ArrayList<>();
  for (  String line : result.getRawOutput().split(HgChangesetUtil.CHANGESET_SEPARATOR)) {
    if (!line.trim().isEmpty()) {
      lines.add(line);
    }
  }
  if (lines.isEmpty()) {
    return new ArrayList<>();
  }
  final List<HgRevisionNumber> revisions=new ArrayList<>(lines.size());
  for (  String line : lines) {
    final List<String> parts=StringUtil.split(line,HgChangesetUtil.ITEM_SEPARATOR);
    if (parts.size() < 2) {
      LOG.error("getRevisions output parse error in line [" + line + "]\n All lines: \n"+ lines);
      continue;
    }
    revisions.add(HgRevisionNumber.getInstance(parts.get(0),parts.get(1)));
  }
  return revisions;
}
