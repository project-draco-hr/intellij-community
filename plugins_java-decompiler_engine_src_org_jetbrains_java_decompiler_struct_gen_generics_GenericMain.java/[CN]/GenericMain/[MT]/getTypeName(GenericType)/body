{
  int tp=type.type;
  if (tp <= CodeConstants.TYPE_BOOLEAN) {
    return typeNames[tp];
  }
 else   if (tp == CodeConstants.TYPE_VOID) {
    return "void";
  }
 else   if (tp == CodeConstants.TYPE_GENVAR) {
    return type.value;
  }
 else   if (tp == CodeConstants.TYPE_OBJECT) {
    StringBuilder buffer=new StringBuilder();
    buffer.append(DecompilerContext.getImportCollector().getShortName(buildJavaClassName(type)));
    if (!type.getArguments().isEmpty()) {
      buffer.append("<");
      for (int i=0; i < type.getArguments().size(); i++) {
        if (i > 0) {
          buffer.append(", ");
        }
        int wildcard=type.getWildcards().get(i);
        if (wildcard != GenericType.WILDCARD_NO) {
          buffer.append("?");
switch (wildcard) {
case GenericType.WILDCARD_EXTENDS:
            buffer.append(" extends ");
          break;
case GenericType.WILDCARD_SUPER:
        buffer.append(" super ");
    }
  }
  GenericType genPar=type.getArguments().get(i);
  if (genPar != null) {
    buffer.append(getGenericCastTypeName(genPar));
  }
}
buffer.append(">");
}
return buffer.toString();
}
throw new RuntimeException("Invalid type: " + type);
}
