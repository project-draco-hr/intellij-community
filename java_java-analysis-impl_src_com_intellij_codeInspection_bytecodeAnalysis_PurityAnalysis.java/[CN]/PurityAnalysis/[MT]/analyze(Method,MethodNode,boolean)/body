{
  Key key=new Key(method,Direction.Pure,stable);
  if ((methodNode.access & UN_ANALYZABLE_FLAG) != 0) {
    return new Equation<Key,Value>(key,FINAL_TOP);
  }
  InsnList insns=methodNode.instructions;
  Set<Key> invokedKeys=new HashSet<Key>();
  for (int i=0; i < insns.size(); i++) {
    AbstractInsnNode insn=insns.get(i);
switch (insn.getOpcode()) {
case Opcodes.PUTFIELD:
case Opcodes.PUTSTATIC:
case Opcodes.IASTORE:
case Opcodes.LASTORE:
case Opcodes.FASTORE:
case Opcodes.DASTORE:
case Opcodes.AASTORE:
case Opcodes.BASTORE:
case Opcodes.CASTORE:
case Opcodes.SASTORE:
case Opcodes.INVOKEDYNAMIC:
case Opcodes.INVOKEINTERFACE:
      return new Equation<Key,Value>(key,FINAL_TOP);
case Opcodes.INVOKESPECIAL:
case Opcodes.INVOKESTATIC:
    invokedKeys.add(new Key(new Method((MethodInsnNode)insn),Direction.Pure,true));
  break;
case Opcodes.INVOKEVIRTUAL:
invokedKeys.add(new Key(new Method((MethodInsnNode)insn),Direction.Pure,false));
break;
default :
break;
}
}
if (invokedKeys.isEmpty()) {
return new Equation<Key,Value>(key,FINAL_PURE);
}
 else {
HashSet<Product<Key,Value>> sumOfProducts=new HashSet<Product<Key,Value>>();
for (Key call : invokedKeys) {
sumOfProducts.add(new Product<Key,Value>(Value.Top,Collections.singleton(call)));
}
return new Equation<Key,Value>(key,new Pending<Key,Value>(sumOfProducts));
}
}
