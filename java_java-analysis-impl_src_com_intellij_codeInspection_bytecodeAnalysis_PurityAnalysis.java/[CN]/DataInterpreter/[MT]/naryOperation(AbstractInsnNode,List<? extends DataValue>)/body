{
  int insnIndex=methodNode.instructions.indexOf(insn);
  int opCode=insn.getOpcode();
switch (opCode) {
case Opcodes.MULTIANEWARRAY:
    return DataValue.LocalDataValue;
case Opcodes.INVOKEDYNAMIC:
  effects[insnIndex]=EffectQuantum.TopEffectQuantum;
return (ASMUtils.getReturnSizeFast(((InvokeDynamicInsnNode)insn).desc) == 1) ? DataValue.UnknownDataValue1 : DataValue.UnknownDataValue2;
case Opcodes.INVOKEVIRTUAL:
case Opcodes.INVOKESPECIAL:
case Opcodes.INVOKESTATIC:
case Opcodes.INVOKEINTERFACE:
boolean stable=opCode == Opcodes.INVOKESPECIAL || opCode == Opcodes.INVOKESTATIC;
MethodInsnNode mNode=((MethodInsnNode)insn);
DataValue[] data=values.toArray(new DataValue[values.size()]);
Key key=new Key(new Method(mNode.owner,mNode.name,mNode.desc),Direction.Pure,stable);
effects[insnIndex]=new EffectQuantum.CallQuantum(key,data,opCode == Opcodes.INVOKESTATIC);
return (ASMUtils.getReturnSizeFast(mNode.desc) == 1) ? DataValue.UnknownDataValue1 : DataValue.UnknownDataValue2;
}
return null;
}
