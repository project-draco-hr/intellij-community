{
  final Key key=new Key(method,new InOut(i,inValue),stable);
  final Result result;
  if (exception || (inValue == Value.Null && interpreter.dereferencedParams[i])) {
    result=new Final(Value.Bot);
  }
 else   if (FalseValue == returnValue) {
    result=new Final(Value.False);
  }
 else   if (TrueValue == returnValue) {
    result=new Final(Value.True);
  }
 else   if (returnValue instanceof TrackableNullValue) {
    result=new Final(Value.Null);
  }
 else   if (returnValue instanceof NotNullValue || ThisValue == returnValue) {
    result=new Final(Value.NotNull);
  }
 else   if (returnValue instanceof NthParamValue && ((NthParamValue)returnValue).n == i) {
    result=new Final(inValue);
  }
 else   if (returnValue instanceof TrackableCallValue) {
    TrackableCallValue call=(TrackableCallValue)returnValue;
    HashSet<Key> keys=new HashSet<Key>();
    for (int argI=0; argI < call.args.size(); argI++) {
      BasicValue arg=call.args.get(argI);
      if (arg instanceof NthParamValue) {
        NthParamValue npv=(NthParamValue)arg;
        if (npv.n == i) {
          keys.add(new Key(call.method,new InOut(argI,inValue),call.stableCall));
        }
      }
    }
    if (ASMUtils.isReferenceType(call.getType())) {
      keys.add(new Key(call.method,Out,call.stableCall));
    }
    if (keys.isEmpty()) {
      result=new Final(Value.Top);
    }
 else {
      result=new Pending(new SingletonSet<Product>(new Product(Value.Top,keys)));
    }
  }
 else {
    result=new Final(Value.Top);
  }
  return new Equation(key,result);
}
