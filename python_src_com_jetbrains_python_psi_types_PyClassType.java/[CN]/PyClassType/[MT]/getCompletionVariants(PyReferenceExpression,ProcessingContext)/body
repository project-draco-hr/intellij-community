{
  Set<String> names_already=context.get(PyType.CTX_NAMES);
  final VariantsProcessor processor=new VariantsProcessor(new PyResolveUtil.FilterNotInstance(myClass));
  myClass.processDeclarations(processor,ResolveState.initial(),null,referenceExpression);
  List<Object> ret=new ArrayList<Object>();
  if (names_already != null) {
    for (    LookupElement le : processor.getResultList()) {
      String name=le.getLookupString();
      if (names_already.contains(name))       continue;
      names_already.add(name);
      ret.add(le);
    }
  }
 else   ret.addAll(processor.getResultList());
  for (  PyClass ancestor : myClass.getSuperClasses()) {
    Object[] ancestry=(new PyClassType(ancestor,true)).getCompletionVariants(referenceExpression,context);
    for (    Object ob : ancestry) {
      if (ob instanceof LookupElementBuilder) {
        ret.add(((LookupElementBuilder)ob).setTypeText(ancestor.getName()));
      }
 else {
        ret.add(ob);
      }
    }
    ret.addAll(Arrays.asList(ancestry));
  }
  return ret.toArray();
}
