{
  if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {
    return PsiElementVisitor.EMPTY_VISITOR;
  }
  return new JavaElementVisitor(){
    private final AtomicNotNullLazyValue<Map<String,PsiClass>> myGuavaClassConversions=new AtomicNotNullLazyValue<Map<String,PsiClass>>(){
      @NotNull @Override protected Map<String,PsiClass> compute(){
        Map<String,PsiClass> map=new HashMap<String,PsiClass>();
        for (        TypeConversionRule rule : TypeConversionRule.EP_NAME.getExtensions()) {
          if (rule instanceof BaseGuavaTypeConversionRule) {
            final String fromClass=((BaseGuavaTypeConversionRule)rule).ruleFromClass();
            final String toClass=((BaseGuavaTypeConversionRule)rule).ruleToClass();
            final Project project=holder.getProject();
            final JavaPsiFacade javaPsiFacade=JavaPsiFacade.getInstance(project);
            final PsiClass targetClass=javaPsiFacade.findClass(toClass,GlobalSearchScope.allScope(project));
            if (targetClass != null) {
              map.put(fromClass,targetClass);
            }
          }
        }
        return map;
      }
    }
;
    @Override public void visitVariable(    PsiVariable variable){
      final PsiType type=variable.getType();
      if (type instanceof PsiClassType) {
        final PsiClassType.ClassResolveResult resolveResult=((PsiClassType)type).resolveGenerics();
        final PsiClass psiClass=resolveResult.getElement();
        if (psiClass != null) {
          final String qName=psiClass.getQualifiedName();
          final PsiClass targetClass=myGuavaClassConversions.getValue().get(qName);
          if (targetClass != null) {
            final VariableTypeFix fix=TypeMigrationVariableTypeFixProvider.createTypeMigrationFix(variable,addTypeParameters(type,resolveResult,targetClass));
            holder.registerProblem(variable,PROBLEM_DESCRIPTION_FOR_VARIABLE,fix);
          }
        }
      }
    }
    @Override public void visitMethodCallExpression(    PsiMethodCallExpression expression){
      if (!isFluentIterableFromCall(expression))       return;
      final PsiMethodCallExpression chain=findGuavaMethodChain(expression);
      PsiClassType initialType=(PsiClassType)expression.getType();
      LOG.assertTrue(initialType != null);
      PsiClass resolvedClass=initialType.resolve();
      PsiClass target;
      if (resolvedClass == null || (target=myGuavaClassConversions.getValue().get(resolvedClass.getQualifiedName())) == null) {
        return;
      }
      PsiClassType targetType=addTypeParameters(initialType,initialType.resolveGenerics(),target);
      holder.registerProblem(chain,PROBLEM_DESCRIPTION_FOR_METHOD_CHAIN,new MigrateFluentIterableChainQuickFix(chain,initialType,targetType));
    }
    private boolean isFluentIterableFromCall(    PsiMethodCallExpression expression){
      PsiMethod method=expression.resolveMethod();
      if (method == null || !"from".equals(method.getName())) {
        return false;
      }
      PsiClass aClass=method.getContainingClass();
      return aClass != null && GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(aClass.getQualifiedName());
    }
    private PsiMethodCallExpression findGuavaMethodChain(    PsiMethodCallExpression expression){
      PsiMethodCallExpression chain=expression;
      while (true) {
        final PsiMethodCallExpression current=PsiTreeUtil.getParentOfType(chain,PsiMethodCallExpression.class);
        if (current != null && current.getMethodExpression().getQualifierExpression() == chain) {
          final PsiMethod method=current.resolveMethod();
          if (method == null) {
            return chain;
          }
          final PsiClass containingClass=method.getContainingClass();
          if (containingClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(containingClass.getQualifiedName()) || GuavaOptionalConversionRule.GUAVA_OPTIONAL.equals(containingClass.getQualifiedName()))) {
            return chain;
          }
        }
 else {
          return chain;
        }
        chain=current;
      }
    }
    private PsiClassType addTypeParameters(    PsiType currentType,    PsiClassType.ClassResolveResult currentTypeResolveResult,    PsiClass targetClass){
      final Map<PsiTypeParameter,PsiType> substitutionMap=currentTypeResolveResult.getSubstitutor().getSubstitutionMap();
      final PsiElementFactory elementFactory=JavaPsiFacade.getElementFactory(holder.getProject());
      if (substitutionMap.size() == 1) {
        return elementFactory.createType(targetClass,ContainerUtil.getFirstItem(substitutionMap.values()));
      }
 else {
        LOG.assertTrue(substitutionMap.size() == 2);
        LOG.assertTrue(GuavaFunctionConversionRule.JAVA_UTIL_FUNCTION_FUNCTION.equals(targetClass.getQualifiedName()));
        final PsiType returnType=LambdaUtil.getFunctionalInterfaceReturnType(currentType);
        final List<PsiType> types=new ArrayList<PsiType>(substitutionMap.values());
        types.remove(returnType);
        final PsiType parameterType=types.get(0);
        return elementFactory.createType(targetClass,parameterType,returnType);
      }
    }
  }
;
}
