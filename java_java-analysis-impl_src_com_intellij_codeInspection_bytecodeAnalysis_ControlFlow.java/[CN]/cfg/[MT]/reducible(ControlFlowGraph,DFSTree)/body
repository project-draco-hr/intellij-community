{
  int size=cfg.transitions.length;
  HashSet<Integer>[] cycles=new HashSet[size];
  HashSet<Integer>[] nonCycles=new HashSet[size];
  int[] collapsedTo=new int[size];
  for (int i=0; i < size; i++) {
    cycles[i]=new HashSet<Integer>();
    nonCycles[i]=new HashSet<Integer>();
    collapsedTo[i]=i;
  }
  for (  Edge edge : dfs.back) {
    cycles[edge.to].add(edge.from);
  }
  for (  Edge edge : dfs.tree) {
    nonCycles[edge.to].add(edge.from);
  }
  for (  Edge edge : dfs.forward) {
    nonCycles[edge.to].add(edge.from);
  }
  for (  Edge edge : dfs.cross) {
    nonCycles[edge.to].add(edge.from);
  }
  for (int w=size - 1; w >= 0; w--) {
    HashSet<Integer> p=new HashSet<Integer>(cycles[w]);
    Queue<Integer> queue=new LinkedList<Integer>(cycles[w]);
    while (!queue.isEmpty()) {
      int x=queue.remove();
      for (      int y : nonCycles[x]) {
        int y1=collapsedTo[y];
        if (!dfs.isDescendant(y1,w)) {
          return false;
        }
        if (y1 != w && p.add(y1)) {
          queue.add(y1);
        }
      }
    }
    for (    int x : p) {
      collapsedTo[x]=w;
    }
  }
  return true;
}
