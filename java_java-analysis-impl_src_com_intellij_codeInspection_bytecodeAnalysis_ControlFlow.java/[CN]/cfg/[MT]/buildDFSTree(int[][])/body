{
  Set<Edge> tree=new HashSet<Edge>();
  Set<Edge> forward=new HashSet<Edge>();
  Set<Edge> back=new HashSet<Edge>();
  Set<Edge> cross=new HashSet<Edge>();
  boolean[] marked=new boolean[transitions.length];
  boolean[] scanned=new boolean[transitions.length];
  int[] preOrder=new int[transitions.length];
  int[] postOrder=new int[transitions.length];
  int entered=0;
  int completed=0;
  Deque<Action> stack=new LinkedList<Action>();
  Set<Integer> loopEnters=new HashSet<Integer>();
  entered++;
  preOrder[0]=entered;
  marked[0]=true;
  stack.push(new MarkScanned(0));
  for (  int to : transitions[0]) {
    stack.push(new ExamineEdge(0,to));
  }
  while (!stack.isEmpty()) {
    Action action=stack.pop();
    if (action instanceof MarkScanned) {
      MarkScanned markScannedAction=(MarkScanned)action;
      completed++;
      postOrder[markScannedAction.node]=completed;
      scanned[markScannedAction.node]=true;
    }
 else {
      ExamineEdge examineEdgeAction=(ExamineEdge)action;
      int from=examineEdgeAction.from;
      int to=examineEdgeAction.to;
      if (!marked[to]) {
        tree.add(new Edge(from,to));
        entered++;
        preOrder[to]=entered;
        marked[to]=true;
        stack.push(new MarkScanned(to));
        for (        int to1 : transitions[to]) {
          stack.push(new ExamineEdge(to,to1));
        }
      }
 else       if (preOrder[to] > preOrder[from]) {
        forward.add(new Edge(from,to));
      }
 else       if (preOrder[to] < preOrder[from] && !scanned[to]) {
        back.add(new Edge(from,to));
        loopEnters.add(to);
      }
 else {
        cross.add(new Edge(from,to));
      }
    }
  }
  return new DFSTree(preOrder,postOrder,tree,forward,back,cross,loopEnters);
}
