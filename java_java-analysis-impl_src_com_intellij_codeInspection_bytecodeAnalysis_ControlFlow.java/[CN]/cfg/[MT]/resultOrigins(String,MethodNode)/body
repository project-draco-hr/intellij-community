{
  try {
    Frame<SourceValue>[] frames=new Analyzer<SourceValue>(MININAL_ORIGIN_INTERPRETER).analyze(className,methodNode);
    InsnList insns=methodNode.instructions;
    TIntHashSet result=new TIntHashSet();
    for (int i=0; i < frames.length; i++) {
      AbstractInsnNode insnNode=insns.get(i);
switch (insnNode.getOpcode()) {
case ARETURN:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
        for (        AbstractInsnNode sourceInsn : frames[i].pop().insns) {
          result.add(insns.indexOf(sourceInsn));
        }
      break;
default :
    break;
}
}
return result;
}
 catch (AnalyzerException e) {
LOG.error(e);
throw new RuntimeException();
}
}
