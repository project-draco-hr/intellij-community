{
  final FunctionalParser<R,T> thisParser=this;
  return new FunctionalParserBase<R,T>(){
    private Object myKey=null;
    private Map<Integer,SoftReference<Pair<R,State>>> myCache=new HashMap<Integer,SoftReference<Pair<R,State>>>();
    @NotNull @Override public Pair<R,State> parse(    @NotNull List<Token<T>> tokens,    @NotNull State state) throws ParserException {
      if (myKey != state.getKey()) {
        myKey=state.getKey();
        myCache.clear();
      }
      final SoftReference<Pair<R,State>> ref=myCache.get(state.getPos());
      if (ref != null) {
        final Pair<R,State> cached=ref.get();
        if (cached != null) {
          return cached;
        }
      }
      final Pair<R,State> result=thisParser.parse(tokens,state);
      myCache.put(state.getPos(),new SoftReference<Pair<R,State>>(result));
      return result;
    }
  }
;
}
