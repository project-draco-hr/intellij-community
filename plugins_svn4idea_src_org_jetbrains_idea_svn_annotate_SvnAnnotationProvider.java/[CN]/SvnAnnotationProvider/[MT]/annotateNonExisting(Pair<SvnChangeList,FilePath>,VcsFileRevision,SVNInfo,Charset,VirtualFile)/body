{
  final File wasFile=pair.getSecond().getIOFile();
  final File root=getCommonAncestor(wasFile,info.getFile());
  if (root == null)   throw new VcsException("Can not find relative path for " + wasFile.getPath() + "@"+ revision.getRevisionNumber().asString());
  final String relativePath=FileUtil.getRelativePath(root.getPath(),wasFile.getPath(),File.separatorChar);
  if (relativePath == null)   throw new VcsException("Can not find relative path for " + wasFile.getPath() + "@"+ revision.getRevisionNumber().asString());
  SVNInfo wcRootInfo=myVcs.getInfo(root);
  if (wcRootInfo == null || wcRootInfo.getURL() == null) {
    throw new VcsException("Can not find relative path for " + wasFile.getPath() + "@"+ revision.getRevisionNumber().asString());
  }
  SVNURL wasUrl=wcRootInfo.getURL();
  final String[] strings=relativePath.replace('\\','/').split("/");
  for (  String string : strings) {
    wasUrl=wasUrl.appendPath(string,true);
  }
  final SVNRevision svnRevision=((SvnRevisionNumber)revision.getRevisionNumber()).getRevision();
  byte[] data=SvnUtil.getFileContents(myVcs,SvnTarget.fromURL(wasUrl),svnRevision,svnRevision);
  final String contents=LoadTextUtil.getTextByBinaryPresentation(data,charset == null ? CharsetToolkit.UTF8_CHARSET : charset).toString();
  final SvnRemoteFileAnnotation result=new SvnRemoteFileAnnotation(myVcs,contents,revision.getRevisionNumber(),pair.getFirst(),pair.getSecond().getPath(),current);
  final ISVNAnnotateHandler annotateHandler=createAnnotationHandler(ProgressManager.getInstance().getProgressIndicator(),result);
  final boolean calculateMergeinfo=SvnConfiguration.getInstance(myVcs.getProject()).isShowMergeSourcesInAnnotate() && SvnUtil.checkRepositoryVersion15(myVcs,wasUrl.toString());
  AnnotateClient client=myVcs.getFactory().createAnnotateClient();
  client.annotate(SvnTarget.fromURL(wasUrl),SVNRevision.create(1),svnRevision,svnRevision,calculateMergeinfo,getLogClientOptions(myVcs),annotateHandler);
  return result;
}
