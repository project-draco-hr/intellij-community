{
  Set<PyClass> classes=new HashSet<PyClass>();
  final MultiMap<PyClass,PyFunction> candidates=new MultiMap<PyClass,PyFunction>();
  for (  PyFunction function : functions) {
    PyClass pyClass=function.getContainingClass();
    if (pyClass != null && function.getName() != null) {
      classes.add(pyClass);
      candidates.putValue(pyClass,function);
    }
  }
  final Set<PyFunction> overridden=new HashSet<PyFunction>();
  for (  final PyClass pyClass : classes) {
    PyClassInheritorsSearch.search(pyClass,true).forEach(new Processor<PyClass>(){
      public boolean process(      final PyClass inheritor){
        for (Iterator<PyFunction> it=candidates.get(pyClass).iterator(); it.hasNext(); ) {
          PyFunction func=it.next();
          if (inheritor.findMethodByName(func.getName(),false,null) != null) {
            overridden.add(func);
            it.remove();
          }
        }
        return !candidates.isEmpty();
      }
    }
);
    if (candidates.isEmpty())     break;
  }
  for (  PyFunction func : overridden) {
    result.add(new LineMarkerInfo<PyFunction>(func,func.getTextOffset(),AllIcons.Gutter.OverridenMethod,Pass.UPDATE_OVERRIDEN_MARKERS,ourOverridingMethodTooltipProvider,ourOverridingMethodNavigator));
  }
}
