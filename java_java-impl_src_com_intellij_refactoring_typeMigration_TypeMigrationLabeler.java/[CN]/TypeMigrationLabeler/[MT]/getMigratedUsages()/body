{
  final LinkedList<Pair<TypeMigrationUsageInfo,PsiType>> declarations=getTypeEvaluator().getMigratedDeclarations();
  final TypeMigrationUsageInfo[] usages=new TypeMigrationUsageInfo[declarations.size() + myConversions.size() + myNewExpressionTypeChange.size()+ myClassTypeArgumentsChange.size()];
  int j=0;
  for (  final PsiElement element : myConversions.keySet()) {
    final Object conv=myConversions.get(element);
    usages[j++]=new TypeMigrationUsageInfo(element){
      public String getTooltipText(){
        if (conv instanceof String) {
          final String conversion=(String)conv;
          return "Replaced with " + conversion.replaceAll("\\$",element.getText());
        }
 else {
          return "Replaced with " + conv.toString();
        }
      }
      @Override public boolean isExcluded(){
        if (conv instanceof TypeConversionDescriptorBase)         return ((TypeConversionDescriptorBase)conv).getRoot().isExcluded();
        return super.isExcluded();
      }
      @Override public TypeMigrationUsageInfo getOwnerRoot(){
        return conv instanceof TypeConversionDescriptorBase ? ((TypeConversionDescriptorBase)conv).getRoot() : null;
      }
    }
;
  }
  for (  final Pair<TypeMigrationUsageInfo,PsiType> p : declarations) {
    final TypeMigrationUsageInfo element=p.getFirst();
    usages[j++]=element;
  }
  for (  TypeMigrationUsageInfo info : myClassTypeArgumentsChange.keySet()) {
    usages[j++]=info;
  }
  for (  final TypeMigrationUsageInfo expr : myNewExpressionTypeChange.keySet()) {
    usages[j++]=expr;
  }
  return sortMigratedUsages(usages);
}
