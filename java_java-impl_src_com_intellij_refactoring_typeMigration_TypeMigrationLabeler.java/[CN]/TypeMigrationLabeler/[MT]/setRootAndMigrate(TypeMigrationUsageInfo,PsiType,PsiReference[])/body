{
  final TypeMigrationUsageInfo oldRoot=getCurrentRoot();
  myCurrentRoot=newRootUsageInfo;
  PsiElement root=newRootUsageInfo.getElement();
  if (root instanceof PsiMethod) {
    migrateMethodReturnExpression(migrationType,(PsiMethod)root);
  }
 else   if (root instanceof PsiParameter && ((PsiParameter)root).getDeclarationScope() instanceof PsiMethod) {
    migrateMethodCallExpressions(migrationType,(PsiParameter)root,null);
  }
 else   if (root instanceof PsiVariable || root instanceof PsiExpression) {
    final PsiElement element=getContainingStatement(root);
    if (root instanceof PsiExpression) {
      migrateExpressionType((PsiExpression)root,migrationType,element,false,true);
      myTypeEvaluator.setType(newRootUsageInfo,migrationType);
    }
    element.accept(new TypeMigrationStatementProcessor(element,this));
  }
 else   if (root instanceof PsiReferenceParameterList) {
    final TypeMigrationUsageInfo info=new TypeMigrationUsageInfo(root);
    info.setOwnerRoot(oldRoot);
    myClassTypeArgumentsChange.put(info,(PsiClassType)migrationType);
    new ClassTypeArgumentMigrationProcessor(this).migrateClassTypeParameter((PsiReferenceParameterList)root,(PsiClassType)migrationType);
  }
  final Set<PsiElement> processed=new HashSet<PsiElement>();
  for (  PsiReference usage : usages) {
    migrateRootUsageExpression(usage,processed);
  }
}
