{
  super.setChecked(checked);
  if (checked) {
    DataNodeCheckedTreeNode parent=this;
    DataNodeCheckedTreeNode moduleNode=null;
    while (parent.parent instanceof DataNodeCheckedTreeNode) {
      if (moduleNode == null && (myDependencyAwareDataKeys.contains(parent.myDataNode.getKey()))) {
        moduleNode=parent;
      }
      parent=(DataNodeCheckedTreeNode)parent.parent;
    }
    parent.isChecked=true;
    final DataNode modifiedParentDataNode=getModifiableDataNode(parent.myDataNode);
    modifiedParentDataNode.setIgnored(false);
    if (moduleNode != null) {
      moduleNode.isChecked=true;
    }
    ExternalSystemApiUtil.visit(moduleNode == null ? myDataNode : moduleNode.myDataNode,new Consumer<DataNode<?>>(){
      @Override public void consume(      DataNode node){
        final DataNode modifiedDataNode=getModifiableDataNode(node);
        modifiedDataNode.setIgnored(false);
      }
    }
);
  }
 else {
    ExternalSystemApiUtil.visit(myDataNode,new Consumer<DataNode<?>>(){
      @Override public void consume(      DataNode node){
        final DataNode modifiedDataNode=getModifiableDataNode(node);
        modifiedDataNode.setIgnored(true);
      }
    }
);
    if (myShowSelectedRowsOnly) {
      final DefaultTreeModel treeModel=(DefaultTreeModel)myTree.getModel();
      TreePath[] before=myTree.getSelectionPaths();
      treeModel.removeNodeFromParent(this);
      myTree.addSelectionPaths(before);
    }
  }
  if (!checked && parent instanceof DataNodeCheckedTreeNode) {
    if (myDataNode.getKey().equals(ProjectKeys.MODULE) && ((DataNodeCheckedTreeNode)parent).myDataNode.getKey().equals(ProjectKeys.PROJECT)) {
      final DataNode projectDataNode=((DataNodeCheckedTreeNode)parent).myDataNode;
      final ProjectData projectData=(ProjectData)projectDataNode.getData();
      final ModuleData moduleData=(ModuleData)myDataNode.getData();
      if (moduleData.getLinkedExternalProjectPath().equals(projectData.getLinkedExternalProjectPath())) {
        if (ExternalSystemApiUtil.findAll(projectDataNode,ProjectKeys.MODULE).size() == 1) {
          ((DataNodeCheckedTreeNode)parent).setChecked(false);
        }
      }
    }
  }
  DataNodeCheckedTreeNode[] unprocessedNodes=myTree.getSelectedNodes(DataNodeCheckedTreeNode.class,new Tree.NodeFilter<DataNodeCheckedTreeNode>(){
    @Override public boolean accept(    DataNodeCheckedTreeNode node){
      return myDependencyAwareDataKeys.contains(node.myDataNode.getKey()) && checked != node.isChecked();
    }
  }
);
  boolean isCheckCompleted=unprocessedNodes.length == 0 && myDependencyAwareDataKeys.contains(myDataNode.getKey());
  updateSelectionState();
  if (selectionState.getValue().isRequiredSelectionEnabled && isCheckCompleted) {
    warnAboutMissedDependencies(checked);
  }
}
