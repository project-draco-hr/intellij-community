{
  long timeoutMs=myTimeUnit.toMillis(myTimeout);
  long lastActiveMoment=System.currentTimeMillis();
  while (true) {
    long current=System.currentTimeMillis();
    if (myIsTouched) {
      myIsTouched=false;
      lastActiveMoment=current;
    }
    long idleTime=current - lastActiveMoment;
    if (idleTime > timeoutMs) {
      int retCode=processTimeoutInEDT();
      return semaphore.waitFor(0) ? 0 : retCode;
    }
    ProgressManager.checkCanceled();
    if (semaphore.waitFor(Math.min(500,timeoutMs - idleTime))) {
      return 0;
    }
  }
}
