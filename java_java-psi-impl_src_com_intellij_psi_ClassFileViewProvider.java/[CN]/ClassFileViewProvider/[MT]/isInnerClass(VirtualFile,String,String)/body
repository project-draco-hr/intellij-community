{
  Boolean isInner=IS_INNER_CLASS.get(file);
  if (isInner != null)   return isInner;
  final Ref<Boolean> ref=Ref.create(Boolean.FALSE);
  try {
    new MyClassReader(file.contentsToByteArray(false)).accept(new ClassVisitor(Opcodes.ASM5){
      @Override public void visitOuterClass(      String owner,      String name,      String desc){
        ref.set(Boolean.TRUE);
        throw new ProcessCanceledException();
      }
      @Override public void visitInnerClass(      String name,      String outer,      String inner,      int access){
        if ((inner == null || childName.equals(inner)) && outer != null && parentName.equals(outer.substring(outer.lastIndexOf('/') + 1)) || inner == null && outer == null && name.substring(name.lastIndexOf('/') + 1).equals(parentName + '$' + childName)) {
          ref.set(Boolean.TRUE);
          throw new ProcessCanceledException();
        }
      }
    }
,ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
  }
 catch (  ProcessCanceledException ignored) {
  }
catch (  Exception e) {
    Logger.getInstance(ClassFileViewProvider.class).warn(file.getPath(),e);
  }
  isInner=ref.get();
  IS_INNER_CLASS.set(file,isInner);
  return isInner;
}
