{
  final File file=new File(PathManager.getSystemPath());
  final AtomicBoolean reported=new AtomicBoolean();
  final ThreadLocal<Future<Long>> ourFreeSpaceCalculation=new ThreadLocal<Future<Long>>();
  JobScheduler.getScheduler().schedule(new Runnable(){
    private static final long LOW_DISK_SPACE_THRESHOLD=50 * 1024 * 1024;
    private static final long MAX_WRITE_SPEED_IN_BPS=500 * 1024 * 1024;
    @Override public void run(){
      if (!reported.get()) {
        Future<Long> future=ourFreeSpaceCalculation.get();
        if (future == null) {
          ourFreeSpaceCalculation.set(future=ApplicationManager.getApplication().executeOnPooledThread(new Callable<Long>(){
            @Override public Long call() throws Exception {
              return file.getUsableSpace();
            }
          }
));
        }
        if (!future.isDone() || future.isCancelled()) {
          JobScheduler.getScheduler().schedule(this,1,TimeUnit.SECONDS);
          return;
        }
        try {
          final long fileUsableSpace=future.get();
          final long timeout=Math.max(5,(fileUsableSpace - LOW_DISK_SPACE_THRESHOLD) / MAX_WRITE_SPEED_IN_BPS);
          ourFreeSpaceCalculation.set(null);
          if (fileUsableSpace < LOW_DISK_SPACE_THRESHOLD) {
            if (!notificationsComponentIsLoaded()) {
              ourFreeSpaceCalculation.set(future);
              JobScheduler.getScheduler().schedule(this,1,TimeUnit.SECONDS);
              return;
            }
            reported.compareAndSet(false,true);
            SwingUtilities.invokeLater(new Runnable(){
              @Override public void run(){
                String productName=ApplicationNamesInfo.getInstance().getFullProductName();
                String message=IdeBundle.message("low.disk.space.message",productName);
                if (fileUsableSpace < 100 * 1024) {
                  LOG.warn(message);
                  Messages.showErrorDialog(message,"Fatal Configuration Problem");
                  reported.compareAndSet(true,false);
                  restart(timeout);
                }
 else {
                  new NotificationGroup("System",NotificationDisplayType.STICKY_BALLOON,false).createNotification(message,file.getPath(),NotificationType.ERROR,null).whenExpired(new Runnable(){
                    @Override public void run(){
                      reported.compareAndSet(true,false);
                      restart(timeout);
                    }
                  }
).notify(null);
                }
              }
            }
);
          }
 else {
            restart(timeout);
          }
        }
 catch (        Exception ex) {
          LOG.error(ex);
        }
      }
    }
    private boolean notificationsComponentIsLoaded(){
      return ApplicationManager.getApplication().runReadAction(new Computable<NotificationsConfiguration>(){
        @Override public NotificationsConfiguration compute(){
          return NotificationsConfiguration.getNotificationsConfiguration();
        }
      }
) != null;
    }
    private void restart(    long timeout){
      JobScheduler.getScheduler().schedule(this,timeout,TimeUnit.SECONDS);
    }
  }
,1,TimeUnit.SECONDS);
}
