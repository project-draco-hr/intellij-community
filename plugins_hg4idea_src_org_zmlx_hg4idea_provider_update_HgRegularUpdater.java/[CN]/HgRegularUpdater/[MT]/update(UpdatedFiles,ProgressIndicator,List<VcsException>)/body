{
  indicator.setText(HgVcsMessages.message("hg4idea.progress.updating",repoRoot.getPath()));
  String defaultPath=HgUtil.getRepositoryDefaultPath(project,repoRoot);
  if (StringUtil.isEmptyOrSpaces(defaultPath)) {
    throw new VcsException(HgVcsMessages.message("hg4idea.warning.no-default-update-path",repoRoot.getPath()));
  }
  List<HgRevisionNumber> branchHeadsBeforePull=new HgHeadsCommand(project,repoRoot).execute();
  if (branchHeadsBeforePull.size() > 1) {
    reportWarning(warnings,HgVcsMessages.message("hg4idea.update.warning.multipleHeadsBeforeUpdate",repoRoot.getPath()));
  }
  HgRevisionNumber parentBeforeUpdate=new HgWorkingCopyRevisionsCommand(project).firstParent(repoRoot);
  HgCommandExitCode pullResult=pull(repoRoot,indicator,shouldRebase());
  if (pullResult == HgCommandExitCode.ERROR) {
    return false;
  }
  if (pullResult == HgCommandExitCode.SUCCESS) {
    HgRevisionNumber parentAfterUpdate=new HgWorkingCopyRevisionsCommand(project).firstParent(repoRoot);
    addUpdatedFiles(repoRoot,updatedFiles,parentBeforeUpdate,parentAfterUpdate);
    return true;
  }
  if (shouldMerge()) {
    indicator.setText2(HgVcsMessages.message("hg4idea.progress.countingHeads"));
    List<HgRevisionNumber> branchHeadsAfterPull=new HgHeadsCommand(project,repoRoot).execute();
    List<HgRevisionNumber> pulledBranchHeads=determinePulledBranchHeads(branchHeadsBeforePull,branchHeadsAfterPull);
    List<HgRevisionNumber> remainingOriginalBranchHeads=determingRemainingOriginalBranchHeads(branchHeadsBeforePull,branchHeadsAfterPull);
    if (branchHeadsAfterPull.size() > 1) {
      abortOnLocalChanges();
      abortOnMultiplePulledHeads(pulledBranchHeads);
      abortOnMultipleLocalHeads(remainingOriginalBranchHeads);
      HgCommandResult mergeResult=doMerge(indicator);
      if (shouldCommitAfterMerge()) {
        commitOrWarnAboutConflicts(warnings,mergeResult);
      }
    }
    resolvePossibleConflicts(updatedFiles);
  }
 else {
    processRebase(updatedFiles);
  }
  return true;
}
