{
  if ((access & Opcodes.ACC_BRIDGE) != 0) {
    return super.visitMethod(access,name,desc,signature,exceptions);
  }
  final Type[] args=Type.getArgumentTypes(desc);
  final Type returnType=Type.getReturnType(desc);
  final MethodVisitor v=cv.visitMethod(access,name,desc,signature,exceptions);
  final Map<Integer,String> paramNames=myMethodParamNames.get(myClassName + '.' + name+ desc);
  return new FailSafeMethodVisitor(Opcodes.ASM5,v){
    private final Map<Integer,NotNullState> myNotNullParams=new LinkedHashMap<Integer,NotNullState>();
    private int mySyntheticCount=0;
    private NotNullState myMethodNotNull;
    private Label myStartGeneratedCodeLabel;
    private AnnotationVisitor collectNotNullArgs(    AnnotationVisitor base,    final NotNullState state){
      return new AnnotationVisitor(Opcodes.ASM5,base){
        @Override public void visit(        String methodName,        Object o){
          if (ANNOTATION_DEFAULT_METHOD.equals(methodName) && !((String)o).isEmpty()) {
            state.message=(String)o;
          }
 else           if ("exception".equals(methodName) && o instanceof Type && !((Type)o).getClassName().equals(Exception.class.getName())) {
            state.exceptionType=((Type)o).getInternalName();
          }
          super.visit(methodName,o);
        }
      }
;
    }
    public AnnotationVisitor visitParameterAnnotation(    final int parameter,    final String anno,    final boolean visible){
      AnnotationVisitor av=mv.visitParameterAnnotation(parameter,anno,visible);
      if (isReferenceType(args[parameter]) && anno.equals(NOT_NULL_TYPE)) {
        NotNullState state=new NotNullState(IAE_CLASS_NAME);
        myNotNullParams.put(new Integer(parameter),state);
        av=collectNotNullArgs(av,state);
      }
 else       if (anno.equals(SYNTHETIC_TYPE)) {
        mySyntheticCount++;
      }
      return av;
    }
    @Override public AnnotationVisitor visitAnnotation(    String anno,    boolean isRuntime){
      AnnotationVisitor av=mv.visitAnnotation(anno,isRuntime);
      if (isReferenceType(returnType) && anno.equals(NOT_NULL_TYPE)) {
        myMethodNotNull=new NotNullState(ISE_CLASS_NAME);
        av=collectNotNullArgs(av,myMethodNotNull);
      }
      return av;
    }
    @Override public void visitCode(){
      if (myNotNullParams.size() > 0) {
        myStartGeneratedCodeLabel=new Label();
        mv.visitLabel(myStartGeneratedCodeLabel);
      }
      for (      Map.Entry<Integer,NotNullState> entry : myNotNullParams.entrySet()) {
        Integer param=entry.getKey();
        int var=((access & ACC_STATIC) == 0) ? 1 : 0;
        for (int i=0; i < param; ++i) {
          var+=args[i].getSize();
        }
        mv.visitVarInsn(ALOAD,var);
        Label end=new Label();
        mv.visitJumpInsn(IFNONNULL,end);
        NotNullState state=entry.getValue();
        String paramName=paramNames == null ? null : paramNames.get(param);
        String descrPattern=state.message != null ? state.message : paramName != null ? NULL_ARG_MESSAGE_NAMED : NULL_ARG_MESSAGE_INDEXED;
        String[] args=state.message != null ? EMPTY_STRING_ARRAY : new String[]{paramName != null ? paramName : String.valueOf(param - mySyntheticCount),myClassName,name};
        generateThrow(state.exceptionType,end,descrPattern,args);
      }
    }
    @Override public void visitLocalVariable(    String name,    String desc,    String signature,    Label start,    Label end,    int index){
      final boolean isStatic=(access & ACC_STATIC) != 0;
      final boolean isParameterOrThisRef=isStatic ? index < args.length : index <= args.length;
      final Label label=(isParameterOrThisRef && myStartGeneratedCodeLabel != null) ? myStartGeneratedCodeLabel : start;
      mv.visitLocalVariable(name,desc,signature,label,end,index);
    }
    @Override public void visitInsn(    int opcode){
      if (opcode == ARETURN) {
        if (myMethodNotNull != null) {
          mv.visitInsn(DUP);
          final Label skipLabel=new Label();
          mv.visitJumpInsn(IFNONNULL,skipLabel);
          String descrPattern=myMethodNotNull.message != null ? myMethodNotNull.message : NULL_RESULT_MESSAGE;
          String[] args=myMethodNotNull.message != null ? EMPTY_STRING_ARRAY : new String[]{myClassName,name};
          generateThrow(myMethodNotNull.exceptionType,skipLabel,descrPattern,args);
        }
      }
      mv.visitInsn(opcode);
    }
    private void generateThrow(    final String exceptionClass,    final Label end,    final String descrPattern,    final String[] args){
      mv.visitTypeInsn(NEW,exceptionClass);
      mv.visitInsn(DUP);
      mv.visitLdcInsn(descrPattern);
      mv.visitLdcInsn(args.length);
      mv.visitTypeInsn(ANEWARRAY,OBJECT_CLASS_NAME);
      for (int i=0; i < args.length; i++) {
        mv.visitInsn(DUP);
        mv.visitLdcInsn(i);
        mv.visitLdcInsn(args[i]);
        mv.visitInsn(AASTORE);
      }
      mv.visitMethodInsn(INVOKESTATIC,STRING_CLASS_NAME,"format","(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",false);
      mv.visitMethodInsn(INVOKESPECIAL,exceptionClass,CONSTRUCTOR_NAME,EXCEPTION_INIT_SIGNATURE,false);
      mv.visitInsn(ATHROW);
      mv.visitLabel(end);
      myIsModification=true;
      processPostponedErrors();
    }
    @Override public void visitMaxs(    final int maxStack,    final int maxLocals){
      try {
        super.visitMaxs(maxStack,maxLocals);
      }
 catch (      Throwable e) {
        registerError(name,"visitMaxs",e);
      }
    }
  }
;
}
