{
  BaseOSProcessHandler.awaitQuiescence(100,TimeUnit.SECONDS);
  NettyUtil.awaitQuiescenceOfGlobalEventExecutor(100,TimeUnit.SECONDS);
  try {
    if (myDefaultProjectInitialized != ((ProjectManagerImpl)ProjectManager.getInstance()).isDefaultProjectInitialized())     return;
    Collection<Thread> after=new THashSet<Thread>(getThreads());
    after.removeAll(before);
    for (    final Thread thread : after) {
      if (thread == Thread.currentThread())       continue;
      ThreadGroup group=thread.getThreadGroup();
      if (group != null && "system".equals(group.getName()))       continue;
      final String name=thread.getName();
      if (ContainerUtil.exists(wellKnownOffenders,new Condition<String>(){
        @Override public boolean value(        String pattern){
          return name.contains(pattern);
        }
      }
)) {
        continue;
      }
      if (!thread.isAlive())       continue;
      if (thread.getStackTrace().length == 0) {
        thread.interrupt();
        if (new WaitFor(10000){
          @Override protected boolean condition(){
            return !thread.isAlive();
          }
        }
.isConditionRealized()) {
          continue;
        }
      }
      String trace="Thread leaked: " + thread + "; "+ thread.getState()+ " ("+ thread.isAlive()+ ")\n--- its stacktrace:\n";
      for (      final StackTraceElement stackTraceElement : thread.getStackTrace()) {
        trace+=" at " + stackTraceElement + "\n";
      }
      trace+="---\n";
      Assert.fail(trace);
    }
  }
  finally {
    before.clear();
  }
}
