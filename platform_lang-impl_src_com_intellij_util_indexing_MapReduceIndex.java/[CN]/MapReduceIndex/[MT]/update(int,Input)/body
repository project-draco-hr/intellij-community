{
  final Map<Key,Value> data=content != null ? myIndexer.map(content) : Collections.<Key,Value>emptyMap();
  ProgressManager.checkCanceled();
  final NotNullComputable<Collection<Key>> oldKeysGetter;
  final int savedInputId;
  boolean weProcessPhysicalContent=content == null || (content instanceof FileContent && ((FileContent)content).getUserData(FileBasedIndexImpl.ourPhysicalContentKey) != null);
  if (myHasSnapshotMapping && weProcessPhysicalContent) {
    try {
      final Integer hashId=myInputsSnapshotMapping.get(inputId);
      final Collection<Key> keys=hashId != null ? mySnapshotMapping.get(hashId) : null;
      oldKeysGetter=new NotNullComputable<Collection<Key>>(){
        @NotNull @Override public Collection<Key> compute(){
          try {
            Integer currentHashId=myInputsSnapshotMapping.get(inputId);
            Collection<Key> currentKeys;
            if ((currentHashId == null && hashId == null) || (currentHashId != null && currentHashId.equals(hashId))) {
              currentKeys=keys;
            }
 else {
              currentKeys=currentHashId != null ? mySnapshotMapping.get(currentHashId) : null;
            }
            return currentKeys == null ? Collections.<Key>emptyList() : currentKeys;
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
;
      if (content instanceof FileContent) {
        FileContent fileContent=(FileContent)content;
        int previouslyCalculatedContentHashId=fileContent instanceof FileContentImpl ? ((FileContentImpl)fileContent).getHashId() : -1;
        if (previouslyCalculatedContentHashId == -1) {
          previouslyCalculatedContentHashId=ContentHashesSupport.calcContentHashIdWithFileType(fileContent.getContent(),fileContent.getFileType());
          fileContent.putUserData(ourSavedContentHashIdKey,previouslyCalculatedContentHashId);
        }
        savedInputId=previouslyCalculatedContentHashId;
        if (!mySnapshotMapping.containsMapping(savedInputId)) {
          mySnapshotMapping.put(savedInputId,data.keySet());
        }
      }
 else {
        savedInputId=NULL_MAPPING;
      }
    }
 catch (    IOException ex) {
      throw new RuntimeException(ex);
    }
  }
 else {
    oldKeysGetter=new NotNullComputable<Collection<Key>>(){
      @NotNull @Override public Collection<Key> compute(){
        try {
          Collection<Key> oldKeys=myInputsIndex.get(inputId);
          return oldKeys == null ? Collections.<Key>emptyList() : oldKeys;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    savedInputId=inputId;
  }
  return new Computable<Boolean>(){
    @Override public Boolean compute(){
      final Ref<StorageException> exRef=new Ref<StorageException>(null);
      ProgressManager.getInstance().executeNonCancelableSection(new Runnable(){
        @Override public void run(){
          try {
            updateWithMap(inputId,savedInputId,data,oldKeysGetter);
          }
 catch (          StorageException ex) {
            exRef.set(ex);
          }
        }
      }
);
      if (exRef.get() != null) {
        LOG.info(exRef.get());
        FileBasedIndex.getInstance().requestRebuild(myIndexId);
        return Boolean.FALSE;
      }
      return Boolean.TRUE;
    }
  }
;
}
