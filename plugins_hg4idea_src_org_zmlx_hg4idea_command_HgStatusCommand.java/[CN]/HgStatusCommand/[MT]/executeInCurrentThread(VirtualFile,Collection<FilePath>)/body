{
  if (repo == null) {
    return Collections.emptySet();
  }
  HgCommandExecutor executor=new HgCommandExecutor(myProject);
  executor.setSilent(true);
  List<String> options=new LinkedList<>();
  if (myIncludeAdded) {
    options.add("--added");
  }
  if (myIncludeModified) {
    options.add("--modified");
  }
  if (myIncludeRemoved) {
    options.add("--removed");
  }
  if (myIncludeDeleted) {
    options.add("--deleted");
  }
  if (myIncludeUnknown) {
    options.add("--unknown");
  }
  if (myIncludeIgnored) {
    options.add("--ignored");
  }
  if (myIncludeCopySource) {
    options.add("--copies");
  }
  if (myCleanStatus) {
    options.add("--clean");
  }
  if (myBaseRevision != null && (!myBaseRevision.getRevision().isEmpty() || !myBaseRevision.getChangeset().isEmpty())) {
    options.add("--rev");
    options.add(StringUtil.isEmptyOrSpaces(myBaseRevision.getChangeset()) ? myBaseRevision.getRevision() : myBaseRevision.getChangeset());
    if (myTargetRevision != null) {
      options.add("--rev");
      options.add(myTargetRevision.getChangeset());
    }
  }
  final Set<HgChange> changes=new HashSet<>();
  if (paths != null) {
    final List<List<String>> chunked=VcsFileUtil.chunkPaths(repo,paths);
    for (    List<String> chunk : chunked) {
      List<String> args=new ArrayList<>();
      args.addAll(options);
      args.addAll(chunk);
      HgCommandResult result=executor.executeInCurrentThread(repo,"status",args);
      changes.addAll(parseChangesFromResult(repo,result,args));
    }
  }
 else {
    HgCommandResult result=executor.executeInCurrentThread(repo,"status",options);
    changes.addAll(parseChangesFromResult(repo,result,options));
  }
  return changes;
}
