{
  if (name.charAt(0) == '<') {
    return null;
  }
  final boolean isStaticMethod=AsmUtil.isStaticMethodDeclaration(access);
  if (isStaticMethod) {
    return null;
  }
  @SuppressWarnings("UnnecessaryLocalVariable") final String methodName=name;
  final String[] methodParams=AsmUtil.getParamsTypes(desc);
  final MethodIncompleteSignature currentMethodSignature=new MethodIncompleteSignature(myClassName,AsmUtil.getReturnType(desc),methodName,isStaticMethod);
  return new JSRInlinerAdapter(new AnalyzerAdapter(Opcodes.ASM4,myRawClassName,access,name,desc,null){
    private final Map<Integer,Variable> myFieldsAndParamsPositionInStack=new HashMap<Integer,Variable>();
    @Override public void visitInsn(    final int opcode){
      super.visitInsn(opcode);
    }
    @Override public void visitFieldInsn(    final int opcode,    final String owner,    final String name,    final String desc){
      boolean onThis=false;
      if (stack != null && opcode == Opcodes.GETFIELD && !ChainCompletionStringUtil.isPrimitiveOrArray(AsmUtil.getReturnType(desc))) {
        final Object objectRef=stack.get(stack.size() - 1);
        if (objectRef instanceof String && objectRef.equals(myRawClassName)) {
          onThis=true;
        }
      }
      super.visitFieldInsn(opcode,owner,name,desc);
      if (onThis) {
        final int index=stack.size() - 1;
        final Object marker=stack.get(index);
        myFieldsAndParamsPositionInStack.put(index,new Variable(marker,VariableType.FIELD));
      }
    }
    @Override public void visitVarInsn(    final int opcode,    final int varIndex){
      super.visitVarInsn(opcode,varIndex);
      if (stack != null && opcode == Opcodes.ALOAD && varIndex > 0 && varIndex <= methodParams.length && !ChainCompletionStringUtil.isPrimitiveOrArray(methodParams[varIndex - 1])) {
        final int stackPos=stack.size() - 1;
        myFieldsAndParamsPositionInStack.put(stackPos,new Variable(stack.get(stackPos),VariableType.METHOD_PARAMETER));
      }
    }
    @Override public void visitMethodInsn(    final int opcode,    final String owner,    final String name,    final String desc){
      if (stack != null && opcode != Opcodes.INVOKESTATIC && !methodName.startsWith("<")) {
        final int index=stack.size() - 1 - AsmUtil.getParamsTypes(desc).length;
        final Object stackValue=stack.get(index);
        final Variable variable=myFieldsAndParamsPositionInStack.get(index);
        if (variable != null && variable.getMarker() == stackValue) {
          final CallingLocation callingLocation=new CallingLocation(currentMethodSignature,variable.getVariableType());
          final MethodNameAndQualifier invokedMethod=new MethodNameAndQualifier(name,AsmUtil.getQualifiedClassName(owner));
          List<CallingLocation> callingLocations=myExtractedMethodsCallings.get(invokedMethod);
          if (callingLocations == null) {
            callingLocations=new ArrayList<CallingLocation>();
            myExtractedMethodsCallings.put(invokedMethod,callingLocations);
          }
          callingLocations.add(callingLocation);
        }
      }
      super.visitMethodInsn(opcode,owner,name,desc);
    }
  }
,access,name,desc,signature,exceptions);
}
