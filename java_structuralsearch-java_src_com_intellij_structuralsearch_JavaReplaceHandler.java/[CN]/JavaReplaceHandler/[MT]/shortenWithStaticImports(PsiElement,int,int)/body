{
  final int elementOffset=affectedElement.getTextOffset();
  final int finalStartOffset=startOffset + elementOffset;
  final int finalEndOffset=endOffset + elementOffset;
  final List<PsiJavaCodeReferenceElement> references=new ArrayList<PsiJavaCodeReferenceElement>();
  final JavaRecursiveElementVisitor collector=new JavaRecursiveElementVisitor(){
    @Override public void visitReferenceElement(    PsiJavaCodeReferenceElement reference){
      final int offset=reference.getTextOffset();
      if (offset > finalEndOffset) {
        return;
      }
      super.visitReferenceElement(reference);
      if (offset + reference.getTextLength() < finalStartOffset) {
        return;
      }
      final PsiElement target=reference.resolve();
      if (!(target instanceof PsiMember)) {
        return;
      }
      final PsiMember member=(PsiMember)target;
      if (!member.hasModifierProperty(PsiModifier.STATIC)) {
        return;
      }
      if (reference.getQualifier() == null) {
        return;
      }
      references.add(reference);
    }
  }
;
  affectedElement.accept(collector);
  for (  PsiJavaCodeReferenceElement expression : references) {
    final PsiElement target=expression.resolve();
    if (!(target instanceof PsiMember)) {
      continue;
    }
    final PsiMember member=(PsiMember)target;
    final PsiClass containingClass=member.getContainingClass();
    if (containingClass == null) {
      continue;
    }
    final String className=containingClass.getQualifiedName();
    if (className == null) {
      continue;
    }
    final String name=member.getName();
    if (name == null) {
      continue;
    }
    if (ImportUtils.addStaticImport(className,name,expression)) {
      final PsiElement qualifier=expression.getQualifier();
      if (qualifier != null) {
        qualifier.delete();
      }
    }
  }
}
