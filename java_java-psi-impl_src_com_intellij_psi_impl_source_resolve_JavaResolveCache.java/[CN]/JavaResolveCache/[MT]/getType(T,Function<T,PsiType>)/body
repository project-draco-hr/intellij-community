{
  final boolean isOverloadCheck=MethodCandidateInfo.isOverloadCheck();
  PsiType type=isOverloadCheck ? null : myCalculatedTypes.get(expr);
  if (type == null) {
    final RecursionGuard.StackStamp dStackStamp=PsiDiamondType.ourDiamondGuard.markStack();
    final RecursionGuard.StackStamp gStackStamp=PsiResolveHelper.ourGraphGuard.markStack();
    type=f.fun(expr);
    if (!dStackStamp.mayCacheNow() || !gStackStamp.mayCacheNow() || isOverloadCheck) {
      return type;
    }
    if (type == null)     type=TypeConversionUtil.NULL_TYPE;
    myCalculatedTypes.put(expr,type);
    if (type instanceof PsiClassReferenceType) {
      PsiClassType.ClassResolveResult result=((PsiClassReferenceType)type).resolveGenerics();
      PsiClass psiClass=result.getElement();
      type=psiClass == null ? type : new PsiImmediateClassType(psiClass,result.getSubstitutor(),((PsiClassReferenceType)type).getLanguageLevel(),type.getAnnotations());
    }
  }
  if (!type.isValid()) {
    if (expr.isValid()) {
      PsiJavaCodeReferenceElement refInside=type instanceof PsiClassReferenceType ? ((PsiClassReferenceType)type).getReference() : null;
      @NonNls String typeinfo=type + " (" + type.getClass()+ ")"+ (refInside == null ? "" : "; ref inside: " + refInside + " ("+ refInside.getClass()+ ") valid:"+ refInside.isValid());
      LOG.error("Type is invalid: " + typeinfo + "; expr: '"+ expr+ "' ("+ expr.getClass()+ ") is valid");
    }
 else {
      LOG.error("Expression: '" + expr + "' is invalid, must not be used for getType()");
    }
  }
  return type == TypeConversionUtil.NULL_TYPE ? null : type;
}
