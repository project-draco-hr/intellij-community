{
  int offset=caretOffset.get();
  if (editor instanceof EditorWindow) {
    file=InjectedLanguageManager.getInstance(file.getProject()).getTopLevelFile(file);
    editor=InjectedLanguageUtil.getTopLevelEditor(editor);
    offset=editor.getCaretModel().getOffset();
  }
  if (!(file instanceof PyFile)) {
    return Result.Continue;
  }
  final Boolean isSplitLine=DataManager.getInstance().loadFromDataContext(dataContext,SplitLineAction.SPLIT_LINE_KEY);
  if (isSplitLine != null) {
    return Result.Continue;
  }
  final Document doc=editor.getDocument();
  PsiDocumentManager.getInstance(file.getProject()).commitDocument(doc);
  final PsiElement element=file.findElementAt(offset);
  CodeInsightSettings codeInsightSettings=CodeInsightSettings.getInstance();
  if (codeInsightSettings.JAVADOC_STUB_ON_ENTER) {
    PsiElement comment=element;
    if (comment == null && offset != 0) {
      comment=file.findElementAt(offset - 1);
    }
    int expectedStringStart=editor.getCaretModel().getOffset() - 3;
    if (PythonDocCommentUtil.atDocCommentStart(comment,expectedStringStart)) {
      insertDocStringStub(editor,comment);
      return Result.Continue;
    }
  }
  if (element == null) {
    return Result.Continue;
  }
  PsiElement elementParent=element.getParent();
  if (element.getNode().getElementType() == PyTokenTypes.LPAR)   elementParent=elementParent.getParent();
  if (elementParent instanceof PyParenthesizedExpression || elementParent instanceof PyGeneratorExpression)   return Result.Continue;
  if (offset > 0 && !(PyTokenTypes.STRING_NODES.contains(element.getNode().getElementType()))) {
    final PsiElement prevElement=file.findElementAt(offset - 1);
    if (prevElement == element)     return Result.Continue;
  }
  if (PyTokenTypes.TRIPLE_NODES.contains(element.getNode().getElementType()) || element.getNode().getElementType() == PyTokenTypes.DOCSTRING) {
    return Result.Continue;
  }
  final PsiElement prevElement=file.findElementAt(offset - 1);
  PyStringLiteralExpression string=PsiTreeUtil.findElementOfClassAtOffset(file,offset,PyStringLiteralExpression.class,false);
  if (string != null && PyTokenTypes.STRING_NODES.contains(prevElement.getNode().getElementType()) && string.getTextOffset() < offset && !(element.getNode() instanceof PsiWhiteSpace)) {
    final String stringText=element.getText();
    final int prefixLength=PyStringLiteralExpressionImpl.getPrefixLength(stringText);
    if (string.getTextOffset() + prefixLength >= offset) {
      return Result.Continue;
    }
    final String pref=element.getText().substring(0,prefixLength);
    final String quote=element.getText().substring(prefixLength,prefixLength + 1);
    final boolean nextIsBackslash="\\".equals(doc.getText(TextRange.create(offset - 1,offset)));
    final boolean isEscapedQuote=quote.equals(doc.getText(TextRange.create(offset,offset + 1))) && nextIsBackslash;
    final boolean isEscapedBackslash="\\".equals(doc.getText(TextRange.create(offset - 2,offset - 1))) && nextIsBackslash;
    if (nextIsBackslash && !isEscapedQuote && !isEscapedBackslash)     return Result.Continue;
    final StringBuilder replacementString=new StringBuilder();
    needPostProcess=true;
    if (PsiTreeUtil.getParentOfType(string,IMPLICIT_WRAP_CLASSES) != null) {
      replacementString.append(quote).append(pref).append(quote);
      doc.insertString(offset,replacementString);
      caretOffset.set(caretOffset.get() + 1);
      return Result.Continue;
    }
 else {
      if (isEscapedQuote) {
        replacementString.append(quote);
        caretOffset.set(caretOffset.get() + 1);
      }
      replacementString.append(quote).append(" \\").append(pref);
      if (!isEscapedQuote)       replacementString.append(quote);
      doc.insertString(offset,replacementString.toString());
      caretOffset.set(caretOffset.get() + 3);
      return Result.Continue;
    }
  }
  if (!PyCodeInsightSettings.getInstance().INSERT_BACKSLASH_ON_WRAP) {
    return Result.Continue;
  }
  return checkInsertBackslash(file,caretOffset,dataContext,offset,doc);
}
