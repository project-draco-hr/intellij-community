{
  if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {
    return true;
  }
  if (myExpression instanceof PsiParenthesizedExpression) {
    constraints.add(new CheckedExceptionCompatibilityConstraint(((PsiParenthesizedExpression)myExpression).getExpression(),myT));
    return true;
  }
  if (myExpression instanceof PsiConditionalExpression) {
    final PsiExpression thenExpression=((PsiConditionalExpression)myExpression).getThenExpression();
    if (thenExpression != null) {
      constraints.add(new CheckedExceptionCompatibilityConstraint(thenExpression,myT));
    }
    final PsiExpression elseExpression=((PsiConditionalExpression)myExpression).getElseExpression();
    if (elseExpression != null) {
      constraints.add(new CheckedExceptionCompatibilityConstraint(elseExpression,myT));
    }
    return true;
  }
  if (myExpression instanceof PsiLambdaExpression || myExpression instanceof PsiMethodReferenceExpression) {
    if (!LambdaUtil.isFunctionalType(myT)) {
      return false;
    }
    final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(myT);
    if (interfaceMethod == null) {
      return false;
    }
    final PsiSubstitutor substitutor=LambdaUtil.getSubstitutor(interfaceMethod,PsiUtil.resolveGenericsClassInType(myT));
    if (myExpression instanceof PsiLambdaExpression && !((PsiLambdaExpression)myExpression).hasFormalParameterTypes() || myExpression instanceof PsiMethodReferenceExpression && !((PsiMethodReferenceExpression)myExpression).isExact()) {
      for (      PsiParameter parameter : interfaceMethod.getParameterList().getParameters()) {
        if (!session.isProperType(substitutor.substitute(parameter.getType())))         return false;
      }
    }
    final PsiType returnType=interfaceMethod.getReturnType();
    if (myExpression instanceof PsiLambdaExpression || !((PsiMethodReferenceExpression)myExpression).isExact()) {
      if (!session.isProperType(substitutor.substitute(returnType)))       return false;
    }
    final List<PsiType> expectedThrownTypes=ContainerUtil.map(interfaceMethod.getThrowsList().getReferencedTypes(),new Function<PsiType,PsiType>(){
      @Override public PsiType fun(      PsiType type){
        return substitutor.substitute(type);
      }
    }
);
    final List<PsiType> expectedNonProperThrownTypes=new ArrayList<PsiType>();
    for (    PsiType type : expectedThrownTypes) {
      if (!session.isProperType(type)) {
        expectedNonProperThrownTypes.add(type);
      }
    }
    final List<PsiType> thrownTypes=new ArrayList<PsiType>();
    if (myExpression instanceof PsiLambdaExpression) {
      PsiElement body=((PsiLambdaExpression)myExpression).getBody();
      if (body != null) {
        thrownTypes.addAll(ExceptionUtil.getUnhandledExceptions(body));
      }
    }
 else {
      final PsiMethodReferenceUtil.QualifierResolveResult qualifierResolveResult=PsiMethodReferenceUtil.getQualifierResolveResult((PsiMethodReferenceExpression)myExpression);
      final PsiSubstitutor psiSubstitutor=qualifierResolveResult.getSubstitutor();
      final PsiMethod method;
      if (((PsiMethodReferenceExpression)myExpression).isExact()) {
        final PsiElement resolve=((PsiMethodReferenceExpression)myExpression).getPotentiallyApplicableMember();
        if (resolve instanceof PsiMethod) {
          method=(PsiMethod)resolve;
        }
 else {
          method=null;
        }
      }
 else {
        method=interfaceMethod;
      }
      if (method != null) {
        for (        PsiType type : method.getThrowsList().getReferencedTypes()) {
          type=psiSubstitutor.substitute(type);
          if (type instanceof PsiClassType && !ExceptionUtil.isUncheckedException((PsiClassType)type)) {
            thrownTypes.add(type);
          }
        }
      }
    }
    if (expectedNonProperThrownTypes.isEmpty()) {
      for (      PsiType thrownType : thrownTypes) {
        if (!isAddressed(expectedThrownTypes,thrownType))         return false;
      }
    }
 else {
      final ArrayList<PsiType> expectedProperTypes=new ArrayList<PsiType>(expectedThrownTypes);
      expectedProperTypes.retainAll(expectedNonProperThrownTypes);
      for (      PsiType thrownType : thrownTypes) {
        if (!isAddressed(expectedProperTypes,thrownType)) {
          for (          PsiType expectedNonProperThrownType : expectedNonProperThrownTypes) {
            constraints.add(new StrictSubtypingConstraint(expectedNonProperThrownType,thrownType));
          }
        }
      }
      for (      PsiType expectedNonProperThrownType : expectedNonProperThrownTypes) {
        final InferenceVariable variable=session.getInferenceVariable(expectedNonProperThrownType);
        LOG.assertTrue(variable != null);
        variable.setThrownBound();
      }
    }
  }
  return true;
}
