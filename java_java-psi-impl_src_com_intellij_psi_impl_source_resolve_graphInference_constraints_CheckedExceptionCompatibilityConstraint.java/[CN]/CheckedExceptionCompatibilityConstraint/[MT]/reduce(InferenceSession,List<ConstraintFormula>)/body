{
  if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {
    return true;
  }
  if (myExpression instanceof PsiParenthesizedExpression) {
    constraints.add(new CheckedExceptionCompatibilityConstraint(((PsiParenthesizedExpression)myExpression).getExpression(),myT));
    return true;
  }
  if (myExpression instanceof PsiConditionalExpression) {
    final PsiExpression thenExpression=((PsiConditionalExpression)myExpression).getThenExpression();
    if (thenExpression != null) {
      constraints.add(new CheckedExceptionCompatibilityConstraint(thenExpression,myT));
    }
    final PsiExpression elseExpression=((PsiConditionalExpression)myExpression).getElseExpression();
    if (elseExpression != null) {
      constraints.add(new CheckedExceptionCompatibilityConstraint(elseExpression,myT));
    }
    return true;
  }
  if (myExpression instanceof PsiLambdaExpression || myExpression instanceof PsiMethodReferenceExpression) {
    if (!LambdaUtil.isFunctionalType(myT)) {
      return false;
    }
    final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(myT);
    if (interfaceMethod == null) {
      return false;
    }
    final PsiSubstitutor substitutor=LambdaUtil.getSubstitutor(interfaceMethod,PsiUtil.resolveGenericsClassInType(myT));
    if (myExpression instanceof PsiLambdaExpression && !((PsiLambdaExpression)myExpression).hasFormalParameterTypes() || myExpression instanceof PsiMethodReferenceExpression && !((PsiMethodReferenceExpression)myExpression).isExact()) {
      for (      PsiParameter parameter : interfaceMethod.getParameterList().getParameters()) {
        if (!session.isProperType(substitutor.substitute(parameter.getType())))         return false;
      }
    }
    final PsiType returnType=interfaceMethod.getReturnType();
    if (myExpression instanceof PsiLambdaExpression || !((PsiMethodReferenceExpression)myExpression).isExact()) {
      if (!session.isProperType(substitutor.substitute(returnType)))       return false;
    }
    final List<PsiType> expectedThrownTypes=ContainerUtil.map(interfaceMethod.getThrowsList().getReferencedTypes(),new Function<PsiType,PsiType>(){
      @Override public PsiType fun(      PsiType type){
        return substitutor.substitute(type);
      }
    }
);
    final List<PsiType> expectedNonProperThrownTypes=new ArrayList<PsiType>();
    for (    PsiType type : expectedThrownTypes) {
      if (!session.isProperType(type)) {
        expectedNonProperThrownTypes.add(type);
      }
    }
    final List<PsiType> thrownTypes=new ArrayList<PsiType>();
    final PsiElement body=myExpression instanceof PsiLambdaExpression ? ((PsiLambdaExpression)myExpression).getBody() : myExpression;
    if (body != null) {
      final List<PsiClassType> exceptions=ExceptionUtil.ourThrowsGuard.doPreventingRecursion(myExpression,false,new Computable<List<PsiClassType>>(){
        @Override public List<PsiClassType> compute(){
          return ExceptionUtil.getUnhandledExceptions(new PsiElement[]{body});
        }
      }
);
      if (exceptions != null) {
        thrownTypes.addAll(ContainerUtil.filter(exceptions,new Condition<PsiClassType>(){
          @Override public boolean value(          PsiClassType type){
            return !ExceptionUtil.isUncheckedException(type);
          }
        }
));
      }
    }
    if (expectedNonProperThrownTypes.isEmpty()) {
      for (      PsiType thrownType : thrownTypes) {
        if (!isAddressed(expectedThrownTypes,thrownType))         return false;
      }
    }
 else {
      final ArrayList<PsiType> expectedProperTypes=new ArrayList<PsiType>(expectedThrownTypes);
      expectedProperTypes.removeAll(expectedNonProperThrownTypes);
      for (      PsiType thrownType : thrownTypes) {
        if (!isAddressed(expectedProperTypes,thrownType)) {
          for (          PsiType expectedNonProperThrownType : expectedNonProperThrownTypes) {
            constraints.add(new StrictSubtypingConstraint(expectedNonProperThrownType,thrownType));
          }
        }
      }
      for (      PsiType expectedNonProperThrownType : expectedNonProperThrownTypes) {
        final InferenceVariable variable=session.getInferenceVariable(expectedNonProperThrownType);
        LOG.assertTrue(variable != null);
        variable.setThrownBound();
      }
    }
  }
  return true;
}
