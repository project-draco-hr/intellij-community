{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  checkExistingMethods(conflicts,true);
  checkExistingMethods(conflicts,false);
  final Collection<PsiClass> classes=ClassInheritorsSearch.search(myClass).findAll();
  for (  FieldDescriptor fieldDescriptor : myFieldDescriptors) {
    final Set<PsiMethod> setters=new HashSet<PsiMethod>();
    final Set<PsiMethod> getters=new HashSet<PsiMethod>();
    for (    PsiClass aClass : classes) {
      final PsiMethod getterOverrider=myDescriptor.isToEncapsulateGet() ? aClass.findMethodBySignature(fieldDescriptor.getGetterPrototype(),false) : null;
      if (getterOverrider != null) {
        getters.add(getterOverrider);
      }
      final PsiMethod setterOverrider=myDescriptor.isToEncapsulateSet() ? aClass.findMethodBySignature(fieldDescriptor.getSetterPrototype(),false) : null;
      if (setterOverrider != null) {
        setters.add(setterOverrider);
      }
    }
    if (!getters.isEmpty() || !setters.isEmpty()) {
      final PsiField field=fieldDescriptor.getField();
      for (      PsiReference reference : ReferencesSearch.search(field)) {
        final PsiElement place=reference.getElement();
        if (place instanceof PsiReferenceExpression) {
          final PsiExpression qualifierExpression=((PsiReferenceExpression)place).getQualifierExpression();
          final PsiClass ancestor;
          if (qualifierExpression == null) {
            ancestor=PsiTreeUtil.getParentOfType(place,PsiClass.class,false);
          }
 else {
            ancestor=PsiUtil.resolveClassInType(qualifierExpression.getType());
          }
          final boolean isGetter=!PsiUtil.isAccessedForWriting((PsiExpression)place);
          for (          PsiMethod overridden : isGetter ? getters : setters) {
            if (InheritanceUtil.isInheritorOrSelf(myClass,ancestor,true)) {
              conflicts.putValue(overridden,"There is already a " + RefactoringUIUtil.getDescription(overridden,true) + " which would hide generated "+ (isGetter ? "getter" : "setter")+ " for "+ place.getText());
              break;
            }
          }
        }
      }
    }
  }
  UsageInfo[] infos=refUsages.get();
  for (  UsageInfo info : infos) {
    PsiElement element=info.getElement();
    if (element != null) {
      PsiElement parent=element.getParent();
      if (RefactoringUtil.isPlusPlusOrMinusMinus(parent) && !(parent.getParent() instanceof PsiExpressionStatement)) {
        conflicts.putValue(parent,"Unable to proceed with postfix/prefix expression when it's result type is used");
      }
    }
  }
  return showConflicts(conflicts,infos);
}
