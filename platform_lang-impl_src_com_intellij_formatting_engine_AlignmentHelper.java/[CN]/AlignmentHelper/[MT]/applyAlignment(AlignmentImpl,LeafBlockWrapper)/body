{
  BlockAlignmentProcessor alignmentProcessor=ALIGNMENT_PROCESSORS.get(alignment.getAnchor());
  if (alignmentProcessor == null) {
    LOG.error(String.format("Can't find alignment processor for alignment anchor %s",alignment.getAnchor()));
    return null;
  }
  BlockAlignmentProcessor.Context context=new BlockAlignmentProcessor.Context(myDocument,alignment,currentBlock,myAlignmentMappings,myBackwardShiftedAlignedBlocks,myBlockIndentOptions.getIndentOptions(currentBlock));
  final LeafBlockWrapper offsetResponsibleBlock=alignment.getOffsetRespBlockBefore(currentBlock);
  myCyclesDetector.registerOffsetResponsibleBlock(offsetResponsibleBlock);
  BlockAlignmentProcessor.Result result=alignmentProcessor.applyAlignment(context);
switch (result) {
case TARGET_BLOCK_PROCESSED_NOT_ALIGNED:
    return null;
case TARGET_BLOCK_ALIGNED:
  storeAlignmentMapping(currentBlock);
return null;
case BACKWARD_BLOCK_ALIGNED:
if (offsetResponsibleBlock == null) {
return null;
}
Set<LeafBlockWrapper> blocksCausedRealignment=new HashSet<LeafBlockWrapper>();
myBackwardShiftedAlignedBlocks.clear();
myBackwardShiftedAlignedBlocks.put(offsetResponsibleBlock,blocksCausedRealignment);
blocksCausedRealignment.add(currentBlock);
storeAlignmentMapping(currentBlock,offsetResponsibleBlock);
if (myCyclesDetector.isCycleDetected()) {
reportAlignmentProcessingError(context);
return null;
}
myCyclesDetector.registerBlockRollback(currentBlock);
return offsetResponsibleBlock.getNextBlock();
case RECURSION_DETECTED:
myAlignmentsToSkip.add(alignment);
return offsetResponsibleBlock;
case UNABLE_TO_ALIGN_BACKWARD_BLOCK:
myAlignmentsToSkip.add(alignment);
return null;
default :
return null;
}
}
