{
  myBuilder.startNode(node);
  final PyForPart forPart=node.getForPart();
  final PyExpression source=forPart.getSource();
  if (source != null) {
    source.accept(this);
  }
  final Instruction head=myBuilder.prevInstruction;
  final PyElsePart elsePart=node.getElsePart();
  if (elsePart == null) {
    myBuilder.addPendingEdge(node,myBuilder.prevInstruction);
  }
  final PyStatementList list=forPart.getStatementList();
  if (list != null) {
    Instruction bodyInstruction=myBuilder.startNode(list);
    final PyExpression target=forPart.getTarget();
    if (target != null) {
      target.accept(this);
    }
    list.accept(this);
    if (myBuilder.prevInstruction != null) {
      myBuilder.addEdge(myBuilder.prevInstruction,bodyInstruction);
      myBuilder.addPendingEdge(node,myBuilder.prevInstruction);
    }
    final Ref<Instruction> bodyInstRef=new Ref<Instruction>(bodyInstruction);
    myBuilder.processPending(new ControlFlowBuilder.PendingProcessor(){
      public void process(      final PsiElement pendingScope,      final Instruction instruction){
        if (pendingScope != null && PsiTreeUtil.isAncestor(list,pendingScope,false)) {
          myBuilder.addEdge(instruction,bodyInstRef.get());
          myBuilder.addPendingEdge(node,instruction);
        }
 else {
          myBuilder.addPendingEdge(pendingScope,instruction);
        }
      }
    }
);
  }
  myBuilder.prevInstruction=head;
  if (elsePart != null) {
    elsePart.accept(this);
    myBuilder.addPendingEdge(node,myBuilder.prevInstruction);
  }
  myBuilder.flowAbrupted();
}
