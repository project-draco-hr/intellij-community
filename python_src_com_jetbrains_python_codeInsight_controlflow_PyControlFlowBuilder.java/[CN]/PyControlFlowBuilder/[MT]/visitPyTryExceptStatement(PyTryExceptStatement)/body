{
  myBuilder.startNode(node);
  final PyTryPart tryPart=node.getTryPart();
  myBuilder.startNode(tryPart);
  tryPart.accept(this);
  final PyElsePart elsePart=node.getElsePart();
  if (elsePart != null) {
    myBuilder.startNode(elsePart);
    elsePart.accept(this);
  }
  myBuilder.addPendingEdge(node,myBuilder.prevInstruction);
  final ArrayList<Instruction> exceptInstructions=new ArrayList<Instruction>();
  final List<Pair<PsiElement,Instruction>> pending=myBuilder.pending;
  myBuilder.pending=new ArrayList<Pair<PsiElement,Instruction>>();
  for (  PyExceptPart exceptPart : node.getExceptParts()) {
    final Instruction exceptInstrcution=addBlockConnectedViaPending(exceptPart,node);
    exceptInstructions.add(exceptInstrcution);
  }
  for (  Pair<PsiElement,Instruction> pair : pending) {
    myBuilder.addPendingEdge(pair.first,pair.second);
  }
  final PyFinallyPart finallyPart=node.getFinallyPart();
  Instruction finallyInstruction=null;
  Instruction lastFinallyInstruction=null;
  if (finallyPart != null) {
    finallyInstruction=addBlockConnectedViaPending(finallyPart,node);
    lastFinallyInstruction=myBuilder.prevInstruction;
  }
  for (  Instruction instruction : myBuilder.instructions) {
    final PsiElement e=instruction.getElement();
    if (e == null || !canRaiseExceptions(instruction)) {
      continue;
    }
    if (PsiTreeUtil.isAncestor(tryPart,e,true)) {
      for (      Instruction inst : exceptInstructions) {
        myBuilder.addEdge(instruction,inst);
      }
      if (finallyPart != null) {
        myBuilder.addEdge(instruction,finallyInstruction);
      }
    }
    if (finallyPart != null) {
      for (      PyExceptPart exceptPart : node.getExceptParts()) {
        if (PsiTreeUtil.isAncestor(exceptPart,e,true)) {
          myBuilder.addEdge(instruction,finallyInstruction);
        }
      }
      if (PsiTreeUtil.isAncestor(elsePart,e,true)) {
        myBuilder.addEdge(instruction,finallyInstruction);
      }
    }
  }
  final Ref<Instruction> finallyRef=new Ref<Instruction>(finallyInstruction);
  final Ref<Instruction> lastFinallyRef=new Ref<Instruction>(lastFinallyInstruction);
  myBuilder.processPending(new ControlFlowBuilder.PendingProcessor(){
    public void process(    final PsiElement pendingScope,    final Instruction instruction){
      final PsiElement pendingElement=instruction.getElement();
      if (pendingElement == null) {
        return;
      }
      final boolean isPending=PsiTreeUtil.isAncestor(node,pendingElement,false) && (finallyPart == null || !PsiTreeUtil.isAncestor(finallyPart,pendingElement,false));
      if (!finallyRef.isNull() && isPending) {
        myBuilder.addEdge(instruction,finallyRef.get());
        myBuilder.addPendingEdge(null,lastFinallyRef.get());
        return;
      }
      myBuilder.addPendingEdge(pendingScope,instruction);
    }
  }
);
}
