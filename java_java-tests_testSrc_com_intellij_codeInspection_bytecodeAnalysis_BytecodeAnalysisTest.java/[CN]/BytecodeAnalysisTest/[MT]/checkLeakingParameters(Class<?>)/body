{
  final HashMap<Method,boolean[]> map=new HashMap<Method,boolean[]>();
  final ClassReader classReader=new ClassReader(jClass.getResourceAsStream("/" + jClass.getName().replace('.','/') + ".class"));
  classReader.accept(new ClassVisitor(Opcodes.ASM5){
    @Override public MethodVisitor visitMethod(    int access,    String name,    String desc,    String signature,    String[] exceptions){
      final MethodNode node=new MethodNode(Opcodes.ASM5,access,name,desc,signature,exceptions);
      final Method method=new Method(classReader.getClassName(),name,desc);
      return new MethodVisitor(Opcodes.ASM5,node){
        @Override public void visitEnd(){
          super.visitEnd();
          try {
            map.put(method,LeakingParameters.build(classReader.getClassName(),node,false).parameters);
          }
 catch (          AnalyzerException ignore) {
          }
        }
      }
;
    }
  }
,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
  for (  java.lang.reflect.Method jMethod : jClass.getDeclaredMethods()) {
    Method method=new Method(Type.getType(jClass).getInternalName(),jMethod.getName(),Type.getMethodDescriptor(jMethod));
    Annotation[][] annotations=jMethod.getParameterAnnotations();
    for (int i=0; i < annotations.length; i++) {
      boolean isLeaking=false;
      Annotation[] parameterAnnotations=annotations[i];
      for (      Annotation parameterAnnotation : parameterAnnotations) {
        if (parameterAnnotation.annotationType() == ExpectLeaking.class) {
          isLeaking=true;
        }
      }
      assertEquals(method.toString() + " #" + i,isLeaking,map.get(method)[i]);
    }
  }
}
