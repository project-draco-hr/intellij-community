{
  GlobalSearchScope scope=parameters.getSearchScope();
  IdFilter filter=parameters.getIdFilter();
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(scope.getProject());
  String completePattern=parameters.getCompletePattern();
  final Condition<PsiMember> qualifiedMatcher;
  if (completePattern.contains(".")) {
    final MinusculeMatcher matcher=new MinusculeMatcher("*" + StringUtil.replace(completePattern,".",".*"),NameUtil.MatchingCaseSensitivity.NONE);
    qualifiedMatcher=new Condition<PsiMember>(){
      @Override public boolean value(      PsiMember member){
        String qualifiedName=PsiUtil.getMemberQualifiedName(member);
        return qualifiedName != null && matcher.matches(qualifiedName);
      }
    }
;
  }
 else {
    qualifiedMatcher=Condition.TRUE;
  }
  final Set<PsiMethod> collectedMethods=new THashSet<PsiMethod>();
  boolean success=cache.processFieldsWithName(name,new Processor<PsiField>(){
    @Override public boolean process(    PsiField field){
      if (isOpenable(field) && qualifiedMatcher.value(field))       return processor.process(field);
      return true;
    }
  }
,scope,filter) && cache.processClassesWithName(name,new Processor<PsiClass>(){
    @Override public boolean process(    PsiClass aClass){
      if (isOpenable(aClass) && qualifiedMatcher.value(aClass))       return processor.process(aClass);
      return true;
    }
  }
,scope,filter) && cache.processMethodsWithName(name,new Processor<PsiMethod>(){
    @Override public boolean process(    PsiMethod method){
      if (!method.isConstructor() && isOpenable(method) && qualifiedMatcher.value(method)) {
        collectedMethods.add(method);
      }
      return true;
    }
  }
,scope,filter);
  if (success) {
    Iterator<PsiMethod> iterator=collectedMethods.iterator();
    while (iterator.hasNext()) {
      PsiMethod method=iterator.next();
      if (!hasSuperMethod(method,scope) && !processor.process(method))       return;
      ProgressManager.checkCanceled();
      iterator.remove();
    }
  }
}
