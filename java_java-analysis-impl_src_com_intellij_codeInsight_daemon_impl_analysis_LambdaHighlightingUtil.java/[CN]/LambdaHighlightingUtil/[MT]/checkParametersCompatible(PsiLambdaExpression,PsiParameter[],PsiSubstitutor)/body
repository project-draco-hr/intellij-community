{
  final PsiParameter[] lambdaParameters=expression.getParameterList().getParameters();
  String incompatibleTypesMessage="Incompatible parameter types in lambda expression: ";
  if (lambdaParameters.length != methodParameters.length) {
    incompatibleTypesMessage+="wrong number of parameters: expected " + methodParameters.length + " but found "+ lambdaParameters.length;
    return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression.getParameterList()).descriptionAndTooltip(incompatibleTypesMessage).create();
  }
 else {
    boolean hasFormalParameterTypes=expression.hasFormalParameterTypes();
    for (int i=0; i < lambdaParameters.length; i++) {
      PsiParameter lambdaParameter=lambdaParameters[i];
      PsiType lambdaParameterType=lambdaParameter.getType();
      PsiType substitutedParamType=substitutor.substitute(methodParameters[i].getType());
      if (hasFormalParameterTypes && !PsiTypesUtil.compareTypes(lambdaParameterType,substitutedParamType,true) || !TypeConversionUtil.isAssignable(substitutedParamType,lambdaParameterType)) {
        final String expectedType=substitutedParamType != null ? substitutedParamType.getPresentableText() : null;
        final String actualType=lambdaParameterType.getPresentableText();
        return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression.getParameterList()).descriptionAndTooltip(incompatibleTypesMessage + "expected " + expectedType+ " but found "+ actualType).create();
      }
    }
  }
  return null;
}
