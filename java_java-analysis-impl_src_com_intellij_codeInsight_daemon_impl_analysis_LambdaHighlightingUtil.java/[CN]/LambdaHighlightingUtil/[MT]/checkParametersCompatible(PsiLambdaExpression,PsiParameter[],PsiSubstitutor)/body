{
  final PsiParameter[] lambdaParameters=expression.getParameterList().getParameters();
  String incompatibleTypesMessage="Incompatible parameter types in lambda expression: ";
  if (lambdaParameters.length != methodParameters.length) {
    incompatibleTypesMessage+="wrong number of parameters: expected " + methodParameters.length + " but found "+ lambdaParameters.length;
    return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression.getParameterList()).descriptionAndTooltip(incompatibleTypesMessage).create();
  }
  boolean hasFormalParameterTypes=expression.hasFormalParameterTypes();
  for (int i=0; i < lambdaParameters.length; i++) {
    PsiParameter lambdaParameter=lambdaParameters[i];
    PsiType lambdaParameterType=lambdaParameter.getType();
    PsiType substitutedParamType=substitutor.substitute(methodParameters[i].getType());
    if (hasFormalParameterTypes && !PsiTypesUtil.compareTypes(lambdaParameterType,substitutedParamType,true) || !TypeConversionUtil.isAssignable(substitutedParamType,lambdaParameterType)) {
      final String expectedType=substitutedParamType != null ? substitutedParamType.getPresentableText() : null;
      final String actualType=lambdaParameterType.getPresentableText();
      return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression.getParameterList()).descriptionAndTooltip(incompatibleTypesMessage + "expected " + expectedType+ " but found "+ actualType).create();
    }
  }
  return null;
}
