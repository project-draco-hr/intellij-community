{
  if (functionalInterfaceType instanceof PsiIntersectionType) {
    final Set<MethodSignature> signatures=new HashSet<>();
    for (    PsiType type : ((PsiIntersectionType)functionalInterfaceType).getConjuncts()) {
      if (checkInterfaceFunctional(type) == null) {
        final MethodSignature signature=LambdaUtil.getFunction(PsiUtil.resolveClassInType(type));
        LOG.assertTrue(signature != null,type.getCanonicalText());
        signatures.add(signature);
      }
    }
    if (signatures.size() > 1) {
      return "Multiple non-overriding abstract methods found in " + functionalInterfaceType.getPresentableText();
    }
    return null;
  }
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
  final PsiClass aClass=resolveResult.getElement();
  if (aClass != null) {
    if (aClass instanceof PsiTypeParameter)     return null;
    MethodSignature functionalMethod=LambdaUtil.getFunction(aClass);
    if (functionalMethod != null && functionalMethod.getTypeParameters().length > 0)     return "Target method is generic";
    if (checkReturnTypeApplicable(resolveResult,aClass)) {
      return "No instance of type " + functionalInterfaceType.getPresentableText() + " exists so that lambda expression can be type-checked";
    }
    return checkInterfaceFunctional(aClass);
  }
  return functionalInterfaceType.getPresentableText() + " is not a functional interface";
}
