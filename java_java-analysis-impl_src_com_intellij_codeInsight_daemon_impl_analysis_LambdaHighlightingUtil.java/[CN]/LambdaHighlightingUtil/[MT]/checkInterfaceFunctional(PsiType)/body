{
  if (functionalInterfaceType instanceof PsiIntersectionType) {
    int count=0;
    for (    PsiType type : ((PsiIntersectionType)functionalInterfaceType).getConjuncts()) {
      if (checkInterfaceFunctional(type) == null) {
        count++;
      }
    }
    if (count > 1) {
      return "Multiple non-overriding abstract methods found in " + functionalInterfaceType.getPresentableText();
    }
    return null;
  }
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
  final PsiClass aClass=resolveResult.getElement();
  if (aClass != null) {
    if (aClass instanceof PsiTypeParameter)     return null;
    final List<HierarchicalMethodSignature> signatures=LambdaUtil.findFunctionCandidates(aClass);
    if (signatures != null && signatures.size() == 1) {
      final MethodSignature functionalMethod=signatures.get(0);
      if (functionalMethod.getTypeParameters().length > 0)       return "Target method is generic";
    }
    if (checkReturnTypeApplicable(resolveResult,aClass)) {
      return "No instance of type " + functionalInterfaceType.getPresentableText() + " exists so that lambda expression can be type-checked";
    }
    return checkInterfaceFunctional(aClass);
  }
  return functionalInterfaceType.getPresentableText() + " is not a functional interface";
}
