{
  if (isBlockStatementNeeded && mLCURLY.equals(builder.getTokenType())) {
    final PsiBuilder.Marker marker=builder.mark();
    OpenOrClosableBlock.parseOpenBlockDeep(builder,this);
    marker.done(GroovyElementTypes.BLOCK_STATEMENT);
    return true;
  }
  if (isBlockStatementNeeded && mSEMI == builder.getTokenType()) {
    return true;
  }
  if (kIMPORT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    ImportStatement.parse(builder,this);
    marker.error(GroovyBundle.message("import.not.allowed"));
    return true;
  }
  if (kIF.equals(builder.getTokenType())) {
    return parseIfStatement(builder);
  }
  if (kSWITCH.equals(builder.getTokenType())) {
    SwitchStatement.parseSwitch(builder,this);
    return true;
  }
  if (kTRY.equals(builder.getTokenType())) {
    return TryCatchStatement.parse(builder,this);
  }
  if (kWHILE.equals(builder.getTokenType())) {
    return parseWhileStatement(builder);
  }
  if (kFOR.equals(builder.getTokenType())) {
    return parseForStatement(builder);
  }
  if (ParserUtils.lookAhead(builder,kSYNCHRONIZED,mLPAREN)) {
    PsiBuilder.Marker synMarker=builder.mark();
    if (SynchronizedStatement.parse(builder,this)) {
      synMarker.drop();
      return true;
    }
 else {
      synMarker.rollbackTo();
    }
  }
  if (kELSE.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("else.without.if"));
    parseStatement(builder,true);
    return true;
  }
  if (kCATCH.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("catch.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (kFINALLY.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("finally.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (kCASE.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder,this);
    marker.error(GroovyBundle.message("case.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (kDEFAULT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder,this);
    marker.error(GroovyBundle.message("default.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (BranchStatement.BRANCH_KEYWORDS.contains(builder.getTokenType())) {
    return BranchStatement.parse(builder,this);
  }
  if (parseLabeledStatement(builder)) {
    return true;
  }
  if (parseDeclaration(builder,false,false,null))   return true;
  return AssignmentExpression.parse(builder,this,true);
}
