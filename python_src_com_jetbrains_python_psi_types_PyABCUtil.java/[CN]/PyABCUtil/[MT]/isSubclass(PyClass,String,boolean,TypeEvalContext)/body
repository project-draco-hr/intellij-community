{
  if (PyNames.CALLABLE.equals(superClassName)) {
    return hasMethod(subClass,PyNames.CALL,inherited,context);
  }
  if (PyNames.HASHABLE.equals(superClassName)) {
    return hasMethod(subClass,PyNames.HASH,inherited,context);
  }
  final boolean hasIter=hasMethod(subClass,PyNames.ITER,inherited,context);
  final boolean hasGetItem=hasMethod(subClass,PyNames.GETITEM,inherited,context);
  if (PyNames.ITERABLE.equals(superClassName)) {
    return hasIter || hasGetItem;
  }
  if (PyNames.ITERATOR.equals(superClassName)) {
    return (hasIter && (hasMethod(subClass,PyNames.NEXT,inherited,context) || hasMethod(subClass,PyNames.DUNDER_NEXT,inherited,context))) || hasGetItem;
  }
  final boolean isSized=hasMethod(subClass,PyNames.LEN,inherited,context);
  if (PyNames.SIZED.equals(superClassName)) {
    return isSized;
  }
  final boolean isContainer=hasMethod(subClass,PyNames.CONTAINS,inherited,context);
  if (PyNames.CONTAINER.equals(superClassName)) {
    return isContainer;
  }
  if (PyNames.SEQUENCE.equals(superClassName)) {
    return isSized && hasIter && isContainer&& hasGetItem;
  }
  if (PyNames.MAPPING.equals(superClassName)) {
    return isSized && hasIter && isContainer&& hasGetItem&& hasMethod(subClass,PyNames.KEYS,inherited,context);
  }
  if (PyNames.ABC_COMPLEX.equals(superClassName)) {
    return hasMethod(subClass,"__complex__",inherited,context);
  }
  if (PyNames.ABC_REAL.equals(superClassName)) {
    return hasMethod(subClass,"__float__",inherited,context);
  }
  if (PyNames.ABC_INTEGRAL.equals(superClassName)) {
    return hasMethod(subClass,"__int__",inherited,context);
  }
  if (PyNames.ABC_NUMBER.equals(superClassName) && "Decimal".equals(subClass.getName())) {
    return true;
  }
  return false;
}
