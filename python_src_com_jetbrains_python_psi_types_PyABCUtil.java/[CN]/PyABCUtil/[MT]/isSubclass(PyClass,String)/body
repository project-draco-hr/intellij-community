{
  if (PyNames.CALLABLE.equals(superClassName)) {
    return hasNonAbstractMethod(subClass,PyNames.CALL);
  }
  if (PyNames.HASHABLE.equals(superClassName)) {
    return hasNonAbstractMethod(subClass,PyNames.HASH);
  }
  final boolean hasIter=hasNonAbstractMethod(subClass,PyNames.ITER);
  final boolean hasGetItem=hasNonAbstractMethod(subClass,PyNames.GETITEM);
  if (PyNames.ITERABLE.equals(superClassName)) {
    return hasIter || hasGetItem;
  }
  if (PyNames.ITERATOR.equals(superClassName)) {
    return (hasIter && (hasNonAbstractMethod(subClass,PyNames.NEXT) || hasNonAbstractMethod(subClass,PyNames.DUNDER_NEXT))) || hasGetItem;
  }
  final boolean isSized=hasNonAbstractMethod(subClass,PyNames.LEN);
  if (PyNames.SIZED.equals(superClassName)) {
    return isSized;
  }
  final boolean isContainer=hasNonAbstractMethod(subClass,PyNames.CONTAINS);
  if (PyNames.CONTAINER.equals(superClassName)) {
    return isContainer;
  }
  if (PyNames.SEQUENCE.equals(superClassName)) {
    return isSized && hasIter && isContainer&& hasGetItem;
  }
  if (PyNames.MAPPING.equals(superClassName)) {
    return isSized && hasIter && isContainer&& hasGetItem&& hasNonAbstractMethod(subClass,PyNames.KEYS);
  }
  return false;
}
