{
  return CachedValuesManager.getCachedValue(expression,new CachedValueProvider<TypeConstraint[]>(){
    @Nullable @Override public Result<TypeConstraint[]> compute(){
      return Result.create(doCompute(),PsiModificationTracker.MODIFICATION_COUNT);
    }
    public TypeConstraint[] doCompute(){
      MyCalculator calculator=new MyCalculator(expression);
      final PsiElement parent=expression.getParent();
      if (parent instanceof GroovyPsiElement) {
        ((GroovyPsiElement)parent).accept(calculator);
      }
 else {
        parent.accept(new GroovyPsiElementVisitor(calculator));
      }
      final TypeConstraint[] result=calculator.getResult();
      List<TypeConstraint> custom=ContainerUtil.newArrayList();
      for (      GroovyExpectedTypesContributor contributor : GroovyExpectedTypesContributor.EP_NAME.getExtensions()) {
        custom.addAll(contributor.calculateTypeConstraints(expression));
      }
      if (!custom.isEmpty()) {
        custom.addAll(0,Arrays.asList(result));
        return custom.toArray(new TypeConstraint[custom.size()]);
      }
      return result;
    }
  }
);
}
