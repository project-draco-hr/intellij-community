{
  ClassWrapper wrapper=node.wrapper;
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper meth=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  MethodWrapper methold=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,meth);
  boolean isInterface=(cl.access_flags & CodeConstants.ACC_INTERFACE) != 0;
  boolean isAnnotation=(cl.access_flags & CodeConstants.ACC_ANNOTATION) != 0;
  boolean isEnum=(cl.access_flags & CodeConstants.ACC_ENUM) != 0 && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
  boolean isDeprecated=mt.getAttributes().containsKey("Deprecated");
  String indstr=InterpreterUtil.getIndentString(indent);
  boolean clinit=false, init=false, dinit=false;
  MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
  StringWriter strwriter=new StringWriter();
  BufferedWriter bufstrwriter=new BufferedWriter(strwriter);
  int flags=mt.getAccessFlags();
  if ((flags & CodeConstants.ACC_NATIVE) != 0) {
    flags&=~CodeConstants.ACC_STRICT;
  }
  if ("<clinit>".equals(mt.getName())) {
    flags&=CodeConstants.ACC_STATIC;
  }
  if (interceptor != null) {
    String oldname=interceptor.getOldName(cl.qualifiedName + " " + mt.getName()+ " "+ mt.getDescriptor());
    if (oldname != null) {
      String[] element=oldname.split(" ");
      bufstrwriter.write(indstr);
      bufstrwriter.write("// $FF: renamed from: " + element[1] + " "+ getDescriptorPrintOut(element[2],2));
      bufstrwriter.write(DecompilerContext.getNewLineSeparator());
    }
  }
  if (isDeprecated) {
    writer.write(indstr);
    writer.write("/** @deprecated */");
    writer.write(DecompilerContext.getNewLineSeparator());
  }
  List<AnnotationExprent> lstAnn=getAllAnnotations(mt.getAttributes());
  for (  AnnotationExprent annexpr : lstAnn) {
    bufstrwriter.write(annexpr.toJava(indent));
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey("Synthetic");
  boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
  if (isSynthetic) {
    bufstrwriter.write(indstr);
    bufstrwriter.write("// $FF: synthetic method");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  if (isBridge) {
    bufstrwriter.write(indstr);
    bufstrwriter.write("// $FF: bridge method");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  bufstrwriter.write(indstr);
  for (int i=0; i < modval_meth.length; i++) {
    if (!isInterface || !mod_notinterface_meth.contains(modval_meth[i])) {
      if ((flags & modval_meth[i]) != 0) {
        bufstrwriter.write(modstr_meth[i]);
      }
    }
  }
  if (isInterface && mt.containsCode()) {
    bufstrwriter.write("default ");
  }
  String name=mt.getName();
  if ("<init>".equals(name)) {
    if (node.type == ClassNode.CLASS_ANONYMOUS) {
      name="";
      dinit=true;
    }
 else {
      name=node.simpleName;
      init=true;
    }
  }
 else   if ("<clinit>".equals(name)) {
    name="";
    clinit=true;
  }
  GenericMethodDescriptor descriptor=null;
  if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
    StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttributes().getWithKey("Signature");
    if (attr != null) {
      descriptor=GenericMain.parseMethodSignature(attr.getSignature());
      int actualParams=md.params.length;
      if (isEnum && init)       actualParams-=2;
      if (actualParams != descriptor.params.size()) {
        DecompilerContext.getLogger().writeMessage("Inconsistent generic signature in method " + mt.getName() + " "+ mt.getDescriptor(),IFernflowerLogger.WARNING);
        descriptor=null;
      }
    }
  }
  boolean throwsExceptions=false;
  int param_count_explicit=0;
  if (!clinit && !dinit) {
    boolean thisvar=(mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
    if (descriptor != null && !descriptor.fparameters.isEmpty()) {
      bufstrwriter.write("<");
      for (int i=0; i < descriptor.fparameters.size(); i++) {
        if (i > 0) {
          bufstrwriter.write(", ");
        }
        bufstrwriter.write(descriptor.fparameters.get(i));
        List<GenericType> lstBounds=descriptor.fbounds.get(i);
        if (lstBounds.size() > 1 || !"java/lang/Object".equals(lstBounds.get(0).value)) {
          bufstrwriter.write(" extends ");
          bufstrwriter.write(GenericMain.getGenericCastTypeName(lstBounds.get(0)));
          for (int j=1; j < lstBounds.size(); j++) {
            bufstrwriter.write(" & " + GenericMain.getGenericCastTypeName(lstBounds.get(j)));
          }
        }
      }
      bufstrwriter.write("> ");
    }
    if (!init) {
      if (descriptor != null) {
        bufstrwriter.write(GenericMain.getGenericCastTypeName(descriptor.ret));
      }
 else {
        bufstrwriter.write(ExprProcessor.getCastTypeName(md.ret));
      }
      bufstrwriter.write(" ");
    }
    bufstrwriter.write(name);
    bufstrwriter.write("(");
    List<List<AnnotationExprent>> lstParAnn=getAllParameterAnnotations(mt.getAttributes());
    List<VarVersionPaar> signFields=meth.signatureFields;
    int lastparam_index=-1;
    for (int i=0; i < md.params.length; i++) {
      if (signFields == null || signFields.get(i) == null) {
        lastparam_index=i;
      }
    }
    boolean firstpar=true;
    int index=isEnum && init ? 3 : thisvar ? 1 : 0;
    int start=isEnum && init && descriptor == null ? 2 : 0;
    int params=descriptor == null ? md.params.length : descriptor.params.size();
    for (int i=start; i < params; i++) {
      if (signFields == null || signFields.get(i) == null) {
        if (!firstpar) {
          bufstrwriter.write(", ");
        }
        if (lstParAnn.size() > param_count_explicit) {
          List<AnnotationExprent> annotations=lstParAnn.get(param_count_explicit);
          for (int j=0; j < annotations.size(); j++) {
            AnnotationExprent annexpr=annotations.get(j);
            if (annexpr.getAnnotationType() == AnnotationExprent.ANNOTATION_NORMAL) {
              bufstrwriter.write(DecompilerContext.getNewLineSeparator());
              bufstrwriter.write(annexpr.toJava(indent + 1));
            }
 else {
              bufstrwriter.write(annexpr.toJava(0));
            }
            bufstrwriter.write(" ");
          }
        }
        if (meth.varproc.getVarFinal(new VarVersionPaar(index,0)) == VarTypeProcessor.VAR_FINALEXPLICIT) {
          bufstrwriter.write("final ");
        }
        if (descriptor != null) {
          GenericType partype=descriptor.params.get(i);
          boolean isVarArgs=(i == lastparam_index && (mt.getAccessFlags() & CodeConstants.ACC_VARARGS) != 0 && partype.arraydim > 0);
          if (isVarArgs) {
            partype.arraydim--;
          }
          String strpartype=GenericMain.getGenericCastTypeName(partype);
          if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(strpartype) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
            strpartype=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
          }
          bufstrwriter.write(strpartype);
          if (isVarArgs) {
            bufstrwriter.write(" ...");
          }
        }
 else {
          VarType partype=md.params[i].copy();
          boolean isVarArgs=(i == lastparam_index && (mt.getAccessFlags() & CodeConstants.ACC_VARARGS) != 0 && partype.arraydim > 0);
          if (isVarArgs) {
            partype.decArrayDim();
          }
          String strpartype=ExprProcessor.getCastTypeName(partype);
          if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(strpartype) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
            strpartype=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
          }
          bufstrwriter.write(strpartype);
          if (isVarArgs) {
            bufstrwriter.write(" ...");
          }
        }
        bufstrwriter.write(" ");
        String parname=meth.varproc.getVarName(new VarVersionPaar(index,0));
        bufstrwriter.write(parname == null ? "param" + index : parname);
        firstpar=false;
        param_count_explicit++;
      }
      index+=md.params[i].stack_size;
    }
    bufstrwriter.write(")");
    StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttributes().getWithKey("Exceptions");
    if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
      throwsExceptions=true;
      bufstrwriter.write(" throws ");
      for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
        if (i > 0) {
          bufstrwriter.write(", ");
        }
        if (descriptor != null && !descriptor.exceptions.isEmpty()) {
          bufstrwriter.write(GenericMain.getGenericCastTypeName(descriptor.exceptions.get(i)));
        }
 else {
          VarType exctype=new VarType(attr.getExcClassname(i,cl.getPool()),true);
          bufstrwriter.write(ExprProcessor.getCastTypeName(exctype));
        }
      }
    }
  }
  boolean hidemethod=false;
  if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
    if (isAnnotation) {
      StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttributes().getWithKey("AnnotationDefault");
      if (attr != null) {
        bufstrwriter.write(" default ");
        bufstrwriter.write(attr.getDefaultValue().toJava(indent + 1));
      }
    }
    bufstrwriter.write(";");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
 else {
    if (!clinit && !dinit) {
      bufstrwriter.write(" ");
    }
    bufstrwriter.write("{");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
    RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
    if (root != null && !meth.decompiledWithErrors) {
      try {
        String code=root.toJava(indent + 1);
        boolean singleinit=false;
        if (init && param_count_explicit == 0 && !throwsExceptions && DecompilerContext.getOption(IFernflowerPreferences.HIDE_DEFAULT_CONSTRUCTOR)) {
          int init_counter=0;
          for (          MethodWrapper mth : wrapper.getMethods()) {
            if ("<init>".equals(mth.methodStruct.getName())) {
              init_counter++;
            }
          }
          singleinit=(init_counter == 1);
        }
        hidemethod=(clinit || dinit || singleinit) && code.length() == 0;
        bufstrwriter.write(code);
      }
 catch (      Throwable ex) {
        DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " "+ mt.getDescriptor()+ " couldn't be written.",ex);
        meth.decompiledWithErrors=true;
      }
    }
    if (meth.decompiledWithErrors) {
      bufstrwriter.write(InterpreterUtil.getIndentString(indent + 1));
      bufstrwriter.write("// $FF: Couldn't be decompiled");
      bufstrwriter.write(DecompilerContext.getNewLineSeparator());
    }
    bufstrwriter.write(indstr + "}");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  bufstrwriter.flush();
  if (!hidemethod) {
    writer.write(strwriter.toString());
  }
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methold);
  return !hidemethod;
}
