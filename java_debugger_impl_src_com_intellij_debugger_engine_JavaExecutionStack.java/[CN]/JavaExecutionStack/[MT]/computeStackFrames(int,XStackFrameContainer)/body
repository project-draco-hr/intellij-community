{
  final AtomicInteger skipCounter=new AtomicInteger(firstFrameIndex);
  myDebugProcess.getManagerThread().schedule(new DebuggerContextCommandImpl(myDebugProcess.getDebuggerContext()){
    @Override public void threadAction(){
      if (!myThreadProxy.isCollected() && myDebugProcess.getSuspendManager().isSuspended(myThreadProxy)) {
        int status=myThreadProxy.status();
        if (!(status == ThreadReference.THREAD_STATUS_UNKNOWN) && !(status == ThreadReference.THREAD_STATUS_NOT_STARTED) && !(status == ThreadReference.THREAD_STATUS_ZOMBIE)) {
          try {
            boolean first=true;
            for (            StackFrameProxyImpl stackFrame : myThreadProxy.frames()) {
              if (first && firstFrameIndex > 0) {
                skipCounter.decrementAndGet();
                first=false;
                continue;
              }
              myDebugProcess.getManagerThread().schedule(new AppendFrameCommand(getSuspendContext(),stackFrame,container,skipCounter));
            }
          }
 catch (          EvaluateException e) {
            container.errorOccurred(e.getMessage());
            return;
          }
        }
        myDebugProcess.getManagerThread().schedule(new SuspendContextCommandImpl(getSuspendContext()){
          @Override public void contextAction() throws Exception {
            container.addStackFrames(Collections.<JavaStackFrame>emptyList(),true);
          }
        }
);
      }
 else {
        container.errorOccurred(DebuggerBundle.message("frame.panel.frames.not.available"));
      }
    }
  }
);
}
