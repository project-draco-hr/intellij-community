{
  if (container.isObsolete())   return;
  myDebugProcess.getManagerThread().schedule(new SuspendContextCommandImpl(myDebugProcess.getDebuggerContext().getSuspendContext()){
    @Override public Priority getPriority(){
      return Priority.NORMAL;
    }
    @Override public void contextAction() throws Exception {
      if (container.isObsolete())       return;
      if (!myThreadProxy.isCollected() && myDebugProcess.getSuspendManager().isSuspended(myThreadProxy)) {
        int status=myThreadProxy.status();
        if (!(status == ThreadReference.THREAD_STATUS_UNKNOWN) && !(status == ThreadReference.THREAD_STATUS_NOT_STARTED) && !(status == ThreadReference.THREAD_STATUS_ZOMBIE)) {
          try {
            int added=0;
            Iterator<StackFrameProxyImpl> iterator=myThreadProxy.frames().iterator();
            if (iterator.hasNext() && firstFrameIndex > 0) {
              iterator.next();
              added++;
            }
            myDebugProcess.getManagerThread().schedule(new AppendFrameCommand(getSuspendContext(),iterator,container,added,firstFrameIndex));
          }
 catch (          EvaluateException e) {
            container.errorOccurred(e.getMessage());
          }
        }
      }
 else {
        container.errorOccurred(DebuggerBundle.message("frame.panel.frames.not.available"));
      }
    }
  }
);
}
