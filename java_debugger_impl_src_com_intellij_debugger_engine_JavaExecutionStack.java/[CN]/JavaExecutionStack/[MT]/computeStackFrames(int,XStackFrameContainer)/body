{
  myDebugProcess.getManagerThread().schedule(new DebuggerCommandImpl(){
    @Override protected void action() throws Exception {
      boolean showLibraryStackframes=DebuggerSettings.getInstance().SHOW_LIBRARY_STACKFRAMES;
      if (!myThreadProxy.isCollected() && myDebugProcess.getSuspendManager().isSuspended(myThreadProxy)) {
        List<JavaStackFrame> frames=new ArrayList<JavaStackFrame>();
        int status=myThreadProxy.status();
        if (!(status == ThreadReference.THREAD_STATUS_UNKNOWN) && !(status == ThreadReference.THREAD_STATUS_NOT_STARTED) && !(status == ThreadReference.THREAD_STATUS_ZOMBIE)) {
          try {
            int framesToSkip=firstFrameIndex;
            boolean first=true;
            for (            StackFrameProxyImpl stackFrame : myThreadProxy.frames()) {
              if (first && framesToSkip > 0) {
                framesToSkip--;
                first=false;
                continue;
              }
              JavaStackFrame frame=new JavaStackFrame(stackFrame,myDebugProcess,myTracker);
              if (showLibraryStackframes || (!frame.getDescriptor().isSynthetic() && !frame.getDescriptor().isInLibraryContent())) {
                if (framesToSkip > 0) {
                  framesToSkip--;
                  continue;
                }
                frames.add(frame);
              }
            }
          }
 catch (          EvaluateException e) {
            container.errorOccurred(e.getMessage());
            return;
          }
        }
        container.addStackFrames(frames,true);
      }
 else {
        container.errorOccurred(DebuggerBundle.message("frame.panel.frames.not.available"));
      }
    }
  }
);
}
