{
  int stateIndex=state.index;
  Conf conf=state.conf;
  int insnIndex=conf.insnIndex;
  List<Conf> history=state.history;
  boolean taken=state.taken;
  Frame<BasicValue> frame=conf.frame;
  AbstractInsnNode insnNode=methodNode.instructions.get(insnIndex);
  List<Conf> nextHistory=dfsTree.loopEnters[insnIndex] ? append(history,conf) : history;
  boolean hasCompanions=state.hasCompanions;
  execute(frame,insnNode);
  boolean notEmptySubResult=subResult != Identity;
  if (subResult == NPE) {
    results[stateIndex]=NPE;
    addComputed(insnIndex,state);
    return;
  }
  int opcode=insnNode.getOpcode();
switch (opcode) {
case ARETURN:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case RETURN:
    if (!hasCompanions) {
      earlyResult=Return;
    }
 else {
      results[stateIndex]=Return;
      addComputed(insnIndex,state);
    }
  return;
default :
}
if (opcode == ATHROW) {
if (taken) {
  results[stateIndex]=NPE;
}
 else {
  results[stateIndex]=Identity;
}
addComputed(insnIndex,state);
return;
}
if (opcode == IFNONNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=insnIndex + 1;
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pending.push(new MakeResult<PResult>(state,subResult,new int[]{nextState.index}));
pending.push(new ProceedState<PResult>(nextState));
return;
}
if (opcode == IFNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pending.push(new MakeResult<PResult>(state,subResult,new int[]{nextState.index}));
pending.push(new ProceedState<PResult>(nextState));
return;
}
if (opcode == IFEQ && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pending.push(new MakeResult<PResult>(state,subResult,new int[]{nextState.index}));
pending.push(new ProceedState<PResult>(nextState));
return;
}
if (opcode == IFNE && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=insnIndex + 1;
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pending.push(new MakeResult<PResult>(state,subResult,new int[]{nextState.index}));
pending.push(new ProceedState<PResult>(nextState));
return;
}
int[] nextInsnIndices=controlFlow.transitions[insnIndex];
List<State> nextStates=new ArrayList<State>(nextInsnIndices.length);
int[] subIndices=new int[nextInsnIndices.length];
for (int i=0; i < nextInsnIndices.length; i++) {
int nextInsnIndex=nextInsnIndices[i];
Frame<BasicValue> nextFrame1=nextFrame;
if (controlFlow.errors[nextInsnIndex] && controlFlow.errorTransitions.contains(new Edge(insnIndex,nextInsnIndex))) {
  nextFrame1=new Frame<BasicValue>(frame);
  nextFrame1.clearStack();
  nextFrame1.push(new BasicValue(Type.getType("java/lang/Throwable")));
}
nextStates.add(new State(++id,new Conf(nextInsnIndex,nextFrame1),nextHistory,taken,hasCompanions || notEmptySubResult));
subIndices[i]=(id);
}
pending.push(new MakeResult<PResult>(state,subResult,subIndices));
for (State nextState : nextStates) {
pending.push(new ProceedState<PResult>(nextState));
}
}
