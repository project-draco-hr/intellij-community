{
  int stateIndex=state.index;
  Conf conf=state.conf;
  int insnIndex=conf.insnIndex;
  List<Conf> history=state.history;
  boolean taken=state.taken;
  Frame<BasicValue> frame=conf.frame;
  AbstractInsnNode insnNode=methodNode.instructions.get(insnIndex);
  List<Conf> nextHistory=dfsTree.loopEnters[insnIndex] ? append(history,conf) : history;
  boolean hasCompanions=state.hasCompanions;
  execute(frame,insnNode);
  boolean notEmptySubResult=subResult != Identity;
  if (subResult == NPE) {
    results[stateIndex]=NPE;
    possibleNPE=true;
    addComputed(insnIndex,state);
    return;
  }
  int opcode=insnNode.getOpcode();
switch (opcode) {
case ARETURN:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case RETURN:
    if (!hasCompanions) {
      earlyResult=Return;
    }
 else {
      results[stateIndex]=Return;
      addComputed(insnIndex,state);
    }
  return;
default :
}
if (opcode == ATHROW) {
if (taken) {
  results[stateIndex]=NPE;
  possibleNPE=true;
}
 else {
  results[stateIndex]=Identity;
}
addComputed(insnIndex,state);
return;
}
if (opcode == IFNONNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=insnIndex + 1;
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pendingPush(new MakeResult(state,subResult,new int[]{nextState.index}));
pendingPush(new ProceedState(nextState));
return;
}
if (opcode == IFNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pendingPush(new MakeResult(state,subResult,new int[]{nextState.index}));
pendingPush(new ProceedState(nextState));
return;
}
if (opcode == IFEQ && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pendingPush(new MakeResult(state,subResult,new int[]{nextState.index}));
pendingPush(new ProceedState(nextState));
return;
}
if (opcode == IFNE && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=insnIndex + 1;
State nextState=new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,hasCompanions || notEmptySubResult);
pendingPush(new MakeResult(state,subResult,new int[]{nextState.index}));
pendingPush(new ProceedState(nextState));
return;
}
int[] nextInsnIndices=controlFlow.transitions[insnIndex];
int[] subIndices=new int[nextInsnIndices.length];
for (int i=0; i < nextInsnIndices.length; i++) {
subIndices[i]=++id;
}
pendingPush(new MakeResult(state,subResult,subIndices));
for (int i=0; i < nextInsnIndices.length; i++) {
int nextInsnIndex=nextInsnIndices[i];
Frame<BasicValue> nextFrame1=nextFrame;
if (controlFlow.errors[nextInsnIndex] && controlFlow.errorTransitions.contains(new Edge(insnIndex,nextInsnIndex))) {
  nextFrame1=new Frame<>(frame);
  nextFrame1.clearStack();
  nextFrame1.push(ASMUtils.THROWABLE_VALUE);
}
pendingPush(new ProceedState(new State(subIndices[i],new Conf(nextInsnIndex,nextFrame1),nextHistory,taken,hasCompanions || notEmptySubResult)));
}
}
