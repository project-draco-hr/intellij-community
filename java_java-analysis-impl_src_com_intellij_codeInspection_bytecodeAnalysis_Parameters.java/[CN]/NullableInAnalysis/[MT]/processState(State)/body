{
  Conf conf=state.conf;
  int insnIndex=conf.insnIndex;
  List<Conf> history=state.history;
  boolean taken=state.taken;
  Frame<BasicValue> frame=conf.frame;
  AbstractInsnNode insnNode=methodNode.instructions.get(insnIndex);
  List<Conf> nextHistory=dfsTree.loopEnters[insnIndex] ? append(history,conf) : history;
  addComputed(insnIndex,state);
  execute(frame,insnNode,taken);
  if (subResult == NPE || top) {
    earlyResult=NPE;
    return;
  }
  if (subResult instanceof ConditionalNPE) {
    myResult=combineNullable(myResult,subResult);
  }
  int opcode=insnNode.getOpcode();
switch (opcode) {
case ARETURN:
    if (popValue(frame) instanceof ParamValue) {
      earlyResult=NPE;
    }
  return;
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case RETURN:
return;
default :
}
if (opcode == ATHROW) {
if (taken) {
earlyResult=NPE;
}
return;
}
if (opcode == IFNONNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=insnIndex + 1;
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false));
return;
}
if (opcode == IFNULL && popValue(frame) instanceof ParamValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false));
return;
}
if (opcode == IFEQ && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=methodNode.instructions.indexOf(((JumpInsnNode)insnNode).label);
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false));
return;
}
if (opcode == IFNE && popValue(frame) == InstanceOfCheckValue) {
int nextInsnIndex=insnIndex + 1;
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame),nextHistory,true,false));
return;
}
for (int nextInsnIndex : controlFlow.transitions[insnIndex]) {
Frame<BasicValue> nextFrame1=nextFrame;
if (controlFlow.errors[nextInsnIndex] && controlFlow.errorTransitions.contains(new Edge(insnIndex,nextInsnIndex))) {
nextFrame1=new Frame<BasicValue>(frame);
nextFrame1.clearStack();
nextFrame1.push(ASMUtils.THROWABLE_VALUE);
}
pendingPush(new State(++id,new Conf(nextInsnIndex,nextFrame1),nextHistory,taken,false));
}
}
