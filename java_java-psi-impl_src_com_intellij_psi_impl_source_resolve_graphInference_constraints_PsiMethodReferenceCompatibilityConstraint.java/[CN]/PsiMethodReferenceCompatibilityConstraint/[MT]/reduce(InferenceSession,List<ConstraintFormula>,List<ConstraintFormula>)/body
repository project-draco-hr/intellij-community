{
  final InferenceVariable inferenceVariable=session.getInferenceVariable(myT);
  if (inferenceVariable != null) {
    delayedConstraints.add(this);
    return true;
  }
  if (LambdaHighlightingUtil.checkInterfaceFunctional(myT) != null) {
    return false;
  }
  final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(myT);
  if (interfaceMethod == null) {
    return false;
  }
  final PsiSubstitutor substitutor=LambdaUtil.getSubstitutor(interfaceMethod,PsiUtil.resolveGenericsClassInType(myT));
  final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
  for (  PsiParameter parameter : parameters) {
    if (!session.isProperType(substitutor.substitute(parameter.getType()))) {
      delayedConstraints.add(this);
      return true;
    }
  }
  final PsiElement resolve=myExpression.resolve();
  if (resolve == null) {
    return false;
  }
  final PsiType returnType=interfaceMethod.getReturnType();
  LOG.assertTrue(returnType != null,interfaceMethod);
  if (PsiType.VOID.equals(returnType)) {
    return true;
  }
  if (resolve instanceof PsiMethod) {
    final PsiMethod method=(PsiMethod)resolve;
    final PsiType referencedMethodReturnType;
    if (method.isConstructor()) {
      final PsiClass containingClass=method.getContainingClass();
      LOG.assertTrue(containingClass != null,method);
      referencedMethodReturnType=JavaPsiFacade.getElementFactory(method.getProject()).createType(containingClass);
    }
 else {
      referencedMethodReturnType=method.getReturnType();
    }
    LOG.assertTrue(referencedMethodReturnType != null,method);
    if (myExpression.getTypeParameters().length == 0 && ((PsiMethod)resolve).getTypeParameters().length > 0 && PsiPolyExpressionUtil.mentionsTypeParameters(returnType,new HashSet<PsiTypeParameter>(Arrays.asList(interfaceMethod.getTypeParameters())))) {
      return true;
    }
    if (PsiType.VOID.equals(referencedMethodReturnType)) {
      return false;
    }
    constraints.add(new TypeCompatibilityConstraint(substitutor.substitute(returnType),referencedMethodReturnType));
  }
  return true;
}
