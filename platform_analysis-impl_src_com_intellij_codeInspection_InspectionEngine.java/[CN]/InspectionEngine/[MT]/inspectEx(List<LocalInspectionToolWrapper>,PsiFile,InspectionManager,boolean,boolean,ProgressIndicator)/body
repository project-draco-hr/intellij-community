{
  if (toolWrappers.isEmpty())   return Collections.emptyMap();
  final Map<String,List<ProblemDescriptor>> resultDescriptors=new ConcurrentHashMap<String,List<ProblemDescriptor>>();
  final List<PsiElement> elements=new ArrayList<PsiElement>();
  TextRange range=file.getTextRange();
  final LocalInspectionToolSession session=new LocalInspectionToolSession(file,range.getStartOffset(),range.getEndOffset());
  Divider.divideInsideAndOutside(file,range.getStartOffset(),range.getEndOffset(),range,elements,new ArrayList<ProperTextRange>(),Collections.<PsiElement>emptyList(),Collections.<ProperTextRange>emptyList(),true,Conditions.<PsiFile>alwaysTrue());
  MultiMap<LocalInspectionToolWrapper,String> toolToLanguages=getToolsForElements(toolWrappers,elements,Collections.<PsiElement>emptyList());
  List<Map.Entry<LocalInspectionToolWrapper,Collection<String>>> entries=new ArrayList<Map.Entry<LocalInspectionToolWrapper,Collection<String>>>(toolToLanguages.entrySet());
  Processor<Map.Entry<LocalInspectionToolWrapper,Collection<String>>> processor=new Processor<Map.Entry<LocalInspectionToolWrapper,Collection<String>>>(){
    @Override public boolean process(    final Map.Entry<LocalInspectionToolWrapper,Collection<String>> entry){
      ProblemsHolder holder=new ProblemsHolder(iManager,file,isOnTheFly);
      final LocalInspectionTool tool=entry.getKey().getTool();
      Collection<String> languages=entry.getValue();
      createVisitorAndAcceptElements(tool,holder,isOnTheFly,session,elements,languages);
      tool.inspectionFinished(session,holder);
      if (holder.hasResults()) {
        resultDescriptors.put(tool.getShortName(),ContainerUtil.filter(holder.getResults(),new Condition<ProblemDescriptor>(){
          @Override public boolean value(          ProblemDescriptor descriptor){
            PsiElement element=descriptor.getPsiElement();
            return element == null || !SuppressionUtil.inspectionResultSuppressed(element,tool);
          }
        }
));
      }
      return true;
    }
  }
;
  JobLauncher.getInstance().invokeConcurrentlyUnderProgress(entries,indicator,failFastOnAcquireReadAction,processor);
  return resultDescriptors;
}
