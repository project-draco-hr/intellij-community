{
  final String base=project.getBasePath();
  final List<String> missing=new LinkedList<String>();
  final ApplyPatchContext patchContext=new ApplyPatchContext(project.getBaseDir(),0,false,false);
  final PatchesPreloader preloader=new PatchesPreloader(project);
  for (  final ShelvedChange shelvedChange : changesFromFirstList) {
    final String beforePath=shelvedChange.getBeforePath();
    final String afterPath=shelvedChange.getAfterPath();
    final VirtualFile file;
    try {
      boolean isNewFile=FileStatus.ADDED.equals(shelvedChange.getFileStatus());
      file=ApplyFilePatchBase.findPatchTarget(patchContext,beforePath,afterPath,isNewFile);
      if (!isNewFile && (file == null || !file.exists()))       throw new FileNotFoundException(beforePath);
    }
 catch (    IOException e) {
      if (beforePath != null)       missing.add(beforePath);
      continue;
    }
    diffRequestProducers.add(new MyDiffRequestProducer(shelvedChange){
      @NotNull @Override public FilePath getFilePath(){
        File file=new File(base,shelvedChange.getAfterPath() == null ? shelvedChange.getBeforePath() : shelvedChange.getAfterPath());
        return VcsUtil.getFilePath(file);
      }
      @NotNull @Override public DiffRequest process(      @NotNull UserDataHolder context,      @NotNull ProgressIndicator indicator) throws DiffRequestProducerException, ProcessCanceledException {
        if (file != null && file.getFileType() == UnknownFileType.INSTANCE) {
          return new UnknownFileTypeDiffRequest(file,getName());
        }
        if (shelvedChange.isConflictingChange(project)) {
          try {
            final CommitContext commitContext=new CommitContext();
            final TextFilePatch patch=preloader.getPatch(shelvedChange,commitContext);
            final FilePath pathBeforeRename=patchContext.getPathBeforeRename(file);
            final String relativePath=patch.getAfterName() == null ? patch.getBeforeName() : patch.getAfterName();
            final Getter<CharSequence> baseContentGetter=new Getter<CharSequence>(){
              @Override public CharSequence get(){
                BaseRevisionTextPatchEP baseRevisionTextPatchEP=Extensions.findExtension(PatchEP.EP_NAME,project,BaseRevisionTextPatchEP.class);
                return baseRevisionTextPatchEP.provideContent(relativePath,commitContext);
              }
            }
;
            Getter<ApplyPatchForBaseRevisionTexts> getter=new Getter<ApplyPatchForBaseRevisionTexts>(){
              @Override public ApplyPatchForBaseRevisionTexts get(){
                return ApplyPatchForBaseRevisionTexts.create(project,file,pathBeforeRename,patch,baseContentGetter);
              }
            }
;
            return PatchDiffRequestFactory.createConflictDiffRequest(project,file,"Shelved Version",getter,getName(),context,indicator);
          }
 catch (          VcsException e) {
            throw new DiffRequestProducerException("Can't show diff for '" + getName() + "'",e);
          }
        }
 else {
          final Change change=shelvedChange.getChange(project);
          return PatchDiffRequestFactory.createDiffRequest(project,change,getName(),context,indicator);
        }
      }
    }
);
  }
  if (!missing.isEmpty()) {
    VcsBalloonProblemNotifier.showOverChangesView(project,"Show Diff: Cannot find base for: " + StringUtil.join(missing,",\n"),MessageType.WARNING);
  }
}
