{
  while (i < kids.size()) {
    final AbstractTreeNode eachKid=kids.get(i);
    final boolean[] nodeWasCollapsed={true};
    final DefaultMutableTreeNode nodeForElement=getNodeForElement(eachKid);
    if (nodeForElement != null) {
      nodeWasCollapsed[0]=getTree().isCollapsed(new TreePath(nodeForElement.getPath()));
    }
    if (nonStopCondition.value(eachKid)) {
      final AsyncResult<AbstractTreeNode> result=expandPathTo(file,eachKid,element,nonStopCondition,indicator,virtualSelectTarget);
      result.doWhenDone(new Consumer<AbstractTreeNode>(){
        @Override public void consume(        AbstractTreeNode abstractTreeNode){
          indicator.checkCanceled();
          async.setDone(abstractTreeNode);
        }
      }
);
      if (!result.isProcessed()) {
        final int next=i + 1;
        result.doWhenRejected(new Runnable(){
          @Override public void run(){
            indicator.checkCanceled();
            if (nodeWasCollapsed[0] && virtualSelectTarget == null) {
              collapseChildren(eachKid,null);
            }
            expandChild(kids,next,nonStopCondition,file,element,async,indicator,virtualSelectTarget);
          }
        }
);
        return;
      }
 else {
        if (result.isRejected()) {
          indicator.checkCanceled();
          if (nodeWasCollapsed[0] && virtualSelectTarget == null) {
            collapseChildren(eachKid,null);
          }
          i++;
        }
 else {
          return;
        }
      }
    }
 else {
      async.setRejected();
    }
  }
  async.setRejected();
}
