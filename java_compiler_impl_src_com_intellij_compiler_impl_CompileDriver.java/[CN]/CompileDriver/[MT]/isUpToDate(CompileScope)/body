{
  if (LOG.isDebugEnabled()) {
    LOG.debug("isUpToDate operation started");
  }
  final CompilerTask task=new CompilerTask(myProject,"Classes up-to-date check",true,false,false,isCompilationStartedAutomatically(scope));
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,task,scope,true,false);
  final Ref<ExitStatus> result=new Ref<ExitStatus>();
  task.start(new Runnable(){
    public void run(){
      final ProgressIndicator indicator=compileContext.getProgressIndicator();
      if (indicator.isCanceled() || myProject.isDisposed()) {
        return;
      }
      try {
        final RequestFuture future=compileInExternalProcess(compileContext,true);
        if (future != null) {
          while (!future.waitFor(200L,TimeUnit.MILLISECONDS)) {
            if (indicator.isCanceled()) {
              future.cancel(false);
            }
          }
        }
      }
 catch (      Throwable e) {
        LOG.error(e);
      }
 finally {
        result.set(COMPILE_SERVER_BUILD_STATUS.get(compileContext));
        if (!myProject.isDisposed()) {
          CompilerCacheManager.getInstance(myProject).flushCaches();
        }
      }
    }
  }
,null);
  if (LOG.isDebugEnabled()) {
    LOG.debug("isUpToDate operation finished");
  }
  return ExitStatus.UP_TO_DATE.equals(result.get());
}
