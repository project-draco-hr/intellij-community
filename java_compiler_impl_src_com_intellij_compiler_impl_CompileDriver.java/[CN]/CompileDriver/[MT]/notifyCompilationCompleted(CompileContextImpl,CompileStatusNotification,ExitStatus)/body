{
  final long duration=System.currentTimeMillis() - compileContext.getStartCompilationStamp();
  if (!myProject.isDisposed()) {
    final Module[] affectedModules=compileContext.getCompileScope().getAffectedModules();
    if (_status != ExitStatus.UP_TO_DATE && _status != ExitStatus.CANCELLED) {
      final Set<File> outputs=new HashSet<File>();
      for (      final String path : CompilerPathsEx.getOutputPaths(affectedModules)) {
        outputs.add(new File(path));
      }
      if (!outputs.isEmpty()) {
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        indicator.setText("Synchronizing output directories...");
        CompilerUtil.refreshOutputDirectories(outputs,_status == ExitStatus.CANCELLED);
        indicator.setText("");
      }
    }
    if (compileContext.isAnnotationProcessorsEnabled() && !myProject.isDisposed()) {
      final Set<File> genSourceRoots=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
      final CompilerConfiguration config=CompilerConfiguration.getInstance(myProject);
      for (      Module module : affectedModules) {
        if (!module.isDisposed() && config.getAnnotationProcessingConfiguration(module).isEnabled()) {
          final String path=CompilerPaths.getAnnotationProcessorsGenerationPath(module);
          if (path != null) {
            genSourceRoots.add(new File(path));
          }
        }
      }
      if (!genSourceRoots.isEmpty()) {
        LocalFileSystem.getInstance().refreshIoFiles(genSourceRoots,true,true,null);
      }
    }
  }
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      int errorCount=0;
      int warningCount=0;
      try {
        errorCount=compileContext.getMessageCount(CompilerMessageCategory.ERROR);
        warningCount=compileContext.getMessageCount(CompilerMessageCategory.WARNING);
      }
  finally {
        if (callback != null) {
          callback.finished(_status == ExitStatus.CANCELLED,errorCount,warningCount,compileContext);
        }
      }
      if (!myProject.isDisposed()) {
        final String statusMessage=createStatusMessage(_status,warningCount,errorCount,duration);
        final MessageType messageType=errorCount > 0 ? MessageType.ERROR : warningCount > 0 ? MessageType.WARNING : MessageType.INFO;
        if (duration > ONE_MINUTE_MS && CompilerWorkspaceConfiguration.getInstance(myProject).DISPLAY_NOTIFICATION_POPUP) {
          ToolWindowManager.getInstance(myProject).notifyByBalloon(ToolWindowId.MESSAGES_WINDOW,messageType,statusMessage);
        }
        final String wrappedMessage=_status != ExitStatus.UP_TO_DATE ? "<a href='#'>" + statusMessage + "</a>" : statusMessage;
        final Notification notification=CompilerManager.NOTIFICATION_GROUP.createNotification("",wrappedMessage,messageType.toNotificationType(),new MessagesActivationListener(compileContext)).setImportant(false);
        compileContext.getBuildSession().registerCloseAction(new Runnable(){
          @Override public void run(){
            notification.expire();
          }
        }
);
        notification.notify(myProject);
        if (_status != ExitStatus.UP_TO_DATE && compileContext.getMessageCount(null) > 0) {
          final String msg=DateFormatUtil.formatDateTime(new Date()) + " - " + statusMessage;
          compileContext.addMessage(CompilerMessageCategory.INFORMATION,msg,null,-1,-1);
        }
      }
    }
  }
);
  return duration;
}
