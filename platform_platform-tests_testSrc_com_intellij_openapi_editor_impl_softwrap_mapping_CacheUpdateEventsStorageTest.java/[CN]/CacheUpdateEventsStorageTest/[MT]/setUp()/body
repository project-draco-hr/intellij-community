{
  myText="line1\n" + "line2\n" + "line3\n"+ "line4\n"+ "line5\n"+ "line6\n"+ "line7";
  myMockery=new JUnit4Mockery(){
{
      setImposteriser(ClassImposteriser.INSTANCE);
    }
  }
;
  myDocument=myMockery.mock(Document.class);
  myFoldingModel=myMockery.mock(FoldingModelEx.class);
  myEditor=myMockery.mock(Editor.class);
  myMockery.checking(new Expectations(){
{
      allowing(myDocument).getTextLength();
      will(new CustomAction("getTextLength()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myText.length();
        }
      }
);
      allowing(myDocument).getLineNumber(with(any(int.class)));
      will(new CustomAction("getLineNumber()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineNumber((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineStartOffset(with(any(int.class)));
      will(new CustomAction("getLineStartOffset()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineStartOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineEndOffset(with(any(int.class)));
      will(new CustomAction("getLineEndOffset()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineEndOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myFoldingModel).getCollapsedRegionAtOffset(with(any(int.class)));
      will(returnValue(null));
      allowing(myEditor).getDocument();
      will(returnValue(myDocument));
      allowing(myEditor).getFoldingModel();
      will(returnValue(myFoldingModel));
    }
  }
);
  myStorage=new CacheUpdateEventsStorage();
}
