{
  MultiMap<PsiElement,String> conflicts=new MultiMap<>();
  final PsiClass existingClass=JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName,GlobalSearchScope.allScope(myProject));
  if (myUseExistingClass) {
    if (existingClass == null) {
      conflicts.putValue(null,RefactorJBundle.message("could.not.find.selected.wrapping.class"));
    }
 else {
      boolean foundConstructor=false;
      final Set<PsiType> returnTypes=new HashSet<>();
      returnTypes.add(myMethod.getReturnType());
      final PsiCodeBlock methodBody=myMethod.getBody();
      if (methodBody != null) {
        methodBody.accept(new JavaRecursiveElementWalkingVisitor(){
          @Override public void visitReturnStatement(          final PsiReturnStatement statement){
            super.visitReturnStatement(statement);
            final PsiExpression returnValue=statement.getReturnValue();
            if (returnValue != null) {
              returnTypes.add(returnValue.getType());
            }
          }
          @Override public void visitClass(          PsiClass aClass){
          }
          @Override public void visitLambdaExpression(          PsiLambdaExpression expression){
          }
        }
);
      }
      final PsiMethod[] constructors=existingClass.getConstructors();
      constr:       for (      PsiMethod constructor : constructors) {
        final PsiParameter[] parameters=constructor.getParameterList().getParameters();
        if (parameters.length == 1) {
          final PsiParameter parameter=parameters[0];
          final PsiType parameterType=parameter.getType();
          for (          PsiType returnType : returnTypes) {
            if (getInferredType(parameterType,returnType,existingClass,myMethod) == null && !TypeConversionUtil.isAssignable(parameterType,returnType)) {
              continue constr;
            }
          }
          final PsiCodeBlock body=constructor.getBody();
          LOG.assertTrue(body != null);
          final boolean[] found=new boolean[1];
          body.accept(new JavaRecursiveElementWalkingVisitor(){
            @Override public void visitAssignmentExpression(            final PsiAssignmentExpression expression){
              super.visitAssignmentExpression(expression);
              final PsiExpression lExpression=expression.getLExpression();
              if (lExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression)lExpression).resolve() == myDelegateField) {
                final PsiExpression rExpression=expression.getRExpression();
                if (rExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression)rExpression).resolve() == parameter) {
                  found[0]=true;
                }
              }
            }
          }
);
          if (found[0]) {
            foundConstructor=true;
            break;
          }
        }
      }
      if (!foundConstructor) {
        conflicts.putValue(existingClass,"Existing class does not have appropriate constructor");
      }
    }
    if (myUnwrapMethodName.length() == 0) {
      conflicts.putValue(existingClass,"Existing class does not have getter for selected field");
    }
  }
 else {
    if (existingClass != null) {
      conflicts.putValue(existingClass,RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"));
    }
    if (myMoveDestination != null && !myMoveDestination.isTargetAccessible(myProject,myMethod.getContainingFile().getVirtualFile())) {
      conflicts.putValue(myMethod,"Created class won't be accessible in the call place");
    }
  }
  return showConflicts(conflicts,refUsages.get());
}
