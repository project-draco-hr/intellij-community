{
  if (!UpdateSettings.getInstance().CHECK_NEEDED)   return;
  final UnknownFeaturesCollector collectorSuggester=UnknownFeaturesCollector.getInstance(project);
  final Set<UnknownFeature> unknownFeatures=collectorSuggester.getUnknownFeatures();
  final KnownExtensions extensions=loadExtensions();
  if (extensions != null && unknownFeatures.isEmpty())   return;
  final Runnable runnable=new Runnable(){
    public void run(){
      final Application application=ApplicationManager.getApplication();
      if (application.isUnitTestMode() || application.isHeadlessEnvironment())       return;
      ProgressManager.getInstance().run(new Task.Backgroundable(project,"Search for non-bundled plugins in plugin repository..."){
        private final Set<PluginDownloader> myPlugins=new HashSet<PluginDownloader>();
        private List<IdeaPluginDescriptor> myAllPlugins;
        private Map<Plugin,IdeaPluginDescriptor> myDisabledPlugins=new HashMap<Plugin,IdeaPluginDescriptor>();
        private boolean myBundledPlugins=false;
        @Override public void run(        @NotNull ProgressIndicator indicator){
          try {
            myAllPlugins=RepositoryHelper.loadPluginsFromRepository(indicator);
            if (project.isDisposed())             return;
            if (extensions == null) {
              loadSupportedExtensions(myAllPlugins);
              EditorNotifications.getInstance(project).updateAllNotifications();
            }
            int idx=0;
            final Map<String,Plugin> ids=new HashMap<String,Plugin>();
            for (            UnknownFeature feature : unknownFeatures) {
              indicator.setText("Searching for plugin supporting \'" + feature.getImplementationName() + "\'");
              ProgressManager.checkCanceled();
              final List<Plugin> pluginId=retrieve(feature);
              if (pluginId != null) {
                for (                Plugin plugin : pluginId) {
                  ids.put(plugin.myPluginId,plugin);
                }
              }
              indicator.setFraction(((double)idx++) / unknownFeatures.size());
            }
            final List<String> disabledPlugins=PluginManagerCore.getDisabledPlugins();
            for (            String id : ids.keySet()) {
              Plugin plugin=ids.get(id);
              if (disabledPlugins.contains(id)) {
                final IdeaPluginDescriptor pluginDescriptor=PluginManager.getPlugin(PluginId.getId(id));
                if (pluginDescriptor != null) {
                  myDisabledPlugins.put(plugin,pluginDescriptor);
                }
              }
            }
            myBundledPlugins=hasBundledNotInstalledPlugin(ids.values());
            for (            IdeaPluginDescriptor loadedPlugin : myAllPlugins) {
              final PluginId pluginId=loadedPlugin.getPluginId();
              if (ids.containsKey(pluginId.getIdString()) && !disabledPlugins.contains(pluginId.getIdString())) {
                myPlugins.add(PluginDownloader.createDownloader(loadedPlugin));
              }
            }
          }
 catch (          Exception e) {
            LOG.info(e);
          }
        }
        @Override public void onSuccess(){
          String message=null;
          if (!myPlugins.isEmpty() || !myDisabledPlugins.isEmpty()) {
            message="Features covered by non-bundled plugins are detected.<br>";
            if (!myDisabledPlugins.isEmpty()) {
              message+="<a href=\"enable\">Enable plugins...</a><br>";
            }
 else {
              message+="<a href=\"configure\">Configure plugins...</a><br>";
            }
            message+="<a href=\"ignore\">Ignore All</a>";
          }
 else           if (myBundledPlugins && !PropertiesComponent.getInstance().isTrueValue(IGNORE_ULTIMATE_EDITION)) {
            message="Features covered by IntelliJ IDEA Ultimate Edition are detected.<br>" + "<a href=\"open\">" + CHECK_ULTIMATE_EDITION_TITLE + "</a><br>"+ "<a href=\"ignoreUltimate\">"+ ULTIMATE_EDITION_SUGGESTION+ "</a>";
          }
          if (message != null) {
            final String displayId="Plugins Suggestion";
            final ConfigurePluginsListener notificationListener=new ConfigurePluginsListener(unknownFeatures,project,myAllPlugins,myPlugins,myDisabledPlugins);
            new NotificationGroup(displayId,NotificationDisplayType.STICKY_BALLOON,true).createNotification(displayId,message,NotificationType.INFORMATION,notificationListener).notify(project);
          }
        }
      }
);
    }
  }
;
  SwingUtilities.invokeLater(runnable);
}
