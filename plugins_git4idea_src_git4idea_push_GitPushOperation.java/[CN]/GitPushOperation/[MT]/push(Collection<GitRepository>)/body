{
  Map<GitRepository,GitPushRepoResult> results=ContainerUtil.newLinkedHashMap();
  for (  GitRepository repository : repositories) {
    PushSpec<GitPushSource,GitPushTarget> spec=myPushSpecs.get(repository);
    Pair<List<GitPushNativeResult>,String> resultOrError=doPush(repository,spec);
    LOG.debug("Pushed to " + DvcsUtil.getShortRepositoryName(repository) + ": "+ resultOrError);
    GitLocalBranch source=spec.getSource().getBranch();
    GitPushTarget target=spec.getTarget();
    GitPushRepoResult repoResult;
    if (resultOrError.second != null) {
      repoResult=GitPushRepoResult.error(source,target.getBranch(),resultOrError.second);
    }
 else {
      List<GitPushNativeResult> result=resultOrError.first;
      final GitPushNativeResult branchResult=getBranchResult(result);
      if (branchResult == null) {
        LOG.error("No result for branch among: [" + result + "]");
        continue;
      }
      List<GitPushNativeResult> tagResults=ContainerUtil.filter(result,new Condition<GitPushNativeResult>(){
        @Override public boolean value(        GitPushNativeResult result){
          return !result.equals(branchResult) && (result.getType() == GitPushNativeResult.Type.NEW_REF || result.getType() == GitPushNativeResult.Type.FORCED_UPDATE);
        }
      }
);
      int commits=collectNumberOfPushedCommits(repository.getRoot(),branchResult);
      repoResult=GitPushRepoResult.convertFromNative(branchResult,tagResults,commits,source,target.getBranch());
    }
    LOG.debug("Converted result: " + repoResult);
    results.put(repository,repoResult);
  }
  for (  GitRepository repository : repositories) {
    if (!results.containsKey(repository)) {
      PushSpec<GitPushSource,GitPushTarget> spec=myPushSpecs.get(repository);
      results.put(repository,GitPushRepoResult.notPushed(spec.getSource().getBranch(),spec.getTarget().getBranch()));
    }
  }
  return results;
}
