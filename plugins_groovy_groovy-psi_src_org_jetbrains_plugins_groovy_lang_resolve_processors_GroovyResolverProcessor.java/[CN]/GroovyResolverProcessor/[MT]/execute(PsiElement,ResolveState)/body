{
  if (!(element instanceof PsiNamedElement))   return true;
  final PsiNamedElement namedElement=(PsiNamedElement)element;
  final PsiElement resolveContext=state.get(ClassHint.RESOLVE_CONTEXT);
  final GroovyResolveKind kind=computeKindAndCheckName(namedElement,resolveContext);
  if (!myAcceptableKinds.contains(kind))   return true;
  if (kind != GroovyResolveKind.PROPERTY && kind != GroovyResolveKind.METHOD) {
    if (!myCandidates.get(kind).isEmpty())     return true;
  }
  final GroovyResolveResultImpl candidate;
{
    PsiSubstitutor substitutor=state.get(PsiSubstitutor.KEY);
    if (substitutor == null)     substitutor=PsiSubstitutor.EMPTY;
    if (kind == GroovyResolveKind.PROPERTY && mySubstitutorComputer.getValue() != null) {
      substitutor=mySubstitutorComputer.getValue().obtainSubstitutor(substitutor,(PsiMethod)element,resolveContext);
    }
    final SpreadState spreadState=state.get(SpreadState.SPREAD_STATE);
    final boolean isAccessible=isAccessible(myRef,namedElement);
    final boolean isStaticsOK=isStaticsOK(myRef,namedElement,resolveContext,false);
    candidate=new GroovyResolveResultImpl(namedElement,resolveContext,spreadState,substitutor,isAccessible,isStaticsOK,kind == GroovyResolveKind.PROPERTY,true);
  }
  (candidate.isValidResult() ? myCandidates : myInapplicableCandidates).putValue(kind,candidate);
  return true;
}
