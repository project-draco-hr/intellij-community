{
  if (LOG.isDebugEnabled()) {
    LOG.debug("enter: lock(configPath='" + configPath + "', systemPath='"+ systemPath+ "')");
  }
  final File config=new File(configPath);
  final File system=new File(systemPath);
  final File portMarkerC=new File(config,"port");
  final File portMarkerS=new File(system,"port");
  return executeAndClose(new Executor<ActivateStatus>(){
    @Override public ActivateStatus execute(    @NotNull List<Closeable> closeables) throws IOException {
      lockPortMarker(config,closeables);
      lockPortMarker(system,closeables);
      MultiMap<Integer,String> portToPath=MultiMap.createSmart();
      addExistingPort(portMarkerC,configPath,portToPath);
      addExistingPort(portMarkerS,systemPath,portToPath);
      if (!portToPath.isEmpty()) {
        for (        Map.Entry<Integer,Collection<String>> entry : portToPath.entrySet()) {
          ActivateStatus status=tryActivate(entry.getKey(),entry.getValue(),args);
          if (status != ActivateStatus.NO_INSTANCE) {
            return status;
          }
        }
      }
      byte[] portBytes=Integer.toString(acquiredPort).getBytes(CharsetToolkit.UTF8_CHARSET);
      FileUtil.writeToFile(portMarkerC,portBytes);
      FileUtil.writeToFile(portMarkerS,portBytes);
      myLockedPaths[0]=configPath;
      myLockedPaths[1]=systemPath;
      return ActivateStatus.NO_INSTANCE;
    }
  }
);
}
