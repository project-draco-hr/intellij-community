{
  IElementType type=super.getTokenType();
  String tokenText=super.getTokenText();
switch (myState) {
case init:
    if (type == PyTokenTypes.BACKSLASH)     break;
  if (PyTokenTypes.WHITESPACE_OR_LINEBREAK.contains(type))   break;
if (PyTokenTypes.END_OF_LINE_COMMENT == type) break;
if (PyTokenTypes.DOCSTRING == type) break;
if (type == PyTokenTypes.FROM_KEYWORD) myState=state.pending_future;
 else myState=state.stop;
break;
case pending_future:
if (type == PyTokenTypes.BACKSLASH) break;
if (PyTokenTypes.WHITESPACE_OR_LINEBREAK.contains(type)) break;
if (type == PyTokenTypes.IDENTIFIER && PyNames.FUTURE_MODULE.equals(tokenText)) myState=state.pending_import;
 else myState=state.stop;
break;
case pending_import:
if (type == PyTokenTypes.BACKSLASH) break;
if (PyTokenTypes.WHITESPACE_OR_LINEBREAK.contains(type)) break;
if (type == PyTokenTypes.IMPORT_KEYWORD) myState=state.pending_lpar;
 else myState=state.stop;
break;
case pending_lpar:
if (type == PyTokenTypes.LPAR) {
myState=state.pending_id;
break;
}
case pending_id:
if (type == PyTokenTypes.BACKSLASH) break;
if (PyTokenTypes.WHITESPACE_OR_LINEBREAK.contains(type)) break;
if (type == PyTokenTypes.IDENTIFIER) {
myState=state.pending_comma;
if (PyNames.UNICODE_LITERALS.equals(tokenText)) {
hasUnicodeImport=true;
myImportOffset=getTokenEnd();
}
}
 else myState=state.init;
break;
case pending_comma:
if (type == PyTokenTypes.RPAR) break;
if (type == PyTokenTypes.BACKSLASH) break;
if (PyTokenTypes.LINE_BREAK == type) myState=state.init;
if (PyTokenTypes.WHITESPACE_OR_LINEBREAK.contains(type)) break;
if (type == PyTokenTypes.COMMA) myState=state.pending_id;
break;
}
super.advance();
}
