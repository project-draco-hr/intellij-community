{
  final Document doc=editor.getDocument();
  final int endOffset=endLine < doc.getLineCount() ? doc.getLineEndOffset(endLine) : doc.getTextLength();
  final int textImageWidth=Math.min(editor.getMaxWidthInRange(doc.getLineStartOffset(startLine),endOffset),ScreenUtil.getScreenRectangle(1,1).width);
  LOG.assertTrue(textImageWidth > 0,"TextWidth: " + textImageWidth + "; startLine:"+ startLine+ "; endLine:"+ endLine+ ";");
  FoldingModelEx foldingModel=editor.getFoldingModel();
  boolean isFoldingEnabled=foldingModel.isFoldingEnabled();
  if (!showFolding) {
    foldingModel.setFoldingEnabled(false);
  }
  Point p1=editor.logicalPositionToXY(new LogicalPosition(startLine,0));
  Point p2=editor.logicalPositionToXY(new LogicalPosition(Math.max(endLine,startLine + 1),0));
  final int y1=p1.y;
  int y2=p2.y;
  final int textImageHeight=y2 - y1 == 0 ? editor.getLineHeight() : y2 - y1;
  LOG.assertTrue(textImageHeight > 0,"Height: " + textImageHeight + "; startLine:"+ startLine+ "; endLine:"+ endLine+ "; p1:"+ p1+ "; p2:"+ p2);
  int savedScrollOffset=editor.getScrollingModel().getHorizontalScrollOffset();
  if (savedScrollOffset > 0) {
    editor.stopOptimizedScrolling();
    editor.getScrollingModel().scrollHorizontally(0);
  }
  final BufferedImage textImage=UIUtil.createImage(textImageWidth,textImageHeight,BufferedImage.TYPE_INT_RGB);
  Graphics textGraphics=textImage.getGraphics();
  UISettings.setupAntialiasing(textGraphics);
  final JComponent rowHeader;
  final BufferedImage markersImage;
  final int markersImageWidth;
  if (showGutter) {
    rowHeader=editor.getGutterComponentEx();
    markersImageWidth=Math.max(1,rowHeader.getWidth());
    markersImage=UIUtil.createImage(markersImageWidth,textImageHeight,BufferedImage.TYPE_INT_RGB);
    Graphics markerGraphics=markersImage.getGraphics();
    UISettings.setupAntialiasing(markerGraphics);
    markerGraphics.translate(0,-y1);
    markerGraphics.setClip(0,y1,rowHeader.getWidth(),textImageHeight);
    markerGraphics.setColor(getBackgroundColor(editor));
    markerGraphics.fillRect(0,y1,rowHeader.getWidth(),textImageHeight);
    rowHeader.paint(markerGraphics);
  }
 else {
    markersImageWidth=0;
    rowHeader=null;
    markersImage=null;
  }
  textGraphics.translate(0,-y1);
  textGraphics.setClip(0,y1,textImageWidth,textImageHeight);
  final boolean wasVisible=editor.setCaretVisible(false);
  editor.getContentComponent().paint(textGraphics);
  if (wasVisible) {
    editor.setCaretVisible(true);
  }
  if (!showFolding) {
    foldingModel.setFoldingEnabled(isFoldingEnabled);
  }
  if (savedScrollOffset > 0) {
    editor.stopOptimizedScrolling();
    editor.getScrollingModel().scrollHorizontally(savedScrollOffset);
  }
  final JComponent component=new JComponent(){
    private static final int R=6;
    @Override public Dimension getPreferredSize(){
      return new Dimension(textImageWidth + markersImageWidth,textImageHeight);
    }
    @Override protected void paintComponent(    Graphics g){
      Graphics2D graphics=(Graphics2D)g;
      if (markersImage != null) {
        UIUtil.drawImage(graphics,markersImage,0,0,null);
        UIUtil.drawImage(graphics,textImage,rowHeader.getWidth(),0,null);
      }
 else {
        UIUtil.drawImage(graphics,textImage,0,0,null);
      }
      if (highlighters.length == 0 || !ApplicationManager.getApplication().isInternal())       return;
      List<Pair<RangeHighlighter,int[]>> list=Arrays.asList(highlighters);
      Collections.sort(list,new Comparator<Pair<RangeHighlighter,int[]>>(){
        public int compare(        Pair<RangeHighlighter,int[]> p1,        Pair<RangeHighlighter,int[]> p2){
          LogicalPosition startPos1=editor.offsetToLogicalPosition(p1.getSecond()[0]);
          LogicalPosition startPos2=editor.offsetToLogicalPosition(p2.getSecond()[0]);
          if (startPos1.line != startPos2.line)           return 0;
          return startPos1.column - startPos2.column;
        }
      }
);
      Map<Integer,Integer> rightEdges=new HashMap<Integer,Integer>();
      for (      Pair<RangeHighlighter,int[]> highlightInfo : list) {
        RangeHighlighter highlighter=highlightInfo.getFirst();
        int hStartOffset=highlightInfo.getSecond()[0];
        int hEndOffset=highlightInfo.getSecond()[1];
        Object tooltip=highlighter.getErrorStripeTooltip();
        if (tooltip == null)         continue;
        String s=String.valueOf(tooltip);
        if (s.isEmpty())         continue;
        final int endOffset2=endLine - 1 < doc.getLineCount() ? doc.getLineEndOffset(endLine - 1) : doc.getTextLength();
        if (hEndOffset < doc.getLineStartOffset(startLine))         continue;
        if (hStartOffset > endOffset2 || doc.getLineNumber(hStartOffset) > endLine)         continue;
        LogicalPosition logicalPosition=editor.offsetToLogicalPosition(hStartOffset);
        Point placeToShow=editor.logicalPositionToXY(logicalPosition);
        placeToShow.y-=(y1 - editor.getLineHeight() * 3 / 2);
        if (markersImage != null) {
          placeToShow.x+=rowHeader.getWidth();
        }
        int w=graphics.getFontMetrics().stringWidth(s);
        int a=graphics.getFontMetrics().getAscent();
        int h=editor.getLineHeight();
        Integer rightEdge=rightEdges.get(logicalPosition.line);
        if (rightEdge == null)         rightEdge=0;
        placeToShow.x=Math.max(placeToShow.x,rightEdge);
        rightEdge=Math.max(rightEdge,placeToShow.x + w + 3 * R);
        rightEdges.put(logicalPosition.line,rightEdge);
        GraphicsUtil.setupAAPainting(graphics);
        graphics.setColor(MessageType.WARNING.getPopupBackground());
        graphics.fillRoundRect(placeToShow.x - R,placeToShow.y - a,w + 2 * R,h,R,R);
        graphics.setColor(new JBColor(JBColor.GRAY,Gray._200));
        graphics.drawRoundRect(placeToShow.x - R,placeToShow.y - a,w + 2 * R,h,R,R);
        graphics.setColor(JBColor.foreground());
        graphics.drawString(s,placeToShow.x,placeToShow.y + 2);
      }
    }
  }
;
  setLayout(new GridLayout(1,1));
  add(component);
  final Color borderColor=editor.getColorsScheme().getColor(EditorColors.SELECTED_TEARLINE_COLOR);
  Border outsideBorder=BorderFactory.createLineBorder(borderColor,1);
  Border insideBorder=BorderFactory.createEmptyBorder(2,2,2,2);
  setBorder(BorderFactory.createCompoundBorder(outsideBorder,insideBorder));
}
