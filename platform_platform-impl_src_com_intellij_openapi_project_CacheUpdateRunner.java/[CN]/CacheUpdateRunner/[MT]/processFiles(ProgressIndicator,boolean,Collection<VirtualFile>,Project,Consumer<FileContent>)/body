{
  indicator.checkCanceled();
  final FileContentQueue queue=new FileContentQueue(files,indicator);
  final double total=files.size();
  queue.startLoading();
  ProgressUpdater progressUpdater=new ProgressUpdater(){
    final Set<VirtualFile> myFilesBeingProcessed=new THashSet<>();
    final AtomicInteger myNumberOfFilesProcessed=new AtomicInteger();
    private boolean fileNameWasShown;
    @Override public void processingStarted(    VirtualFile virtualFile){
      indicator.checkCanceled();
synchronized (myFilesBeingProcessed) {
        boolean added=myFilesBeingProcessed.add(virtualFile);
        if (added) {
          indicator.setFraction(myNumberOfFilesProcessed.incrementAndGet() / total);
        }
        if (!added || (virtualFile.isValid() && virtualFile.getLength() > FILE_SIZE_TO_SHOW_THRESHOLD)) {
          indicator.setText2(virtualFile.getPresentableUrl());
          fileNameWasShown=true;
        }
 else         if (fileNameWasShown) {
          indicator.setText2("");
          fileNameWasShown=false;
        }
      }
    }
    @Override public void processingSuccessfullyFinished(    VirtualFile virtualFile){
synchronized (myFilesBeingProcessed) {
        boolean removed=myFilesBeingProcessed.remove(virtualFile);
        assert removed;
      }
    }
  }
;
  while (!project.isDisposed()) {
    indicator.checkCanceled();
    if (processSomeFilesWhileUserIsInactive(queue,progressUpdater,processInReadAction,project,processor)) {
      break;
    }
  }
  if (project.isDisposed()) {
    indicator.cancel();
    indicator.checkCanceled();
  }
}
