{
  if (resultRef != null && resultRef != subjectRef) {
    reset();
  }
  DataPackUtils du=getDataPackUtils();
  if (position == InsertPosition.BELOW) {
    base=getParent(base);
  }
 else {
  }
  Node lowestInserted=nodesToInsert.get(nodesToInsert.size() - 1);
  if (du.isAncestorOf(base,lowestInserted)) {
    this.branchBase=base;
  }
 else {
    this.branchBase=getParent(lowestInserted);
  }
  if (!fakeBranch.isEmpty()) {
    FakeCommitParents lowestFakeCommit=fakeBranch.get(fakeBranch.size() - 1);
    Node lowestFakeNode=du.getNodeByHash(lowestFakeCommit.getCommitHash());
    if (du.isAncestorOf(lowestFakeNode,branchBase)) {
      branchBase=getParent(lowestFakeNode);
    }
  }
  Set<Node> nodesToRemove=new HashSet<Node>(nodesToInsert);
  List<Node> branch=du.getCommitsInBranchAboveBase(this.branchBase,du.getNodeByHash(subjectRef.getCommitHash()));
  List<Node> result=new ArrayList<Node>();
  boolean baseFound=false;
  for (  Node node : branch) {
    if (node == base) {
      result.addAll(nodesToInsert);
      baseFound=true;
    }
    if (!nodesToRemove.contains(node)) {
      result.add(node);
    }
  }
  if (!baseFound) {
    result.addAll(nodesToInsert);
  }
  this.fakeBranch=createFakeCommits(this.branchBase,result);
  int maxIndex=-1;
  for (  Node node : result) {
    if (maxIndex < node.getRowIndex()) {
      maxIndex=node.getRowIndex();
    }
  }
  insertAfter=maxIndex + 1;
  setResultRef(subjectRef);
}
