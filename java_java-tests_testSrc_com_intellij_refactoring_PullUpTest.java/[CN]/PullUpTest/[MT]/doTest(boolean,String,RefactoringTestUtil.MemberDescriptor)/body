{
  final MultiMap<PsiElement,String> conflictsMap=new MultiMap<PsiElement,String>();
  configureByFile(BASE_PATH + getTestName(false) + ".java");
  PsiElement elementAt=getFile().findElementAt(getEditor().getCaretModel().getOffset());
  final PsiClass sourceClass=PsiTreeUtil.getParentOfType(elementAt,PsiClass.class);
  assertNotNull(sourceClass);
  PsiClass targetClass=sourceClass.getSuperClass();
  assertNotNull(targetClass);
  if (!targetClass.isWritable()) {
    final PsiClass[] interfaces=sourceClass.getInterfaces();
    assertEquals(1,interfaces.length);
    assertTrue(interfaces[0].isWritable());
    targetClass=interfaces[0];
  }
  final MemberInfo[] infos=RefactoringTestUtil.findMembers(sourceClass,membersToFind);
  final int[] countMoved={0};
  final MoveMemberListener listener=new MoveMemberListener(){
    @Override public void memberMoved(    PsiClass aClass,    PsiMember member){
      assertEquals(sourceClass,aClass);
      countMoved[0]++;
    }
  }
;
  JavaRefactoringListenerManager.getInstance(getProject()).addMoveMembersListener(listener);
  final PsiDirectory targetDirectory=targetClass.getContainingFile().getContainingDirectory();
  final PsiPackage targetPackage=targetDirectory != null ? JavaDirectoryService.getInstance().getPackage(targetDirectory) : null;
  conflictsMap.putAllValues(PullUpConflictsUtil.checkConflicts(infos,sourceClass,targetClass,targetPackage,targetDirectory,new InterfaceContainmentVerifier(){
    @Override public boolean checkedInterfacesContain(    PsiMethod psiMethod){
      return PullUpProcessor.checkedInterfacesContain(Arrays.asList(infos),psiMethod);
    }
  }
));
  final PullUpProcessor helper=new PullUpProcessor(sourceClass,targetClass,infos,new DocCommentPolicy(DocCommentPolicy.ASIS));
  helper.run();
  UIUtil.dispatchAllInvocationEvents();
  JavaRefactoringListenerManager.getInstance(getProject()).removeMoveMembersListener(listener);
  if (conflictMessage != null && conflictsMap.isEmpty()) {
    fail("Conflict was not detected");
  }
  if (conflictMessage == null && !conflictsMap.isEmpty()) {
    fail(conflictsMap.values().iterator().next());
  }
  if (conflictMessage != null && !IGNORE_CONFLICTS.equals(conflictMessage)) {
    assertEquals(conflictMessage,conflictsMap.values().iterator().next());
    return;
  }
  if (checkMembersMovedCount) {
    assertEquals(countMoved[0],membersToFind.length);
  }
  checkResultByFile(BASE_PATH + getTestName(false) + "_after.java");
}
