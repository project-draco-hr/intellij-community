{
  super.visitMethod(method);
  if (!method.hasModifierProperty(PsiModifier.STATIC)) {
    return;
  }
  if (method.hasModifierProperty(PsiModifier.PRIVATE)) {
    return;
  }
  if (method.getNameIdentifier() == null) {
    return;
  }
  final UsageProcessor usageProcessor=new UsageProcessor();
  final PsiClass usageClass=usageProcessor.getUsageClass(method);
  if (usageClass == null) {
    return;
  }
  final PsiClass containingClass=method.getContainingClass();
  if (usageClass.equals(containingClass)) {
    return;
  }
  if (ignoreOnConflicts) {
    if (usageClass.findMethodsBySignature(method,true).length > 0 || !areReferenceTargetsAccessible(method,usageClass)) {
      return;
    }
  }
  if (ignoreTestClasses && TestUtils.isInTestCode(usageClass)) {
    return;
  }
  if (usageClass instanceof PsiAnonymousClass) {
    if (ignoreAnonymousClasses) {
      return;
    }
    if (PsiTreeUtil.isAncestor(containingClass,usageClass,true)) {
      return;
    }
    final PsiClass[] interfaces=usageClass.getInterfaces();
    final PsiClass superClass;
    if (interfaces.length == 1) {
      superClass=interfaces[0];
      registerMethodError(method,superClass,Boolean.FALSE);
    }
 else {
      superClass=usageClass.getSuperClass();
      if (superClass == null) {
        return;
      }
      registerMethodError(method,superClass,Boolean.TRUE);
    }
  }
 else {
    registerMethodError(method,usageClass);
  }
}
