{
  Set<Instruction> entryPoints=ContainerUtil.newHashSet();
  if (forward) {
    entryPoints.add(myInstructions[0]);
  }
 else {
    entryPoints.addAll(ContainerUtil.findAll(myInstructions,FilteringIterator.instanceOf(ReturnInstruction.class)));
  }
  Queue<InstructionState> queue=new Queue<>(10);
  for (  Instruction i : entryPoints) {
    queue.addLast(new InstructionState(i,new BitSet()));
  }
  int limit=myForwardMap.size() * 20;
  Set<InstructionState> processed=ContainerUtil.newHashSet();
  while (!queue.isEmpty()) {
    int steps=processed.size();
    if (steps > limit) {
      return false;
    }
    if (steps % 1024 == 0) {
      ProgressManager.checkCanceled();
    }
    InstructionState state=queue.pullFirst();
    Instruction instruction=state.first;
    Collection<Instruction> nextInstructions=forward ? myForwardMap.get(instruction) : myBackwardMap.get(instruction);
    BitSet nextVars=handleState.fun(instruction,state.second);
    for (    Instruction next : nextInstructions) {
      InstructionState nextState=new InstructionState(next,nextVars);
      if (processed.add(nextState)) {
        queue.addLast(nextState);
      }
    }
  }
  return true;
}
