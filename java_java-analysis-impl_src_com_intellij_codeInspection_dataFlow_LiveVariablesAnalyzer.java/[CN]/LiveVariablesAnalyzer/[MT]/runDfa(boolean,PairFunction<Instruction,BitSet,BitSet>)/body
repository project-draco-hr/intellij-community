{
  Set<Instruction> entryPoints=ContainerUtil.newHashSet();
  if (forward) {
    entryPoints.add(myInstructions[0]);
  }
 else {
    entryPoints.addAll(ContainerUtil.findAll(myInstructions,FilteringIterator.instanceOf(ReturnInstruction.class)));
  }
  Queue<InstructionState> queue=new Queue<InstructionState>(10);
  for (  Instruction i : entryPoints) {
    queue.addLast(new InstructionState(i,new BitSet()));
  }
  int steps=0;
  Set<InstructionState> processed=ContainerUtil.newHashSet();
  while (!queue.isEmpty()) {
    steps++;
    InstructionState state=queue.pullFirst();
    Instruction instruction=state.first;
    Collection<Instruction> nextInstructions=forward ? getSuccessors(instruction) : myBackwardMap.get(instruction);
    boolean branching=nextInstructions.size() > 1 || !forward && instruction.getIndex() == 0;
    BitSet nextVars=handleState.fun(instruction,state.second);
    for (    Instruction next : nextInstructions) {
      InstructionState nextState=new InstructionState(next,nextVars);
      if (!branching || processed.add(nextState)) {
        queue.addLast(nextState);
      }
    }
  }
  if (steps > 10000) {
    int a=1;
  }
}
