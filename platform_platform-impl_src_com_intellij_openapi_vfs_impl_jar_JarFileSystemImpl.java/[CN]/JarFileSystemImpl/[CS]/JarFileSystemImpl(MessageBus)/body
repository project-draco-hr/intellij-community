{
  boolean noCopy=SystemProperties.getBooleanProperty("idea.jars.nocopy",!SystemInfo.isWindows);
  myNoCopyJarPaths=noCopy ? null : new ConcurrentHashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
  bus.connect().subscribe(VirtualFileManager.VFS_CHANGES,new BulkFileListener.Adapter(){
    @Override public void after(    @NotNull final List<? extends VFileEvent> events){
      final List<VirtualFile> rootsToRefresh=new ArrayList<VirtualFile>();
      for (      VFileEvent event : events) {
        if (event.getFileSystem() instanceof LocalFileSystem) {
          String path=event.getPath();
          String[] jarPaths;
synchronized (LOCK) {
            jarPaths=myJarPathsCache;
            if (jarPaths == null) {
              myJarPathsCache=jarPaths=ArrayUtil.toStringArray(myHandlers.keySet());
            }
          }
          for (          String jarPath : jarPaths) {
            final String jarFile=jarPath.substring(0,jarPath.length() - JAR_SEPARATOR.length());
            if (FileUtil.startsWith(jarFile,path)) {
              VirtualFile jarRootToRefresh=markDirty(jarPath);
              if (jarRootToRefresh != null) {
                rootsToRefresh.add(jarRootToRefresh);
              }
            }
          }
        }
      }
      if (!rootsToRefresh.isEmpty()) {
        for (        VirtualFile root : rootsToRefresh) {
          if (root.isValid()) {
            ((NewVirtualFile)root).markDirtyRecursively();
          }
        }
        RefreshQueue.getInstance().refresh(!ApplicationManager.getApplication().isUnitTestMode(),true,null,rootsToRefresh);
      }
    }
  }
);
}
