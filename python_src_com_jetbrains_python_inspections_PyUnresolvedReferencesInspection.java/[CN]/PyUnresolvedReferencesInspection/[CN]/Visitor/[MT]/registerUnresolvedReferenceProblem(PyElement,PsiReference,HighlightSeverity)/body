{
  final StringBuilder description_buf=new StringBuilder("");
  final String text=reference.getElement().getText();
  final String ref_text=reference.getRangeInElement().substring(text);
  final PsiElement element=reference.getElement();
  final boolean ref_is_importable=PythonReferenceImporter.isImportable(element);
  final List<LocalQuickFix> actions=new ArrayList<LocalQuickFix>(2);
  if (ref_text.length() <= 0)   return;
  final String refname=(element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;
  if (element instanceof PyReferenceExpression) {
    PyReferenceExpression refex=(PyReferenceExpression)element;
    if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {
      return;
    }
    if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {
      return;
    }
    if (refex.getQualifier() != null) {
      final PyClassType object_type=PyBuiltinCache.getInstance(node).getObjectType();
      if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname))       return;
    }
 else {
      if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {
        if (refname.equals("with")) {
          actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));
        }
      }
      PyClass containedClass=PsiTreeUtil.getParentOfType(node,PyClass.class);
      if (containedClass != null) {
        for (        PyTargetExpression target : containedClass.getInstanceAttributes()) {
          if (Comparing.strEqual(node.getName(),target.getName())) {
            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
          }
        }
        for (        PyStatement statement : containedClass.getStatementList().getStatements()) {
          if (statement instanceof PyAssignmentStatement) {
            if (((PyAssignmentStatement)statement).getLeftHandSideExpression().getText().equals(refex.getText())) {
              PyExpression callexpr=((PyAssignmentStatement)statement).getAssignedValue();
              if (callexpr instanceof PyCallExpression) {
                PyType type=myTypeEvalContext.getType(callexpr);
                if (type != null && type instanceof PyClassType) {
                  String name=((PyCallExpression)callexpr).getCallee().getText();
                  if (name != null && name.equals("property"))                   actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
                }
              }
            }
          }
        }
        for (        PyFunction method : containedClass.getMethods()) {
          if (method.getName().equals(refex.getText())) {
            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
          }
        }
      }
      PyCallExpression callExpression=PsiTreeUtil.getParentOfType(element,PyCallExpression.class);
      if (callExpression != null)       actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression,refex));
    }
    if (PyModuleType.getPossibleInstanceMembers().contains(refname))     return;
    if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node,PyImportElement.class),PyTryExceptStatement.class,PyIfStatement.class) != null)) {
      severity=HighlightSeverity.WEAK_WARNING;
      String errmsg=PyBundle.message("INSP.module.$0.not.found",ref_text);
      description_buf.append(errmsg);
    }
  }
  if (reference instanceof DocStringParameterReference) {
    if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))     return;
  }
  if (reference instanceof PsiReferenceEx) {
    final String s=((PsiReferenceEx)reference).getUnresolvedDescription();
    if (s != null)     description_buf.append(s);
  }
  if (description_buf.length() == 0) {
    boolean marked_qualified=false;
    if (element instanceof PyQualifiedExpression) {
      final PyQualifiedExpression qexpr=(PyQualifiedExpression)element;
      if (PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName())) {
        return;
      }
      final PyExpression qualifier=qexpr.getQualifier();
      if (qualifier != null) {
        PyType qtype=myTypeEvalContext.getType(qualifier);
        if (qtype != null) {
          if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference || (qtype instanceof PyUnionType && ((PyUnionType)qtype).isWeak())) {
            return;
          }
          if (qtype instanceof PyClassType) {
            PyClass cls=((PyClassType)qtype).getPyClass();
            if (cls != null) {
              if (overridesGetAttr(cls)) {
                return;
              }
              if (cls.findProperty(ref_text) != null) {
                return;
              }
              if (!PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {
                if (element.getParent() instanceof PyCallExpression) {
                  actions.add(new AddMethodQuickFix(ref_text,(PyClassType)qtype));
                }
 else                 if (!(reference instanceof PyOperatorReferenceImpl)) {
                  actions.add(new AddFieldQuickFix(ref_text,cls,"None"));
                }
              }
            }
            if (reference instanceof PyOperatorReferenceImpl) {
              description_buf.append(PyBundle.message("INSP.unresolved.operator.ref",qtype.getName(),refname,((PyOperatorReferenceImpl)reference).getReadableOperatorName()));
            }
 else {
              description_buf.append(PyBundle.message("INSP.unresolved.ref.$0.for.class.$1",ref_text,qtype.getName()));
            }
            marked_qualified=true;
          }
 else           if (qtype instanceof PyModuleType) {
            PsiFile file=((PyModuleType)qtype).getModule();
            if (file instanceof PyFile) {
              actions.add(new AddFunctionQuickFix(ref_text,(PyFile)file));
            }
          }
 else {
            description_buf.append(PyBundle.message("INSP.cannot.find.$0.in.$1",ref_text,qtype.getName()));
            marked_qualified=true;
          }
        }
      }
    }
    if (!marked_qualified) {
      description_buf.append(PyBundle.message("INSP.unresolved.ref.$0",ref_text));
      if (ref_text.equals("true") || ref_text.equals("false"))       actions.add(new UnresolvedRefTrueFalseQuickFix(element));
      if (ref_is_importable) {
        AutoImportQuickFix importFix=PythonReferenceImporter.proposeImportFix(node,reference,ref_text);
        if (importFix != null) {
          if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {
            final AutoImportHintAction autoImportHintAction=new AutoImportHintAction(importFix);
            actions.add(autoImportHintAction);
          }
 else {
            actions.add(importFix);
          }
        }
      }
      if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) && PsiTreeUtil.getParentOfType(element,PyImportStatementBase.class) == null) {
        PsiElement anchor=element;
        if (element instanceof PyQualifiedExpression) {
          final PyExpression qexpr=((PyQualifiedExpression)element).getQualifier();
          if (qexpr != null) {
            final PyType type=myTypeEvalContext.getType(qexpr);
            if (type instanceof PyModuleType) {
              anchor=((PyModuleType)type).getModule();
            }
 else {
              anchor=null;
            }
          }
          if (anchor != null) {
            actions.add(new CreateClassQuickFix(ref_text,anchor));
          }
        }
      }
    }
  }
  String description=description_buf.toString();
  ProblemHighlightType hl_type;
  if (severity == HighlightSeverity.WARNING) {
    hl_type=ProblemHighlightType.GENERIC_ERROR_OR_WARNING;
  }
 else {
    hl_type=ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;
  }
  if (GenerateBinaryStubsFix.isApplicable(reference)) {
    actions.add(new GenerateBinaryStubsFix(reference));
  }
  actions.add(new AddIgnoredIdentifierFix(ref_text));
  addPluginQuickFixes(reference,actions);
  PsiElement point=node.getLastChild();
  if (point == null)   point=node;
  TextRange range=reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());
  registerProblem(point,description,hl_type,null,range,actions.toArray(new LocalQuickFix[actions.size()]));
}
