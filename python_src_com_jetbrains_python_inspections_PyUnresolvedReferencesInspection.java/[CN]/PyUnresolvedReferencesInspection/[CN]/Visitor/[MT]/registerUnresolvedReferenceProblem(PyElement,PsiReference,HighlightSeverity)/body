{
  final StringBuilder description_buf=new StringBuilder("");
  final String text=reference.getElement().getText();
  final String ref_text=reference.getRangeInElement().substring(text);
  final PsiElement ref_element=reference.getElement();
  final boolean ref_is_importable=SyntaxMatchers.IN_IMPORT.search(ref_element) == null && IN_GLOBAL.search(ref_element) == null;
  final List<LocalQuickFix> actions=new ArrayList<LocalQuickFix>(2);
  HintAction hintAction=null;
  if (ref_text.length() <= 0)   return;
  if (reference.getElement() instanceof PyReferenceExpression) {
    PyReferenceExpression refex=(PyReferenceExpression)reference.getElement();
    String refname=refex.getReferencedName();
    if (myIgnoredIdentifiers.contains(refname)) {
      return;
    }
    if (refex.getQualifier() != null) {
      final PyClassType object_type=PyBuiltinCache.getInstance(node).getObjectType();
      if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname))       return;
    }
 else {
      if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {
        if (refname.equals("with")) {
          actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));
        }
      }
      PyClass containedClass=PsiTreeUtil.getParentOfType(node,PyClass.class);
      if (containedClass != null) {
        for (        PyTargetExpression target : containedClass.getInstanceAttributes()) {
          if (Comparing.strEqual(node.getName(),target.getName())) {
            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
          }
        }
        for (        PyStatement statement : containedClass.getStatementList().getStatements()) {
          if (statement instanceof PyAssignmentStatement) {
            if (((PyAssignmentStatement)statement).getLeftHandSideExpression().getText().equals(refex.getText())) {
              PyExpression callexpr=((PyAssignmentStatement)statement).getAssignedValue();
              if (callexpr instanceof PyCallExpression) {
                PyType type=myTypeEvalContext.getType(callexpr);
                if (type != null && type instanceof PyClassType) {
                  String name=((PyCallExpression)callexpr).getCallee().getText();
                  if (name != null && name.equals("property"))                   actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
                }
              }
            }
          }
        }
        for (        PyFunction method : containedClass.getMethods()) {
          Property property=method.getProperty();
          if (property != null && method.getName().equals(refex.getText())) {
            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));
          }
        }
      }
      PyCallExpression callExpression=PsiTreeUtil.getParentOfType(ref_element,PyCallExpression.class);
      if (callExpression != null)       actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression,refex));
    }
    if (PyModuleType.getPossibleInstanceMembers().contains(refname))     return;
    if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node,PyImportElement.class),PyTryExceptStatement.class,PyIfStatement.class) != null)) {
      severity=HighlightSeverity.WEAK_WARNING;
      String errmsg=PyBundle.message("INSP.module.$0.not.found",ref_text);
      description_buf.append(errmsg);
    }
  }
  if (reference instanceof PsiReferenceEx) {
    final String s=((PsiReferenceEx)reference).getUnresolvedDescription();
    if (s != null)     description_buf.append(s);
  }
  if (description_buf.length() == 0) {
    boolean marked_qualified=false;
    if (reference.getElement() instanceof PyQualifiedExpression) {
      final PyExpression qexpr=((PyQualifiedExpression)reference.getElement()).getQualifier();
      if (qexpr != null) {
        PyType qtype=myTypeEvalContext.getType(qexpr);
        if (qtype != null) {
          if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference || (qtype instanceof PyUnionType && ((PyUnionType)qtype).isWeak())) {
            return;
          }
          if (qtype instanceof PyClassType) {
            PyClass cls=((PyClassType)qtype).getPyClass();
            if (cls != null) {
              if (overridesGetAttr(cls)) {
                return;
              }
              if (cls.findProperty(ref_text) != null) {
                return;
              }
              if (!PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {
                if (reference.getElement().getParent() instanceof PyCallExpression) {
                  actions.add(new AddMethodQuickFix(ref_text,(PyClassType)qtype));
                }
 else                 actions.add(new AddFieldQuickFix(ref_text,cls,"None"));
              }
            }
            description_buf.append(PyBundle.message("INSP.unresolved.ref.$0.for.class.$1",ref_text,qtype.getName()));
            marked_qualified=true;
          }
 else           if (qtype instanceof PyModuleType) {
            PsiFile file=((PyModuleType)qtype).getModule();
            if (file instanceof PyFile) {
              actions.add(new AddFunctionQuickFix(ref_text,(PyFile)file));
            }
          }
 else {
            description_buf.append(PyBundle.message("INSP.cannot.find.$0.in.$1",ref_text,qtype.getName()));
            marked_qualified=true;
          }
        }
      }
    }
    if (!marked_qualified) {
      description_buf.append(PyBundle.message("INSP.unresolved.ref.$0",ref_text));
      if (ref_text.equals("true") || ref_text.equals("false"))       actions.add(new UnresolvedRefTrueFalseQuickFix(ref_element));
      if (ref_is_importable) {
        ImportFromExistingFix importFix=PythonReferenceImporter.proposeImportFix(node,ref_text);
        if (importFix != null) {
          if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {
            final AutoImportHintAction autoImportHintAction=new AutoImportHintAction(importFix);
            actions.add(autoImportHintAction);
            hintAction=autoImportHintAction;
          }
 else {
            actions.add(importFix);
          }
        }
      }
      if (ref_element != null && ref_is_importable && hintAction == null) {
        final AddImportAction addImportAction=new AddImportAction(reference);
        if (addImportAction.hasSomethingToImport(ref_element.getContainingFile())) {
          actions.add(addImportAction);
        }
      }
      if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) && PsiTreeUtil.getParentOfType(ref_element,PyImportStatement.class,PyFromImportStatement.class) == null) {
        actions.add(new CreateClassQuickFix(ref_text,reference.getElement()));
      }
    }
  }
  String description=description_buf.toString();
  ProblemHighlightType hl_type;
  if (severity == HighlightSeverity.WARNING) {
    hl_type=ProblemHighlightType.GENERIC_ERROR_OR_WARNING;
  }
 else   if (severity == HighlightSeverity.ERROR) {
    hl_type=ProblemHighlightType.ERROR;
  }
 else {
    hl_type=ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;
  }
  if (GenerateBinaryStubsFix.isApplicable(reference)) {
    actions.add(new GenerateBinaryStubsFix(reference));
  }
  actions.add(new AddIgnoredIdentifierFix(ref_text));
  addPluginQuickFixes(reference,actions);
  PsiElement point=node.getLastChild();
  if (point == null)   point=node;
  registerProblem(point,description,hl_type,null,actions.toArray(new LocalQuickFix[actions.size()]));
}
