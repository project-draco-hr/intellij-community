{
  String description=null;
  final String text=reference.getElement().getText();
  TextRange rangeInElement=reference.getRangeInElement();
  String ref_text=text;
  if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0)   ref_text=rangeInElement.substring(text);
  final PsiElement element=reference.getElement();
  final List<LocalQuickFix> actions=new ArrayList<LocalQuickFix>(2);
  if (ref_text.length() <= 0)   return;
  final String refname=(element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;
  if (element instanceof PyReferenceExpression) {
    PyReferenceExpression refex=(PyReferenceExpression)element;
    if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {
      return;
    }
    if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {
      return;
    }
    if (refex.getQualifier() != null) {
      final PyClassType object_type=PyBuiltinCache.getInstance(node).getObjectType();
      if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname))       return;
    }
 else {
      if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {
        if ("with".equals(refname)) {
          actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));
        }
      }
      if (ref_text.equals("true") || ref_text.equals("false"))       actions.add(new UnresolvedRefTrueFalseQuickFix(element));
      addAddSelfFix(node,refex,actions);
      PyCallExpression callExpression=PsiTreeUtil.getParentOfType(element,PyCallExpression.class);
      if (callExpression != null)       actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression,refex));
    }
    if (PyModuleType.getPossibleInstanceMembers().contains(refname))     return;
    if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node,PyImportElement.class),PyTryExceptStatement.class,PyIfStatement.class) != null)) {
      severity=HighlightSeverity.WEAK_WARNING;
      description=PyBundle.message("INSP.module.$0.not.found",ref_text);
    }
  }
  if (reference instanceof DocStringParameterReference) {
    if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))     return;
  }
  if (reference instanceof PsiReferenceEx && description == null) {
    description=((PsiReferenceEx)reference).getUnresolvedDescription();
  }
  if (description == null) {
    boolean marked_qualified=false;
    if (element instanceof PyQualifiedExpression) {
      final PyQualifiedExpression qexpr=(PyQualifiedExpression)element;
      if (myIgnoredIdentifiers.contains(ref_text) || PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName()) || refname == null) {
        return;
      }
      final PyExpression qualifier=qexpr.getQualifier();
      if (qualifier != null) {
        PyType qtype=myTypeEvalContext.getType(qualifier);
        if (qtype != null) {
          if (ignoreUnresolvedMemberForType(qtype,reference,ref_text)) {
            return;
          }
          addCreateMemberFromUsageFixes(qtype,reference,ref_text,actions);
          if (qtype instanceof PyClassType) {
            if (reference instanceof PyOperatorReference) {
              description=PyBundle.message("INSP.unresolved.operator.ref",qtype.getName(),refname,((PyOperatorReference)reference).getReadableOperatorName());
            }
 else {
              description=PyBundle.message("INSP.unresolved.ref.$0.for.class.$1",ref_text,qtype.getName());
            }
            marked_qualified=true;
          }
 else {
            description=PyBundle.message("INSP.cannot.find.$0.in.$1",ref_text,qtype.getName());
            marked_qualified=true;
          }
        }
      }
    }
    if (!marked_qualified) {
      description=PyBundle.message("INSP.unresolved.ref.$0",ref_text);
      if (PythonReferenceImporter.isImportable(element)) {
        addAutoImportFix(node,reference,actions);
      }
      addCreateClassFix(ref_text,element,actions);
    }
  }
  ProblemHighlightType hl_type;
  if (severity == HighlightSeverity.WARNING) {
    hl_type=ProblemHighlightType.GENERIC_ERROR_OR_WARNING;
  }
 else {
    hl_type=ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;
  }
  if (GenerateBinaryStubsFix.isApplicable(reference)) {
    actions.add(new GenerateBinaryStubsFix(reference));
  }
  actions.add(new AddIgnoredIdentifierFix(ref_text));
  addPluginQuickFixes(reference,actions);
  PsiElement point=node.getLastChild();
  if (point == null)   point=node;
  TextRange range=reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());
  if (reference instanceof PyImportReference && refname != null) {
    final PyQualifiedName qname=PyQualifiedName.fromDottedString(refname);
    final List<String> components=qname.getComponents();
    if (!components.isEmpty()) {
      final String packageName=components.get(0);
      final Module module=ModuleUtil.findModuleForPsiElement(node);
      final Sdk sdk=PythonSdkType.findPythonSdk(module);
      if (module != null && sdk != null) {
        final Map<String,String> pyPIPackages=PyPIPackageUtil.getPyPIPackages();
        boolean found=false;
        for (        String s : pyPIPackages.keySet()) {
          if (s.compareToIgnoreCase(packageName) == 0) {
            found=true;
          }
        }
        if (found) {
          final List<PyRequirement> requirements=Collections.singletonList(new PyRequirement(packageName));
          final String name="Install package " + packageName;
          actions.add(new PyPackageRequirementsInspection.InstallRequirementsFix(name,module,sdk,requirements));
        }
      }
    }
  }
  registerProblem(point,description,hl_type,null,range,actions.toArray(new LocalQuickFix[actions.size()]));
}
