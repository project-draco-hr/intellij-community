{
  final ProjectImportAction projectImportAction=new ProjectImportAction(resolverCtx.isPreviewMode());
  final List<KeyValue<String,String>> extraJvmArgs=new ArrayList<KeyValue<String,String>>();
  final List<String> commandLineArgs=ContainerUtil.newArrayList();
  final Set<Class> toolingExtensionClasses=ContainerUtil.newHashSet();
  for (GradleProjectResolverExtension resolverExtension=projectResolverChain; resolverExtension != null; resolverExtension=resolverExtension.getNext()) {
    resolverExtension.setProjectResolverContext(resolverCtx);
    resolverExtension.preImportCheck();
    projectImportAction.addExtraProjectModelClasses(resolverExtension.getExtraProjectModelClasses());
    extraJvmArgs.addAll(resolverExtension.getExtraJvmArgs());
    commandLineArgs.addAll(resolverExtension.getExtraCommandLineArgs());
    toolingExtensionClasses.addAll(resolverExtension.getToolingExtensionsClasses());
  }
  final ParametersList parametersList=new ParametersList();
  for (  KeyValue<String,String> jvmArg : extraJvmArgs) {
    parametersList.addProperty(jvmArg.getKey(),jvmArg.getValue());
  }
  BuildActionExecuter<ProjectImportAction.AllModels> buildActionExecutor=resolverCtx.getConnection().action(projectImportAction);
  File initScript=GradleExecutionHelper.generateInitScript(isBuildSrcProject,toolingExtensionClasses);
  if (initScript != null) {
    ContainerUtil.addAll(commandLineArgs,GradleConstants.INIT_SCRIPT_CMD_OPTION,initScript.getAbsolutePath());
  }
  GradleExecutionHelper.prepare(buildActionExecutor,resolverCtx.getExternalSystemTaskId(),resolverCtx.getSettings(),resolverCtx.getListener(),parametersList.getParameters(),commandLineArgs,resolverCtx.getConnection());
  ProjectImportAction.AllModels allModels;
  final CancellationTokenSource cancellationTokenSource=GradleConnector.newCancellationTokenSource();
  try {
    buildActionExecutor.withCancellationToken(cancellationTokenSource.token());
synchronized (myCancellationMap) {
      myCancellationMap.putValue(resolverCtx.getExternalSystemTaskId(),cancellationTokenSource);
    }
    allModels=buildActionExecutor.run();
    if (allModels == null) {
      throw new IllegalStateException("Unable to get project model for the project: " + resolverCtx.getProjectPath());
    }
  }
 catch (  UnsupportedVersionException unsupportedVersionException) {
    Class<? extends IdeaProject> aClass=resolverCtx.isPreviewMode() ? BasicIdeaProject.class : IdeaProject.class;
    ModelBuilder<? extends IdeaProject> modelBuilder=myHelper.getModelBuilder(aClass,resolverCtx.getExternalSystemTaskId(),resolverCtx.getSettings(),resolverCtx.getConnection(),resolverCtx.getListener(),parametersList.getParameters());
    final IdeaProject ideaProject=modelBuilder.get();
    allModels=new ProjectImportAction.AllModels(ideaProject);
  }
 finally {
synchronized (myCancellationMap) {
      myCancellationMap.remove(resolverCtx.getExternalSystemTaskId(),cancellationTokenSource);
    }
  }
  final BuildEnvironment buildEnvironment=getBuildEnvironment(resolverCtx);
  allModels.setBuildEnvironment(buildEnvironment);
  resolverCtx.setModels(allModels);
  ProjectData projectData=projectResolverChain.createProject();
  DataNode<ProjectData> projectDataNode=new DataNode<ProjectData>(ProjectKeys.PROJECT,projectData,null);
  JavaProjectData javaProjectData=projectResolverChain.createJavaProjectData();
  projectDataNode.createChild(JavaProjectData.KEY,javaProjectData);
  IdeaProject ideaProject=resolverCtx.getModels().getIdeaProject();
  projectResolverChain.populateProjectExtraModels(ideaProject,projectDataNode);
  DomainObjectSet<? extends IdeaModule> gradleModules=ideaProject.getModules();
  if (gradleModules == null || gradleModules.isEmpty()) {
    throw new IllegalStateException("No modules found for the target project: " + ideaProject);
  }
  final Map<String,Pair<DataNode<ModuleData>,IdeaModule>> moduleMap=ContainerUtilRt.newHashMap();
  for (  IdeaModule gradleModule : gradleModules) {
    if (gradleModule == null) {
      continue;
    }
    if (ExternalSystemDebugEnvironment.DEBUG_ORPHAN_MODULES_PROCESSING) {
      LOG.info(String.format("Importing module data: %s",gradleModule));
    }
    final String moduleName=gradleModule.getName();
    if (moduleName == null) {
      throw new IllegalStateException("Module with undefined name detected: " + gradleModule);
    }
    ModuleData moduleData=projectResolverChain.createModule(gradleModule,projectData);
    Pair<DataNode<ModuleData>,IdeaModule> previouslyParsedModule=moduleMap.get(moduleName);
    if (previouslyParsedModule != null) {
      throw new IllegalStateException(String.format("Modules with duplicate name (%s) detected: '%s' and '%s'",moduleName,moduleData,previouslyParsedModule));
    }
    DataNode<ModuleData> moduleDataNode=projectDataNode.createChild(ProjectKeys.MODULE,moduleData);
    moduleMap.put(moduleName,Pair.create(moduleDataNode,gradleModule));
  }
  final List<TaskData> allTasks=ContainerUtil.newArrayList();
  for (  final Pair<DataNode<ModuleData>,IdeaModule> pair : moduleMap.values()) {
    final DataNode<ModuleData> moduleDataNode=pair.first;
    final IdeaModule ideaModule=pair.second;
    projectResolverChain.populateModuleExtraModels(ideaModule,moduleDataNode);
    projectResolverChain.populateModuleContentRoots(ideaModule,moduleDataNode);
    projectResolverChain.populateModuleCompileOutputSettings(ideaModule,moduleDataNode);
    projectResolverChain.populateModuleDependencies(ideaModule,moduleDataNode,projectDataNode);
    if (!isBuildSrcProject) {
      final Collection<TaskData> moduleTasks=projectResolverChain.populateModuleTasks(ideaModule,moduleDataNode,projectDataNode);
      allTasks.addAll(moduleTasks);
    }
  }
  final Collection<TaskData> rootProjectTaskCandidates=projectResolverChain.filterRootProjectTasks(allTasks);
  Set<Couple<String>> rootProjectTaskCandidatesMap=ContainerUtilRt.newHashSet();
  for (  final TaskData taskData : rootProjectTaskCandidates) {
    rootProjectTaskCandidatesMap.add(Couple.of(taskData.getName(),taskData.getDescription()));
  }
  for (  final Couple<String> p : rootProjectTaskCandidatesMap) {
    projectDataNode.createChild(ProjectKeys.TASK,new TaskData(GradleConstants.SYSTEM_ID,p.first,projectData.getLinkedExternalProjectPath(),p.second));
  }
  Collection<DataNode<LibraryData>> libraries=ExternalSystemApiUtil.getChildren(projectDataNode,ProjectKeys.LIBRARY);
  myLibraryNamesMixer.mixNames(libraries);
  return projectDataNode;
}
