{
  final String replacementText=buildDocString();
  final Project project=myDocStringOwner.getProject();
  PyElementGenerator elementGenerator=PyElementGenerator.getInstance(project);
  final PyExpressionStatement replacement=elementGenerator.createDocstring(replacementText);
  final PyStringLiteralExpression docStringExpression=getDocStringExpression();
  if (docStringExpression != null) {
    docStringExpression.replace(replacement.getExpression());
  }
 else {
    PyStatementListContainer container=PyUtil.as(myDocStringOwner,PyStatementListContainer.class);
    if (container == null) {
      throw new IllegalStateException("Should be a function or class");
    }
    final PyStatementList statements=container.getStatementList();
    final String indentation=PyIndentUtil.getExpectedElementIndent(statements);
    final Document document=PsiDocumentManager.getInstance(project).getDocument(myDocStringOwner.getContainingFile());
    if (document != null) {
      if (PyUtil.onSameLine(statements,myDocStringOwner) || statements.getStatements().length == 0) {
        PsiDocumentManager documentManager=PsiDocumentManager.getInstance(project);
        String replacementWithLineBreaks="\n" + indentation + replacementText;
        if (statements.getStatements().length > 0) {
          replacementWithLineBreaks+="\n" + indentation;
        }
        documentManager.doPostponedOperationsAndUnblockDocument(document);
        try {
          document.insertString(statements.getTextOffset(),replacementWithLineBreaks);
        }
  finally {
          documentManager.commitDocument(document);
        }
      }
 else {
        statements.addBefore(replacement,statements.getStatements()[0]);
      }
    }
  }
  myDocStringOwner=CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(myDocStringOwner);
  return myDocStringOwner;
}
