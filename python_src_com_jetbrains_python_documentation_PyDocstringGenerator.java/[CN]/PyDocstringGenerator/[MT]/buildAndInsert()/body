{
  final String replacement=buildDocString();
  final Project project=myDocStringOwner.getProject();
  PyElementGenerator elementGenerator=PyElementGenerator.getInstance(project);
  final PyStringLiteralExpression docStringExpression=getDocStringExpression();
  if (docStringExpression != null) {
    PyExpression str=elementGenerator.createDocstring(replacement).getExpression();
    docStringExpression.replace(str);
  }
 else {
    PyFunction function=PyUtil.as(myDocStringOwner,PyFunction.class);
    if (function == null) {
      throw new IllegalStateException("Should be a function");
    }
    final PyStatementList statements=function.getStatementList();
    final String indentation=PyIndentUtil.getExpectedElementIndent(statements);
    final Document document=PsiDocumentManager.getInstance(project).getDocument(myDocStringOwner.getContainingFile());
    if (document != null) {
      if (PyUtil.onSameLine(statements,function) || statements.getStatements().length == 0) {
        PyFunction func=elementGenerator.createFromText(LanguageLevel.forElement(function),PyFunction.class,"def " + function.getName() + function.getParameterList().getText()+ ":\n"+ indentation+ replacement+ "\n"+ indentation+ statements.getText());
        myDocStringOwner=(PyFunction)function.replace(func);
      }
 else {
        PyExpressionStatement str=elementGenerator.createDocstring(replacement);
        statements.addBefore(str,statements.getStatements()[0]);
      }
    }
  }
  myDocStringOwner=CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(myDocStringOwner);
  return myDocStringOwner;
}
