{
  DebugProcess process=evaluationContext.getDebugProcess();
  ThreadReference threadReference=evaluationContext.getSuspendContext().getThread().getThreadReference();
  ClassLoaderReference classLoader;
  try {
    classLoader=getClassLoader(evaluationContext);
  }
 catch (  Exception e) {
    throw new EvaluateException("Error creating evaluation class loader: " + e,e);
  }
  String version=((VirtualMachineProxyImpl)process.getVirtualMachineProxy()).version();
  JavaSdkVersion sdkVersion=JdkVersionUtil.getVersion(version);
  Collection<OutputFileObject> classes=compile(sdkVersion != null ? sdkVersion.getDescription() : null);
  try {
    defineClasses(classes,evaluationContext,process,threadReference,classLoader);
  }
 catch (  Exception e) {
    throw new EvaluateException("Error during classes definition " + e,e);
  }
  try {
    final Project project=ApplicationManager.getApplication().runReadAction(new Computable<Project>(){
      @Override public Project compute(){
        return myPsiContext.getProject();
      }
    }
);
    ExpressionEvaluator evaluator=DebuggerInvocationUtil.commitAndRunReadAction(project,new EvaluatingComputable<ExpressionEvaluator>(){
      @Override public ExpressionEvaluator compute() throws EvaluateException {
        final TextWithImports callCode=getCallCode();
        PsiElement copyContext=myData.getAnchor();
        final CodeFragmentFactory factory=DebuggerUtilsEx.findAppropriateCodeFragmentFactory(callCode,copyContext);
        return factory.getEvaluatorBuilder().build(factory.createCodeFragment(callCode,copyContext,project),ContextUtil.getSourcePosition(evaluationContext));
      }
    }
);
    ((EvaluationContextImpl)evaluationContext).setClassLoader(classLoader);
    return evaluator.evaluate(evaluationContext);
  }
 catch (  Exception e) {
    throw new EvaluateException("Error during generated code invocation " + e,e);
  }
}
