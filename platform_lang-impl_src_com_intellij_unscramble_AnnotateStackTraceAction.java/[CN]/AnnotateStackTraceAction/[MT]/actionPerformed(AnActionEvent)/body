{
  cache=new HashMap<Integer,LastRevision>();
  ProgressManager.getInstance().run(new Task.Backgroundable(myEditor.getProject(),"Getting File History",true,PerformInBackgroundOption.ALWAYS_BACKGROUND){
    @Override public boolean shouldStartInBackground(){
      return true;
    }
    @Override public void onSuccess(){
    }
    private void showGutter(){
      final EditorGutterAction action=new EditorGutterAction(){
        @Override public void doAction(        int lineNum){
          final LastRevision revision=cache.get(lineNum);
          final List<RangeHighlighter> links=myHyperlinks.findAllHyperlinksOnLine(lineNum);
          if (!links.isEmpty() && revision != null) {
            final RangeHighlighter key=links.get(links.size() - 1);
            HyperlinkInfo info=EditorHyperlinkSupport.getHyperlinkInfo(key);
            if (info instanceof FileHyperlinkInfo) {
              final VirtualFile file=((FileHyperlinkInfo)info).getDescriptor().getFile();
              final Project project=getProject();
              final AbstractVcs vcs=ProjectLevelVcsManager.getInstance(project).getVcsFor(file);
              if (vcs != null) {
                final VcsRevisionNumber number=revision.getNumber();
                final VcsKey vcsKey=vcs.getKeyInstanceMethod();
                ShowAllAffectedGenericAction.showSubmittedFiles(project,number,file,vcsKey);
              }
            }
          }
        }
        @Override public Cursor getCursor(        int lineNum){
          return Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);
        }
      }
;
      myEditor.getGutter().registerTextAnnotation(new ActiveAnnotationGutter(){
        @Override public void doAction(        int lineNum){
        }
        @Override public Cursor getCursor(        int lineNum){
          return Cursor.getDefaultCursor();
        }
        @Override public String getLineText(        int line,        Editor editor){
          final LastRevision revision=cache.get(line);
          if (revision != null) {
            return String.format("%" + maxDateLength + "s",DateFormatUtil.formatPrettyDate(revision.getDate())) + " " + revision.getAuthor();
          }
          return "";
        }
        @Override public String getToolTip(        int line,        Editor editor){
          final LastRevision revision=cache.get(line);
          if (revision != null) {
            return XmlStringUtil.wrapInHtml(revision.getAuthor() + " " + DateFormatUtil.formatDateTime(revision.getDate())+ "<br/>"+ revision.getMessage());
          }
          return null;
        }
        @Override public EditorFontType getStyle(        int line,        Editor editor){
          return line == newestLine ? EditorFontType.BOLD : EditorFontType.PLAIN;
        }
        @Override public ColorKey getColor(        int line,        Editor editor){
          return AnnotationSource.LOCAL.getColor();
        }
        @Override public Color getBgColor(        int line,        Editor editor){
          return null;
        }
        @Override public List<AnAction> getPopupActions(        int line,        Editor editor){
          return Collections.emptyList();
        }
        @Override public void gutterClosed(){
          myGutterShowed=false;
        }
      }
,action);
      myGutterShowed=true;
    }
    @Override public void run(    @NotNull ProgressIndicator indicator){
      Date newestDate=null;
      List<VirtualFile> files=new ArrayList<VirtualFile>();
      for (int line=0; line < myEditor.getDocument().getLineCount(); line++) {
        indicator.checkCanceled();
        final List<RangeHighlighter> links=myHyperlinks.findAllHyperlinksOnLine(line);
        if (links.size() > 0) {
          final RangeHighlighter key=links.get(links.size() - 1);
          final HyperlinkInfo info=EditorHyperlinkSupport.getHyperlinkInfo(key);
          if (info instanceof FileHyperlinkInfo) {
            final OpenFileDescriptor fileDescriptor=((FileHyperlinkInfo)info).getDescriptor();
            if (fileDescriptor != null) {
              final VirtualFile file=fileDescriptor.getFile();
              if (files2lines.containsKey(file)) {
                files2lines.get(file).add(line);
              }
 else {
                final ArrayList<Integer> lines=new ArrayList<Integer>();
                lines.add(line);
                files2lines.put(file,lines);
                files.add(file);
              }
            }
          }
        }
      }
      for (      VirtualFile file : files) {
        indicator.checkCanceled();
        LastRevision revision=getLastRevision(file);
        if (revision != null) {
          final List<Integer> lines=files2lines.get(file);
          final Date date=revision.getDate();
          if (newestDate == null || date.after(newestDate)) {
            newestDate=date;
            newestLine=lines.get(0);
          }
          final int length=DateFormatUtil.formatPrettyDate(date).length();
          if (length > maxDateLength) {
            maxDateLength=length;
          }
          for (          Integer line : lines) {
            cache.put(line,revision);
          }
          ApplicationManager.getApplication().invokeLater(new Runnable(){
            @Override public void run(){
              if (!myGutterShowed) {
                showGutter();
              }
 else {
                ((EditorGutterComponentEx)myEditor.getGutter()).revalidateMarkup();
              }
            }
          }
);
        }
      }
    }
    @Nullable private LastRevision getLastRevision(    @NotNull VirtualFile file){
      try {
        final AbstractVcs vcs=VcsUtil.getVcsFor(myEditor.getProject(),file);
        if (vcs == null)         return null;
        VcsHistoryProvider historyProvider=vcs.getVcsHistoryProvider();
        if (historyProvider == null)         return null;
        FilePath filePath=VcsContextFactory.SERVICE.getInstance().createFilePathOn(file);
        if (historyProvider instanceof VcsHistoryProviderEx) {
          VcsFileRevision revision=((VcsHistoryProviderEx)historyProvider).getLastRevision(filePath);
          if (revision == null)           return null;
          return LastRevision.create(revision);
        }
 else {
          VcsHistorySession session=historyProvider.createSessionFor(filePath);
          if (session == null)           return null;
          List<VcsFileRevision> list=session.getRevisionList();
          if (list == null || list.isEmpty())           return null;
          return LastRevision.create(list.get(0));
        }
      }
 catch (      VcsException ignored) {
        LOG.warn(ignored);
        return null;
      }
    }
  }
);
}
