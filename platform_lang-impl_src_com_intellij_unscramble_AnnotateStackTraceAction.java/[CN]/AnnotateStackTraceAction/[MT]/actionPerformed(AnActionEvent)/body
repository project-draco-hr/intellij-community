{
  cache=new HashMap<Integer,LastRevision>();
  ProgressManager.getInstance().run(new Task.Backgroundable(myEditor.getProject(),"Getting File History",true,PerformInBackgroundOption.ALWAYS_BACKGROUND){
    @Override public boolean shouldStartInBackground(){
      return true;
    }
    @Override public void onSuccess(){
    }
    private void showGutter(){
      ActiveAnnotationGutter gutter=new ActiveAnnotationGutter(){
        @Override public void doAction(        int lineNum){
          final LastRevision revision=cache.get(lineNum);
          if (revision == null)           return;
          VirtualFile file=getHyperlinkVirtualFile(myHyperlinks.findAllHyperlinksOnLine(lineNum));
          if (file == null)           return;
          final Project project=getProject();
          final AbstractVcs vcs=ProjectLevelVcsManager.getInstance(project).getVcsFor(file);
          if (vcs != null) {
            final VcsRevisionNumber number=revision.getNumber();
            final VcsKey vcsKey=vcs.getKeyInstanceMethod();
            ShowAllAffectedGenericAction.showSubmittedFiles(project,number,file,vcsKey);
          }
        }
        @Override public Cursor getCursor(        int lineNum){
          return cache.containsKey(lineNum) ? Cursor.getPredefinedCursor(Cursor.HAND_CURSOR) : Cursor.getDefaultCursor();
        }
        @Override public String getLineText(        int line,        Editor editor){
          final LastRevision revision=cache.get(line);
          if (revision != null) {
            return String.format("%" + maxDateLength + "s",DateFormatUtil.formatPrettyDate(revision.getDate())) + " " + revision.getAuthor();
          }
          return "";
        }
        @Override public String getToolTip(        int line,        Editor editor){
          final LastRevision revision=cache.get(line);
          if (revision != null) {
            return XmlStringUtil.wrapInHtml(revision.getAuthor() + " " + DateFormatUtil.formatDateTime(revision.getDate())+ "<br/>"+ revision.getMessage());
          }
          return null;
        }
        @Override public EditorFontType getStyle(        int line,        Editor editor){
          return line == newestLine ? EditorFontType.BOLD : EditorFontType.PLAIN;
        }
        @Override public ColorKey getColor(        int line,        Editor editor){
          return AnnotationSource.LOCAL.getColor();
        }
        @Override public Color getBgColor(        int line,        Editor editor){
          return null;
        }
        @Override public List<AnAction> getPopupActions(        int line,        Editor editor){
          return Collections.emptyList();
        }
        @Override public void gutterClosed(){
          myGutterShowed=false;
        }
      }
;
      myEditor.getGutter().registerTextAnnotation(gutter,gutter);
      myGutterShowed=true;
    }
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      final List<VirtualFile> files=new ArrayList<VirtualFile>();
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          for (int line=0; line < myEditor.getDocument().getLineCount(); line++) {
            indicator.checkCanceled();
            VirtualFile file=getHyperlinkVirtualFile(myHyperlinks.findAllHyperlinksOnLine(line));
            if (file == null)             continue;
            if (files2lines.containsKey(file)) {
              files2lines.get(file).add(line);
            }
 else {
              final ArrayList<Integer> lines=new ArrayList<Integer>();
              lines.add(line);
              files2lines.put(file,lines);
              files.add(file);
            }
          }
        }
      }
);
      Date newestDate=null;
      for (      VirtualFile file : files) {
        indicator.checkCanceled();
        LastRevision revision=getLastRevision(file);
        if (revision != null) {
          final List<Integer> lines=files2lines.get(file);
          final Date date=revision.getDate();
          if (newestDate == null || date.after(newestDate)) {
            newestDate=date;
            newestLine=lines.get(0);
          }
          final int length=DateFormatUtil.formatPrettyDate(date).length();
          if (length > maxDateLength) {
            maxDateLength=length;
          }
          for (          Integer line : lines) {
            cache.put(line,revision);
          }
          ApplicationManager.getApplication().invokeLater(new Runnable(){
            @Override public void run(){
              if (!myGutterShowed) {
                showGutter();
              }
 else {
                ((EditorGutterComponentEx)myEditor.getGutter()).revalidateMarkup();
              }
            }
          }
);
        }
      }
    }
    @Nullable private LastRevision getLastRevision(    @NotNull VirtualFile file){
      try {
        final AbstractVcs vcs=VcsUtil.getVcsFor(myEditor.getProject(),file);
        if (vcs == null)         return null;
        VcsHistoryProvider historyProvider=vcs.getVcsHistoryProvider();
        if (historyProvider == null)         return null;
        FilePath filePath=VcsContextFactory.SERVICE.getInstance().createFilePathOn(file);
        if (historyProvider instanceof VcsHistoryProviderEx) {
          VcsFileRevision revision=((VcsHistoryProviderEx)historyProvider).getLastRevision(filePath);
          if (revision == null)           return null;
          return LastRevision.create(revision);
        }
 else {
          VcsHistorySession session=historyProvider.createSessionFor(filePath);
          if (session == null)           return null;
          List<VcsFileRevision> list=session.getRevisionList();
          if (list == null || list.isEmpty())           return null;
          return LastRevision.create(list.get(0));
        }
      }
 catch (      VcsException ignored) {
        LOG.warn(ignored);
        return null;
      }
    }
  }
);
}
