{
  final Ref<CompilationLog> result=Ref.create(null);
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  final List<String> generatedFilePaths=new ArrayList<String>();
  getCompilerManager().addCompilationStatusListener(new CompilationStatusAdapter(){
    @Override public void fileGenerated(    String outputRoot,    String relativePath){
      generatedFilePaths.add(relativePath);
    }
  }
,myTestRootDisposable);
  UIUtil.invokeAndWaitIfNeeded(new Runnable(){
    @Override public void run(){
      final CompileStatusNotification callback=new CompileStatusNotification(){
        @Override public void finished(        boolean aborted,        int errors,        int warnings,        CompileContext compileContext){
          try {
            if (aborted) {
              Assert.fail("compilation aborted");
            }
            ExitStatus status=CompileDriver.getExternalBuildExitStatus(compileContext);
            result.set(new CompilationLog(status == ExitStatus.UP_TO_DATE,generatedFilePaths,compileContext.getMessages(CompilerMessageCategory.ERROR),compileContext.getMessages(CompilerMessageCategory.WARNING)));
          }
  finally {
            semaphore.up();
          }
        }
      }
;
      myProject.save();
      CompilerTestUtil.saveApplicationSettings();
      action.run(callback);
    }
  }
);
  final long start=System.currentTimeMillis();
  while (!semaphore.waitFor(10)) {
    if (System.currentTimeMillis() - start > 60 * 1000) {
      throw new RuntimeException("timeout");
    }
    if (SwingUtilities.isEventDispatchThread()) {
      UIUtil.dispatchAllInvocationEvents();
    }
  }
  if (SwingUtilities.isEventDispatchThread()) {
    UIUtil.dispatchAllInvocationEvents();
  }
  return result.get();
}
