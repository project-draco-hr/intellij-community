{
  final String ownerClassName=task.getOwnerClassName();
  final String fieldName=task.getFieldName();
  final int accessFlags=task.getAccessFlags();
  final boolean accessChanged=task.getIsAccessChanged();
  final boolean isRemoved=task.getIsFieldRemoved();
  final Ref<Boolean> isSuccess=Ref.create(Boolean.TRUE);
  final Set<String> affectedPaths=Collections.synchronizedSet(new HashSet<String>());
  try {
    if (isDumbMode()) {
      isSuccess.set(Boolean.FALSE);
      LOG.debug("Constant search task: cannot search in dumb mode");
    }
 else {
      final String qualifiedName=ownerClassName.replace('$','.');
      final PsiClass[] classes=ApplicationManager.getApplication().runReadAction(new Computable<PsiClass[]>(){
        public PsiClass[] compute(){
          return JavaPsiFacade.getInstance(myProject).findClasses(qualifiedName,GlobalSearchScope.allScope(myProject));
        }
      }
);
      try {
        if (isRemoved) {
          ApplicationManager.getApplication().runReadAction(new Runnable(){
            public void run(){
              if (classes.length > 0) {
                for (                PsiClass aClass : classes) {
                  final boolean success=aClass.isValid() && performRemovedConstantSearch(aClass,fieldName,accessFlags,affectedPaths);
                  if (!success) {
                    isSuccess.set(Boolean.FALSE);
                    break;
                  }
                }
              }
 else {
                isSuccess.set(performRemovedConstantSearch(null,fieldName,accessFlags,affectedPaths));
              }
            }
          }
);
        }
 else {
          if (classes.length > 0) {
            final Collection<PsiField> changedFields=ApplicationManager.getApplication().runReadAction(new Computable<Collection<PsiField>>(){
              public Collection<PsiField> compute(){
                final List<PsiField> fields=new SmartList<PsiField>();
                for (                PsiClass aClass : classes) {
                  if (!aClass.isValid()) {
                    return Collections.emptyList();
                  }
                  final PsiField changedField=aClass.findFieldByName(fieldName,false);
                  if (changedField != null) {
                    fields.add(changedField);
                  }
                }
                return fields;
              }
            }
);
            if (changedFields.isEmpty()) {
              isSuccess.set(Boolean.FALSE);
              LOG.debug("Constant search task: field " + fieldName + " not found in classes "+ qualifiedName);
            }
 else {
              for (              final PsiField changedField : changedFields) {
                if (!accessChanged && ClsUtil.isPrivate(accessFlags)) {
                  continue;
                }
                affectDirectUsages(changedField,accessFlags,accessChanged,affectedPaths);
              }
            }
          }
 else {
            isSuccess.set(Boolean.FALSE);
            LOG.debug("Constant search task: class " + qualifiedName + " not found");
          }
        }
      }
 catch (      Throwable e) {
        isSuccess.set(Boolean.FALSE);
        LOG.debug("Constant search task: failed with message " + e.getMessage());
      }
    }
  }
  finally {
    final CmdlineRemoteProto.Message.ControllerMessage.ConstantSearchResult.Builder builder=CmdlineRemoteProto.Message.ControllerMessage.ConstantSearchResult.newBuilder();
    builder.setOwnerClassName(ownerClassName);
    builder.setFieldName(fieldName);
    if (isSuccess.get()) {
      builder.setIsSuccess(true);
      builder.addAllPath(affectedPaths);
      LOG.debug("Constant search task: " + affectedPaths.size() + " affected files found");
    }
 else {
      builder.setIsSuccess(false);
      LOG.debug("Constant search task: unsuccessful");
    }
    channel.writeAndFlush(CmdlineProtoUtil.toMessage(sessionId,CmdlineRemoteProto.Message.ControllerMessage.newBuilder().setType(CmdlineRemoteProto.Message.ControllerMessage.Type.CONSTANT_SEARCH_RESULT).setConstantSearchResult(builder.build()).build()));
  }
}
