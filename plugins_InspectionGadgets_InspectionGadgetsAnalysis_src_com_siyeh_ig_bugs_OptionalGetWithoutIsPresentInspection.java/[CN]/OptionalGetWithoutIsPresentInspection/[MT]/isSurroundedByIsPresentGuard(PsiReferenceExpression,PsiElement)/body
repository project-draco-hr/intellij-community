{
  PsiStatement sibling=PsiTreeUtil.getParentOfType(context,PsiStatement.class);
  sibling=PsiTreeUtil.getPrevSiblingOfType(sibling,PsiStatement.class);
  final IsPresentChecker checker=new IsPresentChecker(optionalReference);
  while (sibling != null) {
    if (sibling instanceof PsiIfStatement) {
      final PsiIfStatement ifStatement=(PsiIfStatement)sibling;
      final PsiExpression condition=ifStatement.getCondition();
      if (condition != null) {
        if (!ControlFlowUtils.statementMayCompleteNormally(ifStatement.getThenBranch())) {
          checker.negate=true;
          checker.checkExpression(condition);
          if (checker.hasIsPresentCall()) {
            return true;
          }
        }
 else         if (!ControlFlowUtils.statementMayCompleteNormally(ifStatement.getElseBranch())) {
          checker.negate=false;
          checker.checkExpression(condition);
          if (checker.hasIsPresentCall()) {
            return true;
          }
        }
      }
    }
 else     if (sibling instanceof PsiAssertStatement) {
      final PsiAssertStatement assertStatement=(PsiAssertStatement)sibling;
      final PsiExpression condition=assertStatement.getAssertCondition();
      checker.negate=false;
      checker.checkExpression(condition);
      if (checker.hasIsPresentCall()) {
        return true;
      }
    }
    sibling=PsiTreeUtil.getPrevSiblingOfType(sibling,PsiStatement.class);
  }
  checker.negate=false;
  PsiElement parent=PsiTreeUtil.getParentOfType(context,PsiIfStatement.class,PsiConditionalExpression.class,PsiPolyadicExpression.class);
  while (parent != null) {
    parent.accept(checker);
    if (checker.hasIsPresentCall()) {
      return true;
    }
    parent=PsiTreeUtil.getParentOfType(parent,PsiPolyadicExpression.class,PsiIfStatement.class,PsiConditionalExpression.class);
  }
  return checker.hasIsPresentCall();
}
