{
  PsiStatement sibling=PsiTreeUtil.getParentOfType(context,PsiStatement.class);
  sibling=PsiTreeUtil.getPrevSiblingOfType(sibling,PsiStatement.class);
  final IsPresentChecker checker=new IsPresentChecker(optionalReference);
  while (sibling != null) {
    if (sibling instanceof PsiIfStatement) {
      final PsiIfStatement ifStatement=(PsiIfStatement)sibling;
      final PsiExpression condition=ifStatement.getCondition();
      if (condition != null) {
        final PsiElement target=optionalReference.resolve();
        if (!(target instanceof PsiVariable)) {
          return true;
        }
        final PsiVariable variable=(PsiVariable)target;
        final PsiStatement thenBranch=ifStatement.getThenBranch();
        if (!ControlFlowUtils.statementMayCompleteNormally(thenBranch) || VariableAccessUtils.variableIsAssigned(variable,thenBranch)) {
          checker.negate=true;
          if (checker.checkExpression(condition)) {
            return true;
          }
        }
        final PsiStatement elseBranch=ifStatement.getElseBranch();
        if (!ControlFlowUtils.statementMayCompleteNormally(elseBranch) || VariableAccessUtils.variableIsAssigned(variable,elseBranch)) {
          checker.negate=false;
          if (checker.checkExpression(condition)) {
            return true;
          }
        }
      }
    }
 else     if (sibling instanceof PsiWhileStatement) {
      final PsiWhileStatement whileStatement=(PsiWhileStatement)sibling;
      final PsiExpression condition=whileStatement.getCondition();
      checker.negate=true;
      if (checker.checkExpression(condition)) {
        return true;
      }
    }
 else     if (sibling instanceof PsiAssertStatement) {
      final PsiAssertStatement assertStatement=(PsiAssertStatement)sibling;
      final PsiExpression condition=assertStatement.getAssertCondition();
      checker.negate=false;
      if (checker.checkExpression(condition)) {
        return true;
      }
    }
 else     if (sibling instanceof PsiExpressionStatement) {
      final PsiExpressionStatement expressionStatement=(PsiExpressionStatement)sibling;
      final PsiExpression expression=expressionStatement.getExpression();
      if (expression instanceof PsiMethodCallExpression) {
        final PsiMethodCallExpression methodCallExpression=(PsiMethodCallExpression)expression;
        if (MethodCallUtils.isCallToMethod(methodCallExpression,"org.junit.Assert",PsiType.VOID,"assertTrue",null) || MethodCallUtils.isCallToMethod(methodCallExpression,"junit.framework.Assert",PsiType.VOID,"assertTrue",null) || MethodCallUtils.isCallToMethod(methodCallExpression,"org.testng.Assert",PsiType.VOID,"assertTrue",null)|| MethodCallUtils.isCallToMethod(methodCallExpression,"org.testng.AssertJUnit",PsiType.VOID,"assertTrue",null)) {
          checker.negate=false;
          final PsiExpressionList argumentList=methodCallExpression.getArgumentList();
          final PsiExpression[] arguments=argumentList.getExpressions();
          for (          PsiExpression argument : arguments) {
            if (checker.checkExpression(argument)) {
              return true;
            }
          }
        }
      }
    }
    sibling=PsiTreeUtil.getPrevSiblingOfType(sibling,PsiStatement.class);
  }
  checker.negate=false;
  PsiElement parent=PsiTreeUtil.getParentOfType(context,PsiIfStatement.class,PsiWhileStatement.class,PsiConditionalExpression.class,PsiPolyadicExpression.class);
  while (parent != null) {
    parent.accept(checker);
    if (checker.hasIsPresentCall()) {
      return true;
    }
    parent=PsiTreeUtil.getParentOfType(parent,PsiIfStatement.class,PsiWhileStatement.class,PsiConditionalExpression.class,PsiPolyadicExpression.class);
  }
  return checker.hasIsPresentCall();
}
