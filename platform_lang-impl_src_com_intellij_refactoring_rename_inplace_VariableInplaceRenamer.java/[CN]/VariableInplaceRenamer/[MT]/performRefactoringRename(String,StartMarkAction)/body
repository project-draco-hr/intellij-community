{
  final String refactoringId=getRefactoringId();
  try {
    PsiNamedElement elementToRename=getVariable();
    if (refactoringId != null) {
      final RefactoringEventData beforeData=new RefactoringEventData();
      beforeData.addElement(elementToRename);
      beforeData.addStringProperties(myOldName);
      myProject.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(refactoringId,beforeData);
    }
    if (!isIdentifier(newName,myLanguage)) {
      return;
    }
    if (elementToRename != null) {
      new WriteCommandAction(myProject,getCommandName()){
        @Override protected void run(        Result result) throws Throwable {
          renameSynthetic(newName);
        }
      }
.execute();
    }
    for (    AutomaticRenamerFactory renamerFactory : Extensions.getExtensions(AutomaticRenamerFactory.EP_NAME)) {
      if (renamerFactory.isApplicable(elementToRename)) {
        final List<UsageInfo> usages=new ArrayList<UsageInfo>();
        final AutomaticRenamer renamer=renamerFactory.createRenamer(elementToRename,newName,new ArrayList<UsageInfo>());
        if (renamer.hasAnythingToRename()) {
          if (!ApplicationManager.getApplication().isUnitTestMode()) {
            final AutomaticRenamingDialog renamingDialog=new AutomaticRenamingDialog(myProject,renamer);
            if (!renamingDialog.showAndGet()) {
              return;
            }
          }
          final Runnable runnable=new Runnable(){
            @Override public void run(){
              ApplicationManager.getApplication().runReadAction(new Runnable(){
                @Override public void run(){
                  renamer.findUsages(usages,false,false);
                }
              }
);
            }
          }
;
          if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable,RefactoringBundle.message("searching.for.variables"),true,myProject)) {
            return;
          }
          if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,PsiUtilCore.toPsiElementArray(renamer.getElements())))           return;
          final Runnable performAutomaticRename=new Runnable(){
            @Override public void run(){
              CommandProcessor.getInstance().markCurrentCommandAsGlobal(myProject);
              final UsageInfo[] usageInfos=usages.toArray(new UsageInfo[usages.size()]);
              final MultiMap<PsiElement,UsageInfo> classified=RenameProcessor.classifyUsages(renamer.getElements(),usageInfos);
              for (              final PsiNamedElement element : renamer.getElements()) {
                final String newElementName=renamer.getNewName(element);
                if (newElementName != null) {
                  final Collection<UsageInfo> infos=classified.get(element);
                  RenameUtil.doRename(element,newElementName,infos.toArray(new UsageInfo[infos.size()]),myProject,RefactoringElementListener.DEAF);
                }
              }
            }
          }
;
          final WriteCommandAction writeCommandAction=new WriteCommandAction(myProject,getCommandName()){
            @Override protected void run(            Result result) throws Throwable {
              performAutomaticRename.run();
            }
          }
;
          if (ApplicationManager.getApplication().isUnitTestMode()) {
            writeCommandAction.execute();
          }
 else {
            ApplicationManager.getApplication().invokeLater(new Runnable(){
              @Override public void run(){
                writeCommandAction.execute();
              }
            }
);
          }
        }
      }
    }
  }
  finally {
    if (refactoringId != null) {
      final RefactoringEventData afterData=new RefactoringEventData();
      afterData.addElement(getVariable());
      afterData.addStringProperties(newName);
      myProject.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(refactoringId,afterData);
    }
    try {
      ((EditorImpl)InjectedLanguageUtil.getTopLevelEditor(myEditor)).stopDumbLater();
    }
  finally {
      FinishMarkAction.finish(myProject,myEditor,markAction);
    }
  }
}
